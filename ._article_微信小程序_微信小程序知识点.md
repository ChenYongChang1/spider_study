标题:微信小程序知识点
描述:一个应用同时只能打开5个页面栈，当已经打开了5个页面之后（现在限制是10层），后续可能出现不能正常打开新页面。wx.navigateTo 跳转会保留当前页面，wx.redirectTo 则不会，所以请避免多层级的交互方式来合理使用跳转方式 template 模块与 compon…

<div><h3>subPackages 分包加载</h3></div><div>因为小程序主包大小不超过2M 限制，所以使用分包是个不错的选择，总分包大小不超过8M，可以添加多个分包，分包加载可以优化小程序首次启动的下载时间，当进入分包页面再进行下载，这种按需加载可以把某些数据量大的抽离出来放入分包（如图表）<br></div><div><h3>rpx 单位</h3></div><div>在做移动端最常用适配的方法就是使用 rem 或 vw 作为单位来进行适配，所以微信小程序提供了 rpx 单位来进行适配<br></div><div><h3>授权弹窗</h3></div><div>wx.getUserInfo 接口调整，以前可以直接主动调用显示授权弹窗  ，现在需要使用 &lt;button open-type="getUserInfo"&gt;&lt;/button&gt; 点击来引导用户去授权，小程序 wx.getUserInfo 接口正式版已调整，体验版和开发版还可以使用原有方式</div><div><h3>原生组件 z-index</h3></div><div>原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上，可以通过 cover-view 来解决，但某些特定环境如 swiper 或弹窗中需要显隐原生组件，需要配合 hidden 来使用</div><div><h3>伪元素</h3></div><p>小程序的伪元素属性无法在微信开发者工具 css 属性中看到，所以对于某些组件样式无法覆盖时（如 button 的边框或某些线条设置），是因为通过伪元素 ::after 设置的，所以必须使用伪元素来覆盖</p><div><h3>页面栈</h3></div><p>一个应用同时只能打开5个页面栈，当已经打开了5个页面之后（现在限制是10层），后续可能出现不能正常打开新页面。wx.navigateTo 跳转会保留当前页面，wx.redirectTo 则不会，所以请避免多层级的交互方式来合理使用跳转方式</p><div><h3>组件化</h3></div><p>template 模块与 component 组件，是小程序中组件化的方式，二者的区别是，template 模块主要是展示，方法需要在使用 template 的页面中定义。而 component 组件，则拥有自己的js 文件，整个 component 组件类似一个 page 页面。简单来说，只是展示用，建议使用 template，组件中涉及到较多的逻辑，建议使用 component</p><div><h3>调式</h3></div><p>一、开发者工具 source 断点调式、console.log 打印数据和 AppData 查看数据</p><p>二、小程序注意当前调式基础库版来调式一些兼容性以及 bug 问题</p><p>三、小程序先在开发版或体验版右上角打开调试显示 vConsole，再切到正式版就能看到 vConsole 模式</p><div><h3>数据传递</h3></div><p>一、使用数据缓存，wx.setStorage 和 wx.getStorage，存储数据只能是字符串格式，所以一般设置时需要使用 JSON.stringfy 来把对象转字符串，获取时使用 JSON.parse 来还原成对象<br></p><p>二、wx.navigateTo 跳转传递参数，在跳转 url 后拼接字符串，在 onLoad() 函数内，通过 options.参数名 的方式获取传递的参数，注意如果有特殊字符（如?#等）,可以使用encodeURIComponent 和 decodeURIComponent 编码和解码，否则会被截断，导致特殊字符后面的数据无法传递<br></p><p>三、getCurrentPages() 函数用于获取当前页面栈的实例，可以获取页面栈或修改页面栈数据<br></p><p>四、getApp() 可以获取全局对象和方法<br></p><div><h3>导航栏胶囊对齐适配</h3></div><p>导航栏一般使用自定义，比较灵活可控，首先需要 app.json 中设置 navigationStyle ：custom 自定义，然后通过小程序 wx.getMenuButtonBoundingClientRect() 可以获取到右上角胶囊菜单位置信息，不过这个接口不稳定，部分机型会出现获取失败的 bug，所以使用 wx.getSystemInfo 来获取该设备的状态栏高度（即手机时间和电量那一栏高度），标题栏高度（即包括导航返回键、标题和胶囊的高度）默认设置安卓为48，ios 为44（小程序默认胶囊在安卓中为48px 的标题栏居中，因为安卓类别比较多，所以会有点差别，ios 为44px 的标题栏居中），导航栏总高度为状态栏高度+标题栏高度，padding-top 高度为状态栏高度，标题栏中元素垂直对齐来达到适配并与胶囊对齐，设置内容高度时可以利用 calc(100vh -  导航栏总高度)，把样式放在全局 app.wxss 中</p><div><h3>unionid 标识</h3></div><p></p><div>unionid 是小程序用户的跨程序标识，拥有 unionid 首先需要绑定微信开放平台（<a href="https://open.weixin.qq.com/">微信开放平台</a>-管理平台-小程序-绑定小程序），因为 unionid 就是微信开放平台分发下来的，不将小程序绑定微信开放平台，就没有 unionid，当不同小程序的 unionid 是不同的，需要把小程序挂载到同一个主体中，同一用户，对同一个微信开放平台下的不同应用，unionid 是相同的</div><p>后台返回 unionid 给前端：首先 wx.login 获取用户登录凭证code，然后 wx.getSetting 查看是否已授权，wx.getUserInfo 获取用户信息，通过用户信息的加密字段给后台向微信服务器换取 unionid 返回，由于获取请求返回数据可能会在 Page.onLoad 之后才返回， 所以一般加上 callback （获取 unionid 一般放在 app.js 的 onLaunch 中，所以需要 callback 来处理 它和页面 onLoad 的数据获取）</p><div><h3>接口请求</h3></div><p>建议把所有请求抽离到同一个 api.js 中，可以方便后期的修改和排查问题，小程序请求是通过微信后台来请求我们的后台地址来进行后端映射、你请求的接口实际到微信的后端做了一道映射，微信后端拿到你的 wx.request 调用的 url、用后端请求后端，所以不会出现跨域问题</p><div><h3>input 键盘</h3></div><p>考虑不同场景使用不同的 type，如文本键盘，数字键盘来提高用户体验</p><div><h3>wux-weapp</h3></div><p>小程序组件比较推荐 wux-weapp，组件丰富并且拓展灵活</p><p><br></p>