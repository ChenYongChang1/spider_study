[{"id": "6969739366939754532", "title": "前端刷题路-Day40：删除链表的倒数第 N 个结点（题号19）", "desc": "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现么？"}, {"id": "6967322878698061837", "title": "位运算初探", "desc": "位运算，就是指按二进制进行的运算，一共有 6 种 与(&)、或(|)、取反(~)、异或(^)、左移(<<) 和 右移(>>)。"}, {"id": "6994815423594102820", "title": "前端之算法（二）选择和插入排序", "desc": "昨天也就是上一章我们聊了算法，以及比较经典的算法之冒泡排序，今天我们接下来要介绍一下选择排序和插入排序。 选择排序 选择排序的思路 找到数"}, {"id": "6997795551597199391", "title": "前端必刷手写题系列 [19]", "desc": "这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 28. 各类继承方式的手写(下) 问题是什么 继承是 OOP (面向对象编程)(Object-oriented programming) "}, {"id": "6999429343705300999", "title": "剑指offer(17)——反转链表(思路及代码)", "desc": "“这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战” 题目 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 思路"}, {"id": "6991650083427057677", "title": "前端算法必刷题系列[77]｜8月更文挑战", "desc": "144. 岛屿数量 (number-of-islands) 标签 染色 中等 题目 leetcode 传送门 这里不贴题了，leetcode打开就行，题目大意： 给你一个由 '1'（陆地）和 '0'（"}, {"id": "6995188487016153096", "title": "Poisson-Disc 算法介绍", "desc": "​ 这是我参与8月更文挑战的第11天，活动详情查看： 8月更文挑战 动画链接：http://bl.ocks.org/mbostock/dbb02448b0f93e4c82c3\\   Poisson-D"}, {"id": "6934487015970832391", "title": "寻找二叉树的下一个节点", "desc": "本文就跟大家分享下这个问题的解决方案与实现代码，欢迎各位感兴趣的开发者阅读本文。 如果存在，则遍历它的左子树至叶节点，将其返回。 如果不存在，则遍历它的父节点至根节点，直至找到一个节点与它父节点的左子节点相等的节点，将其返回。"}, {"id": "6979246469991628808", "title": "前端算法必刷题系列[75]", "desc": "这是我参与更文挑战的第 30 天，活动详情查看 更文挑战 141. 实现 Trie (前缀树/字典树) (implement-trie-prefix-tree) 标签 Trie 前缀树/字典树 中等 "}, {"id": "6999657304190615583", "title": "leetcode刷题-二分查找&分治", "desc": "leetcode刷题-二分查找&分治 1、在一个重复元素的数组中查找key的最左位置 2、x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 "}, {"id": "6982736730633797639", "title": "外观数列解题思路", "desc": "外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 外观数列前5项枚举如上，下面的文字比较清晰的解释了什么是外观数列。这同时也是leetcode的第38题。题目要求给定一个正"}, {"id": "6844904161872461831", "title": "「前端进阶」你真的懂递归吗？", "desc": "数据结构与算法系列文章第三弹来袭，如果没有看过前两篇的同学们请移步下面链接。 因为很多算法思想都基于递归，无论是DFS、树的遍历、分治算法、动态规划等都是递归思想的应用。学会了用递归来解决问题的这种思维方式，再去学习其他的算法思想，无疑是事半功倍的。 「无可奈何花落去，似曾相识…"}, {"id": "6844903581674373127", "title": "Nerv - 京东高性能前端框架", "desc": "Nerv 是一款由京东凹凸实验室打造的高性能类 React 前端框架，具有极佳的性能、全面兼容IE8、支持服务器端渲染等特性，并已在核心业务中广泛使用。"}, {"id": "6844903621474123789", "title": "SVG Path路径在网页开发的作用", "desc": "SVG是矢量图形表示，它的一个强大之处在于path标签可以表示任意的矢量形状，利用好这个path可以做出很多传统html/css做不出来的效果。下面举几个例子。 1. 做路径动画 利用animateMotion结合path做的动画，具体说明可见上文。 2. 实现不规则形状的点击…"}, {"id": "6888516686215905287", "title": "【前端文件计算】浏览器计算大文件SHA256——网页崩溃问题解决", "desc": "最近公司在做文件存证的功能：文件存证上传之后得到SHA256值，当区块链需要用到的时候，比较SHA值，若文件被改动，SHA256值都会产生变化。因此前端需要对文件进行读取并用文件计算出SHA256"}, {"id": "6844903680244711431", "title": "图像处理的滤镜算法", "desc": "就是RGB三种颜色分别取255的差值。 rgb三种颜色取三种颜色的最值的平均值。 高斯模糊的原理就是根据正态分布使得每个像素点周围的像素点的权重不一致，将各个权重（各个权重值和为1）与对应的色值相乘，所得结果求和为中心像素点新的色值。我们需要了解的高斯模糊的公式："}, {"id": "6844903607964270606", "title": "记一次XX前端面试", "desc": "距离自己被外派(俗称外包)出去，已经过了快五个月，工作的话，很闲。人啊，一定保持好的习惯，懒惰是会上瘾，日常摸鱼，怀疑人生，我是谁，我在哪，我要干什么。 中午吃饭的时候，收到了boss直聘的一条消息，XX发来一个信息，是一个前端职位，问我是否感兴趣，讲道理，我还是很诧异的，一是…"}, {"id": "6986993632398016526", "title": "前端常用数据结构与算法整理--链表", "desc": "概念: 由多个元素组成的列表。 元素存储不连续，用next指针将其连在一起。 JavaScript中没有链表这个数据结构，但可以用object去模拟 数组与链表比较： 数组在修改非头尾元素时会移动其中"}, {"id": "6970481350159630350", "title": "前端刷题路-Day42： 平方数之和（题号633）", "desc": "给定一个非负整数 c ，你要判断的是否存在两个整数 a 和 b， 使得 a2 + b2 = c 。"}, {"id": "6997426408087633951", "title": "【温故知新】`416. 分割等和子集`01背包🎒问题存在解-动态规划实现", "desc": "题目描述 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。   示例 1： 输入：nums = [1,5,11,5] 输出：tr"}, {"id": "6979930265921519624", "title": "斐波那契数列从O(2^n)到O(1)", "desc": "斐波那契数列逐步优化，文章列出了5种方法，时间复杂度从O(2^n）到 O(1) 步步精进，最后给出了耗时对比。"}, {"id": "6856546833025237006", "title": "「算法与数据结构」梳理6大排序算法", "desc": "这次梳理了一遍6种排序算法，从掌握思想到实现它，还是画了不少时间，又通过笔记梳理一遍，正好整理出来，对大家起一个抛砖引玉的效果吧。 6中常见的排序算法有GIF动图，更加容易帮助你理解其中的排序思想。 这个名字的由来是向泡泡一样浮起来，脑补一下，就是每次比较相邻的两个元素大小，然…"}, {"id": "6999566031203074062", "title": "LeetCode49-最大子序和 | 算法练习系列", "desc": "这是我参与8月更文挑战的第23天，活动详情查看：8月更文挑战 前言 今天来一道处理数组的算法题，求数组中的最大子序和，何为最大子序和，也就是数组中各个子数组的和的最大值，这是我们可以把子数组一一列举出"}, {"id": "7004743489925677070", "title": "二分法使用小总结", "desc": "二分法是我们在进行算法练习时经常遇到的一种题目的类型，但是关于二分，你真的真的会用吗？ 那些年搞不清楚的区间定义 当我们面对一个有序的数组时，我们首先要考虑是不是可以用二分法来解决相应的问题。但是二分"}, {"id": "6998663284689731592", "title": "手撸二叉树之根据二叉树创建字符串", "desc": "Hello, 大家好，今天是我参加8月更文的第 21 天，今天给大家带来的关于二叉树相关的算法题是根据二叉树创建字符串，正文如下： 题目 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组"}, {"id": "6996058677727723556", "title": "手撸二叉树之二叉树的中序遍历", "desc": "Hello, 大家好，今天是我参加8月更文的第 14 天，今天给大家带来的关于二叉树相关的算法题是求二叉树的中序遍历，正文如下： 题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例"}, {"id": "7005488399461122079", "title": "学算法刷LeetCode【剑指offer专题】：52. 两个链表的第一个公共节点", "desc": "题目描述 52. 两个链表的第一个公共节点 解题思路 思路一： 前后双指针（数节点） 前后双指针其实指的是一个指针先走 n 步，另一个指针再与前一个指针以相同的速度走。用到这个思路的还有 学算法刷Le"}, {"id": "6993893996909035528", "title": "15天算法入门(七）", "desc": "图像渲染 题目 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr,sc)......"}, {"id": "6952674285311754276", "title": "精读《DOM diff 最长上升子序列》", "desc": "在 精读《DOM diff 原理》 一文中，我们提到了 Vue 使用了一种贪心 + 二分的算法求出最长上升子序列，但并没有深究这个算法的原理，因此特别开辟一章详细说明。另外，最长上升子序列作为一道算法"}, {"id": "6981242936365154318", "title": "精读《算法 - 二叉树》", "desc": "二叉树是一种数据结构，并且拥有种类复杂的分支，本文作为入门篇，只介绍一些基本二叉树的题型，像二叉搜索树等等不在此篇介绍。 二叉树其实是链表的升级版，即链表同时拥有两个 Next 指针，就变成了二叉树。"}, {"id": "6888451657504391181", "title": "「算法与数据结构」Trie树之美", "desc": "这次分享的Trie字典树，是数据结构专题中的一个分支，认识了解Trie这种树型数据结构，对构建算法与数据结构知识体系有一定的帮助。 利用字符串的公共前缀来减少查询时间，最大限度的减少无谓的字符串比较，查询效率比哈希树高。 如果你还不了解什么是Trie数据结构的话，或者知道一些，…"}, {"id": "6960460126796906532", "title": "精读《算法基础数据结构》", "desc": "掌握了不同数据结构的特点，可以让你在面对不同问题时，采用合适的数据结构处理，达到事半功倍的效果。 所以这次我们详细介绍各类数据结构的特点，希望你可以融会贯通。 精读 数组 数组非常常用，它是一块连续的"}, {"id": "7001430506252271652", "title": "「前端刷题」27. 移除元素", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 题目 https://leetcode-cn.com/problems/remove-element/ 给你一个数组 nums和一个值 v"}, {"id": "6956769952208519198", "title": "我从来不理解 “压缩算法”，直到有人这样向我解释它", "desc": "写给新手前端的各种压缩算法小知识，从有损压缩谈到哈夫曼编码，再到压缩炸弹。详细对比各种压缩的效果及实现"}, {"id": "7001810638703951902", "title": "前端算法-复杂度分析", "desc": "定义 从广义上讲 从狭义上讲 是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等 数据结构和算法关系 数据结构是为算法服务的，算法要作用在特定的数据结构之上 复杂度分析 事后统计法的"}, {"id": "6874708801208254478", "title": "「算法与数据结构」带你看哈希算法之美", "desc": "最近在某面经上，看到关于哈希表相关的问题，对这个数据结构感兴趣，于是就有了这篇文章。 如果你经常听到哈希算法，哈希表，哈希冲突,但又是有点模棱两可的概念，说不定读完本文，对你些许有点帮助。 公众号前端UpUp，回复哈希，即可获取脑图。 联系👉TianTianUp，遇到问题的话…"}, {"id": "7002495053331431461", "title": "Leetcode1109. 航班预订统计", "desc": "前言 最近leetcode的每日刷题都是前缀和类的，比较有连贯性。没有上来搞个hard打击人。本题用到了差分、前缀和，好记性不烂笔头，笔记之。欢迎点赞👍🏻 读题 有n个航班，起始位置是1。 booki"}, {"id": "6885104477297344525", "title": "「算法与数据结构」分治算法之美", "desc": "这次分享的内容是，经典算法思想-分治，你可以把它称之为一种思想，也可以叫它分治算法，为了更好的区分，接下来我们以「分治法」来称呼它。 如果你还不了解什么是分治法，或者知道一些，但是对于它具体是如何实现回溯，那么这篇文章可能适合你阅读。 联系👉TianTianUp，遇到问题的话…"}, {"id": "6850418120755494925", "title": "「算法与数据结构」链表的9个基本操作", "desc": "说真的，有时候，想要表达清楚自己的想法有点小困难，奈何又是个文笔不是很好的粗汉子，有些概念上问题，还是引用别处的解释比较好，所以还望大家谅解。 一种常见的基础数据结构，也是一种线性表，但是并不会按线性表的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 …"}, {"id": "7002949115776598023", "title": "LeetCode题解：143. 重排链表，数组，JavaScript，详细注释", "desc": "原题链接：143. 重排链表，https://leetcode-cn.com/problems/reorder-list/"}, {"id": "6980233438007656455", "title": "leetcode top100挑战, 每天不鸽一道题之 组合总和(18/100)", "desc": "给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。"}, {"id": "6980203700304232461", "title": "KMP算法分享", "desc": "本文是前端内部分享，参考文章 1. 什么是KMP 一种改进的字符串匹配算法 2. 暴力匹配法 目标字符串（上面）和模式串（下面）一个接一个的对比 当第一次检测到不相同以后 3. 如果是人来处理，会怎么"}, {"id": "6926841756969828360", "title": "【算法与数据结构】伪代码与流程图", "desc": "输出a出现1次，F出现1次，H出现1次......"}, {"id": "6844903726168145934", "title": "图像优化原理", "desc": "我们都喜欢有图片的网页，图片很美好，很有趣，同时它涵盖了丰富的信息。所以，在加载网页时，大部分流量被图像资源所占据（平均60%，数据可能不准确）。 图像资源不只占用网络资源，它也会占用网页中大量的视觉空间。所以图像渲染的速度会直接影响用户体验。图像优化其实就是最大限度地减少图像…"}, {"id": "6844903583834456078", "title": "记一次前端笔试题 | 掘金技术征文", "desc": "这道题主要考查声明提升和函数声明先于变量声明这两个知识点。在解析这个js片段的时候是按照这样的顺序： 这样就很清晰了，第一次输出a的时候仅仅是声明了还没有赋值，所以是undefined。第二次的不用说了。第三次输出2是因为，变量声明是无法覆盖函数声明的，一开始getNum指向一…"}, {"id": "6920504450960326669", "title": "斐波那契数列第 N 项七种解法的 JavaScript 实现", "desc": "这篇文章的代码其实早在 2020 年初的某个夜晚心血来潮已经实现过了，并且发在了自己的博客 https://wfk007.github.io/2020/03/28/fibonacci/ 上，但是，现在回看的话会发现基本都是代码，缺少解释说明，这也是我写这篇文章的目的之一。另外因…"}, {"id": "6880686839746887694", "title": "一分钟了解堆的基本操作", "desc": "基本操作任何一个数据结构，无非就是增删改查四大类：功能方法时间复杂度增offer(E e)O(logn)删poll()O(logn)改无直接的 API删 + 增查peek()O(1)这里 peek()"}, {"id": "6889099509834612743", "title": "前端学数据结构与算法（十）：深入理解快速排序", "desc": "上一章我们已经实现了快速排序，在数据理想化的情况下，上一章的快排性能确实也不错，但如果数据比较极端的，快排的O(nlogn)就不太稳定了，本章将介绍几种快排应对极端数据下优化方案；以及介绍partition操作延伸出来的快速选择算法在解决top K问题时高效。 上一章我们直接选…"}, {"id": "6903272242436636685", "title": "【图文并茂】小白也可以玩转算法——链表篇", "desc": "近期，着手开始了写算法系列的文章，出发点是以算法小白的角度总结分享，所以，文章的阅读门槛不高。并且，文中的大部分题解会附带图例来抽象程序执行的过程，简而言之，看不懂代码，你可以看图 😇。其中，相比较普通的迭代解法，对于递归的解法，本文会秉持递归三要素的原则分析，即返回值、调用…"}, {"id": "6989063589491376164", "title": "【LeetCode】627. Swap Salary", "desc": "Given a table salary, such as the one below, that has m=male and f=female values. Swap all f and m v"}, {"id": "6844903496932655112", "title": "前端 排序算法总结", "desc": "当然，排序和查找两类算法是面试的热门选项。如果你是一个会写快排的程序猿，面试官在比较你和一个连快排都不会写的人的时候，会优先选择你的。那么，前端需要会排序吗？答案是毋庸置疑的，必须会。现在的前端对计算机基础要求越来越高了，如果连排序这些算法都不会，那么发展前景就有限了。本篇将会…"}, {"id": "6988853033975169055", "title": "「✍ Q: 链表合并」", "desc": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。。。"}, {"id": "6988833052147318820", "title": "前端面试算法篇——链表反转问题", "desc": "反转链表1. 反转整个单链表（leetcode#206） 对于递归解法几点注意事项： a.对于所有递归问题，要坚定不移的相信递归函数的定义，包括参"}, {"id": "6844903621818056712", "title": "数据可视化基本原理——可视化模型", "desc": "我刚接触数据可视化是在 4 年前，那时候一位大学老师 S ，叫我们使用 R 对数据进行统计分析（对，哥也学过一阵统计呢），其中有部分知识点是用 R 绘制箱线图、散点图之类的可视化结果。 从此对数据可视化产生了浓厚的兴趣，现在系统地来学习一下数据可视化。今天分享一些关于数据可视化…"}, {"id": "6844904018251104269", "title": "UI2CODE系列文章|如何提高“小目标”检测准确率", "desc": "在计算机视觉领域，存在一个“小目标”检测任务，比如自动驾驶中的交通灯，或者医学图像中的早期肿块。“小目标”的正确检出能极大地提高用户体验，促进自动化行业的发展。UI2CODE是闲鱼技术部推出的一个应用工具。通过对页面ui元素的自动解析并自动生成相关代码，UI2CODE能提高工程…"}, {"id": "6844903567271133197", "title": "从Chrome源码看HTTPS", "desc": "我在《https连接的前几毫秒发生了什么》详细地介绍了https连接的过程，该篇通过抓包工具分析整个过程，本篇将从Chrome源码的角度着重介绍加密和解密的过程，并补充更多的细节。 Chrome/Chromium是使用BoringSSL做为TLS层的库，它是OpenSSL的一个…"}, {"id": "6893519852296732686", "title": "贪心算法", "desc": "通常贪心算法的代码会非常短(比如下图的代码)而且思路也非常的简单，但贪心算法真正的难点在于确定我们当前的问题确实可以使用贪心算法。 这道题是LeetCode中第235题，无重叠区间, 本文从分析这道题来一起学习贪心算法。 还是分析我们上面提到的问题。 题目意思：题目的意思是给定…"}, {"id": "6844904202922098695", "title": "LeetCode 167. 两数之和 II - 输入有序数组：JavaScript 双指针解法", "desc": "1. 两数之和：JavaScript 三种解法，暴力和哈希表 但那样并没有利用本题有序数组的条件。我们应该想一下，如何利用该条件来进一步降低算法复杂度。 因为是有序数组，我们使用两个指针，初始分别位于数组第一个元素和最后一个元素的位置，比较这两个元素之和与目标值的大小。如果和等…"}, {"id": "6844903614394318855", "title": "程序员玩连连看的正确姿势", "desc": "1） 安装 adb 环境。安装完成后，用数据线连接一台 android 手机，执行一些简单的 adb 命令预热下 首先想到的是通过求解图片的 hash 值，利用 hash 值来比对图片的相似度（例如感知 hash 算法）。网上有各种求 hash 值的算法，实现起来倒也简单，但是…"}, {"id": "6897125264216555533", "title": "JS中7种方法实现斐波那契数列(不包括公式法)", "desc": "闲来无事想到折腾点没用的。 Generator不应该在这种场景使用，有点对不住他。"}, {"id": "6999647280949100557", "title": "「前端刷题」22. 括号生成", "desc": "数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 有效括号组合需满足：左括号必须以正确"}, {"id": "6996630390819536910", "title": "前端之算法（七）动态规划", "desc": "大家好，今天我们要聊的是动态规划这种方法，它和分而治之一样，也是算法设计中的一种方法，你同样可以把它当作解决问题的一种思路。接下来让我来"}, {"id": "6996602981709774884", "title": "【温故知新】`494. 目标和` 表达式转化为01背包🎒问题-动态规划实现", "desc": "题目描述： 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，"}, {"id": "6844903565035569160", "title": "移动端rem布局的学习（基于自己写的一个网易云播放页面的思考）", "desc": "对于一个前端的初学者来说，首先要做好的事就是切页面了，切页面不得不说的就是布局了，布局的重要性不言而喻，为了良好的用户体验，提出了许多不一样的布局：响应式布局，弹性布局，流动布局等等，也流入出了许多的框架。最近在看关于移动端的响应式布局，其中涉及到比较多的就是大小属性的设置：p…"}, {"id": "6969037557141078052", "title": "LeetCode第680题：\t 验证回文字符串 Ⅱ  ", "desc": "题干 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 解法：双指针 关于这道题的解法，其实是也是采用双指针，首先看到回文数我们应该第一个想到的就是双指针，但是对于此题还有一个要求"}, {"id": "6991361409372291080", "title": "LeetCode算法学习之--数组--合并两个有序链表", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目[合并两个有序链表] 题目 ![图片转载leetCode] 分析 解法一：迭代 解法二：递归 总结 这道题考察对链表升序组合的理解，小的放"}, {"id": "6844903541610414094", "title": "你不知道的前端算法之热力图的实现", "desc": "inMap 是一款基于 canvas 的大数据可视化库，专注于大数据方向点线面的可视化效果展示。目前支持散点、围栏、热力、网格、聚合等方式；致力于让大数据可视化变得简单易用。 热力图这个名字听起来很高大上，其实等同于我们常说的密度图。 如图表示，红色区域表示分析要素的密度大，而…"}, {"id": "6988766319361392677", "title": "基于FPGA的图像旋转设计", "desc": "该项目是参加2019届全国大学生FPGA大赛的作品，系统主要实现视频任意角度旋转。利用国产的紫光同创公司的FPGA芯片作为开发平台，视频图像从摄像头实时采集，经过算法旋转后，通过hdmi接口显示。"}, {"id": "6991134436825759774", "title": "时间复杂度", "desc": "代码的时间复杂度和代码的执行次数有关。 一、案例 1、案例1 这段代码每一行代码都只会执行一次，所以时间复杂度为O(n)。 2、案例2 这段代码执行次数最多的是for循环，执行n次，因此时间复杂度为O"}, {"id": "6993700728061558791", "title": "二叉树刷题(一）", "desc": "一、 二叉树的前序遍历，二、N 叉树的前序遍历，三、翻转二叉树，四、从上到下打印二叉树 II......"}, {"id": "6844903924906852359", "title": "敏感词过滤算法对比，顺便开源了个工具库", "desc": "AC算法相对复杂，所以其实现方案也比较复杂，没有拿出纸和笔的话还真的挺难读懂的。但是DFA算法就比较简单易懂了，看着代码就能大概完成整个实现逻辑的构建。所以从代码的实现以及可读性，DFA算法算是比较深得我心吧 AC算法的作者提供了诸多功能，比如支持快查询，支持临时添加单词等等，…"}, {"id": "6938044913942528037", "title": "[LeetCode513题找树左下角的值] | 刷题打卡", "desc": "题目地址：513. 找树左下角的值 给定一个二叉树，在树的最后一行找到最左边的值。 注意: 您可以假设树（即给定的根节点）不为 NULL。 题目给定一个二叉树root，要求在树的最后一行找到最左边的值。 看到这种二叉树求某个值的题目，对于我们这些基础比较薄弱的开发来说，不要想着…"}, {"id": "6979104090122879007", "title": "LeetCode第376题：摆动序列", "desc": "题干 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, "}, {"id": "6952020376427692045", "title": "前端基础算法总结- 链表", "desc": "前端基础算法只链表总结，链表在前端实际使用中并不太常见，但是react的源码中其实有涉及到链表的概念"}, {"id": "6950200059543683086", "title": "怎么理解DFS和BFS", "desc": "当遇到列举所有的情况之类的，要联想到DFS和BFS！就像看到直角三角形想到勾股定理，十之八九的要用到！"}, {"id": "6844903792811458568", "title": "JS冒泡排序的6种写法", "desc": "经典版1(实力对决之一个都不能少)经典版2(实力对决之换汤不换药)经典版3(实力对决之副裁判独担重任)升级版1(flag心法？比武可能提前结束)升级版2(左右互博之术？副裁判得周伯通真传)升级版3(f"}, {"id": "6909236730222608398", "title": "我是如何提高自己的「编程能力」的？", "desc": "上周的投票，大家最关心的还是提高技术，那我们今天就来聊聊这个话题。之前主要分享的多是算法和数据结构方面（年后继续），因为我认为算法和数据结构是程序员最最最重要的内功，但是并不是唯一。我自己作为一个非科"}, {"id": "6910935222536110088", "title": "动态规划巧解凑零钱问题 | 创作者训练营", "desc": "状态转移方程，最重要的是先找到状态，然后将「大问题」转换成「小问题」，将「全局问题」转换成「局部问题」。转换的过程用表达式写出来，即是状态转移方程。 我们通常使用 DP （Dynamic Programming）表示状态转移方程。 题目要求凑出给定金额最少的硬币数，这是个唯一的…"}, {"id": "6986649440782123022", "title": "LeetCode算法学习之--链表--两两交换", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[两两交换链表中的节点](https://leetcode-cn.com/problems/count-of-range-sum/) 题目"}, {"id": "6985874270878433317", "title": "双指针方法", "desc": "对撞指针 对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。 示例1:  给你 n 个非负整数 a1，a2，..."}, {"id": "6975047249042604062", "title": "leetcode top100挑战, 每天不鸽一道题之 三数之和(9/100)", "desc": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。"}, {"id": "6888846579113918477", "title": "史上最清晰的「归并排序」讲解", "desc": "那我们借用 cs50 里的例子，比如要把一摞卷子排好序，那用并归排序的思想是怎么做的呢？首先把一摞卷子分成两摞；把每一摞排好序；把排好序的两摞再合并起来。感觉啥都没说？那是因为上面的过程里省略了很多细"}, {"id": "6938657502569431047", "title": "[ 力扣66 ] 我终于找到了js中BigInt的用武之地——大数运算 | 刷题打卡", "desc": "给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 返回以指定基数(base)表示指定数字的字符串。覆盖 Object.prototype…"}, {"id": "6892913579033542669", "title": "彩虹排序 | 荷兰旗问题", "desc": "荷兰旗问题又称三色排序，或者彩虹排序，因为荷兰旗就三种颜色嘛，那这道题的问题就是给你三种颜色，按照给定的顺序排好。当然了，题目的问法各种各样，有的给数字，有的给字母，但本质都是一样的。比如给你一个只含"}, {"id": "6969034918147915789", "title": "手把手教你刷搜索", "desc": "大话搜索 搜索一般指在有限的状态空间中进行枚举，通过穷尽所有的可能来找到符合条件的解或者解的个数。根据搜索方式的不同，搜索算法可以分为 DFS，BFS，A*算法等。这里只介绍 DFS 和 BFS，以及"}, {"id": "6985448282168229896", "title": "7.整数反转", "desc": "这个题的目的就是把这个有符号的整数反转过来，并且规定了是在32的环境下，就意味着这是一个有范围， 所以先把这个范围找出来，然后就是来反转这个数。 反转的方法有两种，最简单的就是调用js的方法，为了去除"}, {"id": "6844904096550354951", "title": "前端工程师的 LeetCode 之旅 -- 180周赛", "desc": "给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 本题主要考察数组的基本操作，两重循环暴力求解。 请你设计一个支持下述操作的栈。 CustomSta…"}, {"id": "6981778812052717599", "title": "今天，我搞懂了老生常谈却又一直没太懂的二叉树遍历", "desc": "二叉树的算法在前端面试中还是很重要的，几乎是算法题必问的压轴题，所以弄懂二叉树的遍历算法还是很有必要的，今天我们就来共同探讨一下二叉树的遍历算法。"}, {"id": "7001104669095247886", "title": "「前端刷题」26. 删除有序数组中的重复项", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 题目 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-arr"}, {"id": "6981742454428925965", "title": "选择、快速、归并、计数排序", "desc": "一、求任意长度数组的最小数 1.1求两个数中最小的数 JS有现成的API：Math.min Math看来像是和Object一样的构造函数，但其实只是一个普通对象 这是唯一一个特例：首字母大写的是构造函"}, {"id": "6984289303102750757", "title": "LeetCode第225题：用队列实现栈", "desc": "题干 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素"}, {"id": "6971673140715847693", "title": "leetcode top100挑战, 每天不鸽一道题之 两数之和", "desc": "leetcode top100挑战, 每天不鸽一道题之 两数之和。给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回。"}, {"id": "6952453714166677534", "title": "「算法」二叉树的最近公共祖先 | 刷题打卡", "desc": "一、题目描述：原题链接 👉 236. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。示例 1:示例 2:示例 3：注意:树中节点数目在范围 [2, 105] 内。-109"}, {"id": "6935052672848363534", "title": "leetcode 数组的移动相关题目 453、665、283 ｜ 刷题打卡", "desc": "题目描述思路一题目要求原数组上操作，但是一开始想到的可能是再添一个数组思路二在原数组上进行操作，记录下非零元素的位置思路三对非零元素进行交换操作思路四当所有元素都是非零元素时，可以进一步优化，减少交换"}, {"id": "6985025773518192670", "title": "算法专题--动态规划  vs 贪心算法 ", "desc": "动态规划（Dynamic Programming, DP） 在查找有很多重叠子问题的情况的最优解时有效。 它将问题重新组合成子问题。 为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单"}, {"id": "6844903663337472008", "title": "浅尝辄止，React是如何工作的", "desc": "React除了是MVC框架，数据驱动页面的特点之外，核心的就是他很\"快\"。 按照普遍的说法：\"因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由R…"}, {"id": "6945781374750031879", "title": "前端刷题路-Day7", "desc": "给定两个字符串 s和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 你可以假设字符串只包含小写字母。 这题本来只想到了用Map或者对象来进行操作，想法比较简单，这里不多做赘述。那么剩下的一种方法就是给两个字符串进行排序，之后比较排序结果是否相等就好，这种方法比较简单…"}, {"id": "6844904086827958280", "title": "前端工程师的 LeetCode 之旅 -- 174周赛", "desc": "给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 0 和 1 表示。 请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但是 i 小于 j ，那么我们认为第 i 行的战斗力比第…"}, {"id": "6951574820391747592", "title": "[LeetCode-206反转链表] | 刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情题目描述反转一个单链表。进阶： 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？解题思路两种方式：指针法，如图示：这个思路比较好理解，我"}, {"id": "6844903953440702471", "title": "数据结构和算法基础(偏向前端方向)", "desc": "提起算法很多CS毕业的人都不会陌生，但是不管你是在学校理论知识学的如何扎实还是在学校中有参加比赛的经历(ACM等)，但是到了工作中因为没有实际的应用场景或者说应用场景很少，导致一些原本顺手拈来的知识点和操作都感到很生疏。 同时，由于本人现在专职于前端工作（原来是前后端都做），很…"}, {"id": "6985721157274206239", "title": "算法--二分查找", "desc": "二分查找 条件：数组必须是有序数组 基础框架： 在实际问题中，我们可能会涉及到查找比目标target大的第一个数或比target小的第一个数，这时需要做稍微的调整来让二分法执行有意义的查找例如： 剑指"}, {"id": "6937626687802703902", "title": "LeetCode701. 二叉搜索树中的插入操作｜刷题打卡", "desc": "给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 我们会…"}, {"id": "6844903637768994823", "title": "使用 Rust + WebAssembly 编写 crc32 ", "desc": "WebAssembly 在最近几年里可以说是如火如荼了。从基于 LLVM 的 Emscripten ，到尝试打造全流程工具链的 binaryen ，再到 Rust 社区出现的wasm-bindgen……现在 webpack 4 已经内置了wasm的引入，甚至连 Go 社区也不甘…"}, {"id": "6844903599735046151", "title": "要不要一起了解一下Canvas?", "desc": "3、 获取到这个画布，每个canvas节点都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用getContext方法。即Canvas.getContext(contextID)，参数 conte…"}, {"id": "6844903748934844430", "title": "JavaScript 数据结构之队栈互搏", "desc": "今天稍微停下前进的脚步，来看下队栈的左右互搏术。 前两天学习了队列和栈以后，今天就可以试着来用两个栈实现队列的功能或者用两个队列来实现栈的功能。 1. 用两个栈实现一个队列 栈是先进后出，队列是先进先出，但可以用两个栈来模拟一个队列的功能，来实现队列中主要的 enqueue，d…"}, {"id": "6844903557359992845", "title": "谈谈 react 中的 key", "desc": "如果你用过 react，并且曾经尝试遍历数组来渲染一个组件，就应该遇到过上面的提示。因为提示的等级为 Warning，而非 Error，所以很多开发同学可能就不会去在意，包括我自己。在前几天开发一个需要动态渲染的组件时，才发现的了 key 的妙用，也因此打算研究下 key 到底…"}, {"id": "6844903632500965389", "title": "JavaScript尾递归优化探索", "desc": "探索JavaScript尾递归优化，解决递归造成的栈溢出问题"}, {"id": "6844903498325180430", "title": "H5游戏开发：贪吃蛇", "desc": "第一种是笔者小时候在掌上游戏机最先体验到的（不小心暴露了年龄），具体玩法是蛇吃完一定数量的食物后就通关，通关后速度会加快；第二种是诺基亚在1997年在其自家手机上安装的游戏，它的玩法是吃到没食物为止。笔者要实现的就是第二种玩法。 基于贪吃蛇的经典，笔者在实现它时也使用一种经典的…"}, {"id": "6844903623072317454", "title": "【刷算法】我知道的所有类似斐波那契数列的问题", "desc": "有一类算法问题类似斐波那契数列，而且解决办法基本差不多。 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 设到第n阶总共有f(n)种跳法，而且想跳到第n阶只有两种可能，要么从第n-1阶跳一阶到达，要么从第n-2阶跳两阶到达，所以递推式…"}, {"id": "6844903585478606856", "title": "js版九宫格拼图与启发式搜索（A*算法）", "desc": "，二号方块在0号位置... 启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。 （4）考察节点n是否为…"}, {"id": "6935803927451402276", "title": "LeetCode 239 滑动窗口最大值 | 刷题打卡", "desc": "本文选取 LeetCode 239. 滑动窗口最大值，这个也是面试的高频题。 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 我们可以采取双…"}, {"id": "6917578615794171917", "title": "javascript 算法之 图 必出精品  有一定难度", "desc": "1、介绍2、图的深度优先遍历那么深度优先遍历的怎么实现？方法论咋们有了那怎么实现这个方法论呢？代码演示一下新建一个图graph.jsdfs.js当然结果我已经显示在上面了这次放在node环境执行一下符"}, {"id": "6844903814575685646", "title": "JavaScript实现经典排序算法", "desc": "1. 冒泡排序（Bubble Sort） 冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，其优点是实现简单，排序数量较小时性能较好。 它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是…"}, {"id": "6969098814766448670", "title": "前端数据结构与算法之队列（js实现）", "desc": "队列是一种先进先出的线性表，通常用链表或者数组来实现。队列只能在队尾插入元素，只能在队首删除元素。 队列示意图： 队列的数据结构 本文使用数组来实现队列的结构，但是你要知道相当于是给队列开辟了一块连续"}, {"id": "6947981054527406116", "title": "leetcode 66 加一 ｜刷题打卡", "desc": "给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。"}, {"id": "6947898701822033928", "title": "算法打卡-leetcode-20210406", "desc": "1. 汉诺塔问题 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制: (3) 盘子只能叠在比它大的盘子上。 请编写程序，用栈…"}, {"id": "6844904119325425672", "title": "只能说我输了的LRU淘汰缓存算法", "desc": "各位看官先不要被这个什么 LRU 给劝退了，这个东西其实很简单。LRU 就是 Lastest Recently Used，即最近最少使用，说人话就是数据中，如果数据最近被访问过，那么将来被访问的几率也更高 ，优先淘汰最近没有被访问到的数据。 当 B 被重新引用的时候，它的顺序就…"}, {"id": "6916503216288956429", "title": "javascript 算法之 树    必出精品 （递归版本简单 非递归版本面试很重要）（一）", "desc": "ps:这部分视频可在b战和知乎看到1、介绍2、深度优先遍历简写dfs那么怎么进行`深度优先遍历呢``？上代码尝试实现一下遍历结果是可预期的3、广度优先遍历简写bfs这个又应该怎么操作一下？上代码注意此"}, {"id": "6976274163979943944", "title": "简单的3道算法题——多用小技巧", "desc": "这是记录个人在刷题时遇到的三道简单的算法题，多利用对象数组将题目简化的技巧。熟悉jsAPI可以达到简化代码的结果。"}, {"id": "6844903511323312135", "title": "大型网站HTTPS 实践（一）| HTTPS 协议和原理", "desc": "百度已经上线了全站 HTTPS 的安全搜索，默认会将 HTTP 请求跳转成 HTTPS。本文就着重介绍了 HTTPS 协议涉及到的重要知识点和平时不太容易理解的盲区，希望能对大家理解 HTTPS 协议有帮助。百度 HTTPS 性能优化涉及到大量内容，从前端页面、后端架构、协议特性"}, {"id": "6994439985017389093", "title": "15天算法入门(八）", "desc": "合并二叉树 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。"}, {"id": "7000737181753049101", "title": " LeetCode算法学习之--Heap--最小的k个数", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 大家好今天给大家分享下一道 LeetCode 简单难度 的题目[剑指 Offer 40. 最小的k个数](https://leetcode"}, {"id": "6991761316679516190", "title": "数据结构与算法之 —— 数组&链表", "desc": "0x01 基本概念 Array 数组 数组存储一系列同一类型的数值，但是在 JavaScript 里面可以存储不同类型的数值，但还是要遵守最佳实践（因为大多数语言的数组都不能存储多种类型）。 创建和初"}, {"id": "6993501836002983943", "title": "15天算法入门(六）", "desc": "题：无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度；"}, {"id": "6985713569992015885", "title": "LeetCode刷题，最近请求次数（933）", "desc": "返回最近请求时间在3000毫秒以内的次数。思路：直接使用队列，每次新请求入队，对比队列头请求时间如果超过3000，则队列头出队，依次判断，最后返回队列长度即可。"}, {"id": "7004681253144231966", "title": "LeetCode题解：897. 递增顺序搜索树，递归，JavaScript，详细注释", "desc": "原题链接：897. 递增顺序搜索树，https://leetcode-cn.com/problems/permutations/"}, {"id": "7001039360778829854", "title": "react入门笔记二(React Hooks)", "desc": "react入门笔记之React Hooks。此篇文章主要介绍了 useState, useEffect和useContext"}, {"id": "6973499606961225741", "title": "做题家：不可不会的“算法设计与分析”！【面试笔试】", "desc": "最近由于要做测评，遂整理算法设计与分析这一块的内容，复习的同时，与大家分享交流~ 喂！算法！逃不掉的！All Right? 分治法 比较典型的有：排序算法（归并排序、快速排序）、傅立叶变换......"}, {"id": "6995063572027932686", "title": "你不知道的 LeetCode 技巧（第一篇）", "desc": "今天来给使用 JS 刷题的朋友分享三个 LeetCode 上你或许不知道的刷题技巧。 今天来给使用 JS 刷题的朋友分享三个 LeetCode 上你或许不知道的刷题技巧。"}, {"id": "6844904132105469960", "title": "视频面试超高频在线编程题，搞懂这些足以应对大部分公司", "desc": "现在大厂面试几乎都会问到算法，回答不上来会让你在面试官前大打折扣。前端怎么进阶算法喃？ 本周是瓶子君前端进阶算法的第三周🎉🎉🎉，这里，会带你 从 0 到 1 构建完整的前端数据结构与算法体系。 本周已经不单是简单的链表操作（一般链表的问题可以考虑使用快慢指针），开始涉及五…"}, {"id": "6977037119373967390", "title": "斐波那契数列的多种解法", "desc": "求任意位置的斐波那契数，最常见的做法是使用递归，这种做法虽然可以得到结果，但是它的性能很差。 本文跟大家分享一种性能较好的解决方案，欢迎各位感兴趣的开发者阅读本文。"}, {"id": "6844904122496319495", "title": "10问10答，带你快速入门前端算法", "desc": "好的数据结构与算法能够大大缩短代码的执行时间与存储空间，那么我们如何去衡量它喃？这节就主要介绍算法性能的衡量指标—复杂度分析。 1. 如何表示算法复杂度？ 通常采用 大 O 表示法 来表示复杂度。它并不代表真正的执行时间或存储空间消耗，而是表示代码执行时间随数据规模增长的变化趋…"}, {"id": "7000910299305885710", "title": "【温故知新】`1367. 二叉树中的列表` 递归分解问题求解", "desc": "题目描述 解题思路 根据平衡性的定义，计算每个节点的左右子树高度。 如果某个节点的左右子树高度差大于1，则不平衡，返回false，算法结束； 否则说明以当前节点为根的子树是平衡的，继续检查当前节点的左"}, {"id": "7002760289196179486", "title": "【温故知新】‘检查二叉树的平衡性’ 递归计算左右子树的高度", "desc": "题目描述 解题思路 根据平衡性的定义，计算每个节点的左右子树高度。 如果某个节点的左右子树高度差大于1，则不平衡，返回false，算法结束； 否则说明以当前节点为根的子树是平衡的，继续检查当前节点的左"}, {"id": "6992141120692027428", "title": "15天算法入门(三）", "desc": "移动零 与 两数之和 II - 输入有序数组。 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。"}, {"id": "7002227259704770568", "title": "前端算法必刷题系列[93]", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 168. 分割等和子集 (partition-equal-subset-sum) 标签 中等 题目 leetcode 传送门 给你一个 只"}, {"id": "6993986321383424031", "title": "动图介绍排序算法之冒泡排序", "desc": "本文是笔者更新排序算法的第一篇，采用文字和动图介绍了冒泡排序的概念和步骤，采用一个标记位来提前结束已经有序的数列，节省比较的开销。"}, {"id": "6900092004043063309", "title": "【FunnyCoder第0期】非科班前端老司机从2K到40K之路", "desc": "朋友们大家好，我是大圣啊。 主要希望能给大家一些启发。我觉得我我本人还是一个很有意思的一个程序员，所以我干脆设计一档节目就叫做FunnyCoder，然后在采访些我周围类似的一些比较有趣的程序员。除了职业生涯之外，还有一些别的特点，所以呢第0期，就是采访我自己，然后也算是给我那段…"}, {"id": "6861376131615227912", "title": "「算法与数据结构」DFS和BFS算法之美", "desc": "最近面网易某部门的时候，其中一道算法题考点就是DFS，深度优先遍历，所以这次准备梳理一遍，练练手，下次再找的话，也比较方便。 一定要会多种解法，面试的时候，我就是写了递归，面试小哥哥问我能不能用迭代去完成，所以多种解法都要会。 简单的说，BFS是从根节点开始，沿着树的宽度遍历树…"}, {"id": "6983580875842093092", "title": "面试官:能不能手写几道链表的基本操作", "desc": "链表 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的"}, {"id": "6844903501600915463", "title": "关于数字货币钱包的基础密码学", "desc": "通过区块链，人类历史上首次通过技术彻底、纯粹地保障「私有财产神圣不可侵犯」。让人沉思，让人兴奋的一段话。可在这背后的基础技术「密码学」是如何工作，以及保障数字资产的安全呢？无论你是爱好者亦或投资客，应该需要多少了解背后的原理，免得误解，轻…"}, {"id": "6922960915012780046", "title": "前端就该用 JS 刷算法29(补)", "desc": "313. 超级丑数（补28号） 313. 超级丑数"}, {"id": "6844903918212923406", "title": "算法学习---简单笔记（持续更新）", "desc": "有条件控制语句 if...else... 有循环控制语句 while(exp) do... 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要…"}, {"id": "6844903696585736199", "title": "JS设计模式-策略模式", "desc": "什么是策略模式定义策略模式主要有两部分构成，一部分是封装不同策略的策略组，另一部分是Context。通过组合和委托来让Context拥有执行策略的能力，从而实现可复用、可扩展和可维护，并且避免大量复制"}, {"id": "6844904205749075976", "title": "当我们谈论算法我们在谈论什么:由疫情核酸检测想到的分治算法(Divide-and-Conquer)", "desc": "北京的疫情一波未平一波又起，由此看来，战“疫”将是一场旷日持久的战争，绝不能掉以轻心、轻易言胜。病毒随时都会死灰复燃，以生命为代价换来的经验教训值得我们每一个人久久深思。笔者所在的小区也开始组织居民批量进行核酸检测，本以为会是一幅摩肩接踵，水泄不通的场景，却出人意料的井然有序、…"}, {"id": "6938018327495344142", "title": "【魅力算法】“按摩师/打家劫舍”-动态规划、滚动数组思想实现 ｜刷题打卡", "desc": "题目描述解题思路动态规划题目理解按摩师对于每一个预约请求：可以接受预约；可以不接受预约；且不能接受相邻的预约请求；最后需要得出请求序列总预约时间最长举例1：预约序列为[1,2,3,1]有以下几种可能："}, {"id": "6844904071715880974", "title": "【第1期】前端算法精选-字符串系列", "desc": "很多前端工程师甚至很多研发工程师都缺乏数据结构和算知识，前端算法精选系列是一个针对常见的、高频的算法题做的一个算法解析系列，文章会给出详细的思路和解答，希望可以帮助到你。 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 既然是最大子串的长度，首先最明显的思路就…"}, {"id": "6844904070910574600", "title": "前端工程师的 LeetCode 之旅 - 夜喵专场（20）", "desc": "LeetCode夜喵🐱专场（20），涉及到的知识点有：位运算、双指针和动态规划。"}, {"id": "6844903945001762829", "title": "算法题--寻找最长子串", "desc": "有一个长度随机的字符串，寻找它的最长子串。 遍历肯定是要遍历，使用两个指针，第一个指向子串首，第二个指向子串尾，当将子串尾向前推进发现和已有子串有重复元素时，改变子串首指针指向当前这个重复元素的后面一位，子串尾的指针一直默认++。"}, {"id": "6948407598315995172", "title": "[LeetCode-0007题-反转整数] ｜ 刷题打卡", "desc": "主要考察数字的一些操作方法，例如Math.abs(), Math.pow()等等。 本题细心一点就好。"}, {"id": "6844904006687391758", "title": "关于栈和队列的一些算法", "desc": "栈 :它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底 队列: 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线…"}, {"id": "6972897912464506887", "title": "leetcode top100挑战, 每天不鸽一道题之 最长回文子串(4/100)", "desc": "题目描述 最长回文子串 标签 中心扩散法 解题分析 1. 中心扩散法 看到了一种解题思路很牛逼，我们用这种思路来解一下题目。 我们把中心扩散法带入到题目当中。 最后 从今天开始不鸽，每天一道算法题并发"}, {"id": "6844903816500871182", "title": "每日一算--求众数", "desc": "给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。"}, {"id": "6948294996978040869", "title": "遇到括号有效性、下一个更大元素、特定的最小值，尝试栈", "desc": "栈的特点：先进后出。 括号有效性：遍历，遇左括号进栈，遇右括号，匹配则出栈，否则 false。遍历完，栈有值为 false，反之为 true 循环数组：利用取余的技巧，没有实际扩充数组，但是遍历的时候，感觉像是在遍历循环数组。 思路：遍历字符串，遇到左括号进栈，遇到右括号，和栈…"}, {"id": "6844903815263551501", "title": "有道算法题--排序之桶排序实现求排序后相邻最大差值问题", "desc": "桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组…"}, {"id": "6936814627271475236", "title": "二叉树遍历(先序、中序、后序)", "desc": "二叉树的先序、中序、后序的递归和非递归遍历。 先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右) 中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右) 后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出…"}, {"id": "6972500515670360095", "title": "字符串 -  设计支持添加和查找的数据结构", "desc": "题目描述 真题描述： 设计一个支持以下两种操作的数据结构 1）void addWord(word) 2）bool search(word) 3）search(word) 可以搜索文字或正则表达式字符串"}, {"id": "6844903878983434253", "title": "算法数据结构里面有没有什么有趣的内容？", "desc": "我记得《算法导论》里就有一些很有意思的例子。"}, {"id": "6844904051272843271", "title": "前端算法系列之 双指针", "desc": "最近在系统的学习算法知识，以锻炼自己的逻辑分析能力和将想法变为代码的能力；为了给自己学习的反馈、和对自己成果的验收，决定写这个系列，输出和学习本身相辅相成，望与大家共同成长。 先说结论，我们用增加一个指针的方式，来降低算法所用的时间或空间。 看如下题目：给定一个有序数字数组和一…"}, {"id": "6936328036212031495", "title": "[LeetCode9. 回文数] | 刷题打卡", "desc": "题目描述示例一：示例二：解题思路及代码1、转换数字2、转字符串从两头比较本文正在参与「掘金2021春招闯关活动」,点击查看活动详情"}, {"id": "6844904158370201613", "title": "算法再好也算不懂你的心 | 邂逅数据结构与算法", "desc": "「数据结构和（与）算法」 是我们的原力。《算法再好也算不懂你的心》系列文章 在今天正式启动。 毫无疑问，茶余饭后，不知不觉，都会提到数据结构与算法 ，至于为什么这两个东西在开发者心中占有那么重的位置呢。我想随着你看到这篇之后，一块探索数据结构算法 的路程便启动了。 至于数据结构…"}, {"id": "6860675286858465293", "title": "【Leetcode 做题学算法周刊】第八期", "desc": "本文记录刷题过程中的整个思考过程，以供参考。主要内容涵盖： 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) -- 将元素 x 推入栈中。 pop() -- 删除栈顶的元素。 top() -- 获取栈顶元素。 getMin() …"}, {"id": "6935969146081542158", "title": "二叉树的一些基本操作 |刷题打卡", "desc": "首先定义一个node，将要插入的data赋值给node。定义一个parent永远指向子树的根节点。然后定义一个current指针，如果data &#x3C;current.data，current = current.left。current指针每次移动douyao判断curr…"}, {"id": "6844903506667634696", "title": "Rxjs实践-各种排序算法排序过程的可视化展示", "desc": "到这一步，我们的单次功能就能正常进行了，但如果在一个排序动画过程还没有结束，我们又点击了一个新的排序类型，则新旧两次的还在序列中没进行的渲染都会依次进行，干扰echart渲染的效果，所以在切换到新的类型时，我们要过滤序列中的值。"}, {"id": "6865151832604934157", "title": "神经支持决策树(NBDT)算法研究", "desc": "摘要准确率和解释性，小孩子才做选择，成年人全都要～背景在闲鱼的很多业务场景中有大量需要利用算法进行分类的需求，例如图片分类、组件识别、商品分层、纠纷类别预测等。这些场景往往需要模型识别出的结果具备可解"}, {"id": "6936035847351304228", "title": "20210305 LeetCode 每日一题，冲！｜刷题打卡", "desc": "Leetcode 链接：232. 用栈实现队列（easy） 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top…"}, {"id": "6844903653287936013", "title": "算法中对数量级的一点理解", "desc": "数量级是指数量的尺度或大小的级别,每个级别之间通常有固定的比例,如10,2,1000,1024,e(欧拉数),大约等于 2.71828182846 的超越数，即自然对数的底）。 需要特别注意的是：数量级应用范围必须是正数或自然数！尽管负数也可以计算数量级，没有实际的意义。比如：…"}, {"id": "6844903600578101256", "title": "JavaScript 工作原理之三－内存管理及如何处理 4 类常见的内存泄漏问题(译)", "desc": "本系列持续更新中，Github 地址请查阅这里。 这是 JavaScript 工作原理的第三章。 我们将会讨论日常使用中另一个被开发者越来越忽略的重要话题，这都是日益成熟和复杂的编程语言的锅，即内存管理问题。我们将会提供在创建 SessionStack 的时候所遵循的处理 Ja…"}, {"id": "6844903764181123079", "title": "简单的算法-解决页面脚本异步加载顺序问题", "desc": "这几天稍微扫了一下CoffeeScript的部分源码，发现了一条挺有意思的算法，它解决了页面异步加载脚本时遇到的顺序问题。只是当初都没想过可以这样优雅地去处理这方面的问题。异步加载的脚本之间可能会有依赖关系，因此加载顺序就异常重要了。 一. 场景分析-同步与异步 1. 同步加载…"}, {"id": "6920154565727928327", "title": "初学者应该了解的数据结构： Tree", "desc": "很多（上层）数据结构，如 Map、Set 等，它们的基础数据结构都（可以）是 Tree。同时，在数据库中快速搜索（元素）用到了树。HTML 的 DOM 节点也通过树来表示对应的层次结构。以上仅仅是树的一少部分例子。在这篇文章中，我们将探讨不同类型的树，如二叉树、二叉搜索树以及如…"}, {"id": "6844904117106638855", "title": "从斐波那契数列看两种常用算法和优化", "desc": "斐波拉契数列是一个非常经典的数学概念，早在 1202 年就由意大利数学家 Leonardo Fibonacci 提出。它的递推方法定义为：F(1) = 1, F(2) = 1, F(n) = F(n - 1) + F(n - 2)（n ≥ 3，n ∈ N）*。本文主要从递归、递…"}, {"id": "6939011449947684895", "title": "「算法」242. 有效的字母异位词 | 刷题打卡", "desc": "给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 原题链接 👉 242. 有效的字母异位词 你可以假设字符串只包含小写字母。 如果s和t的长度不相等，直接返回false。 如果s和t是异位词，相当于两个字符串排序后相等。 将s和t排序后进行比较…"}, {"id": "6901511413329166349", "title": "JS-链表与算法题浅析", "desc": "[维基百科] 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 链表常见的有 3 类： 单链表、双向链表、循环链表。 说到链表，就要提下数组，一般链表都是和数组进行对…"}, {"id": "6844903814093340686", "title": "导师计划--数据结构和算法系列（下）", "desc": "数据结构和算法系列的课程分为上下两篇文章，上篇文章主要是讲解数据结构，可以戳导师计划--数据结构和算法系列（上）进行了解。本篇文章主要讲解的是基本算法，辅助的语言依旧是JavaScript。POST的本篇文章主要是扩展下我们在开发中的方式，发散下思维～ etc. 排序算法又分为…"}, {"id": "6844903551949357063", "title": "深入浅出 JavaScript 的Array.prototype.sort 排序算法", "desc": "本文要解决的问题 1、找出 Array.prototype.sort 使用的什么排序算法 2、用一种直观的方式展示 Array.prototype.sort 的时间复杂度，看看它有多快？ 3、实际开发中要注意的问题 Array.prototype.sort 各浏览器的算法实现"}, {"id": "6844903806690394125", "title": "算法复习", "desc": "通常使用最差的时间复杂度来衡量一个算法的好坏。 常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。 对于一个算法来说，可能会计算出如下操作次数 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候…"}, {"id": "6844903541824307213", "title": "走进snabbdom—Vue2背后的Virtual-DOM的机制", "desc": "snabbdom是一个Virtual-DOM的实现库，它专注于使用的简单以及功能和的模型化，并在效率和性能上有着很好的表现。如果你还不知道什么是Virtual-DOM技术，它是一种网页中通过diff算法来实现网页修改最小化的方法，react底层使用了这样的机制来提高性能。 从V…"}, {"id": "6951569896975106078", "title": "只出现一次的数字|刷题打卡", "desc": "前言本文正在参与掘金团队号上线活动，点击查看大厂春招职位。题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度"}, {"id": "6951493771678711815", "title": "罗马数字转整数(经典面试题)|刷题打卡", "desc": "前言本文正在参与掘金团队号上线活动，点击查看大厂春招职位。题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符数值I1V5L10X50C100D500M1000例如， 罗马数字 "}, {"id": "6844903590868287496", "title": "Leetcode之javascript解题(No33-34)", "desc": "Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runti…"}, {"id": "6997194727707639822", "title": "手撸二叉树之从根到叶的二进制数之和", "desc": "Hello, 大家好，今天是我参加8月更文的第 17 天，今天给大家带来的关于二叉树相关的算法题是求二叉树从根到叶的二进制数之和，正文如下： 题目 给出一棵二叉树，其上每个结点的值都是 0 或 1 。"}, {"id": "6999879739502493703", "title": "LeetCode54-螺旋矩阵 | 算法练习系列", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 前言 螺旋矩阵是一道很有意思的题目，螺旋矩阵也就是从二维数组中取出各项，其实没什么特定的算法来解螺旋矩阵，只要把四个边界（向右，向下，向左"}, {"id": "7001046554492534792", "title": "算法之时间与空间复杂度", "desc": "这是我参与 8 月更文挑战的第 10 天，活动详情查看： 8月更文挑战 为什么需要复杂度分析？ 如果发布上去通过运行代码的方式来查看运行效率，会有如下问题： 测试结果非常依赖测试环境 测试环境中硬件的"}, {"id": "7002856081491755044", "title": "新旧节点对比与更新：differNodes", "desc": "一、前言 工作中遇到这么一个功能，拖动了一些节点，放置在一个数组 currentNodes 中，然后进行下一步的处理。 当对拖动的那些节点进行删除、复制、撤销、重置等操作时，currentNodes "}, {"id": "7004990223503327262", "title": "LeetCode题解：897. 递增顺序搜索树，栈，JavaScript，详细注释", "desc": "原题链接：897. 递增顺序搜索树，https://leetcode-cn.com/problems/increasing-order-search-tree/"}, {"id": "7005204890414743565", "title": "LeetCode算法学习之--Graph--岛屿数量", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目200. 岛屿数量 题目 分析 解法一：DFS 解法二：BFS 总结 这道题考察的是Graph的应用，如何使用DFS 来BFS 遍历节点 "}, {"id": "7001094285273595935", "title": "前端算法必刷题系列[91]", "desc": "这是我参与8月更文挑战的第25天，活动详情查看：8月更文挑战 166. 最大正方形 (maximal-square) 标签 动态规划 中等 题目 leetcode 传送门 在一个由 '0' 和 '1'"}, {"id": "6844903695788802062", "title": "JavaScript 开发者应懂的 33 个概念", "desc": "本篇文章是参照 @leonardomso 创立。 由于原版资源都要翻墙，所以本人创立一个中文版，附上关于这些概念在国内的一些文章和视频。 若有觉得更好的文章或者视频，可以贡献出来，觉得有误的，请联系我删除。"}, {"id": "6995716740567007262", "title": "手撸二叉树之二叉树的最近公共祖先", "desc": "Hello, 大家好，今天是我参加8月更文的第 13 天，在之前的文zhang中，我们已经做过了二叉搜索树的最近公共祖先，今天我们要做的题为二叉树的最近公共祖先，看俩者求解的方式有何不同，正文如下： "}, {"id": "6999024623928999944", "title": "手撸二叉树之合并二叉树", "desc": "Hello, 大家好，今天是我参加8月更文的第 22 天，今天给大家带来的关于二叉树相关的算法题是根据二叉树创建字符串，正文如下： 题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二"}, {"id": "6997233078972186654", "title": "Code review 居然是个数学问题? 从二向箔说起！", "desc": "写代码有两件最重要的事情，一是仰望星空，二是脚踏实地。在搞code review之前，我们先看一张星空的图，梵高的星空： 看到了这张星空，不知道读过《三体》的同学是不是联想到了二向箔。 即使是没有看过"}, {"id": "6999551776697368584", "title": "前端刷题路-Day89：找到所有数组中消失的数字（题号448） ", "desc": "给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的..."}, {"id": "7003616695705141261", "title": "排序总结", "desc": "算法能够帮我们高效稳定的解决某一类问题，在算法世界中，排序算法是我们打开这个神秘世界的钥匙，掌握好排序算法显得至关重要...."}, {"id": "7002408739005267976", "title": "leetcode题解-20分钟学会二分查找", "desc": "今天介绍下二分查找这个算法套路，学会此招，你的内力会精进三分，与路边程序员能立马拉开差距！来看看吧。"}, {"id": "6992616185686654990", "title": "回溯算法 - 机器人的运动范围", "desc": "有一个矩阵，机器人可以从坐标(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但是不能进入行坐标和列坐标的数位之和大于K的格子，求这个机器人总共能走多少个格子以及它的行动轨迹......."}, {"id": "6998097588566097934", "title": "每日题解——2021-8-19", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 345. 反转字符串中的元音字母 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。 元音字母包括 'a'、'e'、'"}, {"id": "6997927996099133454", "title": "LeetCode 102.二叉树的层次遍历 - JavaScript", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 LeetCode 102.二叉树的层次遍历 - JavaScript 题目描述 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从"}, {"id": "6882394656148045838", "title": "「算法与数据结构」带你看回溯算法之美", "desc": "这次梳理的是回溯算法，掌握它的解决问题思路，对很多搜索尝试问题，都会在日后学习工作中有所帮助。 如果你还不了解什么是回溯算法，或者知道一些，但是对于它具体是如何实现回溯，那么这篇文章可能适合你阅读。 联系👉TianTianUp，遇到问题的话，可以联系作者噢，愿意陪你一起学习一…"}, {"id": "7004342841853870094", "title": "二分查找及改进", "desc": "定义： 又称折半查找，核心思想是：在有序序列中，不断缩小搜索区域，降低查找目标元素的难度，时间复杂度：O(logn)。 思路：不断缩小搜索区域。 常用做法： 确定初始作左右边界 left right；"}, {"id": "6890298762917314573", "title": "GitHub上最火的、最值得前端学习的几个数据结构与算法项目！没有之一！", "desc": "前端章鱼猫从 2016 年加入 GitHub，到现在的 2020 年，快整整 5 个年头了。 相信很多人都没有逛 GitHub 的习惯，因此总会有开源信息的不对称，有哪些优秀的前端开源项目值得学习的也不知道。 从 2018 年开始，我就养成了每天逛 GitHub 的习惯，一般在…"}, {"id": "6937311249889755144", "title": "121. 买卖股票的最佳时机｜刷题打卡", "desc": "121. 买卖股票的最佳时机｜刷题打卡 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以…"}, {"id": "6986268433818058783", "title": "单项链表", "desc": "单项链表的定义 单向链表单链表是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始. 特点: 链表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向N"}, {"id": "6986233745858641927", "title": "栈的入门（带图解）", "desc": "栈的小入门： 数据结构：栈 是一个后进先出的数据结构 JavaScript没有栈的数据结构（图解辅助）"}, {"id": "6998502497875116045", "title": "「前端刷题」19. 删除链表的倒数第 N 个结点", "desc": "给你一个链表，删除链表的倒数第 n个结点，并且返回链表的头结点。 **进阶：**你能尝试使用一趟扫描实现吗？   示例 1： 输入："}, {"id": "6844904018989285389", "title": "记忆化斐波那契函数的思考（JavaScript）", "desc": "这种方式计算的时候会有很多重复的计算，而且递归的层数越来越深容易递归爆栈。 通过增加一层缓存，用来存放之前已经计算过的数值，当需要计算新值的时候先通过查找缓存，缓存命中则直接返回，未命中再继续计算。在实现缓存的时候我们可以选择两种方式，第一种是闭包；第二种是函数属性的方式，这种…"}, {"id": "6844903679485542408", "title": "[贝聊科技]在微信小程序中渲染HTML内容", "desc": "大部分Web应用的富文本内容都是以HTML字符串的形式存储的，通过HTML文档去展示HTML内容自然没有问题。但是，在微信小程序（下文简称为「小程序」）中，应当如何渲染这部分内容呢？ 小程序刚上线那会儿，是无法直接渲染HTML内容的，于是就诞生了一个叫做「wxParse」的库。…"}, {"id": "6844903692747948039", "title": "canvas进阶——如何画出平滑的曲线?", "desc": "相信大家平时在学习canvas 或 项目开发中使用canvas的时候应该都遇到过这样的需求：实现一个可以书写的画板小工具。 通过以上几个步骤我们就可以实现基本的画板功能了，然而事情并没那么简单，仔细的童鞋也许会发现一个很严重的问题——通过这种方式画出来的线条存在锯齿，不够平滑，…"}, {"id": "6988720548368891940", "title": "LeetCode第637题:二叉树的层平均值", "desc": "题干 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例 1： 提示： 节点值的范围在32位有符号整数范围内。 来源：力扣（LeetCode） 链接：https://leetcode-c"}, {"id": "6844904057295863822", "title": "简单易懂的红黑树原理及实现(js)", "desc": "在家憋的已经快要疯了，正好好久不发文章了，索性把这些天对红黑树的总结梳理一下总结成这篇文章。图挺多的（都是一点一点画的啊...），代码如果看不下去，理解下原理就好了。顺便安利一下YouTube的一个up主（该这么叫？），Tushar Roy，他的视频相对更简单，更好懂。下面开始…"}, {"id": "6844903703917363208", "title": "找到好工作之 LeetcodeTop100(Easy) by JavaScript", "desc": "1. two sum 因为需要返回下标，因此先排序后用两个指针扫（前->后, 后->前）的方式（NlogN）不行。 20. Valid Parentheses 必须使用相同类型的括号关闭左括号。 必须以正确的顺序关闭左括号。 21. Merge Two Sorted Lists…"}, {"id": "6844904146567593997", "title": "前端工程师的 LeetCode 之旅 -- 周赛 185", "desc": "给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 解释：…"}, {"id": "6988906576975233038", "title": "【LeetCode刷题 不知道能坚持几天 orz...】13. 罗马数字转整数", "desc": "力扣刷题 Day0 原题：13. 罗马数字转整数，不知道能坚持几天 orz...题目难度：简单，时间复杂度：o(n), 空间复杂度：o(n)"}, {"id": "6844904199050756110", "title": "「种树专业户」“树”业有专攻", "desc": "食堂老板(童欧巴)：就算我们作为互联网浪潮中的叶子结点，也需要有蚍蜉撼树的精神，就算蚍蜉撼树是自不量力。因为就算终其一生只是个普通人，但你总不能为了成为一个普通人而终其一生吧。 今日菜谱，蚂蚁上树，下面介绍一下演员。 A 是 根节点。C、D、F、G 是 叶子节点。A 是 B 和…"}, {"id": "7002408928197754910", "title": "「前端刷题」30. 串联所有单词的子串", "desc": "这是我参与8月更文挑战的第30天，活动详情查看：8月更文挑战 题目 https://leetcode-cn.com/problems/substring-with-concatenation-of-a"}, {"id": "6938569371342077959", "title": "338. 比特位计数 | 刷题打卡 ", "desc": "按位与运算（&#x26;）的一个性质是：对于任意整数 x，令 x=x &#x26; (x−1)，该运算将 x 二进制表示的最后一个 1 变成 0。 因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」。 给定一个非负整数 num。对于 0 ≤ i ≤…"}, {"id": "6932331789671202824", "title": "搞定算法-巩固链表基础", "desc": "了解链表的同学都知道，它是通过指针将一组零散的内存串联起来。可见链表对内容的要求降低了，但是随机访问的性能就是没有那么好了，需要O(n)的时间复杂度。 对与链表的操作主要是添加和删除，其实对链表的操作本质是也是对链表之间的指针进行操作。其数据结构大致为： 对链表的操作也就是更改…"}, {"id": "6913143820129402893", "title": "前端就该用 JS 刷算法2", "desc": "题目翻转二叉树以匹配前序遍历过程在最开始做题的时候，是想根据完全二叉树的方式来判断左右节点的值是否需要翻转，但是voyage并不会将所有null节点引入，所以找的pos和voyage数组的index是"}, {"id": "6895894824415657991", "title": "一文带你玩转设计模式之「责任链」", "desc": "前言对于已经工作了的小伙伴，你应该是见过\"责任链\"这种面向对象的设计模式的，还在上学的小伙伴也不用着急，你迟早会接触到的。本文旨在让小白同学和不太熟悉责任链的朋友能够迅速对这一设计模式有一个大致的了解"}, {"id": "6862597822248976398", "title": "记一次HEX和RGB互换算法的思考及应用", "desc": "由于笔者最近在开发可视化平台,所以对动态编辑器这块做了一段时间的研究, 发现其中有个小模块的知识点比较有意思,所以在这里分享一下. 所以笔者在这里就分享一下HEX与RGB之间相互转换的原理和算法, 并且实现随机生成HEX值和随机生成RGB值的函数,最后带着大家深度理解和掌握颜色…"}, {"id": "6969368478608261150", "title": "前端刷题路-Day39：两数相加（题号2）", "desc": "给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。"}, {"id": "6844903630579957774", "title": "从闭包函数的变量自增的角度 - 解析js垃圾回收机制", "desc": "感觉每一道都可以深入研究下去，单独写一篇文章，包括不限于闭包，原型链，从url输入到页面展示过程，页面优化，react和vue的价值等等。 因为times变量一直被引用，没有被回收，所以，每次自增1。 按照JavaScript里垃圾回收的机制,是从root(全局对象)开始寻找这…"}, {"id": "6844903679460376590", "title": "ARKit：增强现实技术在美团到餐业务的实践", "desc": "增强现实（Augmented Reality）是一种在视觉上呈现虚拟物体与现实场景结合的技术。Apple 公司在 2017 年 6 月正式推出了 ARKit，iOS 开发者可以在这个平台上使用简单便捷的 API 来开发 AR 应用程序。 本文将结合美团到餐业务场景，介绍一种基于…"}, {"id": "6844903629753679886", "title": "美团外卖iOS多端复用的推动、支撑与思考", "desc": "美团外卖2013年11月开始起步，随后高速发展，不断刷新多项行业记录。截止至2018年5月19日，日订单量峰值已超过2000万，是全球规模最大的外卖平台。业务的快速发展对技术支撑提出了更高的要求：为线上用户提供高稳定的服务体验，保障全链路业务和系统高可用运行的同时，要提升多入口…"}, {"id": "6887157774787018765", "title": "矩阵链相乘", "desc": "给定n个矩阵序列：（A1，A2，A3，...,An）。计算他们的乘积，使得乘法次数最小 在此数组中，最终目标是求出m[1,4]，也就是A1A2A3A4四个矩阵相乘的最优乘法次数。设想可以通过已经得出的结果求出最终结果，在数组中利用对角线的顺序求解，如下图所示："}, {"id": "6844903599793766408", "title": "网站登录JWT的实现", "desc": "JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。 JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 第一部分我们称它为头部（header),第二部分…"}, {"id": "6844903696153706509", "title": "VueJS 的编译阶段到挂载节点", "desc": "为了实现响应式模式，Vue用render函数来生成vnode，并使用diff算法对比新旧vnode，最后更新到真实DOM上。 由于是在编译阶段而不是在监听阶段，所以vnode没有对比的对象，直接通过vnode生成真实DOM。 Vnode是Vdom上的一个节点，是对真实DOM的抽…"}, {"id": "6844903815657816071", "title": "每日一算 -- 斐波那契数列类型题", "desc": "斐波那契数列指的是这样一个数列1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368........ 这个数列从第3项开始，每一…"}, {"id": "6971288037800017951", "title": "LeetCode第122题：买股票的最佳时间2", "desc": "题干 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能"}, {"id": "6971286253085917220", "title": "LeetCode第121题：买股票的最佳时间", "desc": "题干 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个"}, {"id": "6938296362274881549", "title": "[ 力扣53 ] 最大子序和 | 刷题打卡", "desc": "给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 数组的sort方法如果参数不传，…"}, {"id": "6911679187271024647", "title": "回溯算法巧解全排列问题  | 创作者训练营", "desc": "回溯算法的主要特征有两点：一是要遍历所有的情况；二是找到一种可行解后，要回退到上一步，遍历其他情况。 回溯算法，重在「回溯」。有来有回，遍历完一种情况，需要回退到上一步。这里是理解回溯算法的关键。在代码中则表现为：回溯的前一步将子项加入到数组中，后一步又将子项移除。刚开始看着有…"}, {"id": "6844903628935806984", "title": "浅解前端必须掌握的算法（四）：希尔排序", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，了解一下基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎添翼，能让我们的…"}, {"id": "6844903648762265613", "title": "擒贼先擒王，简单谈一下JavaScript作用域链（Scope Chain）", "desc": "我们都知道一个执行上下文的数据（变量、函数声明和函数的形参）作为属性存储在变量对象中，同时我们也应该知道变量对象在每次进入上下文时创建并填入初始值，值的更新出现在代码执行阶段。那么咱们专门讨论与执行上下文直接相关的更多细节，这次我们将提及一个议题——作用域链。 如果要简要的描述…"}, {"id": "6937229953859584007", "title": "[ 力扣38 ] 外观数列|刷题打卡", "desc": "给定一个正整数 n ，输出外观数列的第 n 项。 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 要描述 一个数字字符串，首先要将字符串…"}, {"id": "6844903498111254541", "title": "常用滤镜算法以及WebGL实现", "desc": "如果你想仔细了解文中WebGL实现的滤镜算法，首先你得具备一些原生WebGL知识，但是如果你只是想大概了解滤镜算法的作用和规律，不具备原生WebGL知识也没关系，建议跳过具体实现，聚焦文字说明、函数、图形、矩阵等；另外下述部分关于滤镜的WebGL实现都是参考于WebGLImag…"}, {"id": "6950592875860066340", "title": "前端必会的数据结构与算法之算法复杂度", "desc": "求复杂度的数学基础估计算法资源消耗所需的分析一般说来是一个理论问题，因此需要一套正式的系统构架。我们先从某些数学定义开始。这些定义的目的主要是在函数间建立一种相对的级别。"}, {"id": "6950431137831321607", "title": "前端刷题路-Day15｜刷题打卡", "desc": "解数独（题号37） 题目 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 1. 数字 `1-9` 在每一行只能出现一次。 2. 数字 `1-9` 在"}, {"id": "6844903500975980557", "title": "从 Template 到 DOM（Vue.js 源码角度看内部运行机制）", "desc": "从 Template 到 DOM（Vue.js 源码角度看内部运行机制）"}, {"id": "6844903926769123342", "title": "「leetcode」392.判断子序列", "desc": "给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符…"}, {"id": "6937843019781668872", "title": "[LeetCode55.跳跃游戏] | 刷题打卡", "desc": "给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 如果能够到达最远的地方，那一定能到到最远前面的任意地方。 主要是能够理解，最远能到达某个位置，就一定能到达它前面的任何位置。"}, {"id": "6993666899858948104", "title": "前端算法必刷题系列[81]", "desc": "这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 前面连续的难题，来几个简单点放松下 149. 只出现一次的数字(single-number) 标签 简单 异或 给定一个非空整数数组，除了某"}, {"id": "6971229232617750542", "title": "前端刷题路-Day44：砖墙（题号554）", "desc": "你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等..."}, {"id": "6844903632974905358", "title": "JavaScript中的强制类型转换", "desc": "总结和剖析JavaScript中的强制类型转换，主要参考《你不知道的JavaScript(中卷)》第四章。 文章内容主要分为五个部分，第一部分讲述向基本类型数据转换的4种抽象操作，第二部分讲述显式强制类型转换，第三部分讲述隐式强制类型转换，第四部分讲述相等关系，其中需要掌握“抽…"}, {"id": "6951368041590423582", "title": "AES 前后端加解密方案", "desc": "AES: 密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准，是最为常见的对称加密算法"}, {"id": "6993710363510308900", "title": "「前端刷题」7. 整数反转", "desc": "给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−23"}, {"id": "6991460821033287694", "title": "LeetCode两数之和｜8月更文挑战", "desc": "背景 本人是一个前端程序猿，每天从事着普普通通的工作，羡慕那些能进大厂的大佬，总感觉自己很迷茫，也想要进大厂，于是便咨询了一些大佬，通过大佬们了解到进大厂都需要考察算法题，于是我便开始了我的刷算法之旅"}, {"id": "6987339666156584968", "title": "OpenRASP xss算法的几种绕过方法", "desc": "openrasp默认只能检测反射型XSS，存储型XSS仅IAST商业版支持。对于反射型xss，openrasp也只能检测可控输出点在html标签外的情况，本文的绕过方法是针对这种情况。如果可控输出点在"}, {"id": "6979396673436909604", "title": "前端刷题路-Day66：石子游戏（题号877）", "desc": "亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克..."}, {"id": "6894577333630418958", "title": "【算法】JS 实现对象的扁平化", "desc": "我们从结果入手，可以知道我们需要对象进行遍历，把里面的属性值依次输出，所以我们可以知道核心方法体就是：传入对象的 key 值和 value，对 value 再进行递归遍历。 我们知道 js 的数据类型可以基础数据类型和引用数据类型，对于题目而言，基础数据类型无需再进行深层次遍历…"}, {"id": "6844903505203822599", "title": "JS中的算法与数据结构——排序（Sort）", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6844903991151706119", "title": "动画：二分查找(上) | 面试官问我如何在 1 亿数据中快速查找某一整数？", "desc": "今天就来学习一下在一组有序数据中如何快速查找一个数。也就是我们所说的二分查找，虽然很多小伙伴对二分查找很熟悉，但是到了真正的应用问题上，还是不能更好的来把握二分的思想。要想把这部分把握好，还需要真正的体验一下二分查找的强大的效率。 如题目中所述，如果你今天去面试，面试官要问你如…"}, {"id": "6940449659194179621", "title": " 春招冲冲冲(钉钉+腾讯)", "desc": "春招已经开始了。 你是不是已经开始准备了呢？为了帮助大家获得更好的 offer，lucifer 开辟了春招冲冲冲栏目。 今天我们的猎物是钉钉和腾讯。来看看这两家的算法题难度几何吧！ 随机生成一个长度为 8 的字符并将其存到哈希表中，下次生成后判断是否已经在哈希表中了。如果存在，…"}, {"id": "6994435150604042247", "title": "算法题-顺时针打印矩阵", "desc": "题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 分析：矩阵可以用二维数组来模拟。 示例 ： 题解 方法一：模拟打印"}, {"id": "6844904038060785671", "title": "二叉树前中后序遍历非递归实现（JavaScript）", "desc": "二叉树使用递归实现前中后序遍历是非常容易的，本文给出非递归实现前中后序遍历的方法，核心的思想是使用一个栈，通过迭代来模拟递归的实现过程 下面实现中root代表二叉树根节点，每个节点都具有left,ri"}, {"id": "6844903687819624461", "title": "理解 JSON Web Tokens (JWT) 的 5 个简单步骤", "desc": "在本文中，将解释JSON Web Tokens（JWT）的基本原理以及使用原因。 JWT 是确保应用程序信任和安全的重要部分。 JWT 允许以安全的方式表示诸如用户数据之类的声明。 为了解释 JWT 如何工作，让我们从一个抽象的定义开始。 应该注意，双引号字符串被认为是有效的 …"}, {"id": "6992970434635366437", "title": "LeetCode 42 Trapping Rain Water (Tag:Array Difficulty:Hard)", "desc": "这是我参与8月更文挑战的第5天，活动详情查看：8月更文挑战 前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉"}, {"id": "6844903654357467144", "title": "堆栈的应用——用JavaScript描述数据结构", "desc": "基于堆栈的特性，可以用数组做线性表进行存储。 接下来，就是在原型上，对入栈、出栈、清空栈、读取栈顶、读取整个栈数据这几个接口的实现。 Stack类默认以数组头部做栈底，尾部做栈顶。 入栈可以利用js数组的push方法，在数组尾部压入数据。 出栈同样是利用js数组的pop方法，在…"}, {"id": "6972367100967026724", "title": "背包问题", "desc": "前端算法-背包问题 最近刷LeetCode的发现最近几天的每日一题，背包问题还是蛮多，下面我将根据自己对解答方式的看法，做出的一些总结。 前言 假设我有一个背包，容量为10 如有一下物品，计算出，用容"}, {"id": "6989038298463207431", "title": "一起学习正则表达式（四）常见的4种匹配模式", "desc": "往期回顾： 《一起学习正则表达式（一）那些让人头晕的元字符》 《一起学习正则表达式（二）量词与贪婪》 《一起学习正则表达式（三）分组与引用》 《一起学习正则表达式（四）常见的4种匹配模式》 0.写在前"}, {"id": "6891444190190780429", "title": "快速排序为什么这么快？", "desc": "快速排序首先选一个基准 pivot，然后过一遍数组，把小于 pivot 的都挪到 pivot 的左边，把大于 pivot 的都挪到 pivot 的右边。这样一来，这个 pivot 的位置就确定了，也就"}, {"id": "7007627531981422628", "title": "LeetCode《初级算法》字符串之整数反转 -- JavaScript ", "desc": "LeetCode《初级算法》-- JavaScript 实现； 字符串：整数反转； 解题思路和代码实现；"}, {"id": "7007341127900626957", "title": "【算法】如果玉兔遇到莱昂纳多 · 斐波那契，那明年中秋嫦娥在月亮上会拥有几只玉兔？", "desc": "马上中秋节就要到了，也不知道我家嫦娥在月亮上过的怎么样，玉兔还陪在她身边吗？ 今天我们来探讨一个有趣的问题，如果玉兔遇到莱昂纳多·斐波那契，那明年中秋嫦娥在月亮上会拥有几只玉兔？"}, {"id": "7007689733325193223", "title": "我建造一条楼梯通往月球，我有多少种方式能追到嫦娥姐姐呢？", "desc": "我正在参加中秋创意投稿大赛，详情请看：中秋创意投稿大赛 前言 我昨晚冥思苦想啊，想想如何才能出一篇跟中秋有关的文章呢？但是我的眼里只有嫦娥，所以我想到了嫦娥奔月，话说嫦娥奔月那是有多长的路径啊？如果我"}, {"id": "7007450902990684191", "title": "js实现空间复杂度为O(1)的快排", "desc": "看了各种快排实现，想寻找一种空间复杂度为O(1)的实现，无奈没有找到合适的。 因此想自己动手试试，半个小时过去没有半点进展。 想起曾经收藏过一个算法可视化网站Data Structure Visual"}, {"id": "7004454008634998821", "title": "太震撼了！我把七大JS排序算法做成了可视化！！！太好玩了！", "desc": "前言 大家好，我是林三心。写这篇文章是有原因的，偶然我看到了一个Java的50种排序算法的可视化的视频，但是此视频却没给出具体的实现教程，于是我心里就想着，我可以用JavaScript + canva"}, {"id": "7007654648832245774", "title": "30分钟简单实现对10W+数组字符串进行快速筛选", "desc": "背景 最近想到搜索引擎是如何快速的匹配字符串的，假如数据库录入几十万甚至几千万的数据...那计算量该有多大？大量字符串搜索"}, {"id": "7000266544181674014", "title": "DIff算法看不懂就一起来砍我(带图)", "desc": "前言 面试官:\"你了解虚拟DOM(Virtual DOM)跟Diff算法吗,请描述一下它们\"; 我:\"额,...鹅,那个\",完了😰,突然智商不在线,没组织好语言没答好或者压根就答不出来;"}, {"id": "7002746459456176158", "title": "电商最小存货 - SKU 和 算法实现", "desc": "前言 目前电商平台的业务中，只要有商品，不可避免的会遇到 SKU 方面功能。这篇文章就从理论到实践，从商品创建到商品购买，手把手带你实现 SKU 相关的“核心算法”。 让我们看看实际场景： 有了上图规"}, {"id": "6983904373508145189", "title": "面试了十几个高级前端，竟然连（扁平数据结构转Tree）都写不出来", "desc": "「本文已参与好文召集令活动，点击查看：后端、大前端双赛道投稿，2万元奖池等你挑战！」 前言 招聘季节一般都在金三银四，或者金九银十。最近在这五六月份，陆陆续续面试了十几个高级前端。有一套考察算法的小题"}, {"id": "7007764964026875918", "title": "前端算法 动态规划", "desc": "1.爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢 2.打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一"}, {"id": "7007990107035123726", "title": "揭秘你处理数据的“底层逻辑”，详解公式引擎计算（一）", "desc": "背景 身处信息时代之中，我们最能明显感受到的一点就是密集数据大量爆发，人们积累的数据也越来越多。这些庞杂的数据出现在一起，传统使用的很多数据记录、查询、汇总工具并不能满足人们的需求。更有效的将这些大量"}, {"id": "7007800114848890917", "title": "【JavaScript算法刷题：最大子序列和】力扣53题", "desc": "本文主要解析力扣第53题的解法，本体较为基础，但思路很巧妙。 重点语句解析： addRes = Math.max(nums[i]+addRes,nums[i]) 这段代码主要是采用了如下的思路： 假设"}, {"id": "7002884193910784013", "title": "连接更广的世界，首届稀土开发者大会将于线上召开，免费预约通道现已开启！", "desc": "稀土开发者大会是由稀土掘金技术社区主办，集国际化前瞻性及实践性一体，性价比极高的综合性技术大会。面向开发者社区新生中坚力量，旨在帮助研发团队骨干拓宽视野，实现跨越式成长。"}, {"id": "7007680617735258142", "title": "前端“树”结构数据常用操作汇总", "desc": "树结构数据的一些常用操作函数，如树的遍历、树转列表、列表转树、树节点查找、树节点路径查找，树过滤等等"}, {"id": "7006617009416831006", "title": "前端与数据结构和算法之栈", "desc": "前言 关于数据结构和算法，是前端或者说是整个技术界上技术进阶以及涨薪路上的最大难题。 不过任何难题，当你打算去细看和仔细动手实现一番时，它并没有你想象的那么难。 笔者也是正在路上的一枚小菜鸟罢了，这篇"}, {"id": "7004599447795548191", "title": "公开抽奖算法！公示开奖记录！请叫我“蜻蜓队长”！", "desc": "第一，绝对不意气用事；第二，绝对不漏判一件坏事；第三，绝对裁判得公正漂亮。裁判机器人蜻蜓队长前来觐见！"}, {"id": "7007332489068806181", "title": "每日一道LeetCode  提神醒脑", "desc": "每日一道LeetCode 提神醒脑 此篇文章用来记录自己学习算法的点点滴滴 每天进步一点点 每天努力一点点 每天成长一点点"}, {"id": "7000883000749588510", "title": "手撸二叉树之二叉搜索树的最小绝对差", "desc": "Hello, 大家好，今天是我参加8月更文的第 27 天，今天给大家带来的关于二叉树相关的算法题是二叉搜索树的最小绝对差，正文如下： 题目 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点"}, {"id": "7007682956584026119", "title": "Ant Design Transfer 双树穿梭框“造轮子”", "desc": "主要实现完整的树形穿梭框，穿梭框左侧和右侧都是树形结构，而且父子节点有联动关系，还是用于城市选择组件"}, {"id": "7007609943528325157", "title": "算法题：LRU缓存机制", "desc": "运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和写入数据 put 。 获取数据 get(key) - 如果密钥 ( key ) 存"}, {"id": "6979999939753574407", "title": "LeetCode 46. 全排列 --javascript DFS", "desc": "47. 全排列 II 描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 示例 2： 示例 3： 提示： 题解 回溯法 回溯法（bac"}, {"id": "6940957081633718280", "title": "前端刷题路-Day1", "desc": "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 解释：因为 nums[0] + nums[…"}, {"id": "6989264400683106311", "title": "LeetCode算法学习之--链表--K个组翻转链表", "desc": "大家好今天给大家分享下一道 LeetCode 困难难度 的题目[K 个一组翻转链表](https://leetcode-cn.com/problems/linked-list-cycle-ii/) 题"}, {"id": "6844903698179555341", "title": "前端与人工智能", "desc": "好吧，我承认这个标题有点太大了，其实我更想要说的是“在人工智能时代、在人工智能公司、在人工智能部门，我们前端er的角色到底是怎样的”。 众(ge)所(ren)周(yi)知(yin)，现在或者说未来的的前端发展有这么几个方向，前端+Node.js、前端+各种端(包括IOT)、前端…"}, {"id": "6996552925145202695", "title": "算法（leetode，附思维导图 + 全部解法）300题之（11）盛最多水的容器", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（11）盛最多水的容器 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码："}, {"id": "6992031872818053157", "title": "前端算法必刷题系列[78]｜8月更文挑战", "desc": "145. 七进制数 (base-7) 标签 数学 简单 题目 leetcode 传送门 这里不贴题了，leetcode打开就行，题目大意： 给定一个整数，将其转化为7进制，并以字符串形式输出。 示例 "}, {"id": "6962083070442733598", "title": "【前端学算法】位运算的算法应用", "desc": "作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，本文将会介绍位运算的原理、常见的算法题以及一些日常开发中的小技巧"}, {"id": "6983315841404108808", "title": "Leetcode刷题：最长连续序列", "desc": "点击查看：如何为一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度"}, {"id": "6957226461673553957", "title": "JS算法-删除链表节点", "desc": "本文来自于leetcode 第 237 题 和 剑指 offer 第 18 题。 题目描述 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点。"}, {"id": "6991464200430157855", "title": "村庄分水最优分配（上）｜ 8月更文挑战", "desc": "假设要给一个村庄的所有房屋供水，在一间房屋建造水井具有开销，建造房屋之间的管道来输送水也有开销，那么如何才能成本最小得给所有房屋供水呢？"}, {"id": "6904595258915422215", "title": "前端玩转位运算(N皇后+Vue3位运算应用)", "desc": "其实很简单，小学数学题难度，花几分钟看完如果看懂了请点个赞呗。 二进制左移一位，就是将数字翻倍。 二进制 110101 向左移一位，就是在末尾添加一位 0，也就是 1101010。(此处讨论的是数字没有溢出的情况) 二进制右移一位，就是将数字除以 2 并求整数商。 二进制 11…"}, {"id": "7000370254018953252", "title": "JavaScript链表刷题（三）", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 之前写了JavaScript链表刷题，JavaScript链表刷题（二） 有兴趣的童鞋可以冲，接下来继续刷两道链表题~~ 一、反转链表II"}, {"id": "6844903917008977928", "title": "LeetCode 攻略 - 2019 年 8 月上半月汇总（109 题攻略）", "desc": "自 2019-05-16 开始，jsliang 开始了 算法与数据结构 攻略（划水）之旅。 jsliang 每天会折腾一道及以上 LeetCode 题目，并将其解题思路记录成文章，发布到 GitHub 和 微信公众号 上。 这里不一一累述。 汇总了【数组】知识点。 攻略了 8 …"}, {"id": "6969719701958033421", "title": "记一道算法题解题思路，字符串解析成标题结构", "desc": "如何将一串字符串解析为一棵标题树呢？如果将功能应用在Markdown当中，又如何去适应不同标题的前缀呢？"}, {"id": "6935309050145931272", "title": "树遍历算法之深度优先和广度优先", "desc": "前言前两天看到一个阿里面试题关于dfs和bfs的算法题，在网上找了很多，没确切答案。今天我们一起来做下这个题目题目要求非递归方式拿到搜索内容，那么我们不用递归怎么去实现查找呢？如果我们用递归方式非常简"}, {"id": "6976790342322356238", "title": "【算法】懂点算法 01 —— 时间复杂度和空间复杂度", "desc": "为了帮助更多人去理解数据结构和算法，将开辟新的博文系列《懂点算法》，希望大家能够渡过痛苦的日子。本人在算法研究上，能力有限，希望大家能够取其精华，汲取干货。"}, {"id": "6844904055190323208", "title": "朝花夕拾 - 2019 总结（附  283 道 LeetCode 题解）", "desc": "时间：2020.02.01。 [x] jsliang 把 Visio Studio Code 中的所有简单难度 LeetCode 都刷完了。 完成的那一刻，除了和朋友分享下喜悦，并没有想象中的非常激动。 我从 2019.05.16 开始，经公司同事 @__MARPTS罗 的推荐…"}, {"id": "7000367780990189604", "title": "「前端刷题」24. 两两交换链表中的节点", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 题目 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。   示例"}, {"id": "6988708396866207758", "title": "LeetCode刷题，二叉树的后序遍历（145）", "desc": "思路：递归的本质就是使用栈来进行计算，所以我们手动创建一个栈，一直找到最底层的树节点，按照左右根的顺序进行入栈即可。"}, {"id": "6998092459037163527", "title": "JavaScript链表刷题（二）", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 之前写了JavaScript链表刷题，有兴趣的童鞋可以冲，接下来继续刷两道链表题~~ 一、快乐树 202. 快乐数 编写一个算法来判断一个"}, {"id": "6985065102709882917", "title": "LeetCode第110题：平衡二叉树", "desc": "题干 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 示例 2： 来源：力扣（Leet"}, {"id": "6877828426892328974", "title": "寻找一定范围内的质数", "desc": "还请大家带着这样的疑问，继续深入的向下看。 1. 第一版：双循环 OK，题目写完了，我们就来验证一下。 1. 查找 100 以内的质数数量。 这里我们可以看到，逻辑没问题，能正常筛选出来。 2. 查找 10000 以内的质数 3. 查找 1000000 以内的问题 这里，当我们…"}, {"id": "6936203702378332197", "title": "53. 最大子序和｜刷题打卡", "desc": "53. 最大子序和｜刷题打卡 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 进阶：如果你已经实现复杂度为 O(n) …"}, {"id": "6844903695226765320", "title": "图像主题色的提取", "desc": "工作时遇到一个需求：提取图片主题色，通过某种映射关系，选取ui给出的对应颜色。脑海中浮现如果只是纯前端如何实现呢？ 利用canvas获取图像像素信息，然后用某种算法将主题颜色提取出来。 data：Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范…"}, {"id": "6938410175846383647", "title": "LeetCode 103 & 199 & 542 | 刷题打卡", "desc": "DFS（deep-first-search 深度优先遍历）和 BFS（breath-first-search 广度优先遍历）都是常见的搜索算法。往往和递归、遍历、回溯的概念相关联。我把这两种搜索过程，形象描述成以下两个场景： 深度优先的过程符合我们生活中的寻路逻辑，因为它有一条…"}, {"id": "6844903703942529037", "title": "初探虚拟 DOM", "desc": "如果有这么一张表格要你维护。 表格简单的时候还好，用 JavaScript 操作起来还算方便。但随着应用越来越复杂，需要处理的数据也越来越大，越来越复杂的时候，需要利用 JavaScript 操作的地方也会越来越多，这个时候准确地修改数据就变得不是那么容易了。 用这个对象来表示…"}, {"id": "6844903677841391623", "title": " TypeScript实现数组相关简单算法", "desc": "算法看起来在离我们一般的开发者不是很近，但是实际上又和我们的开发息息相关。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。现在想想大学的时候没有好好的学习算法和数据结构真的是后悔的吐血。本文只是简单理解算法，并不会深入的…"}, {"id": "6968339012738088997", "title": "前端数据结构与算法学习之链表（js 实现）", "desc": "链表的概念 根据百科的描述： 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 它大致长这样： 图片来源：wikipedia 链表有很多种结构，比"}, {"id": "6867344961382776840", "title": "简单理解KMP算法", "desc": "学到KMP算法是不是感觉明明不难原理都懂但是总感觉没有理解透彻？next数组怎么求出来的？尤其是代码实现里的那句j=next[j]怎么理解？ 如果你脑袋里也有这些问号，不要着急，你不是一个人。耐心看完这篇文章，相信能让你茅塞顿开，豁然开朗。 说起字符串匹配，最直观的也是最容易想…"}, {"id": "6844903669012381709", "title": "Box2D 学习：平衡车", "desc": "使用 p5.js 和 JavaScirpt 版 Box2D 实现简易平衡车模型"}, {"id": "6844903501856768013", "title": "翻译 | 像 JavaScript 一样思考", "desc": "「几天前我在一个专题讨论会讲 JavaScript，午饭时候一个学员跑来向我请教一个 JS 难题，而它确实把我给难住了。他保证说这个问题是偶然间遇到的，而我对此表示怀疑，因为这极有可能是一道有意而为之的烧脑题。」"}, {"id": "6844903656874049543", "title": "[译] 关于 Angular 依赖注入你需要知道的", "desc": "如果你之前没有深入了解 Angular 依赖注入系统，那你现在可能认为 Angular 程序内的根注入器包含所有合并的服务提供商，每一个组件都有它自己的注入器，延迟加载模块有它自己的注入器。 不久前有个叫 Tree-Shakeable Tokens feature 被合并到 m…"}, {"id": "6973121302466920462", "title": "汉诺塔（hanoi）问题", "desc": "汉诺塔（hanoi）问题古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小 不等，大的在下，小的在上（如图）。有一个和尚想把这64个盘子从A座移 到C座，但每次只能允许移动一个盘子，"}, {"id": "6932380743083491336", "title": "实现一个did you mean效果", "desc": "这次来尝试实现一下did you mean效果。 具体来说就是比如我们使用一些cli工具的时候，如果打错了几个字，则会提示你要输入的是不是别的什么东西。 比如使用vue-cli打一个命令vue create的时候故意打错vue creat，就会有类似的提示。 一般这种效果会使用…"}, {"id": "6844903757143080973", "title": "算法的时间复杂度", "desc": "作为一个非典型的前端开发人员，我们要懂得一些算法的概念，并将其理论知识引入日常的开发中，提高日常的开发效率和提升产品的体验。 算法： 算法是指解题方案的准确而完整的描述，是一系列解决问腿的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 算法的效率： 是指算法执行的时间…"}, {"id": "6978340003139026958", "title": "LeetCode第300题：最长递增序列", "desc": "题干 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1"}, {"id": "6978337125150228517", "title": "LeetCode第90题：解码方法", "desc": "题干 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\" 可以映射为： 注意，消息"}, {"id": "6984016792251269150", "title": "算法的复杂性分析，时间和空间复杂度。", "desc": "为什么需要复杂度分析？ 有些人认为写的一套算法，通过监控和统计，就能很准确的知道运行时间和占用的内存大小。 这种统计法是对的，但是它有一个很大的局限。 结果依赖于机器 找配置高的机器，和配置低的机器，"}, {"id": "6952440950392094756", "title": "爬楼梯|刷题打卡", "desc": "前言本文正在参与掘金团队号上线活动，点击查看大厂春招职位。题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个"}, {"id": "6844903743796822024", "title": "《计算机程序设计艺术》作者高德纳", "desc": "提起算法大师高德纳（Donald Knuth），不得不提他这 50 年来的鸿篇巨制——《计算机程序设计艺术》。 半个世纪以来，斯坦福大学计算机科学高德纳已然成为算法领域的精神指南，他与 Yoda（译者注：《星战》中的尤达大师）略有相似之处 - 虽然他身高 6 英尺 4 英寸，戴…"}, {"id": "6951428345988907039", "title": "算法小记", "desc": "计算字符串中出现最多的字符和其出现次数，快排，冒泡，插入，斐波那契数列，单链表反转等基本算法，作者会持续更新"}, {"id": "6844903902916116487", "title": "拿起算法的钢笔: 找出两个有序数组的中位数", "desc": "题目：请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 i 与 j 满足一定的关系 i + j = ( m + n )/2 , 或者 i + j = ( m + n + 1)/2 ,…"}, {"id": "6844903618861088781", "title": "数据可视化的基本原理——视觉通道", "desc": "数据可视化为了达到增强人脑认知的目的，会利用不同的视觉通道对冰冷的数据进行视觉编码。 我们在数据可视化的时候，一方面，展现可视化对象本身的位置、特性，对应的视觉通道类型是定性或者分类，比如汽车在什么地方、汽车的种类；另一方面，展现对象的某一个属性值大小，对应的视觉通道类型是定量…"}, {"id": "6937607940903796750", "title": "[ 力扣125 ] 验证回文串（简单题开个好头） | 刷题打卡", "desc": "给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 所以能拿到另一半字符串，如果是偶数长度，则忽略中间字符，得到同样效果。 本题解已同步GitHub地址，可以复制代码进行调试。"}, {"id": "6938301455086387208", "title": "[LeetCode617题合并二叉树] | 刷题打卡", "desc": "题目地址: 617. 合并二叉树 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。…"}, {"id": "6844904169279586311", "title": "【91算法-基础篇】05.双指针", "desc": "顾名思议，双指针就是「两个指针」，但是不同于C，C++中的指针， 其是一种「算法思想」。 如果说，我们迭代一个数组，并输出数组每一项，我们需要一个指针来记录当前遍历的项，这个过程我们叫单指针（index）的话。 那么双指针实际上就是有两个这样的指针，最为经典的就是二分法中的左右…"}, {"id": "6936060863761612813", "title": "力扣 (LeetCode)-只出现一次的数字 | 刷题打卡", "desc": "暴力法，根据索引来判断。indexOf从左往右找，lastIndexOf从右往左找。 当元素只出现一次时，无论从哪里找起，索引都是相同的。结果返回元素即可 暴力干掉一切。"}, {"id": "6844903725392216071", "title": "G6的插件系统", "desc": "G6的插件系统做的相当完善, 可惜文档没有具体说到. 这里整理一下g6的插件. 这四种插件都有各自的写法以及api, 但是文档中没有提到, 这里简单介绍一下. 一下都以官方插件为例. 其实到这里我们已经知道了, 只要是在一些内置事件中注册一下自定义事件再引入我们就可以称之为一个…"}, {"id": "6985407458810265613", "title": "LeetCode第543题：二叉树的直径", "desc": "题干 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例 : 给定二叉树 返回 3, 它的长度是路径 [4,2,1"}, {"id": "6844903517132423176", "title": "A*寻路算法 - 躲避障碍物 - 找到最短路径", "desc": "我是这么理解的，Dijkstra算法就是从起点开始一圈一圈向外扩散，直到扩散到终点，这样做肯定慢，但还是能找到一条最短路径。贪婪算法从直观上理解就是用最快的方法来解决问题，主要目标是快，从数学上来理解就是在做判断时以当前最优解为基础，每次取的都是当前位置距离终点最近的点，因为算…"}, {"id": "6906835912580300813", "title": "Backtracking algorithm 回溯算法", "desc": "回溯算法是一种通用的算法。回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实…"}, {"id": "6844903748267933703", "title": "JavaScript数据结构之队列", "desc": "队列添加新的元素，左侧是队列的头部，右侧是队列的尾部，新的元素如果想进入队列，只能从尾部进入。 日常生活中，排队就是典型的队列结构，先到的先被服务，后来的在队尾等着，直到轮到他为止（当然，特殊情况除外）。比如说其他场景 提交操作系统执行的一系列进程、打印任务池等，一些仿真系统用…"}, {"id": "6844903809701904397", "title": "从基础讲全排列（Java实现）", "desc": "提起全排列，第一印象是不是大学概率中的排列和组合呢，回头翻了翻书（怪自己太笨，记不住），才发现全排列是排列的一种。那就先延伸一下排列和组合呗。 一般地说，从n个不同元素中，任取m(m≤n)个元素，按照一定的顺序排成一列，这就叫做从n个元素中取出m个元素的一个排列。 这表明，n个…"}, {"id": "6844903592785084429", "title": "Vue.js 源码解析 2 - 编译与渲染函数", "desc": "感谢大家喜欢我的上一篇文章, 该系列的第二和第三篇文章将会分析 Vue.js 对 UI 的处理, 这一篇包括前半部分: 模板的编译, 渲染函数的生成和 VNode."}, {"id": "6844903641518882824", "title": "剑指Offer-29-字符串的排列", "desc": "输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 全排列：n个数按照一定顺序组成的排列，成为全排列。意思就是所有元素都参与排列。这些排列为n!。因为第一…"}, {"id": "6950503710682251294", "title": "[打卡4：leetcode7-整数反转]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第四题题目描述题目链接：整数反转题目"}, {"id": "6844903614838751245", "title": "用 js 获取页面元素的位置图文总结", "desc": "在做一些组件和交互时，常常需要动态获取鼠标点击位置、元素宽高和元素位置信息，网上有很多种方法，但自己没有总结过，不知道各种方法的优缺点和兼容性，在此专门的总结一下。 这些关于视觉的内容都被定义在了 W3C 的 CSSOM View Module 模块中，里面有详细的接口定义和说…"}, {"id": "6913558173530095629", "title": "动态规划入门与基本解题思路", "desc": "新的一年，大家要好好打起精神哟。从现在开始，争取每周输出一篇文章，激励自己不断成长。 讲一讲最近很喜欢的动态规划，语言是用JavaScript来写的，以后的文章可能也会多以前端为主。 动态规划是四种经典的算法思想之一，它不是一种具体的算法，而是提供一种解题思路。很多人觉得动态规…"}, {"id": "6979435279493332999", "title": "leetcode top100挑战, 每天不鸽一道题之 删除有序数组中的重复项(17/100)", "desc": "给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。"}, {"id": "6844903716877762574", "title": "【译】Facebook如何通过工具学习自动修复Bug ？", "desc": "Facebook的这个Getafix确实能做到自动修复bug，不过目前来看能修复的bug非常有限，在文中详细介绍了null pointer这种bug的解决方案，但在现实中很多bug是跟业务相关的，计算机几乎不能理解。 所以在译者看来，目前这个工具只能算作一个加强版的Lint工具…"}, {"id": "6844903616470319111", "title": "基于chart.js绘制热力图", "desc": "最近玩了玩图表的热力图，因为公司有同事想做无线设备的信号强度可视化，在不同频段（x 轴: MHz）的信号强度 ( y轴: dbm)本身就是一个两维的数据，加上随着时间的信号强度变化，在二维空间中会累加出热区效果，我们可以计算出热力值作为第三维数据。 ps: 以下图表显示的都是随…"}, {"id": "6844904074018553864", "title": "【第2期】前端算法精选-字符串系列", "desc": "今天精选的题目是关于字符串操作的，涉及到的技巧有字符串的滑动窗口思路、大数相乘。 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 理解一下题意，要求s1的字符串排列之一是第二个字符串的子串…"}, {"id": "6938793129839427614", "title": "LeetCode946.验证栈序列 | 刷题打卡", "desc": "给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 1.借助一个辅助栈来模拟压入、弹出的过程。 3.将pushV（压入顺序）中的…"}, {"id": "6948358673320116255", "title": "[LeetCode1. 两数之和][简单] | 刷题打卡", "desc": "给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 说明:你可以假设字符串只包含小写字母。 1、前面的思路和官方题解差不多，但是后面循环去比较不如官方版的方法好，自己考虑的还是不太全面，t 是 ss 的异位词等价于「两个字符串排序后相等」。因此我们…"}, {"id": "6948338880206602277", "title": "队列的典型题：栈实现队列、双端队列", "desc": "队列的特点：先进先出。 栈后进先出，队列先进先出。 思路是：「输入栈」正常push的时候，相当于队列的倒序；如果把「输入栈」的元素逐个弹出放到「输出栈」，相当于正序的队列，此时弹出就实现了先进先出。 当 pop() 元素的时候，优先从「输出栈」弹出元素。如果「输出栈」为空，则把…"}, {"id": "6844903556764401677", "title": "基于JavaScript求解八数码最短路径并生成动画效果", "desc": "本次分享一下通过广度优先搜索解决八数码问题并展示其最短路径的动画效果。"}, {"id": "6844903865574391816", "title": "动态规划学习笔记", "desc": "本文为个人学习动态规划的笔记，欢迎指正、评论。 R.Bellman从1955年开始系统地研究动态规划方法，为这个领域奠定了坚实的数学基础。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。距今（2019）已经62年。 动态规划（Dyna…"}, {"id": "6844903617728610312", "title": "Redux应用多人协作的思路和实现", "desc": "由于redux更改数据是dispatch(action)，所以很自然而然想到以action作为基本单位在服务端和客户端进行传送，在客户端和服务端用数组来存放action，那么只要当客户端和服务端的action队列的顺序保持一样，reducer是纯函数的特性可以知道计算得到的st…"}, {"id": "6844903667842154510", "title": "论如何获取 2 个多边形相交关系", "desc": "先向大家阐述我的应用场景：需求方欲通过在地图上绘制蜂窝以分配员工所负责区域。纯手工绘制易将道路、楼、园林、水系等切割引发划分纠纷，故我们接入一叫 block 的服务，根据绘制点返回周围的 N 个 block 即真正的地理分区（不切割道路、楼、园林、水系等），我们将这 N 个 b…"}, {"id": "6844903636816887821", "title": "vue响应式数据的实现原理解析", "desc": "今天讲下vue的响应式数据，也就是mvvm双向绑定模式，主要的目的是要让大家了解该模式在vue中是如何实现的，所以将以极简的代码进行示例。 这里就涉及到了vue的双向绑定。 接下来我就用一些非常简单代码实现以上功能。 首先，我们得解析vue中的v-model指令，也就是html…"}, {"id": "6972166729006841869", "title": "LeetCode第53题：最大子序和", "desc": "题干 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 思路：贪心 此题主要是寻找子问题，子问题每循环一次记录前面值的和，但是如果到当"}, {"id": "6972130152381677575", "title": "算法 - 二叉树递归遍历", "desc": "一、遍历方式 按照顺序规则 1.先序遍历 2.中序遍历 3.后序遍历 4.层序遍历 按照实现方式 1.递归遍历 （先、中、后序） 2.迭代遍历（层次） 递归思想 1.确定边界 (递归停止下来的条件，r"}, {"id": "6844903619045949447", "title": "深入理解javascript系列(二):内存空间", "desc": "因为javascript有GC存在，所以内存空间并不是被我们重视。王立大神说\"理解内存空间，就是成为大牛的开始\"。所以我们很有必要学习和理解内存空间。 函数运行时，会创建一个执行环境，这个执行环境叫做执行上下文（Execution Context）。在执行上下文中，会创建一个叫…"}, {"id": "6939063137886797854", "title": "创建一个简单的哈希表你会吗？｜刷题打卡", "desc": "原题链接705. 设计哈希集合 不使用任何内建的哈希表库设计一个哈希集合（HashSet）。 void add(key) 向哈希集合中插入值 key 。 bool contains(key) 返回哈希集合中是否存在这个值 key 。 void remove(key) 将给定值 …"}, {"id": "6938775765756411941", "title": "[LeetCode：Average of Levels in Binary Tree] | 刷题打卡", "desc": "应该也不难，给 preOrder 函数加一个 depth 参数，初始化的时候就是 preOrder(root,1)，表示根节点在第一层。递归访问左右子树时分别将 depth+1，下次递归时就能判断字数在哪一层 根据问题二，可以知道递归时节点所在的层级，更新数组中相应索引值的内容…"}, {"id": "6844903975645364231", "title": "算法小试--如何判断一个整数是复数", "desc": "首先分析下四个例子，我们很容易得知限制的场景是怎样的。 首先负整数肯定不符合，0符合, 但是能被10整除的显然也不符合。"}, {"id": "6844903585289863175", "title": "浏览器渲染过程与原理浅析（一）", "desc": "我为啥要知道浏览器渲染过程，嗯...面试会问....但最重要的是了解它工作原理，让你在弄它时，游刃有余。 先看下浏览器有什么。 用户界面 - 除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 …"}, {"id": "6844903846985072653", "title": "【算法题】最大连续子序和", "desc": "一道 LeetCode 的动态规划题的分析。 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 在分析如何使用动态规划求解该问题前，我们先简单了解下什…"}, {"id": "6909304763104362510", "title": "数组中数字出现", "desc": "稍微思考一会儿，你就能想出至少一道解法。。。。是不是觉得非常简单，其实！！！实现确实就是那么简单，毕竟条条大路通罗马。 能做出来，但是要求：其他数字智能出现2次，出现3 这个方法就挂了。 第三种，看完之后，惊叹：为何自己那么菜逼。 对于这题你可以理解为：不存在做加法，存在做减法…"}, {"id": "6938288831716294664", "title": "[LeetCode81.搜索旋转排序数组 II]｜刷题打卡", "desc": "假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 难度：中等。 这是 搜索旋转排序…"}, {"id": "6844903607855251463", "title": "详解动态规划01背包问题--JavaScript实现", "desc": "一开始在接触动态规划的时候，可能会云里雾里，似乎能理解思路，但是又无法准确地表述或者把代码写出来。本篇将一步一步通过作图的方式帮助初次接触动态规划的同学来理解问题。这一篇将以经典的 01背包 问题为例子来讲解，最后通过纯 JavaScript 来实现，在 Sublime 上运行…"}, {"id": "6974583777683046414", "title": "剑指offer之算法篇（上）", "desc": "本篇主要谈谈面试中比较头疼的一个点：算法 随着技术发展进入深水区，包括前端在内的程序员都躲不了算法这一关，今天主要结合自己研究算法的一些心得，和大家探讨下如何通过算法练习提高自身的技术水平"}, {"id": "6936471829791899685", "title": "[3. 无重复字符的最长子串] | 刷题打卡 ", "desc": "前言大三上学期了，为了拿offer，操练起来了！刷刷刷题目描述给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。示例1: 示例2:示例3:示例4:解题思路见示例出想法s=\"abcabcbb\""}, {"id": "6844903501743521800", "title": "漫画：什么是MD5算法？", "desc": "摘要哈希生成的正确姿势是什么样呢？分三步：1.收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。2.按照规则，把参数名和参数值拼接成一个字符串，同时把给"}, {"id": "6982531031346151455", "title": "Day 1 | 两数之和", "desc": "题目描述： LeetCode 地址 标签：数组 难度：简单 描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那 两个 整数，并返回它"}, {"id": "6847902220785025032", "title": "从酒桌游戏看二分查找算法", "desc": "酒桌上曾经玩过这样一个小游戏，游戏规则是：主持人每次随机从 1-1000 中选择一个数字，比如是 171。只有主持人自己知道并事先写在纸条上留存，然后分别让大家来猜，能够用最少次数猜到的人获胜并拥有指定一个人罚酒的权利。 主持人再次挑选数字，让扒蒜小妹去猜... 最后，童欧巴用…"}, {"id": "6844903574766370829", "title": "JavaScript变量的生命周期：为什么let不被提升", "desc": "提升实际上是把变量和函数定义移动到作用域顶部的过程，通常发生在变量声明var或函数声明function fun() {...} 。 当let（包括和let有同样声明行为的const和class）被ES2015提出来的时候，包括我在内的许多开发人员都使用提升来描述变量是如何被访问…"}, {"id": "6980295679050678285", "title": "常见背包问题——01背包和完全背包", "desc": "背包问题是动态规划最经典的一个例题。背包问题又分为01背包，完全背包，多重背包等，面试种常见的就是01背包问题和完全背包问题。 在我们开发面试中，最常见的两种背包问题就是01背包和完全背包。所以我们这"}, {"id": "6844903616902332424", "title": "JavaScript中不得不说的断言?", "desc": "仔细地查找一下JavaScript中的API，实际上并没有多少关于断言的方法。唯一一个就是console.assert： 当condition为false时，该方法则会将错误消息写入控制台。如果为true，则无任何反应。 几个方法的区别可以查看这可能是你学习ES7遗漏的知识点。…"}, {"id": "6844904193740767245", "title": "学习算法前你需要了解的‘大O表示法’", "desc": "不管看懂了没看懂的，👬👭们都给个💗吧。写作排版不易，谢谢大家！ 在现实生活中，解决一个问题可以有多种方法，其中有好的方法，也有较为一般的方法。评判标准虽有不同，但总体思想是：用最小的代价获得最多的收益。 这里所说代价并不仅指金钱开销，有时也包括时间，所耗费资源等。 计算机…"}, {"id": "6994114286826029087", "title": "算法：除自身以外数组的乘积", "desc": "给你一个长度为给你一个长度为n的整数数组nums，其中n > 1，返回输出数组output,其中output[i]等于nums中除nums[i]之外其余各元素的乘积。"}, {"id": "6844903988018544647", "title": "vue 首次加载缓慢/刷新后加载缓慢 原因及解决方案", "desc": "如果提示Element未定义,是因为Element依赖Vue，vue.js需要在element-ui之前引入，所以vue.js也要改为cnd的引入方式."}, {"id": "6979980637939712008", "title": "Leetcode 417. 太平洋大西洋水流问题 - javascript DFS", "desc": "太平洋大西洋水流问题 描述 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。 规定水流只能按照上、下、左"}, {"id": "6970496252488187935", "title": "LeetCode第524题：通过删除字母匹配到字典里最长单词&最长子序列", "desc": "题干 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。 如果答案不止一个，返回长度最长且字典序最小的字符"}, {"id": "6844904174014955527", "title": "齐姐漫画：排序算法（三）之「快排」", "desc": "把大于 pivot 的都挪到 pivot 的右边。 这样一来，这个 pivot 的位置就确定了，也就是排好了 1 个元素。 就完成了。 答：同样的方法。 所以快排也是用的分治法的思想。 这两个问题。 就是最开始描述的方法，直到每个区间内没有元素或者只剩一个元素就可以返回了。 放…"}, {"id": "6941648141049397261", "title": "算法：找出数组中比左边大比右边小的元素", "desc": "然后正序（从左往右）遍历，判断当前元素是否为它左边所有元素的最大值，如果满足条件，最后再跟当前 index 右边的最小值对比，获取符合条件的元素。"}, {"id": "6996929078137716750", "title": "大数相加浅析", "desc": "前言 我们知道当在浏览器输入 9999999999999999999999 + 9999999999999999999999 时，它的结果是一个科学计数法。往往我们不需要也看不懂科学计数法。所以需要实"}, {"id": "6844903504302047245", "title": "【译】2017 年最受欢迎的 10 个编程挑战网站", "desc": "想快速提升编程技能？那么，这 10 个编程竞技网站会给你带来极大的帮助。当然，或许你也是这上面的常客。^ ^"}, {"id": "6986639440441507871", "title": "LeetCode算法学习之--数组--搜索旋转数组", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[面试题 10.03. 搜索旋转数组](https://leetcode-cn.com/problems/count-of-range-s"}, {"id": "6949709155007463454", "title": "前端刷题路-Day13｜刷题打卡", "desc": "给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 没啥可说的，在对应的地方加上对应的代码即可。 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 用到了…"}, {"id": "6955014155774459940", "title": "滑动窗口相关算法题", "desc": "一、滑动窗口相关概念 1.1 概念 滑动窗口算法可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。 1.1 应用场景的特点 需要输出或比较的结果在原数据结"}, {"id": "6971204252785967134", "title": "记一道算法题解题思路，打印二叉树", "desc": "一个数组，要如何转换为一棵树？当我们在厘清他的结构之后，有如何打印出来给其他人看？这个问题我不敢说我完全回答了，但有我自己的思考"}, {"id": "6844903955592380424", "title": "【前端学算法】排序算法", "desc": "作为一个非计算机专业出身的渣渣小前端，算法是前端技能进阶路上一座绕不开的大山。曾经尝试到 leetcode 上开坑，然而发现做出一道题，要花上好几个小时的时间。后来搜了一些算法学习方法相关的文章，许多人都提到：算法需要先系统性的学习，再去做题。而我平时开发最常使用 JavaSc…"}, {"id": "6995908581144920072", "title": "JavaScript实现堆", "desc": "这是我参与8月更文挑战的第12天，活动详情查看：8月更文挑战 上一篇讲了堆和优先队列的基本概念，有兴趣的小伙伴请冲 堆与优先队列概念。 这篇我们用js来实现一个大顶堆。 一、基础代码 我们先来写下基础"}, {"id": "6987603887616163876", "title": "算法学习之一维数据结构(one-dimentional data structure)", "desc": "一维数据结构(one-dimentional data structure)主要包含：数组，链表，栈，队列，双端队列，集合，映射..."}, {"id": "6987583330468233252", "title": "理解KMP算法笔记", "desc": "KMP 题外话：刚刚学习KMP算法，一脸懵逼，不过经过一天的思考、查找资料、手动画图模拟啥的终于算是搞清楚了（可能吧，其实我心里也没底），在此写一篇解析整理一下思路。 一、什么是KMP算法及一些基本概"}, {"id": "6987320221023338532", "title": "时间复杂度空间复杂度概念和对应的实例", "desc": "1.算法时间复杂度和空间复杂度的自我认识 2. 时间复杂度和空间复杂度的举例 o(1) log^n O(n) o(nlog^n) o(n^2) o(nn^3) o(2^n)"}, {"id": "6844903934331453448", "title": "聊一聊前端算法面试——二分查找", "desc": "今天来聊一聊前端面试中出现频率比较高的一种有序数据的算法——「二分查找」。 你可以先思考一下如何回答上边的问题🤔，然后带着答案来阅览接下来的内容。 最简单粗暴的方法就是直接遍历数组，然后找到对应的值把index返回回来，但这种方法的弊端就是如果运气不好，要找的值在数组的末尾，…"}, {"id": "6844903721504079879", "title": "五分钟学会一个高难度算法：快速排序", "desc": "由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 -----《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。 快速排序是由东尼·霍尔所发展…"}, {"id": "6844903682891333640", "title": "深入探究immutable.js的实现机制（二）", "desc": "本文是深入探究immutable.js系列的第二篇。 上一篇我们研究了 Immutable.js 持久化数据结构的基本实现原理，对其核心数据结构Vector Trie进行了介绍，并着重探究了其中的位分区机制。采用位分区的根本原因是为了优化速度，而对于空间的优化， Immutab…"}, {"id": "6950159124160053261", "title": "[打卡1：leetcode179-最大数]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！首先打开leetcode找算法题，来了个"}, {"id": "6984289353514090510", "title": "LeetCode第155题：最小栈", "desc": "题干 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈"}, {"id": "6844903683931504647", "title": "为什么你应该放弃React老的Context API用新的Context API", "desc": "通过在父组件上声明getChildContext方法为其子孙组件提供context，我们称其ProviderComponent。注意必须要声明Parent.childContextType才会生效，而子组件如果需要使用context，需要显示得声明Child.contextTy…"}, {"id": "6984782586270711844", "title": "队列", "desc": "队列定义 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作， 而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入 操作的端称为队尾，"}, {"id": "6877702694891421704", "title": "靠这些秋招秘笈，齐姐的学妹今年已经拿到了 8 个offer！", "desc": "小齐说：现在秋招进行时，正在找工作的小伙伴进度都怎么样了呀？今天这篇文章是我武大的学妹今年秋招的经验分享，庆妹去年才决定转行，现在已手握 N+ 个 offer ～这篇文章干货满满，庆妹对每一块面试考察"}, {"id": "6958025562891763720", "title": "JS算法-最小覆盖子串", "desc": "本题来自leetcode 第 76 题。 题目描述 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" "}, {"id": "6844903619720904717", "title": " javascript 垃圾回收算法了解一下", "desc": "V8的垃圾回收策略主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代,然后分别对不同分代的内存施以更高效的算法。在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象, 老生代中的对象为存活时间较长或常驻内存的…"}, {"id": "6844903697634295821", "title": "数字图像处理-前端实现", "desc": "数字图像处理（Digital Image Processing)是指用计算机进行的处理。说起数字图像处理大家都会想到C++有很多库和算法，MATLAB的方便，但自从有了canvas，JavaScript可以对图像进行像素级的操作，甚至还可以直接处理图像的二进制原始数据。 HTM…"}, {"id": "6979566744184553486", "title": "小孩也能看懂的 LeeCode 题解：135.分发糖果", "desc": "135.分发糖果 题目描述 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 你需要按照以下要求，帮助老师给这些孩子分发糖果"}, {"id": "6923945185034371085", "title": "时间、空间复杂度", "desc": "主要还是从算法所占用的时间和空间两个维度去考量。 时间维度：是指执行当前算法所消耗的时间，我们通常用时间复杂度来描述。 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用空间复杂度来描述。 因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时…"}, {"id": "6978106145546502180", "title": "JSMS27-合并两个排序的链表-剑指offer17", "desc": "题目描述，两个单链表按照增序排列，合并之后仍然为增序。 分析：这道题目相对来说比较简单，创建一个h指针，指向a的头结点，当a->data大于b->data时，h->next指向b，反之h->next指"}, {"id": "6938645688272191495", "title": "[ 力扣283 ] 移动零（js数组splice方法极简实现） | 刷题打卡", "desc": "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 本题解已同步leetcode-js-simple/08.[ 283 ] 移动零，可以复制代码进行调试。"}, {"id": "6938392828040970248", "title": "leetcode10分钟题解——宝石与石头", "desc": "今天是第一次写算法题解，其实我也是最近开始刷题，之前也没这习惯。程序员刷题就像是煎饼大叔煎饼，一天不煎几十个感觉没法在这行混了。我之所以开始刷题是因为好些大厂的朋友都有这习惯，我突然意识到，像我这种不刷题还能习以为常的情况真的是好多啊！大厂之所以是大厂，是因为别人是真的在煎饼，…"}, {"id": "6938410406704742436", "title": "二叉树遍历问题 | 刷题打卡", "desc": "二叉树的遍历通常有三种模式：前序、中序、后序、层序遍历。比如，以下这棵树对应的遍历结果为： 递归写法理解起来比较简单，按照我们遍历的顺序执行递归函数即可。 144. 二叉树的前序遍历 94. 二叉树的中序遍历 145. 二叉树的后序遍历 102. 二叉树的层序遍历 这里，前序、…"}, {"id": "6844903518478794759", "title": "一起来刷 LeetCode :D", "desc": "前端也可以用 JS 刷 LeetCode 啦"}, {"id": "6844903506218860551", "title": "AI：人工智能时代的一些思考", "desc": "人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 最近阅读了阮一峰写的一本书，书名叫未来世界的幸存者，书中对技术进步带来的变革有着深度的思考，以“2016年3月…"}, {"id": "6937201743537111053", "title": "[LeetCode5198.丑数 III] | 刷题打卡", "desc": "请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 很多问题看似复杂，其实可以分解为一步一步的来做，拆分题目，寻找边界，最后拼装组合。"}, {"id": "6937183860023099422", "title": "[LeetCode13.罗马数字转整数] | 刷题打卡", "desc": "题目描述：罗马数字包含以下七种字符：I，V，X，L，C，D和M。例如，罗马数字2写做II，即为两个并列的1。12写做XII，即为X+II。 27写做XXVII,即为XX+V+II。  通常情况下，罗马"}, {"id": "6936145704817688606", "title": "[ 力扣1021 ] 删除最外层的括号｜刷题打卡", "desc": "有效括号字符串为空 (\"\"), \"(\" + A + \")\" 或 A + B, 其中 A 和 B 都是有效的括号字符串, + 代表字符串的连接. 例如, \"\", \"()\", \"(())()\" 和 \"(()(()))\" 都是有效的括号字符串. 如果有效字符串 S 非空, 且不存在将…"}, {"id": "6844903827653525517", "title": "每日一算--不同路径", "desc": "一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 例如，上图是一个7 x 3 的网格。有多少可能的路径 说明：m 和 n 的值均不超过 1…"}, {"id": "6844903992254808071", "title": "埃拉托斯特尼筛法寻找某一整数范围内的所有素数", "desc": "埃拉托斯特尼筛法简称埃氏筛，也称素数筛。是一种简单且历史悠久的筛法，用来找出一定范围内所有的素数。"}, {"id": "6844903748003708942", "title": "【重写 CryptoJS】二、WordArray 与位操作", "desc": "我们常见的各种编码、散列、加密算法，其基础都是位操作。 不管是对哪种数据类型，位操作对象的本质都是一段连续的比特序列。从性能的角度讲，位操作最好是能直接操作连续的内存位。很多语言提供了直接操作连续内存位的操作，比如 C++ 中的数组与指针，ECMAScript 6 中的 Arr…"}, {"id": "6844903860717240333", "title": "04|复杂度分析(下):浅析最好、最坏、平均、均摊时间复杂度", "desc": "上面的代码是用来在数组中寻找变量x出现的位置，如果没有找到就返回-1，我们一眼能看出代码的时间复杂度为。但是这个代码是可以优化的，因为可能中途就找到了这个元素，就不需要继续后面的循环了。所以我们改一下代码 修改完毕后，这个函数的时间复杂度还是吗？不一定把，因为都不一定会执行n次…"}, {"id": "6913067207886897165", "title": "js函数防抖和函数节流", "desc": "函数防抖(debounce)概念:在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。functiondebounce(fn,wait){vartimer=null;returnfunc"}, {"id": "6844903612821274637", "title": "怎么用广度遍历的方法删除一个目录？？？", "desc": "这样，通过 next() 方法，利用 index+1 ，就会不断的顺着目录找下去。。。找下去。。。 突然，找到头了怎么办？报错了。。。我们需要在它找到头的时候阻止它继续往下找，什么情况下，我们知道到头了呢？"}, {"id": "6844903624166866951", "title": "从MDN上的canvas例子受到的启发", "desc": "在MDN上面有一个弹球的例子，我们的小球会在屏幕上弹跳，当它们碰到彼此时会变色。 如果两个小球被检测到碰撞的时候，而且加上他们的速度下一步还是处于碰撞范围内，就像引力一样无法脱离，无限原地碰撞。这时候，需要其他小球碰撞来解散这种纠缠。有时候，可能3个小球都会一起进入无限纠缠的状…"}, {"id": "6949873270359818253", "title": "kiner算法刷题记（五）：堆（Heap）与优先队列（数据结构基础篇）", "desc": "堆（Heap）与优先队列引申知识何为数据结构堆的基础知识完全二叉树知识回顾之前分享的文章中我们有讨论过完全二叉树的一些基本的概念与特性，在这里不就详述了，如果不了解的同学，可以先去看看之前的文章你真的"}, {"id": "6949102090895491079", "title": "leetcode 154. 寻找旋转排序数组中的最小值 II ｜刷题打卡", "desc": "154. 寻找旋转排序数组中的最小值 II 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。 二分法查找"}, {"id": "6844903844690804744", "title": "关于Efficient Subgraph Matching by Postponing Cartesian的批注", "desc": "子图匹配：假设有两个图 和图子图 同构即从到存在这样一个函数 并且 使得 同样成立 叫做子图同构的一个映射。在这篇论文中，两个图的顶点都是带属性的，这样还需要满足. 在一个个查询点进行匹配的过程中，实时构建一个叫压缩路径索引（compact path-index，CPI）的数据…"}, {"id": "6844903498425827335", "title": "Preact 源码解析之 setState 相关流程", "desc": "Preact 作为实现大部分 React 的接口，并且专注于轻量的框架，本文作为 Preact 源码解读系列的第一篇，将介绍一些关于 Preact 的在调用 setState 后相关操作的基础源码。"}, {"id": "6844903743717113863", "title": "看动画轻松理解「 堆 」", "desc": "本文通过堆的实现、最小堆（最大堆）、堆的时间复杂度、优先队列的实现、堆排序来介绍「 堆 」。 堆的一个经典的实现是完全二叉树(complete binary tree)，这样实现的堆称为二叉堆(binary heap)。 这里来说明一下满二叉树的概念与完全二叉树的概念。 满二叉…"}, {"id": "6935782357697822757", "title": "LeetCode15. 三数之和｜刷题打卡", "desc": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 三数之和，看完题目先思考，千万不能萌生了要三层循环的想法。 固定其中一…"}, {"id": "6936183050594156551", "title": "[LeetCode48题旋转图像] | 刷题打卡", "desc": "给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 拿出小本本，用例题来找方法，找思路，就是各种乱试，其实我是不推荐这样的，主要是我是…"}, {"id": "6941986460312535053", "title": "kiner算法刷题记（二）：递归与栈（解决表达式求值问题）", "desc": "本系列所有文章都将会收录到GitHub中统一收藏与管理，欢迎ISSUE和Star。 (()())这样我们其实可以理解为外层的一对括号代表一个大任务,但我们要完成这个大任务是有前置条件的，那就是完成里面的两个小任务，也就是中间的两对括号。因此，类似括号配对的这种思维方式，其实不仅…"}, {"id": "6939000985150816263", "title": "141. 环形链表｜刷题打卡", "desc": "141. 环形链表｜刷题打卡 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该…"}, {"id": "6844903570446221319", "title": "JavaScript中的图片处理与合成(四)", "desc": "这类型的重点主要在于 算法 和 性能 层面，在前端由于js及设备性能的限制，通常表现并不理想。在真正的线上业务中，为了追求更好的用户体验，只能运行一些相对比较轻量级的，性能好的算法。由服务端来进行进行，会是更好的选择。 这个小应用是一个万圣节活动。人物脸部的木偶妆容确实很炫酷，…"}, {"id": "6970975540211613710", "title": "数据结构/算法 知识引导篇", "desc": "概览 什么是数据结构？数据结构的作用是啥？ 什么是算法？算法有什么作用？ 本篇文章只是简单了解一些专业术语、基本概念，作为后期文章的引导篇。"}, {"id": "6936070093278871560", "title": "[LeetCode53题最大子序和] | 刷题打卡", "desc": "53. 最大子序和. 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 看到题目求最大子序和，很简单，我直接上来就是一个for循环，从1开始，和前一项做比较，如果前一项>0,那么就用当前项加上前一项，为什么要用前一项>0来作…"}, {"id": "6844904055316152333", "title": "javascript实现链表数据结构 和 反转单链表方法", "desc": "对于一个切图调接口写vue写久了的前端er来说，这还挺有趣的，也比较初级，算法大佬直接忽略吧。 链表就像它的名字一样，是一个链条一直链下去，知道最后一个节点的next为null。 答： 上面的不了解，没办法做面试题。 面试官问你算法了解吗？ 你说知道一些，然后就问你链表的问题了…"}, {"id": "6948576997236801544", "title": "前端刷题路-Day10｜刷题打卡", "desc": "给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 树中节点数目在范围 [2, 1…"}, {"id": "6941556143248375821", "title": "前端你应该了解常见的算法", "desc": "``` javascript // 防抖 function debounce (fn, time = 1000) { let timeId = null; return function (...ar"}, {"id": "6844904093459152904", "title": "前端工程师的 LeetCode 之旅 -- 179周赛", "desc": "给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 解释：'pppz' 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 '…"}, {"id": "6844903926790094855", "title": "「leetcode」3.无重复字符的最长子串", "desc": "给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 本题同样是一道使用双指针思路（滑动窗口）的题目。 我们的start和end指针初始都是指向字符串的首部，紧接着end向后移动，每向后移动一步，都需要确认start和end之间的字符串是否有重复的字符。 使用什么方…"}, {"id": "6934596616989097998", "title": "20210301 LeetCode 每日一题，冲！｜刷题打卡", "desc": "为了准备校招，这两个个月俺也在 Leetcode 上开始慢慢刷起了一些算法题。从一开始的 eay 都要看题解，到现在可以自己攻破大多数 medium，偶尔也能冲一下 hard，感觉多少是有些进步的。我也在 GitHub 上开了个 JavaScript 写算法的 repo，前端的…"}, {"id": "6844904176166633480", "title": "动态规划之截气球", "desc": "这是一道比较难且巧妙的动态规划题目；这道题目并不适合初学者看，比较适合dp进阶选手研究。好了，废话不多说，直接上菜。 分析一下这道题，就是要截破所有的气球，获得硬币的最大数量，然后左右两边的气球相邻了。那就截呗，我的第一反应就是暴力，回溯法；但是肯定会超时，为什么呢？因为题目给…"}, {"id": "6844904178163138567", "title": "动态规划之单词拆分", "desc": "之前我一直都在刷矩阵型，背包型的dp题目，今天我们来一道存在型的dp，这道题我觉得是比较有意思一点吧。（其实是相对简单一点，容易分析，困难题写不动，菜QAQ） 我相信很多小伙伴刷题都是为了应付面试，而应付面试，简单到中等的题目其实就够了，大部分公司都不会出很难的。再说了我只是个…"}, {"id": "6844903842572681229", "title": "用滑动窗口来解决最长无重复子串问题", "desc": "滑动窗口是解决字符串和数组类问题的一个重要工具。就本地而言，我们使用如下解题思路： 初始化map， key为字符，value为该字符在输入字符串中的位置。 初始化i=0，j=0。 如果它在map中，则从map中删除i所指向的元素，并将i向右滑动，继续执行4。 如果它不在map中…"}, {"id": "6890513616236363790", "title": "【小小心得】证明洗牌算法随机性", "desc": "打乱一个没有重复元素的数组。 比如 const arr = [1, 2, 3, 4, 5], shuffle(arr) 后返回一个随机的数组。 上面我们解释了随机的意思，数组上的每个数字出现在每一个位置的可能性都是随机的。有一种比较常用的算法，洗牌算法。（参阅 维基百科-洗牌算…"}, {"id": "6962523376448045093", "title": "前端必会数据结构与算法系列之集合与字典(五)", "desc": "集合是由一组无序且唯一（即不能重复）的项组成的，可以把集合想象成一个既没有重复元素，也没有顺序概念的数组。在JavaScript中集合的实现为Set()"}, {"id": "6966403210764353550", "title": "前端刷题路-Day35：搜索旋转排序数组 II（题号81）", "desc": "已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums."}, {"id": "6987018712754700324", "title": "LeetCode算法学习之--数组--寻找旋转排序数组中的最小值", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/count-of-range-sum/)"}, {"id": "6948708063621120030", "title": "714. 买卖股票的最佳时机含手续费｜刷题打卡", "desc": "给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这…"}, {"id": "6999494618219806750", "title": "学习记录之算法篇——链表", "desc": "1.反转链表 描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 迭代解法 解题思路： 先定义两个指针pre、cur 分别表示前置节点和当前节点，要进行链表反转的话，只要实现所有"}, {"id": "6999261118912790558", "title": "「前端刷题」21. 合并两个有序链表", "desc": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。    示例 1： 输入： l1 ="}, {"id": "6989896746969071653", "title": "前端算法入门之路（十）（二分算法：致敬经典，超越经典）--开课吧门徒计划历程", "desc": "二分查找算法 将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x<a[n/2],则只要在数组a的左半部分继续搜索x,如果x>a[n/2],则只要"}, {"id": "6924668410416791566", "title": "简述图着色算法的原理与使用", "desc": "图着色是指将特定的颜色按照约束条件（相邻任意两个部分的颜色不能相同）在图中分配的问题。要进行图着色算法，你必须先为一个图形着色，要么是上色顶点或是上色图的边，并且需要保证不存在两个相邻的部分有相同的颜色 —— 没有两个相邻的顶点或边会有相同的颜色。 我是在偶然间发现了这个算法，…"}, {"id": "6948574387373080607", "title": "谈谈动态规划的本质", "desc": "但是动态规划远不止这么简单。 今天这篇文章，让我们深入动态规划，一窥动态规划的本质。 动态规划于递归 ：只是单纯的空间换时间吗？ 并不是，斐波那切数列的例子很好的推翻了这个观点。 动态规划于贪心：只是贪心的加强版吗？并不是，零钱兑换的例子同样推翻了这个观点。 相信当我们认识到哪…"}, {"id": "6986933290028498981", "title": "LeetCode 31 Next Permutation (Tag:Array Difficulty:Medium)", "desc": "前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉得有帮助的话，记得多多点赞关注哦，感谢！ 题目描述 实现获取"}, {"id": "6976418150254395405", "title": "漫画算法:小灰的算法之旅学习 - 第1章 算法概述（空间复杂度？）", "desc": "这是我参与更文挑战的第22天，活动详情查看： 更文挑战 紧跟上篇，这篇主要是空间复杂度及相关 什么是空间复杂度 简单来说,时间复杂度是执行算法的时间成本,空问复杂度是执行算法的空间成本 在运行一段程序"}, {"id": "6960906343259570206", "title": "虚拟 DOM 和 diff 算法 -01", "desc": "diff 用于精细化对比，最小量更新；虚拟 DOM 则是用 js 对象描述 DOM 的层次结构。DOM 中的一切属性都在虚拟 DOM 中有对应的属性。"}, {"id": "6844904168537194503", "title": "符合人类思维的动态规划", "desc": "首先声明一下，我没有卖焦虑，是我自己焦虑了。其次，要感谢我的师傅，西湖区最帅..... 好了，言归正传，在leetCode评论区你都可以看到 lucifer，简称路西法大佬；他的题解才是符合人类思维的思考方式，思考的点都是很深入浅出的。 为什么要刷算法呢？因为现在大前端时代，而…"}, {"id": "6844903861782577160", "title": "你和名企的距离，差的不只是985/211或研究生学历", "desc": "今天高考结束了， 或许有些热爱代码的00后同学，看到网上公布的答案，开始估分，自已离985/211就差做错或少做一道题， 感觉没戏，来社区看代码来了。我在很多年前，考上的也是双非学校。虽然有一点怪自己懵懂暗恋上的女同桌在一个考场前后桌，在考场上发挥不佳，但是，每门功课，对偏难的…"}, {"id": "6844903518357159949", "title": "React Fiber初探", "desc": "React 16版本已经推出多时，提出了包括Portal，异常边界等新特性，最重要的是重写了调和算法，推出了新版本算法实现-Fiber，于是博主历时三周，在业余时间学习Fiber架构实现和源码，对Fiber整体有了初步了解，并总结分享出来，若对一些源码不感兴趣，大可跳过，另博主…"}, {"id": "6947973790496194573", "title": "20. 有效的括号｜刷题打卡", "desc": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 题目很简单，使用一个栈便可以解决。根据提示可知，字符串长度大于等于1，所以可以不考虑为0的情况。 符合')'，…"}, {"id": "6934563298180333581", "title": "[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡", "desc": "这题是LeetCode0303题区域和检索 - 数组不可变，也是今天的每日一题。 给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。 int sumRange(int i, int j) 返回数组 nums 从索引 i 到…"}, {"id": "6844903624640823310", "title": "完全吃透 TLS/SSL ", "desc": "TLS/SLL 是现在网络安全通信比较重要的一环，通过一些列的 key 交换和 key 生成，最终确立加密通道的整个流程。众所周知，TLS/SSL 耗费的时间也是挺可观的，相对于 TCP 的3次 RTT 来说，如果加上 TLS/SSL, 则总的 RTT 时间至少为 4 次。虽然…"}, {"id": "6986940714949017636", "title": "电话号码验证器（FreeCodeCamp）", "desc": "题目描述 解题思路 本题我采用的是正则的方法，通过考虑多种情况，因为所有的测试案例都已经给出，只要能够将所有情况考虑全面，通过正则表达式就可以通过测试。 本题可能不是最优解，如果读者有其他更优解，欢迎"}, {"id": "6952695356073181197", "title": "实现一个简易计算器 | 刷题打卡", "desc": "一、题目描述：这道题目是华为机试题，主要实现两个功能：绑定按钮点击事件。完成calculate函数的编写，实现加减乘除的功能。二、思路分析：这道题目需要实现两个功能：绑定按钮点击事件。分析: 主要考察"}, {"id": "6987141298327126053", "title": "算法第一章 贪心算法", "desc": "基本概念 leetcode 122 思想：利用贪心算法的思想，只要下一天卖出赚钱就卖 leetcode 860 柠檬水找零 思路：对于找零这种题目，优先考虑贪心算法 策略: 优先找最大的零钱,开辟两个"}, {"id": "6867817179673772040", "title": "写给前端的数据结构和算法 - 理解递归算法, 并实现 Proxy 的 Deep 版本", "desc": "最近一直在研究数据结构和算法在前端领域的应用, 颇有一些心得, 希望能开一个系列讲讲, 能帮助大家更好的抽象和设计 JavaScript 代码. 因为这两天在写一个有趣的东西, 其中涉及到将对象 Proxy 化, 但原生的 Proxy 是浅处理, 并不支持深度处理一个对象, 就…"}, {"id": "6998504051147014174", "title": "力扣每日一题  - 反转字符串", "desc": "这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 8.20 - 541. 反转字符串 II 题意 示例1： 示例2： 分析 根据题意，分为两步处理即可，分为完整截取的部分和不完整截取的部分"}, {"id": "6951298026237329445", "title": "使用递归回溯算法实现的前端解数独游戏", "desc": "前言最近一个多月来，我一直全身心投入于数据结构和算法的学习，一边学习各种典型的算法类型，一边疯狂刷题，从一个对算法一无所知的小白，到现在leetcode破百的解题数，还是很有成就感的。逻辑思维能力也是"}, {"id": "6844903858502631432", "title": "JavaScript 数据结构与算法之美 - 时间和空间复杂度", "desc": "1. 什么是复杂度分析 ？ 数据结构和算法解决是 “如何让计算机更快时间、更省空间的解决问题”。 因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。 复杂度描述的是算法执行时间（或占用空间）与数…"}, {"id": "6844903661450035207", "title": "惰性求值——lodash源码解读", "desc": "lodash受欢迎的一个原因，是其优异的计算性能。而其性能能有这么突出的表现，很大部分就来源于其使用的算法——惰性求值。 本文将讲述lodash源码中，惰性求值的原理和实现。 以下是How to Speed Up Lo-Dash ×100? Introducing Lazy E…"}, {"id": "7002581638873874446", "title": "递归与栈刷题（二）", "desc": "这是我参与8月更文挑战的第28天，活动详情查看：8月更文挑战 之前写了递归与栈刷题， 有兴趣的童鞋可以冲，接下来再刷两道递归与栈的题~~ 一、入栈出栈 844. 比较含退格的字符串 给定 S 和 T "}, {"id": "6992130289543675918", "title": "LeetCode无重复字符的最长子串｜8月更文挑战", "desc": "前言 字符串处理在前端或者后端都有着举足轻重的地位，处理好字符串是我们每个人都必须掌握的技能，下面来一道简单的字符串相关的算法题。 LeetCode 无重复字符的最长子串 题目描述 给定一个字符串s，"}, {"id": "6992087133872160782", "title": "javascript实现 下一个排列｜ 8月更文挑战", "desc": "上周的沸点活动-每日算法题里有一个这样的题目：下一个排列，要求是这样的： 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字"}, {"id": "6997763570935005191", "title": "LeetCode 64 Minimum Path Sum (Tag:Array Difficulty:Medium)", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。"}, {"id": "6844904129261731847", "title": "LeetCode 爬楼梯算法题的解法及优化", "desc": "本人大三学生，萌新小白一个，第一次发布文章，有不好的地方希望各位大佬能指出点评一下，小弟不才，希望学习到更多东西。 骚话不多说，咱们进入正题。 有两阶楼梯的时候，也很显然的知道有两种走法。就会有下面这句判断语句 冷静下来仔细一想，我就发现了问题所在，原来是递归的重复计算导致了内…"}, {"id": "6844903667196248078", "title": "微信小程序抽奖-翻牌", "desc": "翻牌打乱活动抽奖活动，大概需求是这样的，九宫格卡牌，先正面展示所有奖品，然后卡牌翻转，打乱排序，点击卡牌，然后抽奖。 展示所有卡牌，然后翻转。 我们先在dom中渲染9个卡牌。 backface-visibility 属性定义当元素不面向屏幕时是否可见。 如果在旋转元素不希望看到…"}, {"id": "6934918546619105288", "title": "[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡", "desc": "昨天做了[LeetCode0303题区域和检索 - 数组不可变] | 刷题打卡和[LeetCode1200. 最小绝对差] | 刷题打卡两道题，303题是昨天的每日一题考察的是前缀和，果然今天的每日一题也是，其实大家从每天的每日一题点进相似题目，如果看到官方题解更新了，那这道题…"}, {"id": "6989623815470841864", "title": "LeetCode算法学习之--数组--爬楼梯", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目[爬楼梯](https://leetcode-cn.com/problems/linked-list-cycle-ii/) 题目 分析 解"}, {"id": "6952678617327337480", "title": "方格染色", "desc": "每个正方形已经被染成红色或者绿色。选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将会被覆盖。完成染色之后,每个红色R都比每个绿色G距离最左侧近。牛牛想知道他最少需要涂染几个？"}, {"id": "6968651934609702925", "title": "LeetCode第167题：有序数字的两数之和", "desc": "题干 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers"}, {"id": "6901853596838133767", "title": "来看看黑五小齐都买了什么好东西？", "desc": "转眼进入 2020 的最后一个月，自习室里大家纷纷立下了最后一个 flag，也随之进入买买买季。 我一般是不吃补剂的，但会买点蛋白类的产品，因为我喜欢吃零食特别是甜食。。蛋白棒之类的产品，就既可以补充蛋白质，又能当零食吃，这样毫无负罪感！ 一般它家的产品不会踩雷，所以闭着眼买就…"}, {"id": "7004618258703712292", "title": "第7章第1节4-3 用递归实现斐波那契数列", "desc": "4-1 用递归实现斐波那契数列 思路分析 代码实现........................."}, {"id": "6844903550170972168", "title": "【英】免费编程书籍笔记大全", "desc": "涉及主流编程语言的笔记大全，内容源自 Stack Overflow 文档，支持 PDF 下载。"}, {"id": "6988808130851241992", "title": "LeetCode算法学习之--链表--环形链表II", "desc": "大家好今天给大家分享下一道 LeetCode 中间难度 的题目环形链表 II 题目 分析 解法一：Map 法 解法二：双指针法 代码借鉴 https://leetcode-cn.com/problem"}, {"id": "6844903670593634312", "title": "携程前端模拟排序动画", "desc": "昨天晚上做携程的笔试，第三道题是让模拟一个排序的步骤，也就是将排序的过程以动画的形式表现出来。 首先赞一下携程的这道题目，这才是前端该做的题目，既有意思，又考察了排序算法，还考察了部分动画及 dom 操作。话不多说，分析一下这道题目。 为什么绝对定位呢，首先绝对定位可以让元素脱…"}, {"id": "6844903680945192974", "title": "用 canvas 的 getImageData 做点有趣的事", "desc": "canvas 可以实现对图像的像素操作，这就要说到 getImageData() 方法了。 CanvasRenderingContext2D.getImageData() 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始…"}, {"id": "6938023006325178405", "title": "leetcode 二叉树的遍历 ｜刷题打卡", "desc": "题目描述思路递归思路迭代题目描述先左再中后右思路递归思路迭代感觉这个迭代几个月前比较难理解现在一看亲切许多题目描述先左再右后中思路递归思路迭代题目描述思路迭代"}, {"id": "6938734855895285774", "title": "[ 力扣392 ] indexOf第二个参数解判断子序列 | 刷题打卡", "desc": "给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 如果有大量输入的 S，称作 S1, S2, ...…"}, {"id": "6989988009743974431", "title": "[JavaScript]557-反转字符串中的单词 III", "desc": "记录下做题思路 解题思路 反转字符，字符串本身是没有reverse()方法的，因此需要将其转成数组。需要注意单词的顺序是不变的。 涉及到的知识点扩展 字符串和数组之间如何转换 1.字符串的split方"}, {"id": "6844903845772935176", "title": "这道算法题太太太太太简单啦", "desc": "今天分享一道很简单的算法题。 题目来源于 LeetCode 上第 268 号问题：缺失数字。题目难度为 Easy，目前通过率为 50.2% 。 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 你的算法应该具有线…"}, {"id": "6950991500814188580", "title": "《算法导论》第四部分-贪心算法浅析及其 Javascript 实现", "desc": "系列目录:《算法导论》一，二部分算法浅析及其 Javascript 实现《算法导论》第四部分-动态规划浅析及其 Javascript 实现完整的代码都在这里贪心算法（英语：greedy algorit"}, {"id": "6844903925368225799", "title": "地图POI类别标签体系建设实践", "desc": "POI是“Point of interest”的缩写，中文可以翻译为“兴趣点”。在地图上，一个POI可以是一栋房子、一个商铺、一个公交站、一个湖泊、一条道路等。在地图搜索场景，POI是检索对象，等同于网页搜索中的网页。在地图客户端上，用户选中一个POI，会有一个悬浮的气球指向这…"}, {"id": "6882588628187349000", "title": "前端必会数据结构与算法系列之队列(二)", "desc": "队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。"}, {"id": "6844903625194471432", "title": "浅解前端必须掌握的算法（三）：直接插入排序", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，了解一下基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎添翼，能让我们的…"}, {"id": "6905771321066520583", "title": "前端也得懂点儿——算法入门", "desc": "numbers 接收一个数组。 代码简单，但不易理解。推荐使用代入法，层层剖开理解"}, {"id": "6977198164721811470", "title": "前端算法与数据结构之图、堆、搜索排序（三）", "desc": "前端算法与数据结构之栈、队列、链表（一） 11、图 11-1图是什么？ 图是网络结构的抽象模型，是一-组由边连接的节点。 图可以表示任何二元关系，比如道路、航班。 JS中没有图,但是可以用Object"}, {"id": "6922405238645211149", "title": "算法刷题系列——滑动窗口", "desc": "用左右指针维护一个窗口（连续的子数组/子串），根据题目在遍历数组或者字符串的时候动态调整两个指针（一般都是++），遇到可行解就进行记录。 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条…"}, {"id": "6989659402647109645", "title": "【LeetCode刷题 不知道能坚持几天 orz...】Day002 21. 合并两个有序链表", "desc": "Day002 21. 合并两个有序链表 - 力扣（LeetCode） 时间复杂度o(n),空间复杂度不知道js实现的链表这种数据结构怎么算了 =_=!!!"}, {"id": "6844903614796808205", "title": "JavaScript数据结构与算法（串）", "desc": "例如一个字符串有30W个字符判断是否存在\"I am Chinese\". 类似这样的查找字符的毫无疑问需要使用KMP. KMP算法由二个部分组成. while (n > 0 && str[i] != str[n])这段代码可能比较难理解. 主要是根据next(n-1)最大匹配数来…"}, {"id": "6844904066888237070", "title": "12306 抢票系列之只要搞定RAIL_DEVICEID的来源,从此抢票不再掉线(下)", "desc": "现在已经还原了算法的实现逻辑,下一步就是如何更好地伪造自己,本文提供临时设置的实现方式,方便在不修改之前复现代码的基础上实现扩展,当然也可以直接在还原算法源码中写入伪造代码. 亲测构造请求 /otn/HttpZF/logdevice时,关于参数 algID 经常性发生变化,因此…"}, {"id": "6938633018408075271", "title": "LeetCode 11. 盛最多水的容器｜刷题打卡", "desc": "Leetcode 链接：11. 盛最多水的容器（medium） 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 …"}, {"id": "6844903721097232391", "title": "看完这个你还不会 插入排序 么", "desc": "由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 -----《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。 你可以关注公众号 五分钟学算…"}, {"id": "6982565130999431182", "title": "Leetcode刷题：整数转罗马数字", "desc": "这是我参与新手入门的第2篇文章。 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X "}, {"id": "6844904085104115719", "title": "[大白话] 归并排序 单循环/哨兵版", "desc": "归并排序关注度一直比不上快排，毕竟空间复杂度在那儿摆着，只有在最差情况上比快排厉害一些，但人家快排可以优化这一点，把这个最差情况的概率做到极低。 把Github上排名靠前的JS算法仓库都看了下，他们的归并排序基本上都是用的三次循环版。当然，说是三次循环，实际的每一轮合并，循环只…"}, {"id": "6874474323147980807", "title": "前端仔的“数据结构与算法”之路——数组", "desc": "数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 数组内存空间的申请还是需要固定大小的，如果不是后续的内存无法分配，因为你不确定这个连续的内存地址该什么时候结束。 线性表，就好比一条绳，绳上存储了数据，绳的方向只有头和尾，线性表的方向同样也只有向…"}, {"id": "6948695073559314439", "title": "二分查找 && 稀疏数组搜索 ｜刷题打卡", "desc": "从题目描述中给出了一个特定的条件排好序的字符串数组, 当我们看到排序好的数组题目时，我们优先考虑 二分查找 来解决。这道题也算是一道典型的 二分查找算法题。通过完成这道题，我希望读者朋友能掌握 二分查找 算法的基础步骤，文末附加 二分查找 的通用步骤模版。 我们分析一下问题：一…"}, {"id": "7000564748236357646", "title": "【LeetCode 343.整数拆分 】- JavaScript（动态规划+贪心）", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 LeetCode 343.整数拆分 - JavaScript 题目描述 题目分析 题目中“n 至少可以拆分为两个正整数的和”，这个条件说明"}, {"id": "6844903682455109640", "title": "2万5千字大厂面经 | 掘金技术征文", "desc": "简历不是一份记流水账的东西，而是让用人方了解你的亮点的。 平时有在做一些修改简历的收费服务，也算看过蛮多简历了。很多简历都有如下特征 以上类似简历可以说用人方也看了无数份，完全抓不到你的亮点。除非你呆过大厂或者教育背景不错或者技术栈符合人家要求了，否则基本就是看运气约面试了。 …"}, {"id": "6844903919722692621", "title": "前端该如何准备数据结构和算法？", "desc": "据我了解，前端程序员有相当一部分对“数据结构”和“算法”的基础概念都不是很清晰，这直接导致很多人在看到有关这部分的内容就会望而却步。 实际上，当你了解了“数据结构”和“算法”存在的真正意义，以及一些实际的应用场景，对它有了一个整体的认知之后，你可能会对它产生强烈的兴趣。当然，它…"}, {"id": "7000123623021215758", "title": "手撸二叉树之二叉树的所有路径", "desc": "Hello, 大家好，今天是我参加8月更文的第 25 天，今天给大家带来的关于二叉树相关的算法题是二叉树的所有路径，正文如下： 题目 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节"}, {"id": "7005766827645075463", "title": "AST，真香", "desc": "抽象语法树（Abstract Syntax Tree, AST），是源代码的抽象语法结构的树状表示，与之对应的是具体语法树；之所以是抽象的，是因为抽象语法树并不会表示出真实语法中出现的每一个细节"}, {"id": "6992169847207493639", "title": "淘宝详情页分发推荐算法总结：用户即时兴趣强化", "desc": "商品详情页是手淘内流量最大的模块之一，它加载了数十亿级商品的详细信息，是用户整个决策过程必不可少的一环。"}, {"id": "6999364519373832229", "title": "手撸二叉树之另一棵树的子树", "desc": "Hello, 大家好，今天是我参加8月更文的第 23 天，今天给大家带来的关于二叉树相关的算法题是另一棵树的子树，正文如下： 题目 给你两棵二叉树 root 和 subRoot 。检验 root 中是"}, {"id": "6987320619394138148", "title": "【算法面试】leetcode最常见的150道前端面试题 --- 简单题上（44题）", "desc": "前言 本文题目选自 LeetCode 精选 TOP 面试题，而这些题在自己和同事亲身经历中，确实遇到的几率在百分之80%以上（成都和北京的前端岗位）。本文挑选其中所有简单题做归类和解法分析。后续更新所"}, {"id": "6995368093509746701", "title": "面向 JavaScript 初学者的二叉搜索树算法", "desc": "这是我参与8月更文挑战的第12天，活动详情查看：8月更文挑战 在本文中，我将尽力解释一些您在编码面试之前应该学习的核心算法。 什么是二叉搜索树 (BST)？ 在编码面试中很常见，BST 是一种树状数据"}, {"id": "6999894028682526728", "title": "淘宝视频内容标签的结构化分析和管理", "desc": "背景介绍 随着5g时代的到来，视频内容形态迸发出勃勃生机，各大短视频app获得的巨大成功、淘宝短视频完成的种草和成交转化都说明短视频承担着商品介绍、图文内容等其他形式不可替代的重要作用。"}, {"id": "7005606944345948167", "title": "100道算法题，每天1道", "desc": "每天一道算法题，从LeetCode，top100开始，记录思路和相关知识点 动态规划有点像初中归纳法，核心思想是：拆分子问题，记住过往，减少重复计算， 并且动态规划一般都是自底向上、"}, {"id": "7003227402960633864", "title": "什么，leetcode easy级别？5种解法重拳出击👊🏻", "desc": "就像费曼学习法说的，在理解后要能输出出来，以教促学。今天会有5中解法：普通的两次遍历、双指针、递归、栈、哈希表。发散下思维，对于 easy 的题重拳出击！欢迎点赞评论收藏👍🏻"}, {"id": "7004648219913224200", "title": "图解算法js篇|数组排序1-冒泡排序", "desc": "冒泡排序（Bubble Sort） 冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行"}, {"id": "7005746866381914125", "title": "刷完这 12 道滑动窗口，就可以手撕前端面试了", "desc": "经常会有人问，作为前端，你在实际工作中用到过哪些算法，之前我回答是，树和位运算，而最近在学习网络模块，发现了和前端，起码是和网络相关的一种算法，那就是 `滑动窗口`；"}, {"id": "7002355667310739469", "title": "手撸二叉树之二叉搜索树中俩个节点之和", "desc": "Hello, 大家好，今天是我参加8月更文的第 31 天，今天给大家带来的关于二叉树相关的算法题是二叉搜索树中俩个节点之和，正文如下： 题目 给定一个二叉搜索树的 根节点 root 和一个整数 k ,"}, {"id": "6999798995975405581", "title": "手撸二叉树之二叉树的坡度", "desc": "Hello, 大家好，今天是我参加8月更文的第 24 天，今天给大家带来的关于二叉树相关的算法题是二叉树的坡度，正文如下： 题目 给定一个二叉树，计算 整个树 的坡度 。 一个树的 节点的坡度 定义即"}, {"id": "7005779972086300709", "title": "【算法】（冒泡 | 快速 | 归并 ） 排序", "desc": "目录 排序分类 交换排序 - 冒泡排序 交换排序 - 快速排序 归并排序 快排和归并区别 十大基本排序 零、排序分类 一、 交换排序 - 冒泡排序 1.1） 冒泡排序优化 **改进冒泡排序： **设置"}, {"id": "7005239473588043813", "title": "【温故知新】`122. 买卖股票的最佳时机 II` 贪心算法、动态规划实现", "desc": "题目描述 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你"}, {"id": "7005107106235809806", "title": "Ant Design TreeSelect 树选择控件异步加载", "desc": "之前对`Ant Design TreeSelect` 树选择控件进行了基础封装，这一篇主要讲异步数据的处理，也顺便讲了一下深度优先遍历(DFS)和广度优先遍历(BFS)"}, {"id": "6999822223372451848", "title": "【LeetCode 233.数字1的个数 】- JavaScript（规律）", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 LeetCode 233.数字1的个数 - JavaScript 题目描述 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 "}, {"id": "6916108094385143815", "title": "并查集: 处理集合问题的优秀方案", "desc": "不知为何，我最近看的数据结构相关的内容都很少提到并查集，可能是因为并查集并非面试热点。但是我个人觉得是一种很有用的数据结构，而且本身也不难，值得一学。因此整理成此文。 网上有很多不同解释，我认为比较好理解的一种解释是：并查集就是一种树形的数据结构，用于处理一些不相交集合（Dis…"}, {"id": "6915768948197687303", "title": "[力扣上岸] 堆算法 - 高频题Top k问题，你会做了吗？", "desc": "相信面试经验多的朋友一定见过top k问题。虽然是一道中等题，但是掌握了堆算法后就很简单了。 第一个类是自己实现的一个array，第二个类是最大堆。 add(value): 做了两件事:1. 把最新加入的value放在堆的最后面（也就是_count这个位置。_count统计的是…"}, {"id": "6844903537600626695", "title": "你需要知道的算法之排序算法", "desc": "实际生活中我们需要对很多数据进行处理，排序就是其中之一。而面试的时候一些排序算法、设计模式也是很多面试官的青睐，所以我们更需要理解这些常用的排序算法的思路（实现原理），排序的代码就不在文章内贴出来了（想看的各位请点相应的链接）。 图上的灰色矩形代表着正在进行步骤2操作的区域，与…"}, {"id": "6844904142004027406", "title": "Trie树-提高海量数据的模糊查询性能", "desc": "今天这篇文章源于上周在工作中解决的一个实际问题，它是个比较普遍的问题，无论做什么开发，估计都有遇到过。具体是这样的，我们有一份高校的名单（2657个），需要从海量的文章标题中找到包含这些高校的标题，其实就是模糊查询。（关注公众号 渡码，回复关键词 trie 获取完整源代码）对应…"}, {"id": "6844903577404571662", "title": "基于规则评分的密码强度检测算法分析及实现(JavaScript)", "desc": "用正则表达式做用户密码强度的通过性判定，过于简单粗暴，不但用户体验差，而且用户帐号安全性也差。那么如何准确评价用户密码的强度，保护用户帐号安全呢？本文分析介绍了几种基于规则评分的密码强度检测算法，并给出了相应的演示程序。大家可以根据自己项目安全性需要，做最适合于自己的方案选择。…"}, {"id": "6844903550334533639", "title": "javascript背包问题详解", "desc": "史上最详细的零基础学背包问题，语言是javascript，所有代码都是可以运行的，不是伪代码，保证学有所得，面试高级职位50％会遇到！"}, {"id": "6936113028601479204", "title": "3-不用运算符也能做加法？？｜刷题打卡", "desc": "写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 后来想想，计算机的语言和我们并不一样，我们平时使用的编程语言都是高级语言，是为了方便开发者使用的，运算符也是这样，如果不用运算符，那么只能从更底层的代码入手，看起来是跟二进制过不…"}, {"id": "6951963217044176904", "title": "「算法」最大数 | 刷题打卡", "desc": "一、题目描述：原题链接 👉 179. 最大数给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整"}, {"id": "6940999975455162376", "title": "leetcode10分钟题解—— 访问所有点的最小时间", "desc": "这道题一到手，感觉高大上，第一反应是觉得好难，其实是个典型的扮猪吃老虎的题目，找对方法就很简单。 题目1266. 访问所有点的最小时间 平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。…"}, {"id": "6844903907647291399", "title": "092反转链表II(JS)", "desc": "反转从位置 *m* 到 *n* 的链表。请使用一趟扫描完成反转。 1 ≤ m ≤ n ≤ 链表长度。 空间复杂度: 。我们仅仅在原有链表的基础上调整了一些指针，只使用了 的额外存储空间来获得结果。 我们定义一个递归函数用于反转给定链表的一部分。 将函数记为 recurse。该函…"}, {"id": "6844903613928570888", "title": "基于ES5`defineProperty` 实现简单的 Mvvm框架", "desc": "首先是一个 Mvvm类，接受两个参数（后期会加入method等参数）: el 和data。 2. 定义Mvvm类 #####4. Observe类 #####6. 订阅者Watcher Compile类用于将所选的el元素节点 赋值给mvvm实例树，并转为createDocum…"}, {"id": "6901866680633753613", "title": "【动态规划】LeetCode174.地下城游戏-Hard", "desc": "一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡…"}, {"id": "6974395396298637320", "title": "JSMS15-逆向输出单链表剑指Offer05", "desc": "逆向输出单链表 分析：刚开始我想的是逆置单链表，逆置之后遍历一遍就可以输出单链表了。时间复杂度为O(n),后来看了解析，是用栈来存单链表数据然后出栈。也就是常用的牺牲空间换取效率、 解法1、利用递归（"}, {"id": "6844904029768646664", "title": "算法学习in js：希尔排序", "desc": "希尔排序是一种基于插入排序的排序算法，经过改动，它解决了插入排序所存在的问题：对于大规模乱序数组插入排序会很慢，因为它只能交换相邻的元素。假设数组最小元素在末尾，升序排序中它就需要移动N-1次到数组开头。而希尔排序通过交换不相邻的元素对数组进行局部排序，最终用插入排序将局部有序…"}, {"id": "6950478192226336804", "title": "有效的括号|刷题打卡", "desc": "前言本文正在参与掘金团队号上线活动，点击查看大厂春招职位。题目给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：1、左括号必须用相同"}, {"id": "6961613025761558535", "title": "js数组中的排序", "desc": "js中数组排序常用的几种方法 一、选择排序 所谓“选择”，就是每次遍历时，选择一个最小的交换到已排好序列的后面。 思路： 每次找到最小的数放在最开始的位置， 详细解释： 1、找到最小的数，放在第一个位"}, {"id": "6918662526989238279", "title": "算法入门 -> 线性查找法", "desc": "1、什么是算法2、算法的五大特点3、线性查找法顾名思义：线性查找就是简单顺序或逆序查查找是不是简单的受不了😃,那就加一点难度"}, {"id": "6938008981910585374", "title": "求解最大子序和应该怎么做？？｜刷题打卡", "desc": "今天的题目是这个53. 最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 原题链接：53. 最大子序和 初步看来，题目不难，甚至可以说是简洁。先对题目分析一番。 既然是连续子数组，那么前一个子数组的和必然会影响到…"}, {"id": "6844903878454935566", "title": "理解算法的时间复杂度", "desc": "在计算机科学中，算法分析是非常关键的部分。找到解决问题的最有效算法非常重要。可能会有许多算法能够解决问题，但这里的挑战是选择最有效的算法。现在关键是假如我们有一套不同的算法，应该如何识别最有效的算法呢？在这里算法的空间和时间复杂度的概念出现了。空间和时间复杂度是算法的测量尺度。…"}, {"id": "6844903618563293192", "title": "聊聊前端排序的那些事", "desc": "聊聊前端排序的那些事shenbin2016-07-18JavaScript,algorithm前言貌似前端[1]圈一直以来流传着一种误解：前端用不到算法知识。[2]长久以来，我也曾受这种说法的影响。直"}, {"id": "6998887230680858638", "title": "算法（leetode，附思维导图 + 全部解法）300题之（13）罗马数字转整数", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（13）罗马数字转整数 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码："}, {"id": "6844904118708879367", "title": "前端进阶算法4：链表原来如此简单（+leetcode刷题）", "desc": "链表相对于数组来说，要复杂的多，首先，链表不需要连续的内存空间，它是由一组零散的内存块透过指针连接而成，所以，每一个块中必须包含当前节点内容以及后继指针。最常见的链表类型有单链表、双链表以及循环链表。 1. 追加节点： 2. 查找： 3. 在 position 位置插入： 4.…"}, {"id": "6844903713060945934", "title": "理解 JavaScript 中的高阶函数", "desc": "本文将让大家了解什么是高阶函数以及如何在 JavaScript 中使用它们。 如果你正在学习 JavaScript，那么你应该见过高阶函数这个术语。 它虽然听起来很复杂，但其实并不难。 使 JavaScript 适合函数式编程的原因是它接受高阶函数。 高阶函数在 JavaScr…"}, {"id": "6992526585400131620", "title": "LeetCode整数反转 | 算法练习系列", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 前言 整数翻转是一道非常经典的算法小题，在日常的工作中可能不会遇到这样的业务，但是解决这种问题的思想非常重要，解决的方法有很多，下面和大家分"}, {"id": "6985534963508576286", "title": "前端常见数据结构与算法整理--队列", "desc": "概念： 队列是先进先出的数据结构，与栈相反。 JavaScript中没有自带队列这个数据结构，但可以用数组模拟 概念代码实现： 队列常见用途： 所有需要用到先进先出特性的地方 JavaScript中的"}, {"id": "6992605267003342885", "title": "【温故知新】`53. 最大子序和` 动态规划实现", "desc": "题目描述 解题思路 思路1：动态规划 时间复杂度O(n) 子数组至少包含一个元素；初始化ans为nums[0]; 遍历数组元素： 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保"}, {"id": "6995832713592700965", "title": "前端算法必刷题系列[86]", "desc": "这是我参与8月更文挑战的第12天，活动详情查看：8月更文挑战 158. 回文子串 (palindromic-substrings) 标签 动态规划 中等 题目 leetcode 传送门 给定一个字符串"}, {"id": "7001700411052818463", "title": "JavaScript链表刷题（五）", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 之前写了JavaScript链表刷题，JavaScript链表刷题（二），JavaScript链表刷题（三），JavaScript链表刷题"}, {"id": "6844903573784887309", "title": "前端算法收集库", "desc": "1. 前言 这是一个常见的js算法面试题收集库，包含测试，欢迎star，如果库中没有的算法，欢迎提issue或者PR，补全。 提到算法，这里就要说下时间复杂度。 时间复杂度：算法的时间复杂度是一个函数，描述了算法的运行时间。时间复杂度越低，效率越高。 2. 关于代码规范 3. …"}, {"id": "6995193346096365575", "title": "前端常见算法题(动态规划篇)--上", "desc": "javascript 前端LeetCode刷题（动态规划篇上）：主要包含两大类型题目，即路径问题及股票问题"}, {"id": "6994821853537632293", "title": "【温故知新】`138. 复制带随机指针的链表`  链表深拷贝 哈希表实现", "desc": "题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。 构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，"}, {"id": "6982831231138267144", "title": "一个小题目考考你的数据结构与链式调用", "desc": "一个考察数据结构（主要是队列）和链式调用的笔试题，没有那么多套路，但是能比较体现出前端er的基础编码能力，都来试试看吧～"}, {"id": "6979846977156546574", "title": "三种时间复杂度为O(n^2)的排序算法", "desc": "冒泡排序 冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法： 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位； 经过优化的写法：使用一个变量记录当前轮次的比较是"}, {"id": "6990930961311629342", "title": "前端就该用 JS 刷算法212 --  简单树", "desc": "二叉树的遍历 递归遍历 递归的时候前中后序都能直接处理完了 递归是前中后序遍历最简单也是最容易出理解的方法，不懂的画个图就好了 迭代遍历 -- 双色标记法 使用颜色标记节点状态，新节点为白色，已经访问"}, {"id": "6921636695423057933", "title": "关于双列瀑布流布局的优化思考", "desc": " 导语在前端领域，经常会遇到瀑布流布局的开发，最近整理了下相关的使用场景和解决方案，其中包含了简单算法DP，前端基础知识，业务场景的思考。什么是瀑布流布局瀑布流又称瀑布流式布局，是一种比较流行的页面布"}, {"id": "6944645061581733902", "title": "排序，搜索，算法模式，算法复杂度 | 数据结构与算法综合笔记", "desc": "冒泡排序在运行时间的角度来看，是最差的。 游戏示例：一个1到100的数字游戏。我们每回应一个数字，那个人就会说这个数字是高了、低了还是对了。 它会一直执行下去(栈溢出错误)。(需要一个不再递归调用的条件)"}, {"id": "6844903605816786958", "title": "前端人工智能？TensorFlow.js 学会游戏通关", "desc": "T-Rex Runner 是隐藏在 Chrome 中的彩蛋游戏，最近我用刚推出的 TensorFlow.js 开发了一个完全独立运行于浏览器环境下的 AI 程序，如下图所示 AI 可以轻松控制暴龙（T-Rex）避开障碍物。 作为 Chrome 浏览器死忠，你或许早已发现隐藏在 …"}, {"id": "6988145377262174216", "title": "按位操作符-按位与（AND）", "desc": "上一章我们学习了按位操作符 带你认识按位操作符 这一章我们整理一下按位运算的经典案例 回顾 使用按位操作符运算的数， 会先转成 32 位比特序列， 也就是32 位的二进制数。 异或与（&） 两个二进制"}, {"id": "6844904110320254983", "title": "前端进阶算法1：如何分析、统计算法的执行效率和资源消耗？", "desc": "前端还要学算法？必须学，而且必须狠狠地学。现在去大厂面试，数据结构与算法已经是标配，要是不会的话，那基本与大厂无缘了。 作为一名前端，虽然在平常开发中很少写算法，但当我们需要深入前端框架、开发语言、开源库时，懂算法将大大提高我们看源码的能力。例如 react 的 diff 算法…"}, {"id": "6989919065217171492", "title": "数据结构-堆", "desc": "堆，是一种特殊的完全二叉树。 他要求他的子节点必须大于等于或小于等于父节点。且每个二叉树都必须填满，或者最后的右子树可以为空。同时，堆又分为最小堆和最大堆。"}, {"id": "6903032619307712520", "title": "前端必会的面试高频算法：LRU 缓存淘汰算法", "desc": "之前的面试中，面试官问了我这样一个问题。如果你首次进入一个页面，每看一条博客都会记入缓存中，下次就可直接读取缓存而不用重新请求。那么假设存储缓存的容器最大容量是100条，你如何设计一个算法来保证缓存达到容量后，淘汰最早记入容器的缓存数据。 当时我的第一反应是每次存入容器的时候赋…"}, {"id": "6870834212493066247", "title": "Spring IoC 到底是什么", "desc": "前言「上一篇文章」我们对Spring有了初步的认识，而Spring全家桶中几乎所有组件都是依赖于IoC的。刚开始听到IoC，会觉得特别高大上，但其实掰开了很简单。跟着我的脚步，一文带你吃透IoC原理。"}, {"id": "6844903752361590798", "title": "为什么我认为数据结构与算法对前端开发很重要？", "desc": "一个具有层级结构的数据，实现这个功能非常容易，因为这个结构和组件的结构是一致的，递归遍历就可以了。但是，由于后端通常采用的是关系型数据库，所以返回的数据通常会..."}, {"id": "6844903502985068558", "title": "[译] React 16 带来了什么以及对 Fiber 的解释", "desc": "React 核心算法的更新已经进行了多年了 —— 这次更新提供了一个从底层重写了 React 的 reconciliation 算法（译注：reconciliation 算法，是 React 用来比较两棵 DOM 树差异、从而觉得哪一部分应当被更新的算法）。React将维护相同…"}, {"id": "6844903650028945416", "title": "React 16.0+ 新特性初探(How to use)", "desc": "我技术没有大牛的水平，所以我写文章并不是为了吸引人，一方面是记录自己新学的东西，写出来觉得自己的理解也会加深；另一方面是让比我还入门的人找到个非常合适的入门文章。我喜欢配上一些Demo，这样不太明白的人才能看懂，受教人群不一样，大牛可以去看官方文档说明，小白可以看看demo感受…"}, {"id": "6844903502150369293", "title": "JS中的算法与数据结构——集合(Set)", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6937223416869027871", "title": "[ 剑指 Offer 59 - I ] 滑动窗口的最大值（一看就懂的详细文字注释） | 刷题打卡", "desc": "本题解已同步GitHub地址，可以复制代码进行调试。"}, {"id": "6970244398453882910", "title": "异或位运算实战算法题", "desc": "原题目：给定一个由多个数字组成的数组arr，数字a出现了k次，其他数字都出现了m次,找到这出现k数次的a数字, 其中m>1, k<m， 要求时间复杂度O(N) 空间复杂度O(1)"}, {"id": "6943803764151156750", "title": "嵌套遍历同一个数组的时候，试试Map优化", "desc": "嵌套遍历同一个数组的时候，试试Map优化。 因为嵌套遍历的时间复杂度是O(n^2)，有点大，于是可以想下，用空间换时间，在遍历的时候，记录已经遍历过的元素和对应的下标，常用的记录方式就是Map。 几乎所有的求和问题，都可以转化为求差问题，这样会变得更简单。 没有算法基础的话，第…"}, {"id": "6844903677308698632", "title": "canvas像素点操作 —— 视频绿幕抠图", "desc": "今天学一下canvas像素点操作。 下面的栗子简单实现了几个简单的滤镜效果，具体算法参考的这里，学过《数字图像处理》的同学应该对此理解更深刻。 然后被朋友圈吐槽抠图。其实当时就是站在一块绿幕前拍的😂 。 PS中魔法棒工具可以把图片中一定容差下的相近像素都选中、清空，轻松做到一…"}, {"id": "6844903624657600526", "title": "浅解前端必须掌握的算法（二）：简单选择排序", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，了解一下基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎添翼，能让我们的…"}, {"id": "6844903897115394055", "title": "理解动态规划", "desc": "动态规划是一个经典而实用的算法，经常在面试题中出现。 以最著名的刷题网站leetcode为例，目前有147道动态规划算法题，占比约 13% 。 这篇文章就来详细分析一下动态规划相关知识点。 重叠子问题。 最优子结构。 重叠子问题很好理解，递归就是解决重叠子问题的一种方式。 简单…"}, {"id": "6938708679009140772", "title": "[ 力扣104 ] 【二叉树经典问题】二叉树的最大深度 | 刷题打卡", "desc": "给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 本题解已同步leetcode-js-simple/01.[ 104 ] 二叉树的最大深度，可以复制代码进行调试。"}, {"id": "6844904129010073608", "title": "作者的新书《图解数据结构与算法》上市了，全彩印刷！", "desc": "《图解数据结构与算法》的写作初衷是为大家提供一种形象且易于理解的方式来学习常见的数据结构和算法，本书采用一步一图的方式来呈现数据结构中常见概念以及算法的步骤，降低了理解难度和阅读压力。 对于不是专门写算法的程序员来说，其实我们更需要的是一种形象且更加容易理解的方式来帮助我们学习…"}, {"id": "6883665806942142472", "title": "Java 集合看这一篇就够了", "desc": "大家好，这里是《齐姐聊数据结构》系列之大集合。话不多说，直接上图：Java集合，也称作容器，主要是由两大接口(Interface)派生出来的：Collection和Map顾名思义，容器就是用来存放数据"}, {"id": "6844904013758988296", "title": "字符串匹配算法之 BF 和 KMP 讲解", "desc": "字符串匹配算法有很多种，现在为大家带来 BF 和 KMP 的讲解，其中讲 BF 是为了与 KMP 算法做一个对比，让本文有由浅到深这样的一个递进关系。 查找一个字符串是否在另一个字符串中，我们最容易想到的方法就是使用两个循环来解决，这种算法就叫做 BF，全称是 Brute-Fo…"}, {"id": "6844903880292040711", "title": "JavaScript 数据结构与算法之美 - 递归", "desc": "1. 前言 因为之后要讲有内容和算法，其代码的实现都要用到递归，所以，搞懂递归非常重要。 2. 定义 方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 简单来说就是：自己调用自己。 于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。…"}, {"id": "6844903636766556167", "title": "node ~ zip压缩 && 文件加密", "desc": "blowfish算法是一种对称的加密算法,对称的意思就是加密和解密使用的是同一个密钥。"}, {"id": "6934968739045572644", "title": "20210302 LeetCode 每日一题，冲！｜刷题打卡", "desc": "给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2 。 对于这个问…"}, {"id": "6861495979426709511", "title": "博弈论系列(10/10): 大鱼和小鱼的问题", "desc": "首先，我想聪明的大家已经猜到这是一道什么类型的题。对，博弈论！因为题中出现了博弈论中的经典条件“无限聪明”。现在让我们思考该题： 我们是有十条鱼，分析起来是比较麻烦的。所以我们从最简单的两条鱼开始分析： 3条鱼的情况下，第2条鱼不能吃第1条鱼，否则将化为只有2条鱼的情形，它将会…"}, {"id": "6844904065864826893", "title": "12306 抢票系列之只要搞定RAIL_DEVICEID的来源,从此抢票不再掉线(上)", "desc": "本文针对自主开发的抢票脚本在抢票过程中常常遇到的请求无效等问题,简单分析了 12306 网站的前端加密算法,更准确的说,是探究 RAIL_DEVICEID 的生成过程. 因为该 cookie 值是抢票请求的核心基础,没有它将无法正确发送请求,或者一段时间后就会到期失效需要重新获…"}, {"id": "6844903507691044878", "title": "精读《JS 中的内存管理》", "desc": "我为什么要选这篇文章呢？ sessionstack最近接连发了好几篇文章, 深入探讨JS, 以及 JS 中一些内部原理. 文中也讲到了, 伴随深入了解 JS 中的一些工作原理, 才有可能写出更好的代码和程序. 而 JS 中的内存管理, 我的感觉就像 JS 中的一门副科, 我们…"}, {"id": "6844904119098966030", "title": "快速入门数据结构与算法之贪心、分治与动态规划", "desc": "上一篇我们学习了一些查找和排序的算法，今天我们来学习几个设计算法时常用的策略。本篇要介绍的策略有 很多同学都会觉得对这些策略不太理解？分治和动态规划分不清？下面我们一步一步的真正的去理解他们。 贪心策略是比较好理解的，略是一种近似解决问题的技术，所谓贪心，就是先选择当前阶段的最…"}, {"id": "6844904065067909127", "title": "算法-判断回文链表", "desc": "中文里,有回文诗句、对联,如:\"灵山大佛,佛大山灵\",\"客上天然居,居然天上客\"等等,都是美妙的符合正念倒念都一样的回文句. 回文数则是有类似22、383、5445、12321,不论是从左向右顺读。 因为js没有链表这种数据结构，要做这道题先来声明一个链表节点对象。还记得链表有…"}, {"id": "6844903938861318152", "title": "算法题 -- 求最长路径", "desc": "给定一张包含N个点、N-1条边的无向连通图，节点从1到N编号，每条边的长度均为1。假设你从1号节点出发并打算遍历所有节点，那么总路程至少是多少？ 第一行包含一个整数N，1≤N≤10^5。 接下来N-1行，每行包含两个整数X和Y，表示X号节点和Y号节点之间有一条边，1≤X，Y≤N…"}, {"id": "6913899234190327816", "title": "前端就该用 JS 刷算法4", "desc": "每日一题二叉树中所有距离为K的节点注意事项dfs查找目标节点的时候，记得条件深度遍历，否则给null加parent属性就尴尬了开始查找距离的时候，记得保存所有走过的节点，防止重复跑使用paths保存走"}, {"id": "6844903657830350856", "title": "如何用堆栈来保存和恢复滚动条位置", "desc": "问题背景思路基于jq.ui的实例1、在jq.ui源码中页面切换之前手动触发个事件（用于在自己的代码中捕捉此事件并记录老页面滚动条位置信息）2、在页面上监听第一步中触发的beforeHideOldPan"}, {"id": "6844903858087395336", "title": "【算法题】递归求二叉树深度", "desc": "二叉树的深度算法，是二叉树中比较基础的算法了。对应 LeetCode 第104题。 然后你会发现 LeetCode 后面有些算法题需要用到这个算法的变形，比如第110题、543题。这两道题，如果你知道二叉树深度算法的递归过程，就很容易做出来。 给定一个二叉树，找出其最大深度。 …"}, {"id": "6981022070159179783", "title": "Leetcode 51. N 皇后 -- javascript DFS", "desc": "Leetcode 51. N 皇后 javascript 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n"}, {"id": "6844903550347116551", "title": "javascript背包问题详解", "desc": "打算好好学一下算法，先拿背包问题入手。但是网上许多教程都是C++或java或python，大部分作者都是在校生，虽然算法很强，但是完全没有工程意识，全局变量满天飞，变量名不明所以。我查了许多资料，花了一个星期才搞懂，最开始的01背包耗时最多，以前只会枚举（就是普通的for循环，…"}, {"id": "6981033041619583006", "title": "DFS和BFS ", "desc": "深度优先搜索(DFS) 和广度优先搜索一样，深度优先搜索（DFS）是用于在树/图中遍历/搜索的一种重要算法。 与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在DFS 中找到的第一"}, {"id": "6911877972756545543", "title": "每日算法-整数反转（数学-简单）", "desc": "给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 result * 10 + x % 10 取出末位 x % 10（负数结果还是负数，无需关心正负），拼接到 result 中。 x / 10 去除末位，| 0 强制转换为32位有符号整数。 通过 | 0 …"}, {"id": "6844903545548996621", "title": "《Node.js设计模式》高级异步准则", "desc": "本系列文章为《Node.js Design Patterns Second Edition》的原文翻译和读书笔记，在GitHub连载更新，同步翻译版链接。 几乎所有我们迄今为止看到的设计模式都可以被认为是通用的，并且适用于应用程序的许多不同的领域。但是，有一套更具体的模式，专注…"}, {"id": "6854573218947465229", "title": "平衡二叉树专题", "desc": "力扣关于平衡二叉树的题目还是有一些的，并且都非常经典，推荐大家练习。今天给大家精选了 4 道题，如果你彻底搞明白了这几道题，碰到其他的平衡二叉树的题目应该不至于没有思路。当你领会了我的思路之后， 建议再找几个题目练手，巩固一下学习成果。 110. 平衡二叉树（简单） 最简单的莫…"}, {"id": "6936175434027499557", "title": "leetcode 双射 （单词规律）｜刷题打卡", "desc": "题目描述思路1定义两map在两个map中双方的键值对互换,这样就确认了对应关系以下为看了评论处小宇的精美回答后，挑选且修改后的回答"}, {"id": "6911097134427308046", "title": " 有迹可循的 BFS 问题 | 创作者训练营", "desc": "按层打印，如何换行就是首先要关心的问题。 根节点是明确的，同时根节点又是下一层的入口（通过 root.left / root.right 带出）。所以我们需要一个队列（queue）储存当前层所有的节点。每次换行，将上一层的节点推到结果数组中，并且通过递归收集当前层所有的节点，直…"}, {"id": "6844903617728610317", "title": "Virtual Dom算法实现笔记", "desc": "网上关于virtual dom（下面简称VD）的博客数不胜数，很多都写得很好，本文是我初学VD算法实现的总结，在回顾的同时，希望对于同样初学的人有所启发，注意，这篇文章介绍实现的东西较少，见谅。 很多代码来自github库：hyperapp，几百行代码的库，拥有了redux和r…"}, {"id": "6924978746441072647", "title": "《算法导论》一，二部分算法浅析及其JavaScript实现", "desc": "...... 先理解一个概念，算法中有一种设计思想叫分治法。 这里直接给出公式 证明过程。。。。你懂的 堆总是一棵完全二叉树。 increase: 只要不停的与父节点进行比较，若比父节点大则互换位置。若比父节点小则位置恰好，结束循环。 快速排序是一种最坏情况时间复杂度位n^2的…"}, {"id": "6951500353275691016", "title": "买卖股票的最佳时机|刷题打卡", "desc": "前言本文正在参与掘金团队号上线活动，点击查看大厂春招职位。题目给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，"}, {"id": "6936451340285509645", "title": "LeetCode739. 每日温度(栈问题进阶)｜刷题打卡", "desc": "请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的…"}, {"id": "6956018544597270564", "title": "JS算法-下一个更大元素 I", "desc": "本题来自leetcode 第 496 题。 题目要求 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。"}, {"id": "6983928977807114270", "title": "LeetCode第232题：用栈实现队列", "desc": "题干： 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到"}, {"id": "6952517028804558884", "title": "有效的括号｜刷题打卡", "desc": "给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。有效字符串需满足：1、左括号必须用相同类型的右括号闭合。2、左括号必须以正确的顺序闭合。"}, {"id": "6933033465126322184", "title": "用RxJs让axios支持重试", "desc": "axios是前端常用的http请求库，在业务中希望增加重试功能，本来通过自己简单的封装也能实现这个功能，详见我以前的帖子，本着杀鸡用牛刀的精神通过RxJs为axios增加这个功能未改造前的函数改造后调"}, {"id": "6900507534676164622", "title": "前端学数据结构与算法（十三）：01执行的艺术 - 回溯算法(上)", "desc": "在最初尝试学习算法时，对两个算法留下了深刻的印象，一个是动态规划，另一个就是回溯算法。如果说算法思想的艺术，那归于动态规划；但如果说用计算机执行机制解决问题的艺术，那非回溯算法莫属了，也由衷的赞叹，原来计算机还能这么执行。 什么是回溯算法？它能解决什么问题？带着这两个问题，然后…"}, {"id": "6844904199084310542", "title": "【数据结构与算法】力扣实战之移动零、盛最多的水、爬楼梯", "desc": "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 第三种方法也是用了双指针，与第二种方法的唯一区别就是先替换掉所有0的元素，最后把剩余的元素全部一次性替换成0。可读性来说…"}, {"id": "6972824515701112840", "title": "LeetCode第278题：第一个错误的版本", "desc": "题干 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 "}, {"id": "6972825178132725767", "title": "LeetCode第540题：有序数组中的单一元素", "desc": "题干 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 示例 2: 思路1：一次循环 这种解法思路比较简单，每一次循环时将当前元素与下一个元素进行比"}, {"id": "6947296481355235358", "title": "你真的了解二叉树吗（手撕算法篇）", "desc": "本系列所有文章都将会收录到GitHub中统一收藏与管理，欢迎ISSUE和Star。 本文属于系列文章《你真的了解二叉树吗》的第二部分——手撕算法篇。如果你还没有看过第一部分你真的了解二叉树吗（树形结构基础篇）的话，强烈建议先看一下第一部分的内容，这样你在解题时会更加如虎添翼。很…"}, {"id": "6877123371272929287", "title": "求字符串的全排列", "desc": "相信很多人都会被这道题考查过，也有很多人不能写出来，放轻松，接下来我们来看下如何实现这道题。 首先我们来看下问题是什么。 准备好了吗？ 来一起看下如何实现吧。 当前给的字符串为 'a' 。那么返回的只有一个排列 [ 'a' ]。 当前给的字符串为 'ab' 。则返回 [ 'ab…"}, {"id": "6896436531125452813", "title": "数据结构与算法学习之集合", "desc": "什么是集合集合集合是由一组无序且唯一(即不能重复)的项组成。在数学中，集合是一组不同对象的集合。比如是说，一个又大于或等于0的整数组成的自然数集合：N={0,1,2,3,4,5,6,...}。集合中的"}, {"id": "6844903610016923661", "title": "你可能忽略的js类型转换", "desc": "相信刚开始了解js的时候，都会遇到 2 =='2'，但 1+2 == 1+'2'为false的情况。这时候应该会是一脸懵逼的状态，不得不感慨js弱类型的灵活让人发指，类型转换就是这么猝不及防。结合实际中的情况来看，有意或无意中涉及到类型转换的情况还是很多的。既然要用到，就需要掌…"}, {"id": "6844903661366165512", "title": "React高级指南之高阶组件", "desc": "这个需要大家对diff算法有所了解，如果从 render 返回的组件等同于之前render函数返回的组件，React将会迭代地通过diff算法更新子树到新的子树。如果不相等，则先前的子树将会完全卸载。 高阶组件可以把所有属性传递给被包裹组件，但是ref除外，因为ref不是一个真…"}, {"id": "6997405537771978759", "title": "「前端刷题」16. 最接近的三数之和", "desc": "给定一个包括 n 个整数的数组 nums和 一个目标值 target。找出 nums中的三个整数，使得它们的和与 target 最接"}, {"id": "6974682080772882463", "title": " 动态规划、状态转移方程、求解硬币找零问题", "desc": "动态规划、状态转移方程、求解硬币找零问题 题目描述:给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金"}, {"id": "6986916547348398094", "title": "LeetCode 27 Remove Element (Tag:Array Difficulty:Easy)", "desc": "题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输"}, {"id": "6844903894082912269", "title": "揭开在线协作的神秘面纱 - OT算法", "desc": "相信大家或多或少都有使用过在线文档，国内的像我们在做的腾讯文档还有其他家的很多类似产品。今天主要为大家揭开在线协作的神秘面纱，那就是OT算法。 在线文档，抽象一下，这些产品的模式都是富文本编辑器+后台，富文本编辑器产生内容，展示内容，然后后台负责保存。 富文本编辑器现在业界已经…"}, {"id": "6844903497784098823", "title": "JS中的算法与数据结构——栈(Stack)", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6937582883552886821", "title": "118. 杨辉三角｜刷题打卡", "desc": "118. 杨辉三角｜刷题打卡 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 所以我们可以用双层循环迭代实现。 分析一下题目，递归到 numRows = 0 时或者 numRows = 1 时都可以终止…"}, {"id": "6970474667316346917", "title": "LeetCode第141题：判断链表中是否有环", "desc": "题干 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置"}, {"id": "6844903942996885512", "title": "广度优先搜索 ( BFS ) 寻找最短路径", "desc": "分享一个简单的小游戏，利用 BFS 寻找距离出口的最短路径。 硬币如何找到最近出口呢，这里就用到了 BFS 搜索。 这种搜索很适合我们游戏里硬币的寻找出口。 至此，JS 部分就结束了，当我们随意点击棋盘上某一空白处时，该位置会变成障碍物，同时硬币会将自己位置传进 getSolu…"}, {"id": "6969037348713529358", "title": "LeetCode第345题：反转字符串中的元音字符", "desc": "题干 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例1： 解法: 思路：其实一看到这种类似于替换的题，我们应该首先想到的就是双指针，前指针向后遍历，后指针向前遍历，在每次循环初始时判"}, {"id": "6942469162174251044", "title": "使用二进制处理均等概率问题", "desc": "在解决算法问题中我们会经常遇到要求均等概率的问题， 以leetcode 470. 用 Rand7() 实现 Rand10() 为例。 上面代码略蠢，我们用移位的方法优化下， 左移操作符是二进制进位的。 两道小题都是用二进制位来解决的算法题。 解题思路也是两个大致的方向，一个是把…"}, {"id": "6991298176552534030", "title": "「每周一题」前端工程师算法系列(1)-冒泡排序", "desc": "算法的确实是硬伤，但是又不得不学，接下用JavaScript语言来分析常见的算法，力求通俗易懂，如果你觉得不错，或者发现文章中的错误，或者有更好的建议，欢迎提出 后续文章中会涉及：常见排序算法、常见搜"}, {"id": "6915203040421085192", "title": "前端就该用 JS 刷算法8", "desc": "但是大佬毕竟是用 py 实现的，我用 js 实现一次，也算是一种补充吧。"}, {"id": "6844903774067097607", "title": "google经典算法面试题-鸡蛋问题", "desc": "最近在 leetcode 上看到了一道题 Super Egg Drop, 刚好之前看到过一到很类似的题，就是 google 的一道经典的面试题。这里记录一下自己整个的解题思路。 给你两个鸡蛋，它们有可能都在某一层楼往下摔就会摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，…"}, {"id": "6950178747647524901", "title": "[打卡2：leetcode1-两数之和]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！题目描述题目链接：两数之和题目描述我用截"}, {"id": "6956172064252231717", "title": "JavaScript实现深度优先（DFS）和广度优先（BFS）算法", "desc": "遍历树状数据结构最常用的两个算法就是：深度优先算法（Depth-First-Search，简称DFS）和广度优先算法（Breadth-First-Search，简称BFS）。我们以封面节点为例说明两种"}, {"id": "6844903630642872334", "title": "V8 —— 你需要知道的垃圾回收机制", "desc": "V8 blog近日发布了文章描述了“并发标记”的新技术，提升标记过程的效率。 并发标记是一个主要用新的平行和并发的垃圾收集器替换旧的垃圾回收器的项目，现在Chrome 64和Node.js v10已经默认启用并发标记。讲解之前我们先回顾一下基本知识点。 V8的GC也是基于假设将…"}, {"id": "6968838679573823518", "title": "学习JavaScript数据结构与算法之图(七)", "desc": "图是网络结构的抽象模型，是一组由边链接的节点。 任何社交网络，例如 Facebook、Twitter 和 Google+，都可以用图来表示，图还可以表示任何二元关系，比如道路，航班"}, {"id": "6952064088692228127", "title": "[打卡11：leetcode27. 移除元素]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第11题。题目描述题目链接：移除元素"}, {"id": "6844903623684702221", "title": "浅解前端必须掌握的算法（一）：冒泡排序", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，了解一下基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎添翼，能让我们的…"}, {"id": "6951190671944318984", "title": "[打卡7：leetcode9-回文数]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第七题题目描述题目链接：回文数题目描"}, {"id": "6844904184941117448", "title": "面试必备 | 不可不会的反转链表", "desc": "反转链表这题真的是面试非常喜欢考的了，这题看起来简单，但是能用两种方法一遍 bug free 也是不容易的，面试的时候可以筛下来一大批人，无论是对 junior 还是 senior 面试都很爱考。 今天齐姐就带你梳理清楚思路，思路清楚了才能写码如有神。 这是从力扣中文站上截下来…"}, {"id": "6938352909734117390", "title": "70. 爬楼梯｜刷题打卡", "desc": "70. 爬楼梯｜刷题打卡 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 例如第 N 阶的楼梯，有几种方式能够跳上来呢？只有(n - 1)和(n - 2)阶楼梯能跳上来。 依…"}, {"id": "6937681886776918046", "title": "[LeetCode1438题绝对差不超过限制的最长连续子数组] | 刷题打卡", "desc": "1438. 绝对差不超过限制的最长连续子数组 给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 题目给定整数数组nums…"}, {"id": "6935690559067521061", "title": "[LeetCode141题环形链表] | 刷题打卡", "desc": "[LeetCode1200. 最小绝对差] | 刷题打卡 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如…"}, {"id": "6968471235403448328", "title": "斐波那契数", "desc": "~~简单的算法题：斐波那契数。递归解法和动态规划解法。动态规划基本方程三个条件 使用动态规划思想解答"}, {"id": "6844904032671105038", "title": "数据结构-二叉树遍历算法", "desc": "在计算机科学中, 树(tree) 是一种广泛使用的抽象数据类型(ADT)，是一类非线性数据结构。树在计算机领域得到广泛应用，尤其二叉树最为常用。 概念：每个节点最多含有两个子树的树称为二叉树。 二叉树有两种遍历深度遍历和广度遍历，其中深度遍历有前序、 中序和后序三种遍历方法。 …"}, {"id": "6938414829715587109", "title": "LeetCode19. 删除链表的倒数第 N 个结点｜刷题打卡", "desc": "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 链表不能倒序遍历，所以这道题的难点在于这个“倒数第 N 个”如何定位。 我们可以将“倒数第 N 个” 转变为：“正数第 len - n + 1\"个。 我们可以先遍历一遍得到链表长度len，再遍历一遍找到第len…"}, {"id": "6933798952558919694", "title": "跌妈不认？一口气团灭6道股票算法打打气", "desc": "2021 年的基金市场开年至今，暴涨又暴跌。刚迎完财神，期待牛气冲天的年轻人们，刚刚入场就狠狠的吃了资本市场的一记重锤。 各种“人类迷惑行为大赏”轮番上演，让本就魔幻的世界变得更加魔幻。如果你最近也跌了，请点个赞，让我们互相抱团取暖。 与现实略有不同，题目中添加了一些限制条件，…"}, {"id": "7001042279532085261", "title": "AES算法（十）浏览器端 JS 实战", "desc": "本篇将对之前所属的 AES 算法在浏览器端的 JavaScript 语言中做实战讲解，为什么要强调是浏览器端？因为后面还会对 Node 环境下 AES 算法应用单独做个实战演示。"}, {"id": "6996964395159027742", "title": "前端算法：二叉树遍历", "desc": "二叉树基本概念 二叉树（Binary tree）是树形结构的一个重要类型。二叉树遍历时基本的二叉树操作，掌握好遍历技巧是进行后续二叉树相关操作的基础。"}, {"id": "6993526646825287693", "title": "栈和队列算法实战", "desc": "这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 栈 栈是一种特殊的线性表,仅能够在栈顶进行操作,有着先进后出、后进先出的特性 实现 栈的实现其实就是基于数组的封装,既然已经有了数组,为何还"}, {"id": "7001149867133239332", "title": " 【温故知新】谷歌面试：`226. 翻转二叉树`  广度优先、深度优先 、前序、后序递归4种解法", "desc": "题目描述 备注: 这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕"}, {"id": "7001770660456300557", "title": "前端面试算法篇——动态规划（Dynamic Programming）", "desc": "简介 动态规划是大厂面试常考的算法题类型，这类问题类似于数学归纳法，又像求数列的通项公式，即假设[0, n-1]的情况已知，如何去求dp[n]。解决问题的关键自然是找到这个通项公式，也就是状态转移方程"}, {"id": "6998076760927502372", "title": "【双指针问题】已知链表中含有环，返回这个环的起始位置", "desc": "双指针 双指针一般可以分为两类，一类是快慢指针，一类是左右指针。快慢指针通常是用来解决链表中的问题，比如典型的是判断链表中是否含有环，左右指针主要是用来解决数组/字符串的问题，比如二分搜索等 这道题主"}, {"id": "6844903609981763592", "title": "JavaScript 算法与数据结构", "desc": "这个仓库包含了多种基于 JavaScript 的算法与数据结构，每种算法和数据结构都有自己的 README 并提供相关说明以及进一步阅读和 YouTube 视频。供参考与学习。（分享自：GitHub）"}, {"id": "6982739946339565599", "title": "leetcode每日一题系列-主要元素", "desc": "leetcode-面试17.10-主要元素 [博客链接] 菜🐔的学习之路 掘金首页 [题目描述 [题目链接] leetcode题目链接 [github地址] 代码链接 [思路介绍] 思路一：Boyer"}, {"id": "6991649627023867918", "title": "15天算法入门(二）", "desc": "有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。"}, {"id": "6965403251533414407", "title": "前端工程师必学的经典排序算法", "desc": "算法为王。 想学好前端，先练好内功，内功不行，就算招式练的再花哨，终究成不了高手；只有内功深厚者，前端之路才会走得更远。"}, {"id": "7002418185907470373", "title": "前端刷题路-Day97：两个数组的交集（题号349）", "desc": "给定两个数组，编写一个函数来计算它们的交集。说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序..."}, {"id": "6991297404142092302", "title": "15天算法入门(一）", "desc": "leetcode：今天一共有三道题目，从题目中可以看出，以二分作为基础，第二道和第三道作为二分查找的延申拓展。"}, {"id": "7005478094052163592", "title": "二叉树的遍历小结--递归实现", "desc": "前一段时间项目比较紧张，就把力扣刷题停下来了，现在又开始继续刷题了。为什么要刷题呢？最主要的就是面试的时候想去大厂都逃不掉算法，还有就是作为一个程序员要走的更远算法是躲不开的。你不懂算法，数据结构计算"}, {"id": "6975013738915037215", "title": "王国挖矿问题-动态规划逐步分析详解", "desc": "题目： 10 个工人 5个金矿，每个金矿对应收益和所需工人如下 400kg/5人 500kg/5人 200kg/3人 300kg/4人 350kg/3人 每个金矿要么全挖，要么不挖，不能派出一半人挖取"}, {"id": "6999065068839108645", "title": "前端刷题路-Day88：寻找重复数（题号287）", "desc": "给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数..."}, {"id": "7001667337359196168", "title": "前端刷题路-Day95：有序数组中的单一元素（题号 540）", "desc": "给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例..."}, {"id": "6991318941167517703", "title": "编译原理学习笔记-基于less实践探究（一）", "desc": "场景 编译原理这本书不用多说,别名龙书是程序员的圣经宝典。我一年之前就看过一点，也就是单纯的看过，现在可以说是基本毫无印象，一是没有做读书笔记，二是没有去实践，还是那句话纸上得来终觉浅，绝知此事要躬行"}, {"id": "6998802230807625735", "title": "01背包问题及滚动数组优化空间", "desc": "小M公司年会运气爆棚中奖，老板说给你一个容量w的蛇皮袋，去奖池里愉快的捞吧。奖池里的商品都独一份。袋子能装多少，就算中多少。不同奖品体积价格都不同，且每种奖品拿一次。小X心想这机会千载难逢，我"}, {"id": "6997445260632653861", "title": "一个最简单的扁平数组与树形结构相互转换的算法", "desc": "数组与结构 扁平数组 树形结构 转换算法 「扁平数组」转「树形结构」 「树形结构」转「扁平数组」~~~"}, {"id": "6972343725544439838", "title": "前端刷题路-Day47：二叉树的堂兄弟节点（题号993）", "desc": "在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点..."}, {"id": "6996096527580004389", "title": "前端刷题路-Day80：最长连续序列（题号128）", "desc": "给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题..."}, {"id": "6844903556265279502", "title": " 简单了解JavaScript垃圾回收机制", "desc": "先科普一下：内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 抱歉，我理解能力有限，不明白“离开标记”是什么，“然后去掉”是什么时候去掉的，具体怎么触发的还是自动运行…"}, {"id": "6974211415619928100", "title": "javascript常用算法-快速排序（宝，我输液了，输的想你的夜）", "desc": "这是我参与更文挑战的第16天，活动详情查看： 更文挑战 javascript常用算法-快速排序 快排像二分法一样都基于“分治”的算法思想，通过对数据进行分类处理，不断降低数量级，实现O(logN)（对"}, {"id": "6990612029463592967", "title": "LeetCode题解：61. 旋转链表，双指针，JavaScript，详细注释", "desc": "原题链接：61. 旋转链表，https://leetcode-cn.com/problems/rotate-list/"}, {"id": "6988147091457441806", "title": "JavaScript 数据结构--数组", "desc": "数组是计算机编程世界里最常见的数据结构。任何一种编程语言都包含数组。它是编程语言中的内建模型，通常效率很高，可以满足不同需求的数据存储。"}, {"id": "6844904115877707784", "title": "瓶子君前端进阶算法营首周总结", "desc": "我是瓶子君，在3月31号发起了一个「前端进阶算法」活动，从 0 到 1 构建完整的数据结构与算法体系。到现在已经过去了一周了，在这一周里，我们做了： 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。 …"}, {"id": "6990918308207788045", "title": "LeetCode算法学习之--数组--旋转数组", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[旋转数组](https://leetcode-cn.com/problems/linked-list-cycle-ii/) 题目 分析 "}, {"id": "7000744523189977095", "title": "【剑指offer】 二维数组中的查找 、 0～n-1中缺失的数字", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 题目 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入"}, {"id": "6944913393627168798", "title": "什么是前缀和?", "desc": "前缀和指一个数组的某下标之前的所有数组元素的和（包含其自身）。前缀和分为一维前缀和，以及二维前缀和。前缀和是一种重要的预处理，能够降低算法的时间复杂度。 一维前缀和的公式：sum[i] = sum[i-1] + arr[i] ; sum是前缀和数组, arr是内容数组。拥有前缀…"}, {"id": "7002195333438504997", "title": "学算法刷LeetCode【剑指offer专题】：59-II.队列的最大值", "desc": "题目描述 59-II.队列的最大值 解题思路 思路1(暴力解法) 使用队列的特性尾部插入，头部删除实现 push_back 和 pop_front， 至于寻找最大值，则遍历队列元素，找到最大值就返回，"}, {"id": "6965659104937246756", "title": "为什么我不用 TS 刷算法", "desc": "事情是酱紫的... 昨天我写了一篇前端为什么要使用 JS 刷算法的感悟文章，然后屁颠屁颠去算法群里求关注，求点赞，然后有大佬就问我以上的问题，这个其实也确实考虑过，所以我就来了。 细心的小伙伴会发现，"}, {"id": "6937605496341790757", "title": "几乎刷完了力扣所有的二分题，我发现了这些", "desc": "大家好，我是 lucifer。今天给大家带来的是《二分》专题。先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我会继续完善，将其他专题逐步完善起来。 几乎刷完了力扣所有的链表题，我发现了这些东西。。。 几乎刷完了力扣所有的树题，我发现了这些东西。。。 几乎刷完了…"}, {"id": "6844903587462512647", "title": "Canvas API 详解", "desc": "一、首先新建一个<canvas>网页元素。 上面代码中，如果浏览器不支持这个API，则就会显示<canvas>标签中间的文字——“您de浏览器不支持canvas！”。 每个canvas节点都有一个对应的context对象（上下文对象），Canvas API定义在这个contex…"}, {"id": "6993955773218816008", "title": "刷完这 30 道树，可能还是手撕不了大厂面试", "desc": "前言 某个男人说过 几乎刷完了力扣所有的树题，我发现了这些东西。。。,而我作为一个致力称为厨师界最会写算法的前端，总得刷上一部分题，有那么一点发现吧，现在我们就来聊聊，菜鸡如我，发现了什么。"}, {"id": "6992393928590753805", "title": "前端算法必刷题系列[79]", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 147. 编辑距离 (edit-distance) 标签 动态规划 困难 题目 leetcode 传送门 给你两个单词 word1 和 wo"}, {"id": "6993926231708139533", "title": "为什么复杂度是O(nlogn)?深入讲解归并排序", "desc": "归并排序（`Merge Sort`）是利用分治法（`Divide and Conquer`）的一种非常经典的排序算法。通过几句话地描述这个算法就是： 先不断`拆分`数组成为多个只有一个元素最小"}, {"id": "6993979613084909598", "title": "二叉树刷题(二）", "desc": "二叉树刷题(二）,这篇写下稍微复杂一点点的题。一、路径总和，二、判断平衡二叉树，三、二叉树的层序遍历 II......"}, {"id": "6958006678537109535", "title": "如何判断链表有环", "desc": "如果判断链表有环？如下链表 解法1： 双循环遍历，每次遍历新的节点，就往前查找此节点是否存在过，时间复杂度 O(n2)，空间复杂度O(1) 解法2： 但循环遍历，没遍历一个节点，就存入对象，遍历新节点"}, {"id": "6952659317015183397", "title": "前端刷题路-Day21｜刷题打卡", "desc": "爬楼梯（题号70） 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？"}, {"id": "6987304054095347742", "title": "逆波兰表示法求四则运算", "desc": "逆波兰表示法可用来解决表达式的优先运算问题。比如对中缀表达式12 +（7-3）*2+9/3，用逆波兰表示法应该是：12 7 3 - 2 * + 9 3 / +。逆波兰表示法虽然看起来奇怪，不利于人阅读"}, {"id": "6990745429683994632", "title": "前端面试每日 3+1 —— 第836天", "desc": "今天的知识点 (2021.07.30) —— 第836天 (我也要出题) [html] 使用HTML5绘制一道闪电 [css] 使用CSS3实现柱状图效果 [js] 使用js写个方法截取视频的第一帧 "}, {"id": "6844904083111804936", "title": "聊聊二叉树的各种姿势（递归, AVL, BST, DFS, BFS）", "desc": "前言：这是作为一个正在学习的前端开发者整理一下最近写的题，这篇文章是我对二叉树算法的浅显的理解，和我对一些常用算法思想的理解，希望可以让你在看完文章之后对常见的二叉树操作有一定的了解，文中列举了我觉得比较经典的一些题目。有不对的地方欢迎指出。😮😮😮 树的定义：是一类重要的…"}, {"id": "6997606522037469192", "title": "LeetCode两两交换链表中的节点 | 算法练习系列", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 前言 今天依旧是LeetCode上边的一道链表题目，两两交换链表中的节点，链表这东西真的上头，做着还挺有意思，做链表提我们一定要明确谁的n"}, {"id": "6996680993398587400", "title": "剑指 Offer第61题-扑克牌中的顺子", "desc": "这是我参与8月更文挑战的第14天，活动详情查看： 8月更文挑战 题干 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大"}, {"id": "6991024497109237796", "title": "算法（leetode，附思维导图 + 全部解法）300题之（4）寻找两个正序数组的中位数", "desc": "标题：算法（leetode，附思维导图 + 全部解法）300题之（4）寻找两个正序数组的中位数 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： 3"}, {"id": "6992016321676312607", "title": "前端刷题路-Day69：跳跃游戏（题号55）｜ 8月更文挑战", "desc": "给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。"}, {"id": "6844903498362912775", "title": "JS中的算法与数据结构——链表(Linked-list)", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6993211921230987300", "title": "javascript 实现 最长公共前缀和最大子序和", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 之前参加了沸点的每日算法题的活动，这是其中的两道题在此记录一下。（难度：简单） 最长公共前缀 题目描述： 编写一个函数来查找字符串数组中的最"}, {"id": "6844903702621323278", "title": "Egret白鹭H5开发-围住神经猫", "desc": "简单地说，白鹭引擎就是一套H5游戏开发解决方案，拥有以下产品，其中最核心的就是Egret Engine，其他的都是一些开发辅助工具。关于这些的介绍，还是直接戳上方官网链接去看看吧。 点击屏幕上的白色格子，将神经猫围起来，别让猫跑到上下左右四个边界上，最后猫无路可走就玩家赢了，如…"}, {"id": "6991853947396816932", "title": "【温故知新】`14. 最长公共前缀` 分治法、横向扫描实现", "desc": "`14. 最长公共前缀` 分治法、横向扫描实现，分治算法将一个问题分而治之，横向比较：将数组中的第一个元素作为最长公共前缀进行比较"}, {"id": "6844903592520843277", "title": "浅入浅出图解domDIff", "desc": "我们常说的虚拟DOM是通过JS对象模拟出来的DOM节点,domDiff是通过特定算法计算出来一次操作所带来的DOM变化。 react和vue中都使用了虚拟DOM，vue我只停留在使用层面就不多说了，react了解多一些，就借着react聊聊虚拟DOM。 干前端的都知道DOM操作…"}, {"id": "6984953099894915085", "title": "凯撒密码（FreeCodeCamp）", "desc": "题目描述 解题思路 首先遍历每一个字符。 通过charCodeAt()来判断字符的ASCII码值，如果该值在A-Z之间继续判断-13之后是否还在这个范围，如果还在这个范围直接通过charCodeAt("}, {"id": "6978647771410595847", "title": "前端刷题路-Day64：旋转图像（题号48）", "desc": "给定一个n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另外一个矩阵来旋转图像..."}, {"id": "6844904146470961159", "title": "【趣味算法】31道二叉树算法，给自己的五一礼物", "desc": "最近把树的算法做了一个小小滴总结。这些题目来自leetcode，都是一些代表二叉树算法思想的经典题目。 比如高度平衡二叉树，二叉搜索树BST，tire树等数据结构，深度广度优先遍历，递归，迭代等算法思想。如果对于递归不熟悉可以看看我的算法第一篇《雾都孤儿》图文并茂，手刃算法，也…"}, {"id": "6844903725442531341", "title": "[译] 在JS中，如何让(a===1 && a===2 && a === 3)(严格相等)的值为true？", "desc": "我们先简单了解\u001c这道JS经典问题, 然后再解决它的扩展问题。 如果你已经了解过这个问题并且知道如何解决这个JS谜题(是的，只是一个谜题，我并不想在生产代码中看到这样的用例) , 那你可以直接跳到下一节，阅读它的扩展问题。关于这个问题在reddit上有相关讨论， 下面是我看到最有…"}, {"id": "6844903592587952135", "title": "深入深入再深入 js 深拷贝对象", "desc": "对象是 JS 中基本类型之一，而且和原型链、数组等知识息息相关。不管是面试中，还是实际开发中我们都会碰见深拷贝对象的问题。 顾名思义，深拷贝就是完完整整的将一个对象从内存中拷贝一份出来。所以无论用什么办法，必然绕不开开辟一块新的内存空间。 1. 迭代递归法 这是最常规的方法，思…"}, {"id": "6844903609667321863", "title": "探索Virtual DOM的前世今生", "desc": "在前端开发过程中，对性能产生最大影响的因素莫过于DOM的重排重绘了，React作为前端框架领跑者，为了有效解决DOM更新开销的问题，采用了Virtual DOM的思路，不仅提升了DOM操作的效率，更推动了数据驱动式组件开发的形成与完善。一旦习惯了数据驱动式开发，再要求我们使用显…"}, {"id": "6978272377499025421", "title": "前端刷题路-Day63：第一个错误的版本（题号278）", "desc": "你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的..."}, {"id": "6995176840684011556", "title": "前端之算法（三）归并排序", "desc": "今天要介绍的是归并排序，它相对复杂一点，但是性能更好，那他具体如何呢？废话少说，让我们来揭开它神秘的面纱。 归并排序 归并排序的思路 分"}, {"id": "6995579120444768269", "title": "「前端刷题」13. 罗马数字转整数", "desc": "罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D"}, {"id": "6844903709772611592", "title": "深入理解CSS选择器优先级", "desc": "这句话也是很抽象，暂且先不管它了。但是我们可以先看一个例子： 那最后文字是什么颜色呢？答案很简单：红色。这就涉及到了优先级问题，同一块内容，我们同时用了 ID选择器 和 类选择器,因为 ID选择器 优先级大于 类选择器 , 所以最终显示为红色。 但是，浏览器具体的优先级算法是怎…"}, {"id": "6989842324482162719", "title": "LeetCode题解：456. 132 模式，n平方暴力，JavaScript，详细注释", "desc": "原题链接：456. 132 模式，https://leetcode-cn.com/problems/132-pattern/"}, {"id": "6991819508482572302", "title": "算法的复杂度估算", "desc": "在所有的算法面试中，有一个问题几乎是逃不掉的 — 你的算法时间复杂度是多少？在一般的企业面试中，算法复杂度分析是我们绕不过去的坎儿。"}, {"id": "6997036122006257701", "title": "前端之算法（八）贪心算法", "desc": "大家好，今天我们要聊的是贪心算法这种方法，它和分而治之、动态规划一样，也是算法设计中的一种方法，你同样可以把它当作解决问题的一种思路。接"}, {"id": "6989867285569765390", "title": "LeetCode刷题，函数的独占时间（636）", "desc": "可以用栈进行记录每一个编号id，start入栈，end出栈，获取区间值，使用下一个节点 减去前一个节点的起始点就是前半段区间，后半段区间使用前一个节点结束点范围减去当前点节点结束位置"}, {"id": "6970822445775192100", "title": "记一道算法题解题思路，字符串解析成DOM树", "desc": "一个小伙伴给的一道题， 把下列字符串解析成一个类似DOM树的存在;有点像是虚拟DOM，不过如果想自己写一个解析器，或许能参考下"}, {"id": "6844903699911802894", "title": "前端AI实战——告诉世界前端也能做AI", "desc": "我想大多数人和我一样，第一次听见“人工智能”这个词的时候都会觉得是一个很高大上、遥不可及的概念，特别像我这样一个平凡的前端，和大部分人一样，都觉得人工智能其实离我们很遥远，我们对它的印象总是停留在各种各样神奇而又复杂的算法，这些仿佛都是那些技术专家或者海归博士才有能力去做的工作…"}, {"id": "6988843926752854046", "title": "性能还能更好？你需要了解的堆排序", "desc": "原理 堆排序是利用堆这种数据结构而设计的一种排序算法，用一句话描述它就是 对于有序区这个概念，在本专栏上一篇文章已经讲过，简单来说是无序"}, {"id": "6976424733885595661", "title": "前端刷题路-Day58：目标和（题号494）", "desc": "给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数..."}, {"id": "6844904149541191693", "title": "前端进阶算法6：一看就懂的队列及配套算法题", "desc": "队列这种数据结构，据瓶子君了解，前端需要了解的队列结构主要有：双端队列、滑动窗口，它们都是算法中是比较常用的数据结构。 常见队列的操作有： enqueue(e) 进队、 dequeue() 出队、 isEmpty() 是否是空队、 front() 获取队头元素、clear() …"}, {"id": "6995455718996312095", "title": "经典算法-01背包问题", "desc": "01背包问题是什么？ 假设现在有物品[a,b,c,d,e] 5件， 每件物品的重量（KG）不同，分别为[3,4,1,8,4] 每件物品的价值不同，分别为[1,2,3,4,5], 现在小明现在用可以装1"}, {"id": "6971980093493084167", "title": "算法简介", "desc": "这是我参与更文挑战的第10天，活动详情查看：更文挑战 前言 相信很多人在工作或者面试中经常听到算法两个字，特别是现在的互联网大数据时代，对于面试大厂的开发来说算法几乎是必考的题目。那么算法究竟是什么呢"}, {"id": "6844903815116750856", "title": "算法学习思路", "desc": "很多前端童鞋对算法都有莫名的恐惧，究其原因无非两点：其一，对算法不了解；其二，没有找到实际应用场景。 这是个很有意思的问题，对算法感兴趣的人，不需要问为什么，算法对他们可能是一种兴趣。曾经有位同事，他刷遍了所有算法题，只要有算法竞赛，他都会去参加。当然，也取得了不错的成绩，甚至…"}, {"id": "6844903949795852295", "title": "聊一聊前端算法面试——动态规划", "desc": "现在竞争越来越激烈，以往前端算法面试只问问排序的日子一去不复返了。现在大厂喜欢问一些进阶性的算法问题，比如今天要聊的面试中经常出现但理解起来有些困难的一种算法思想——「动态规划」。 如下图所示：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” …"}, {"id": "6989108331675648030", "title": "LeetCode刷题，验证二叉树的前序序列化（331）", "desc": "验证二叉树的前序序列化 序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #"}, {"id": "6844903661575880717", "title": "简单聊聊 GZIP 的压缩原理与日常应用", "desc": "在基于 HTTP 协议的网络传输中 GZip 经常被使用，Nginx 中也可以使用半行代码开启 GZip。GZip 压缩的原理是什么呢？本篇文章是我在网上阅读了一些文档后做的简单总结。 RFC 1952 是 GZIP file format specification vers…"}, {"id": "6985043301271339044", "title": "前端常见数据结构与算法整理--栈", "desc": "前端数据结构与算法整理-栈。 栈的概念和用处，JavaScript与栈，leetcode有关栈的算法题。"}, {"id": "6985181918253826055", "title": "leetcode解析--如何传递数据", "desc": "题目描述 LCP 07. 传递信息 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的"}, {"id": "6951262583894573087", "title": "括号有效配对一箭三连（三）", "desc": "1） 任何一个左括号都能找到和其正确配对的右括号2） 任何一个右括号都能找到和其正确配对的左括号返回一个括号字符串中，最长的括号有效子串长度"}, {"id": "7004419621205835789", "title": "算法：盛最多水的容器", "desc": "给你n个非负整数a1, a2, a3, ..., an，每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0)。找出其中的两条线间的最大面积"}, {"id": "6992380839606616078", "title": "手撸二叉树之二叉搜索树的最近公共祖先", "desc": "Hello, 大家好，今天是8月更文的第 4 天，今天要和大家分享的关于二叉树的算法题是：给定一个二叉搜索树，找到该树中俩个指定节点的最近的公共祖先。 题目 给定一个二叉搜索树, 找到该树中两个指定节"}, {"id": "7003617994228105253", "title": "《大话数据结构》--时间复杂度", "desc": "算法时间复杂度的定义 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记做：T(n) ="}, {"id": "6980925339358724104", "title": "理解 P/NP 问题时，我产生了一种已经触碰到人类认知天花板的错觉？！", "desc": "在研究算法时，遇到 P/NP 问题。在我逐层尝试理解的过程中，我产生了一种已经触碰到人类认知天花板的错觉？！你觉得 P = NP 吗？"}, {"id": "7001005056606601252", "title": "前端算法：迷宫问题", "desc": "迷宫问题 我们常常会遇到各种迷宫问题，即从起点走到终点，会有哪些路径或者是求起点到终点最短路径。"}, {"id": "7004663115358928932", "title": "【温故知新】`121. 买卖股票的最佳时机` 动态规划、双指针实现", "desc": "题目描述 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计"}, {"id": "6992747199733956622", "title": "手撸二叉树之平衡二叉树", "desc": "Hello, 大家好，今天是我 8 月更文的第 5 天，今天给大家带来的有关二叉树的算法题为平衡二叉树，正文如下。 题目： 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定"}, {"id": "7005461836501893157", "title": "第一章：字符串", "desc": "01.替换空格 1. 题目描述 请实现一个函数，把字符串中的每个空格替换成\"%20\"。 例如输入“We are happy.”，则输出“We%20are%20happy.”。 2. 解题思路 一种是正"}, {"id": "6855918303756582919", "title": "前端算法入门系列 ---（一）数据结构", "desc": "算法就是计算或解决问题的步骤。 区别在于，程序是以计算机能够理解的编程语言编写的，可以在计算机上运行，而算法是以人类能够理解的数学方式来描述的，用于编程之前。但，算法和编程没有具体边界。 同样的问题，不同的开发者解法不同，不同的编程语言，写法不同，为算法设立评判标准的目的在于选…"}, {"id": "7001824283865382948", "title": "从一道算法题实现一个文本diff小工具", "desc": "众所周知，很多社区都是有内容审核机制的，除了第一次发布，后续的修改也需要审核，最粗暴的方式当然是从头再看一遍，但是编辑肯定想弄死你，显然这样效率比较低，比如就改了一个错别字，再看几遍可能也看不出来，所"}, {"id": "6844904138044604424", "title": "前端进阶算法：常见算法题及完美题解", "desc": "大厂面试越来越难，对算法的要求也越来越多，当面试官问到一个算法题，给出一份完美答案能大大提高面试官的好感度，本系列就是致力于打造一套适用于前端的算法。 1. 解法一：使用API 2. 解法二：不使用API 3. 更多题解 1. 题目 给定一个字符串，请你找出其中不含有重复字符的…"}, {"id": "6971254859643224095", "title": "来自小姐姐的灵魂拷问：位运算是什么？", "desc": "前两天上班，突然小叶给我发消息：哥哥，你看这两段代码是什么意思啊？ 乍一看，感觉这代码既熟悉又陌生。好像在哪里见过，但平时好像又很少用到。 我喝口水，冷静的想了 3s：咦，这个不就是那个位运算符吗？"}, {"id": "7005166216000045087", "title": "三种方法解决约瑟夫环问题（JavaScript）", "desc": "约瑟夫环问题又称约瑟夫杀人问题或丢手绢问题，是一道经典的算法问题。问题描述也有很多变式，但大体的解题思路是相同的。本篇将以循环链表、有序数组、数学递归三种方式来解决约瑟夫环问题。"}, {"id": "6996804960272777247", "title": "LeetCode 684.冗余连接 - JavaScript(并查集+DFS)", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 LeetCode 684.冗余连接 - JavaScript 题目描述 题目分析 题目很长，通俗来说就是有一棵树，然后输入中给出了这颗树中"}, {"id": "7002240480456998949", "title": "你应该烙在心上的基础算法", "desc": "这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 前言 自己的算法有些许的薄弱，决定开撕算法。 望自己能够坚持下去！！！ 二分查找 定义 小时候应该玩过一种猜字游戏: 小朋友 A 心里想着一"}, {"id": "6997578568175714317", "title": "手撸二叉树之单值二叉树", "desc": "Hello, 大家好，今天是我参加8月更文的第 18 天，不知不觉中 8 月份已过半, 时间过得太快了, 你有没有抓紧时间来看书充电或者刷题呢！ 今天给大家带来的关于二叉树相关的算法题是判断二叉树是否"}, {"id": "6844903569422811150", "title": "记录面试中一些回答不够好的题（Vue 居多） | 掘金技术征文", "desc": "flex 布局 与 grid 布局。 实现 Vue SSR 。 从 SPA 使用最小成本迁移到 SSR 。 根据指定元素，在数组里面找出 ff 数组（ff 数组这个名字是我瞎说的）。比如数组 [2, 3, 6, 7] ，指定元素 7，则 ff 数组是 [2, 2, 3]（2+2…"}, {"id": "6844903703917363207", "title": "三年前端，面试思考（头条蚂蚁美团offer）", "desc": "985本科，软件工程专业，前端。 工作三年半，第一家创业公司，半年。 第二家前端技术不错的公司，两年半。 第三家，个人创业半年。 可以看出，我是个很喜欢折腾的人，大学期间也做过很多项目，非常愿意参与到产品中去。技术上勉强合格，不过独自负责过很复杂的前端项目，所以一般基础面试题还…"}, {"id": "6844903656865677326", "title": "前端笔试&面试爬坑系列---算法", "desc": "终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。 JS…"}, {"id": "6998361405086760967", "title": "【LeetCode 110.平衡二叉树】两种递归实现：自顶向下、自底向上", "desc": "这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 【LeetCode 110.平衡二叉树】两种递归实现：自顶向下、自底向上 题目描述 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中"}, {"id": "7000181962077896718", "title": "LeetCode-1094. 拼车(JavaScript-差分数组解法）", "desc": "解法：差分数组 前面讲了 前缀和 的方法，利用 前缀和 ，可以得到数组中 num[i] ... nums[j] 任意区间的累加和 而利用 差分数组，可以实现对数据的某个区间段进行频繁的操作，如加减乘除"}, {"id": "6997806028007931912", "title": "LeetCode 1. 两数之和", "desc": "力扣第一题：两数之和。 题目描述： 一个函数，接收两个参数，一个数组、一个目标数，求出数组中两个元素之和等于目标数的两个数（必有一个有效答案）。 一、暴力 两层遍历，找到答案。 这样写可以，但太暴力，"}, {"id": "6997354627536683016", "title": "LeetCode合并两个有序链表 | 算法练习系列", "desc": "这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 前言 今天继续来一道链表的题目，来自LeetCode的合并两个有序链表，讲道理感觉链表这种数据结构挺呆的，不像数组一样，想取那个直接用下标"}, {"id": "6996857302598811684", "title": "前端刷题路-Day82：最小栈（题号155）", "desc": "设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素..."}, {"id": "6979447341589725192", "title": "数据结构之图简介", "desc": "这是我参与更文挑战的第30天，活动详情查看：更文挑战 什么是图 图是网络结构的抽象模型。 图是一组由边连接的节点（或顶点）。 因为任何二元关系都可以用图来表示"}, {"id": "6991812060069756941", "title": "FreeCodeCamp经典题目（收银机）｜ 8月更文挑战", "desc": "题目描述 测试案例 题目分析 题目接收的参数是什么？ 参数1：顾客所有产品的总价。 参数2：顾客给的钱数。 参数3：是一个二维数组，每一个小数组中的第一个元素是面值，第二个元素是收银机中该面额的总值（"}, {"id": "6987035945660841992", "title": "斐波那契数列之性能评测", "desc": "斐波那契数列指的是这样一个数列： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...... 这个数列从第3项开始，每一项都等于前两项之和。"}, {"id": "7002994503007092749", "title": "leetcode刷题-BFS&DFS", "desc": "leetcode刷题-BFS&DFS 1、完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一"}, {"id": "6844903824235167751", "title": "前端「N皇后」递归回溯经典问题图解", "desc": "在我的上一篇文章《前端电商 sku 的全排列算法很难吗？学会这个套路，彻底掌握排列组合。》中详细的讲解了排列组合的递归回溯解法，相信看过的小伙伴们对这个套路已经有了一定程度的掌握（没看过的同学快回头学习~）。 这是一道 LeetCode 上难度为 hard 的题目，听起来很吓人…"}, {"id": "7003570423405215757", "title": "学习笔记：剑指 Offer 04. 二维数组中的查找", "desc": "题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 "}, {"id": "7001140035810656263", "title": "JavaScript 二分查找 经典面试算法", "desc": "这是我参与8月更文挑战的第28天，活动详情查看：8月更文挑战 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。 二分查找的思路很简单，算法思想写在下边，不懂得看一看（当"}, {"id": "6999167792326901797", "title": "LeetCode算法学习之--HashMap--有效的字母异位词", "desc": "这是我参与8月更文挑战的第15天，活动详情查看：8月更文挑战 大家好今天给大家分享下一道 LeetCode 中等难度 的题目字母异位词分组 题目 分析 解法一：hashMap + 计数 解法二：has"}, {"id": "6992449912042422303", "title": "栈和队列算法题（基于JavaScript数组）", "desc": "栈和队列 基于数组 优先级队列 即由插入元素的优先级来决定它的位置，而不是按照元素进出的顺序排列的。 2道算法题。"}, {"id": "6995954292687388709", "title": "【温故知新】`474. 一和零` 01背包🎒问题最大解-动态规划实现", "desc": "题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y "}, {"id": "6921515173614354445", "title": "「算法与数据结构」JavaScript中的链表", "desc": "我们思考下，既然是来模拟一个链表类，那么就应该把它所有可能会用到的特性都塞进这个类里，就比如数组有 push/splice/indexOf/... 等等这些好用的方法我们链表必须也得有啊，我们先仔细构思下要给链表添加哪些实用的特性或者说方法，先搭一个基础骨架，这里我列出了很多，…"}, {"id": "6998326263173611557", "title": "前端刷题路-Day86：除自身以外数组的乘积（题号238）", "desc": "给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外..."}, {"id": "7002355392973897764", "title": "「字符串」leetcode 14.最长公共前缀（简单）", "desc": "一、了解题目 附上原题链接：14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 : 二、解题思路 依据以上题意，我们来写下解题思路： "}, {"id": "6996918370427748383", "title": "LeetCode删除链表的倒数第 N 个结点 | 算法练习系列", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 前言 链表操作对于前端开发人员感觉还是很陌生的，日常的工作中也不怎么接触链表相关的操作，这道题可以很好的让你对链表有一个认识，这道题是一个"}, {"id": "6999636949849882637", "title": "前端算法必刷题系列[90]", "desc": "这是我参与8月更文挑战的第21天，活动详情查看：8月更文挑战 164. 打家劫舍 (house-robber) 标签 中等 动态规划 题目 leetcode 传送门 你是一个专业的小偷，计划偷窃沿街的"}, {"id": "6844903666944573447", "title": "Vue.js从Virtual DOM映射到真实DOM的过程", "desc": "Virtual DOM的概念相信大家都不会陌生，Vritual DOM是相对与DOM(文档对象模型)来说的，MDN上关于DOM的定义：“DOM模型用一个逻辑树来表示一个文档，树的每个分支的终点都是一个节点(node)，每个节点都包含着对象(objects)。DOM的方法(met…"}, {"id": "6995730180107534349", "title": "前端刷题路-Day79：只出现一次的数字（题号136）", "desc": "给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外..."}, {"id": "6992374682200735781", "title": "前端刷题路-Day70：减小和重新排列数组后的最大元素（题号1846）", "desc": "给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件..."}, {"id": "7000408924549545998", "title": "最简单的数据结构-数组", "desc": "对数组的认识 几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。JavaScript里也有数据结构，虽然它的第一版并没有支持数组。 数组存储一系列同一种数据类型的值。但在JavaS"}, {"id": "6844903687949664269", "title": "前端AI实战——告诉世界前端也能做AI", "desc": "我想大多数人和我一样，第一次听见“人工智能”这个词的时候都会觉得是一个很高大上、遥不可及的概念，特别像我这样一个平凡的前端，和大部分人一样，都觉得人工智能其实离我们很遥远，我们对它的印象总是停留在各种各样神奇而又复杂的算法，这些仿佛都是那些技术专家或者海归博士才有能力去做的工作…"}, {"id": "6976402139178336270", "title": "算法|计数排序", "desc": "计数排序是使用空间换时间的排序算法，虽然使用它排序的速度很快，但是当数列的最大值最小值之间的插值鸿沟过大时，不适合计数排序。"}, {"id": "6995431041229914142", "title": "剑指第Offer57题-和为s的连续正数序列", "desc": "这是我参与8月更文挑战的第11天，活动详情查看： 8月更文挑战 题干 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序"}, {"id": "6996500608337313805", "title": "LeetCode题解：208. 实现 Trie (前缀树)，对象，JavaScript，详细注释", "desc": "原题链接：208. 实现 Trie，https://leetcode-cn.com/problems/implement-trie-prefix-tree/"}, {"id": "6974198826626187277", "title": "前端刷题路-Day52：最长回文子串（题号5）", "desc": "给你一个字符串 s，找到 s 中最长的回文子串。 示例 1：输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 ..."}, {"id": "6988893644556075045", "title": "最近刷题的合集（附解法）", "desc": "最近空闲的时候就在lettcode刷题，下面把自己刷的题以及自己的解法总结一下。 最长回文子串 leetcode地址 描述：给你一个字符串 s，找到 s 中最长的回文子串。 （回文子串就是正着读"}, {"id": "6994419323431288839", "title": "前端常见算法题(树篇)--下", "desc": "javascript 前端LeetCode刷题（树篇下）：主要包含一大类型题目，即特殊二叉树相关问题"}, {"id": "6994418340626186253", "title": "前端常见算法题(树篇)--上", "desc": "javascript 前端LeetCode刷题（树篇上）：主要包含两大类型题目，即遍历问题以及二叉搜索问题"}, {"id": "6951203359378374687", "title": "绳子盖住的最多点", "desc": "给定一个有序数组arr 从左到右依次表示X轴上从左往右点的位置，给定一个正整数k，返回如果有一根长度为k的绳子，最多能盖住几个点，绳子的边缘点碰到X轴上的点，也算盖住。"}, {"id": "6988143974527533063", "title": "带你认识按位操作符", "desc": "前言 最近 CodeReview 时发现，项目的历史代码中有一些像 &、|、^、~、<<、>>、>>> 的符号， 本人不甚了解原理， 翻文档学习了一下。 按位与（ AND） 两个二进制数，它们对应位的"}, {"id": "6850037263633252365", "title": "前端进阶算法：别再说你不懂topk问题了", "desc": "在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素。 在 V8 引擎 7.0 版本之前，数组长度小于10时， Array.prototype.sort() 使用的是插入排序，否则用快速排序。 在 V8 引擎 7.0 版本之后就舍弃了快…"}, {"id": "6994695626600480805", "title": "LeetCode——反转链表（双指针）", "desc": "题目描述 解题思路 采用一个指针指向当前节点，cur节点的初始值为head. 采用另一个指针指向当前节点的前一个节点(pre),该节点的初始值为null. 每当我们修改当前指针的指向的时候，一定要保存"}, {"id": "6844903651366928391", "title": "如何正确的在项目中接入微信JS-SDK", "desc": "如果你点进来，那么我相信你应该知道微信的JS-SDK可以用来做什么了。微信的官方文档描述如下。 通过使用微信的JS-SDK，你可以让你网页在微信内调用拍照、语音、支付、位置、扫一扫这些只能在微信内使用的功能。进过下面的步骤，一步一步的配置，就可以让你正确的在项目中引入微信的JS…"}, {"id": "6975676594903859237", "title": "前端刷题路-Day56：合并两个有序链表（题号21）", "desc": "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的..."}, {"id": "6966426853464604702", "title": "分享算法练习的网站", "desc": "算法练习的网站 推荐一些个人觉得还不错的算法练习网站 一、leetcode(力扣)   地址：https://leetcode-cn.com/   里面有各个企业（包括腾讯、阿里、蚂蚁、shopee等"}, {"id": "6844903750985842695", "title": "JavaScript 算法之复杂度分析", "desc": "新的一年，先给大家整理分享一个简单而又重要的知识点：时间复杂度和空间复杂度。因为在前几篇文章中，提到了时间复杂度，也许有些小伙伴还不清楚。（ps：希望在我上篇文章留言的那位小伙伴别失望哦，慢慢来。） 学习数据结构和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使…"}, {"id": "6978043133997088799", "title": "前端算法必刷题系列[73] ", "desc": "这是我参与更文挑战的第 26 天，活动详情查看 更文挑战 137. Z 字形变换 (zigzag-conversion) 标签 字符串 简单 题目 leetcode 传送门 这里不贴题了，leetco"}, {"id": "6844904133271486478", "title": "程序员必备的几种常见排序算法和搜索算法总结", "desc": "我想对于每个前端工程师来说, 最头疼的就是算法问题, 但是算法往往也是衡量一个人编程能力的一个很重要的指标.目前很多主流框架和库都应用了大量的算法和设计模式,为了让自己的段位更高,我们只能不断的\"打怪\"(也就是刷算法)升级,才能成为\"最强王者\". 有详细介绍. 接下来就让我们来…"}, {"id": "7002476192917897230", "title": "学算法刷LeetCode【剑指offer专题】： 59 - I. 滑动窗口的最大值", "desc": "题目描述 解题思路 还记得59-II.队列的最大值这道题的解法吗？这道题难度是困难 ，实际上理清思路并不难，无非就是滑动窗口+单调度双端队列的结合。我们来一步一步拆解一下： 第一步 总思路：我们准备一"}, {"id": "6999280198898155528", "title": "【温故知新】'20有效的括号'  利用栈先进后出原则", "desc": "题目描述 有效的括号 解题思路 stack 栈先进后出 定义一个map对象，将左括号作为key值，右括号作为value值； 利用栈先进后出的原则；定义栈stack； 遍历括号字符串s; 如果是左括号则"}, {"id": "6990635900858269733", "title": "leetcode每日一题题解——171. Excel 表列序号      （2021年7月30日）", "desc": "leetcode每日一题题解——171. Excel 表列序号 （2021年7月30日） 171. Excel Sheet Column Number Title Description"}, {"id": "6844904167715110925", "title": "前端进阶算法8：头条正在面的哈希表问题", "desc": "不同与之前我们介绍的线性表，所有的数据都是顺序存储，当我们需要在线性表中查找某一数据时，当线性表过长，需要查找的数据排序比较靠后的话，就需要花费大量的时间，导致查找性能较差。 例如学号，如果你想通过学号去找某一名学生，假设有 n 学生，难道你要一个一个的找，这时间复杂度就为 O…"}, {"id": "6886000134732627981", "title": "朝花夕拾 - 2020 1024", "desc": "2020 的 1024 程序员节快到了，从 2018 年写下第一篇文章， 至今已有 2 年多，还记得 2018 的 1024 写了篇 1024，快速打造你的文档库/静态博客。 应届生的我入职一家电信外包小公司，开始了前端工程师之旅。 至于其中曲折，因为太久了我就不哆嗦了，磨啊磨…"}, {"id": "6996550065049305095", "title": "题19：删除链表的第N个节点", "desc": "题19：删除链表的第N个节点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 示例 1： 示例 2： 示例 3： 提示： 解题思路： 利用双指针"}, {"id": "6844904179278823437", "title": "前端进阶算法9：看完这篇，再也不怕堆排序、Top K、中位数问题面试了", "desc": "一直重复上一步，直到不需要交换或交换到根节点，此时插入完成。 原地建堆的方法有两种：一种是承袭上面插入的思想，即从前往后、自下而上式堆化建堆；与之对应的另一种是，从后往前、自上往下式堆化建堆。其中 所以，自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右…"}, {"id": "7002826631496597534", "title": "学习笔记：剑指 Offer 58 - II. 左旋转字符串", "desc": "题目描述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cde"}, {"id": "6998809772141051912", "title": "前端算法必刷题系列[89]", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 好久没做关于树的题目，来两道 162. 二叉树的直径 (diameter-of-binary-tree) 标签 简单 递归 题目 leet"}, {"id": "6994063745907425287", "title": "LeetCode最长公共前缀 | 算法练习系列", "desc": "这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 前言 已经连着几天更新js算法题了，好多都和字符串相关，这让我更加意识到对字符串的处理在js中是何等的重要，今天仍然是一道字符串相关的题目，"}, {"id": "6997970627797712910", "title": "LeetCode寻找两个正序数组的中位数 | 算法练习系列", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 前言 今天来一道数组相关的题目，寻找数组中的中位数，本题的思路不是很难，本文主要是给前端开发人员来个JavaScript版本的解题方法，本"}, {"id": "6988510067838418974", "title": "按位操作符-按位异或（XOR）", "desc": "上一章我们认识了按位操作符， 这一章我们整理一下按位运算的经典案例 带你认识按位操作符 回顾 使用按位操作符的数，会先转成 32 位比特序列，也就是32 位的有符号的整数， 如果这个数大于 $2^{3"}, {"id": "6994357062436290567", "title": "两个有序数组合并为一个有序数组", "desc": "经典面试题，将两个有序数组合并为一个有序数组。 1、实现方式： （1）while循环遍历两个数组（不破坏原数组，生成新数组）。 直到两个数组的计算的索引（i与j），其中任何一个大于自身数组的长度，终止"}, {"id": "6974563479642439716", "title": "前端刷题路-Day53：盛最多水的容器（题号11）", "desc": "给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点(i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条.."}, {"id": "6844903903062917127", "title": "LeetCode 攻略 - 2019 年 7 月下半月汇总（100 题攻略）", "desc": "7 月下半旬攻略 45 道题，目前已攻略 100 题。 自 2019-05-16 开始，jsliang 每天会折腾一道及以上 LeetCode 题目，并将其解题思路记录成文章，发布到 GitHub 和 微信公众号。 【完成】2019/08/15 前。LeetCode 简单难度题…"}, {"id": "6988321035162501150", "title": "LeetCode刷题，有效的括号（20）", "desc": "有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。"}, {"id": "6844903655041138702", "title": "前端面试&笔试&错题指南(三）", "desc": "Q1. 下面程序的输出结果是？ 分析下在method(fn,1)执行时，经历了什么： 首先两个参数fn和1会被放入arguments中，在arguments中第一个参数就是我们传入的函数；接下来fn执行，此时this没有绑定因此指向window，输出10。 然而到了argume…"}, {"id": "6844904021598142472", "title": "前端算法题目解析（一）", "desc": "前几天逛 github 的时候看到一些前端的算法题，自己做了一遍发现还挺有意思的，因此整理了一下收录 daily-question 的 algorithm 文件夹中，后续会继续增加，本文分享我整理的十个算法题目。 完成将 toChineseNum， 可以将数字转换成中文大写的表…"}, {"id": "6970300902703890468", "title": "经典算法题-大数相加&数字字符串相加", "desc": "大数相加是一个校招面试时候遇到频率比较高的一个算法题，这里给大家分享三种方法： 一个常规解法，两个清奇的思路"}, {"id": "6997798788333043720", "title": "【温故知新】`70. 爬楼梯进阶版` 完全背包🎒问题AC-动态规划实现", "desc": "题目描述 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解"}, {"id": "7002063831572676615", "title": "学算法刷LeetCode【剑指offer专题】：09-用两个栈实现队列", "desc": "思路，维护两个栈，分别实现队列的出队和入队。 时间复杂度：O(n) 空间复杂度： O(n) 难易：易"}, {"id": "6995556784458989581", "title": "前端Leetcode系列｜28. 实现 strStr()", "desc": "这是我参与8月更文挑战的第12天，活动详情查看：8月更文挑战； 这是力扣系列第4篇，今天来和小伙伴们一起打卡力扣第28题：实现 strStr()。 一、题目描述 实现 strStr() 函数。 给你两"}, {"id": "6942645048945147911", "title": "前端刷题路-Day2", "desc": "罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。…"}, {"id": "6996298020660707335", "title": "前端之算法（六）分而治之 ", "desc": "大家好，前面几章我们说了很多的像链表，集合，字典等数据结构，也说了很多的排序和搜索算法，今天我们要聊的是分而治之这种方法，它既不是数据结"}, {"id": "6937960800422199332", "title": "链表+6道前端算法面试高频题解｜刷题打卡", "desc": "数组在上一篇的专栏数组回炉重造+6道前端算法面试高频题解｜刷题打卡中我们进行了回顾和刷题。 趁热打铁，我们来对比数组来学习链表。 首先要明确的是，链表和数组的底层存储结构不同，数组要求存储在一块连续的内存中，而链表是通过指针将一组零散的内存块串联起来。 可见链表对内存的要求降低…"}, {"id": "6968700344054317092", "title": "前端数据结构与算法之栈（js 实现）", "desc": "栈的概念 根据百科描述： 栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据"}, {"id": "6994008470533963813", "title": "记忆化递归求第N个位置的斐波那契数", "desc": "递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。"}, {"id": "6969047355421097992", "title": "【LeetCode刷题--剑指Offer】=> 01.两数目之和", "desc": "原题 思路 用 hashMap 存储遍历过的元素和对应的索引。 每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。 所有事情在一次遍历中完成（用了空间换取时间）。"}, {"id": "6972352457468805157", "title": "对象键唯一： 解决一类问题", "desc": "这是一篇心得类的文章，来源自对一些基础算法题的思路解析，运用的一个基本思想，或者说是基本逻辑。 利用对象的键唯一的特性，可以实现一类算法题"}, {"id": "6990252075149951006", "title": "LeetCode刷题，表现良好的最长时间段（1124）", "desc": "将原问题转换，假如是大于 8 的，变为 + 1，小于的变为 -1，再转换为前缀和，然后求解当前位置的数字找到前一个比它小的数字位置，当前区间就是一段大于等于0的区间，最长区间只需要依次遍历找到最大值"}, {"id": "6993958042807042085", "title": "算法（leetode，附思维导图 + 全部解法）300题之（7）整数反转", "desc": "算法（leetode，附思维导图 + 全部解法）300题之（7）整数反转。 我的解法很多 且 很sao，你忍一下~"}, {"id": "6844903665510121479", "title": "Web 魔方模拟器的设计与实现", "desc": "魔方是个结构简单而变化无穷的神奇玩具。那么如何在万能的浏览器里模拟出魔方的无尽变换，又如何将其还原呢？下面让我们一步步地来一探究竟吧。 拆解过魔方的同学可能知道，现实中魔方的内部结构包含了中轴、弹簧、螺丝等机械装置。但当我们只是想要「模拟」它的时候，我们只需抓住它最显著的性质即…"}, {"id": "6844903666382553102", "title": "用Vue实现一个美团app的影院推荐选座功能", "desc": "上图是点击推荐选座5人后选出的座位(绿色)，这个demo和美团app不同的地方在于可以连续进行推荐选座，美团app点击了推荐选座就必须买票才能继续选择。 这里注意vue中改变data中的二维数组必须先缓存二维数组，修改后，最终将二维数组重新赋值，否则修改不生效，因为Vue无法侦…"}, {"id": "6994447075769319460", "title": "JS算法之翻转单词顺序及左旋转字符串", "desc": "这是我参与8月更文挑战的第9天。JS算法之翻转单词顺序及左旋转字符串，坚持刷题，一起冲大厂，拿offer。"}, {"id": "6844903608618598407", "title": "Cookie防篡改机制", "desc": "为什么要做Cookie防篡改，一个重要原因是 Cookie中存储有判断当前登陆用户会话信息（Session）的会话票据-SessionID和一些用户信息。 当发起一个HTTP请求，HTTP请求头会带上Cookie，Cookie里面就包含有SessionID。 后端服务根据Ses…"}, {"id": "6844904131539238926", "title": "「前端进阶」前端如何搞定数据结构与算法(先导篇)", "desc": "在0202年的今天，由于每天被无数的信息轰炸，大多数人已经变得越来越浮躁了，并且丧失了独立思考的能力。 然后，你也变得焦虑起来。那你有没有静下心来想过，如何才能抵御年龄增长并且使自己增值呢？ 无非是终身学习，持续修炼自己的内功。内功也就是基础知识和核心概念，这些轰轰烈烈发展的技…"}, {"id": "6987037464179245093", "title": "前端常见数据结构与算法整理--集合", "desc": "概念: 无序且唯一 es6中有集合，Set 集合常用操作: 去重 查询是否为集合中元素 求两个集合的交集: 集合本身并不带有求交集的方法，需要将其转换为数组，然后调用数组的filter方法，筛选结束后"}, {"id": "6994395856849862670", "title": "前端算法必刷题系列[83]", "desc": "这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 153. 最长有效括号 (longest-valid-parentheses) 标签 动态规划 困难 题目 leetcode 传送门 给你一"}, {"id": "6961677202157109261", "title": "学前端算法的数据结构基础？只要4999！", "desc": "冲击！学习《前端算法与数据结构面试：底层逻辑解读与大厂真题训练 》小册，一方面记录学习要点，一方面方便大家简单了解"}, {"id": "6844904190578278414", "title": "「算法思想」分治、动态规划、回溯、贪心一锅炖", "desc": "初学者一听到算法思想，就会觉得它们高深莫测，只能望而却步。 但如果你看过《事实》这本书，你就不会被大脑中的惯性思维所影响。 只要我们理解算法思想的关键点，多做题练习并加深理解记忆。其实算法思想就像切菜一样简单。 上一篇算法系列专栏中我们搞明白了递归。其实递归这种编程技巧是很多算…"}, {"id": "6999144690830770212", "title": "【leetcode 题解】46题-全排列", "desc": "给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以按任意顺序返回答案。这题的核心实现逻辑是，将所有的路径都走一遍，不重复不遗漏。"}, {"id": "6997578099437076493", "title": "路径算法(二)", "desc": "Dijkstra 算法 宽度优先搜索算法，解决了起始顶点到目标顶点路径规划问题，但不是最优以及合适的，因为它的边没有权值（比如距离），路径无法进行估算比较最优解。为何权值这么重要，因为真实环境中，2个"}, {"id": "6846687564682756110", "title": "“了解”日常使用的加密方式（基本介绍，加密特点，应用场景）", "desc": "本文主要分享一下笔者过去曾使用过，或者了解过的加密方式。 \"了解\"而非”熟悉“，更适合表达文章的难度级别，底层的原理笔者也是一脸懵逼，更别提加密用到了什么算法。 本文只能浅谈一下不同的加密方式中的，基本介绍，加密特点，应用场景。 如有理解错误，欢迎指出。 首先加密就是为了不暴露…"}, {"id": "6998891026584698916", "title": "leetcode刷题-贪心", "desc": "leetcode刷题-贪心 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的 1. 分发饼干 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对"}, {"id": "7002468522966122532", "title": "leetcode 678.有效的括号字符串 | 刷题打卡", "desc": "题目链接 双栈法 思路 先简化一下，如果这道题没有*，只有(，)的话，只需要用一个栈就搞定了。 创建一个栈用来存( 遍历字符串，如果当前字符为(就入栈，如果当前字符为)并且栈不为空就出栈一个( 如果最"}, {"id": "6844903615652610055", "title": "深入框架本源系列 —— Virtual Dom", "desc": "众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多。 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 当然在实际操作中，我们还需要给…"}, {"id": "6993502549818998797", "title": "前端刷题路-Day73：最小路径和（题号64）", "desc": "给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小..."}, {"id": "6991369604551409672", "title": "前端刷题路-Day67：有效数字（题号65）｜ 8月更文挑战", "desc": "有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分..."}, {"id": "7002836981361164324", "title": "学习笔记：剑指 Offer 03. 数组中重复的数字", "desc": "题目描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中"}, {"id": "6993540770745548808", "title": "【温故知新】`189. 旋转数组` 额外数组、翻转数组(better)实现", "desc": "题目描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。   进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原"}, {"id": "6997219080570667016", "title": "路径算法(一)", "desc": "寻路在程序实现起来就需要一定的寻路算法来解决，如何在最短时间内找到一条路径最短的路线，这是寻路算法首先要考虑的问题。 如何寻路 你所看到的行走方式： 开发人员实际所看到的方式： 对于一张地图，开发人员"}, {"id": "6844903626050273294", "title": "前端你应该了解的数据结构与算法", "desc": "队列: 也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。 栈: 是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bo…"}, {"id": "6937526265201033230", "title": "数组回炉重造+6道前端算法面试高频题解｜刷题打卡", "desc": "在刷题之前让我们先来一起回顾一下 JavaScript 中数组的基础知识。 数组可以根据索引下标随机访问(时间复杂度为 O(1))，这个索引通常来说是数字，用来计算元素之间的存储位置的偏移量。 与其他编程语言不同，JavaScript 中的数组长度可以随时改变，数组中的每个槽位…"}, {"id": "6989146257058955272", "title": "什么是归并排序 mergeSort", "desc": "1. 什么是归并排序？ 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之"}, {"id": "6996584732423094286", "title": "算法：螺旋矩阵", "desc": "给你一个m行n列的矩阵matrix，请按照顺时针螺旋顺序，返回矩阵中的所有元素，matrix矩阵所有元素范围在[-100, 100]。"}, {"id": "7001826981868208159", "title": "算法（leetode，附思维导图 + 全部解法）300题之（16）最接近的三数之和", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（16）最接近的三数之和 导读： 作者简介 1 作者简历 2 作者标签 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方"}, {"id": "6974927739224588318", "title": "一文了解分而治之和动态规则算法在前端中的应用", "desc": "一文了解分而治之和动态规则算法 众多周知，分而治之算法和动态规则算法是前端面试中的“宠儿”。而在我们的日常生活中，这两个场景的应用也相对比较广泛。"}, {"id": "6999503644798222349", "title": "LeetCode题解：28. 实现 strStr()，暴力法，JavaScript，详细注释", "desc": "原题链接：28. 实现 strStr()，https://leetcode-cn.com/problems/implement-strstr/"}, {"id": "6979226007530111007", "title": "数据结构与算法系列——链表系列题目（1）", "desc": "这是我参与更文挑战的第9天，活动详情查看： 更文挑战 前言 链表这个数据结构，在我们前端开发中用的比较少，但是抵不住源码中有这样的数据结构。如果你对链表中的基本操作你都不是很熟悉的话。你很难看懂源码中"}, {"id": "6844903587215048711", "title": "浅谈React中的diff", "desc": "diff算法在React中处于主导地位，是React V-dom和渲染的性能保证，这也是React最有魅力、最吸引人的地方。 React一个很大一个的设计有点就是将diff和V-dom的完美结合，而高效的diff算法可以让用户更加自由的刷新页面，让开发者也能远离原生dom操作，…"}, {"id": "6844903635034308622", "title": "想要一份senior工作，务必要读 React 源代码吗？", "desc": "这段面试了一些。很多公司都会甩这个问题给你：读过 React 的源代码吗？ 答曰：没读过。瞬间感到自己的自信心掉了一块。网上也不乏各种分析源代码的文章和精读，只是我还是没有那个勇气和兴趣去读如此成熟的一个库的源代码，甚至想读也不知从何读起。 于是跑上 Reddit 发了一贴，想…"}, {"id": "6974666603438800926", "title": "排列组合-组合", "desc": "给出数据集合，从集合中选出 n 个元素，问可能出现的元素组合情况？ 组合特点：内部元素是无序的，即[1,2,3] 和[3,2,1]是同一种组合情况"}, {"id": "6991488113667211300", "title": "leetcode刷题-双指针", "desc": "双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 1. 两数之和 II - 输入有序数组 题目 给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加"}, {"id": "6873233326186954765", "title": "拓扑排序就这么回事", "desc": "前言大家好，这里是《齐姐聊算法》系列之拓扑排序问题。Topologicalsort又称Topologicalorder，这个名字有点迷惑性，因为拓扑排序并不是一个纯粹的排序算法，它只是针对某一类图，找"}, {"id": "6844904174971256845", "title": "【数据结构与算法】分析时间与空间复杂度", "desc": "学习任何一门知识的时候，我们需要分析清楚这门知识的核心是什么，从而在这个核心中我们可以得到什么。如果我们是盲目的吸收知识，其实很多知识我们都是在目前场景、工作、生活中无法使用的。也是因为学习之后无法运用，所以我们很快就会遗忘，或者是在学习的过程中很容易就会放弃。 这篇笔记记录了…"}, {"id": "6971442842744913957", "title": "LeetCode 对链表进行插入排序/排序链表（归并）[排序]", "desc": "这是我参与更文挑战的第 8 天，活动详情查看： 更文挑战 对链表进行插入排序（147） 题目描述 从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用"}, {"id": "6993238876508651556", "title": "前端算法入门之路（十一）（哈希表与布隆过滤器）--开课吧门徒计划历程", "desc": "哈希表 1. 若关键字为k，则其值存放在f(k)的存储位置上 2. 对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为哈希冲突"}, {"id": "6911165907779715086", "title": "DP 就是暴力，暴力就是艺术", "desc": "题目地址（面试题 17.23. 最大黑方阵） 看了下数据范围，矩阵大小不超过 $200 \\times 200$，因此答案应该就是暴力，这个数据范围差不多 N 的三次方的复杂度都可以通过，其中 N 为矩阵的边长。原因我也在之前的文章来和大家聊聊我是如何刷题的（第三弹）中讲过了，那…"}, {"id": "6844903573105573895", "title": "React源码分析 - Diff算法", "desc": "蓝色框框的部分分别是Diff算法的核心代码updateChildren以及processUpdates，通过Diff算法获取了组件更新的updates队列之后一次性进行更新。 《深入React技术栈》这本书对Diff算法的解释比较好。其实只要记住几个原则以及在具体的计算upda…"}, {"id": "6844903504457252877", "title": "JavaScript 性能优化", "desc": "前端工程师不但要保证完成界面的规划与开发，并且同时需要保证代码的质量，其中Javscript的运行速度则变得非常重要，此篇文章从工程师的角度入手，结合了开发者工具进行分析, 总结了一些常用的优化手段和法则.... - 小亦俊"}, {"id": "6973114262759669790", "title": "LeetCode第153题：寻找旋转排序数组中的最小值", "desc": "题干 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以"}, {"id": "6844903709537746957", "title": "详解leetcode146题【LRU (最近最少使用) 缓存机制】(附js最优解法！)", "desc": "leetcode 146. LRU (最近最少使用) 缓存机制 从以上分析，要想找到缓存末尾的值，我想到两个办法。 执行get的时候，如果缓存中存在get的数据，则更新缓存顺序，跟以上一样。 以上，是我第一感觉的做法。为什么说是第一感觉，首先，题目要求O(1)的复杂度，所以我不…"}, {"id": "6937823897853100046", "title": "547. 省份数量 | 刷题打卡 ", "desc": "前言冲冲冲！！！题目描述有n个城市，其中一些彼此相连，另一些没有相连。如果城市a与城市b直接相连，且城市b与城市c直接相连，那么城市a与城市c间接相连。省份是一组直接或间接相连的城市，组内不含其他没有"}, {"id": "6900686552045731848", "title": "KMP —— 字符串分析算法", "desc": "同学们好，我是来自 《技术银河》的 💎 三钻 。 大家可能觉得 KMP 这个算法的名字很特别、很怪，因为 KMP 它并不是三个英文单词的开头，而是三个计算机科学家的名字。发明这个算法的三位计算机科学家分别为：Knuth、Morris、Pratt。第一个是大家都非常熟悉的 Do…"}, {"id": "6997043596465537060", "title": "「前端刷题」15. 三数之和", "desc": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 a + b + c = 0 ？"}, {"id": "6844904198467747853", "title": "🎃 进来挑战一下只有 2% 的人能解的题目！", "desc": "好了，不卖关子了，我说的就是“斑马难题”。网传斑马难题是爱因斯坦设下的一道谜题，世界上只有 2% 的人能解。其实对此我深表怀疑... 我们直接看看题目吧，如果实在毫无头绪的话，可以直接跳到文末视频（BiliBili 干杯~ []~(￣▽￣)~*）。 根据条件判断，哪所房子里的人…"}, {"id": "6844903699584647176", "title": "用 JavaScript 的方式理解递归", "desc": "1. 递归是啥? 递归概念很简单，“自己调用自己”（下面以函数为例）。 在分析递归之前，需要了解下 JavaScript 中“压栈”（call stack） 概念。 2. 压栈与出栈 栈是什么？可以理解是在内存中某一块区域，这个区域比喻成一个箱子，你往箱子里放些东西，这动作就是…"}, {"id": "6970672197413109790", "title": "前端必会数据结构与算法系列之二叉堆(九)", "desc": "1. 什么是二叉堆 二叉堆是计算机科学中一种非常著名的数据结构，由于它能高效、快速地找出最大值和最小值 二叉堆是一种特殊的二叉树，有以下两个特性。 它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节"}, {"id": "6844904063654428685", "title": "算法-数组去重", "desc": "这是一篇考古文，2013玉伯在优化SeaJs性能时提出的一个问题，原文出处在这里从js数组去重谈性能优化, 以数组去重为切入点，比较辩证的谈了解决问题的方法论。 核心观点可以看下原文，本文只讲数组去重的最优方法以及其他几种方法。 利用对象的属性不会重复这一特性，首先创建一个空对…"}, {"id": "6844903648317685773", "title": "前端与算法-动态规划之01背包问题浅析与实现", "desc": "那么为解决这一类问题的算法就称为背包算法。 我们可以将背包的容量(v)拆解，分为0到v不同的背包，那么子问题就是，容量为(0-v)的背包，我们要算出对应的各个背包所能容纳下的最大价值，聪明的小伙伴这时候一定想起了上面我们介绍的动态规划，没错！背包问题的最优解法就是动态规划，它完…"}, {"id": "6844903688402632711", "title": "基于NodeJS的HTTP server Plus 6：加密（crypto）", "desc": "加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义，通过这种方式提高网络数据传输的安全性，加密算法常见的有哈希算法、HMAC 算法、签名、对称性加密算法和非对称性加密算法，加密算法也分为可逆和不可逆，比如 md5 就…"}, {"id": "6844903651610214407", "title": "从 0 到 1 实现 React 系列 —— 4.优化 setState 和 ref 的实现", "desc": "看源码一个痛处是会陷进理不顺主干的困局中，本系列文章在实现一个 (x)react 的同时理顺 React 框架的主干内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/ref/...)"}, {"id": "6938319917636648996", "title": " [LeetCode 704. 二分查找] | 刷题打卡", "desc": "分享这个题目的主要目的就是通过一个简单的算法题，了解二分查找的核心思想。 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 你可以假设 nums 中的所有元…"}, {"id": "6950140596023459847", "title": "[LeetCode-0083题-删除排序链表中的重复元素] ｜ 刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情一、题目描述二、思路分析三、解题代码四、总结升序排列的链表，重复元素一定是相邻的。每天一练，持续学习"}, {"id": "6844904066296840199", "title": "12306 抢票系列之只要搞定RAIL_DEVICEID的来源,从此抢票不再掉线(中)", "desc": "Js文件中关于网络请求最典型的就是异步回调,将原本简单的操作复杂化,非要你等我,我等他,他还等着他的她. 核心代码最外层函数是 initEc 函数,而该函数的写法明显是传统 js 的属性方法,因此判断挂载于该对象的属性方法应该都是完成某些相同的功能. 暂时先不着急继续寻找谁在调…"}, {"id": "6973637180476375047", "title": "LeetCode第34题：在排列数组中查找元素的起始位置", "desc": "题干 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 进阶： 你可以"}, {"id": "6844903944104198151", "title": "数据结构--无向图", "desc": "图是由一组顶点和一组能够将两个顶点相连的边组成。 连通图：如果从任意一个顶点都存在一条路径到达另一个任意顶点，就称为连通图，一个非连通图由若干连通的部分组成，都称为极大连通子图。 无向图：即连接两个顶点的边是没有方向的。 从起点开始选择一条边走到下一个顶点，没到一个顶点便标记此…"}, {"id": "6919245088925155342", "title": "前端就该用 JS 刷算法19", "desc": "783. 二叉搜索树节点最小距离 783. 二叉搜索树节点最小距离 113. 路径总和 II 113. 路径总和 II"}, {"id": "6844903565014761480", "title": "用React写一个数字华容道，你需要知道的秘密", "desc": "年末了。哦，不，要过年了。以前只能一路站到公司的我，今早居然是坐着过来的。新的一年，总要学一个新东西来迎接新的未来吧，所以选择了一直未碰的那个据说是全宇宙最牛逼的前端框架-React，在上下班的地铁上看了两天官方教程，so what。光看不练假把式，于是就想着做个什么，偶然看到…"}, {"id": "6854573212509208584", "title": "【内含干货】611. 有效三角形的个数", "desc": "题目地址(611. 有效三角形的个数) 首先要有一个数学前提： 如果三条线段中任意两条的和都大于第三边，那么这三条线段可以组成一个三角形。即给定三个线段 a，b，c，如果满足 a + b > c and a + c > b and b + c > a，则线段 a，b，c 可以构…"}, {"id": "6938428292525457422", "title": "[LeetCode112. 路径总和] | 刷题打卡", "desc": "给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。 看到根节点到叶子节点的路径，首先想到dfs。套用dfs的模板，…"}, {"id": "6844903665501732877", "title": "从 0 到 1 实现 React 系列 —— 5.PureComponent 实现 && HOC 探幽", "desc": "使用 PureComponent 是优化 React 性能的一种常用手段，相较于 Component, PureComponent 会在 render 之前自动执行一次 shouldComponentUpdate() 函数，根据返回的 bool 值判断是否进行 render。其…"}, {"id": "6894172377228754952", "title": "使用LL算法构建AST —— 编程训练", "desc": "同学们好，我是来自 《技术银河》的 💎 三钻 。 在之前的 《前端进阶》系列的学习笔记中已经讲到过不少跟字符串处理相关的内容。但是我们的主要学习的都是如何进行对字符串做一些初步的分析。我们这里就来一起学一些边缘里面的稍微高级一点的字符串处理，就是使用 LL 算法构建 AST。…"}, {"id": "6937654871231299621", "title": "「算法」LeetCode算法题63.股票的最大利润 | 刷题打卡", "desc": "年初那段时间股票涨势喜人，不知有没有韭菜入场。最近股票跌的让人心碎💔，大家别上火，能下车的下车，不舍得割肉的话就装si等市场好转好了💪。今天这道算法题就和股票有关，让我们来计算一下如何实现股票利润最大化。 原题链接 👉 剑指 Offer 63. 股票的最大利润 双重for…"}, {"id": "6844903520542408711", "title": "基于canvas使用贝塞尔曲线平滑拟合折线段", "desc": "本次分享一下在canvas中将绘制出来的折线段的棱角“磨平”，也就是通过贝塞尔曲线穿过各个描点来代替原有的折线图。"}, {"id": "6844903541522333704", "title": "动态规划-01背包问题", "desc": "背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为： 给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 它们的价值分别是6,3,5,4,6，现在给你个承重为 10 的背包, 怎么装背包，…"}, {"id": "6844903570349768712", "title": "JavaScript中的图片处理与合成(二)", "desc": "上篇文章，我们介绍了图片的裁剪/旋转与缩放，接下来本文主要介绍 图片的合成 ，这是基础类图片处理中比较实用且复杂的一部分，可以算第一篇文章内容的实践。 图片的合成原理其实类似于photoshop的理念，通过 图层的叠加 ，最后合成并导出，相比于裁剪和缩放，其实基本原理是一致的，…"}, {"id": "6844903847027015687", "title": "什么是备胎算法？", "desc": "假设有三男（分别是 A ，B ，C ）和三女（分别是 x，y ，z ），他（她）们对异性的心仪程度如对话框所示。 比如对于男 A 来说，心仪对象排名为 x 排第一，y 排第二，z 排第三。 今天是特殊节日，你化身为丘比特，来设计一个算法分配对象。 下面以男生主动追求对象为例来讲…"}, {"id": "6937479801377095710", "title": "【魅力算法】“使用最小花费爬楼梯”-动态规划、双指针-滚动数组思想实现 ｜刷题打卡", "desc": "题目描述解题思路动态规划：题目理解：你可以花费cost[i]的体力值，向上跳一个台阶或者两个台阶；你可以选择台阶起点为cost[o]或者cost[1]使用最少体力值，跳出数组边界即为成功；举例1:如果"}, {"id": "6844903895748067341", "title": "JavaScript 动态规划 & 贪心算法", "desc": "这一章，我们将介绍另外两种常用的算法：动态规划和贪心算法。动态规划常被人比作是递归的逆过程，而贪心算法在很多求优问题上，是不二之选。下面，我们针对这两种算法，展开详细的学习。 动态规划有时为什么被认为是一种与递归相反的技术呢？是因为递归是从顶部开始将问题分解，通过解决掉所有分解…"}, {"id": "6975861599777062926", "title": "数据结构-树形结构数据的生成和花式遍历姿势", "desc": "前言 衔接上一篇Node里的文件操作（到时候这里要放对应链接），专门写一篇树形结构的了解是和实现 ，同时加深自己对树形结构数据的了解 什么是树 线性结构 像数组 ，栈，队列，默认都是线性结构； 非线性"}, {"id": "6844903876429086734", "title": "LeetCode 攻略 - 2019 年 6 月汇总（30 题攻略）", "desc": "自 2019-05-16 开始，经过前期的阵痛（做公众号，稳定作息，稳定工作，调整时间……）后，jsliang 开始了持续攻略的 LeetCode。 有印象的小伙伴应该还记得，jsliang 一开始会将 LeetCode 题解发布到 掘金，但是因为掘金的个人主页不支持分标签，文…"}, {"id": "6992375863928946702", "title": "C++ 迪杰斯特拉算法和弗洛伊德算法(from GodOuO)｜8月更文挑战", "desc": "C++ 迪杰斯特拉算法和弗洛伊德算法C++ 迪杰斯特拉算法和弗洛伊德算法C++ 迪杰斯特拉算法和弗洛伊德算法"}, {"id": "6844903591510016007", "title": "聊聊V8引擎的垃圾回收", "desc": "我们知道，JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。 希望这篇文章能帮到你，同时本文也会收录到我自己的个人网站。 在C语言和C++语言中，我们如果想要开辟一块堆内存…"}, {"id": "6988854308515086372", "title": "一维数组和二维数组的相互转换", "desc": "使用场景：接口返回一个数组，展示时每行固定显示n个，则可将返回的数组转成二维数组[[...n], [...n]...]的形式循环展示 1. 一维数组转二维数组 输出： 将其封装为如下： 结果如下图 2"}, {"id": "6844903647340396558", "title": "前端算法之弹幕设计", "desc": "大家都说前端写页面较多，几乎用不到算法。本文愿从弹幕设计这个场景来描述算法在前端中的应用，我们先来看下实现效果： 开场之前我们先来描述弹幕开发的难度，再集中精力描述算法设计的思路。 如果弹幕采用相同的字号，碰撞的问题处理起来比较简单，只要考虑相邻弹幕的播放速度和偏移的位置就可以…"}, {"id": "6988721264160407560", "title": "LeetCode第513题 ：找树左下角的值", "desc": "题干 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 提示: 二叉树的节点个数的范围是 [1,104] -231 <= No"}, {"id": "6966771186944442398", "title": "前端刷题路-Day36：二叉搜索树节点最小距离（题号783）", "desc": "二叉搜索树节点最小距离（题号783） 题目 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 注意：本题与 530：https://leetcode-cn.com/"}, {"id": "6942790881904853005", "title": "几乎刷完了力扣所有的二分题，我发现了这些东西。。。（下）", "desc": "大家好，我是 lucifer。今天给大家带来的是《二分》专题。先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我会继续完善，将其他专题逐步完善起来。 几乎刷完了力扣所有的链表题，我发现了这些东西。。。 几乎刷完了力扣所有的树题，我发现了这些东西。。。 几乎刷完了…"}, {"id": "6994410013229842469", "title": "一种基于视神经网络的高动态范围（HDR）图像自适应局部色调映射的实现【OpenCV】【CUDA】", "desc": "​ 这是我参与8月更文挑战的第9天，活动详情查看： 8月更文挑战 正文 原理是基于这篇论文——《Adaptive Local Tone Mapping Based on Retinex for Hig"}, {"id": "6966105166663647263", "title": "JavaScript 二叉树的前中后序遍历", "desc": "JavaScript 二叉树的前序遍历、中序遍历、后序遍历，递归方法，迭代方法，Morris 遍历。后序遍历空值标记法。"}, {"id": "6995543629083181086", "title": "前端之算法（四）快速排序", "desc": "大家好，今天我们要聊的是快速排序，一种性能更好的排序算法。那我们开始吧！Let's go ！ 快速排序 快速排序的思路 分区：从数组中任"}, {"id": "6994782222452523038", "title": "算法（leetode，附思维导图 + 全部解法）300题之（8）字符串转换整数 (atoi)", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（8）字符串转换整数 (atoi) 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2"}, {"id": "7004381256464990244", "title": "动态规划算法", "desc": "动态规划 青蛙跳台阶问题： f(0)=1 , f(1)=1 , f(2)=2 ； 斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。 打家劫舍问题 最大子序和 零钱兑换 三角形中"}, {"id": "6987575437928955918", "title": "前端常见数据结构与算法整理--字典", "desc": "概念 一种用来存储唯一值的数据结构，通常以键值对的方式存储。 es6中拥有字典这个数据结构，叫做map。map（映射） map常用操作（增删改查） 增加 查询 删除 修改 leetcode相关算法题 "}, {"id": "6996289062776602637", "title": "算法题---打印从1到最大的n位数", "desc": "算法题---打印从1到最大的n位数 题目描述：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、"}, {"id": "6993340984524439565", "title": "LeetCode 45 Jump Game II (Tag:Array Difficulty:Medium)", "desc": "这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉"}, {"id": "6977314386322915364", "title": "前端算法必刷题系列[71]", "desc": "这是我参与更文挑战的第 24 天，活动详情查看 更文挑战 135. 分割回文串 (palindrome-partitioning) 标签 字符串 中等 题目 leetcode 传送门 这里不贴题了，l"}, {"id": "6936381040864788494", "title": "LeetCode135.分发糖果 | 刷题打卡", "desc": "老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 每个孩子至少分配到 1 个糖果。 评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。"}, {"id": "7001180614049136670", "title": "娱乐-JS怎么算0.1+0.2？", "desc": "打开控制台输入 `0.1 + 0.2` 得到 `0.30000000000000004` 为什么会这样，问题很大！"}, {"id": "7003229551987785736", "title": "两道简单的算法题：算出两个集合的补集和计算出⼀个数组内的所有波峰和波⾕", "desc": "算出两个集合的补集 说明：补集：如果 b 是 a 的⼦集，返回存在于 a 不存在于 b 的元素集合，反之返回空集合 思路 因为数组只包含字符串和数字，所以不用考虑对象、数组的情况。分别求相对于另一个数"}, {"id": "6844903693507117063", "title": "JS中的数组过滤，从简单筛选到多条件筛选", "desc": "在上家公司工作的时候，有一个需求是在前端部分完成筛选功能，一次拿到所有数据，然后根据条件筛选。通常情况下筛选是后台给接口，在数据量不大的情况下，也有人可能会遇到前端筛选这样的情况，特别写了这篇文章分享给大家，有问题请指出，互相学习。 一般情况下的单条件筛选，数组的filter方…"}, {"id": "7004996552812920862", "title": "js滑动窗口的应用", "desc": "滑动窗口主要用来解决寻找满足一定条件的连续区间的性质-如长度问题。由于区间连续，因此当区间变化时，可以利用旧有的计算结果进行剪枝，从而减少计算量。例如“满足xx的最x的子数组”问题就可以用滑动窗口解决"}, {"id": "6844903608467587085", "title": "解锁多种JavaScript数组去重姿势", "desc": "JavaScript数组去重，一个老生常谈的问题了，但这次是解锁多种JavaScript数组去重姿势。 双重循环去重实现比较容易。 基本思路：如果索引不是第一个索引，说明是重复值。 基本思路：先对原数组进行排序，然后再进行元素比较。 基本思路：利用了对象的key不可以重复的特性…"}, {"id": "6996218406785515550", "title": "算法（leetode，附思维导图 + 全部解法）300题之（9）回文数", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（9）回文数 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： 3 方案"}, {"id": "7001108964834279432", "title": "HTML+CSS中的2D转换translate rotate scale小案例", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 rotate案例 transform-origin案例 设置旋转中心 scale案例 2D转换综合写法示例代码"}, {"id": "7000578988280119333", "title": "LeetCode16-最接近的三数之和 | 算法练习系列", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 前言 今天来一道简单的算法题（虽然LeetCode中说它是中等的题目），最接近的三数之和，这道题题目很简单，但想要做到最优也需要一些思考，"}, {"id": "7002137975920263175", "title": "学算法刷LeetCode【剑指offer专题】：30.包含min函数的栈", "desc": "题目描述 30.包含min函数的栈 解体思路 这道题只对时间复杂度有要求，那可以在空间复杂度上放宽。因此，我们可以使用两个栈， 栈1正常实现的 push、pop()、top() 等 API 栈2则用于"}, {"id": "6959549674990600228", "title": "什么是尾递归？ 尾递归和普通的递归的区别", "desc": "简介 首先解释什么是尾递归和尾调用，后面再来解释什么是斐波拉契数列，怎么用JavaScript实现斐波拉契数列，尾递归和它有什么关联。让你彻底理解尾递归和尾调用。"}, {"id": "7001739086142636045", "title": "JS算法之复杂链表的复制及二叉搜索树与双向链表", "desc": "这是我参与8月更文挑战的第29天，活动详情查看：8月更文挑战 复杂链表的复制 请实现copyRandomList函数，复制一个复杂链表。"}, {"id": "7000019513320144910", "title": "【温故知新】`102. 二叉树的层序遍历` 广度优先遍历、队列先进先出的原则", "desc": "题目描述 解题思路 广度优先遍历 特殊情况优先处理 层序遍历利用queue队列的先进先出的原则 定义队列queue并初始化为根节点root; 遍历队列queue 我们定义levelNum为当前层级的节"}, {"id": "6993228699256979463", "title": "JavaScript_算法与数据结构之 队列 -＞ Queue-＞ First In First Out 以及 优先队列", "desc": "@TOC 队列的定义 队列的方法 enqueue(element):向队列尾部添加一个(或多个)新的项。 dequeue()︰移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。 front("}, {"id": "6988423535773351950", "title": "LeetCode算法学习之--数组--三数之和", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目 三数之和 题目 分析 解法一：暴力法（通过不了，只提供思路） 解法二：Set 法 代码借鉴 https://leetcode-cn.co"}, {"id": "6844903597092651015", "title": "重构 - 改善代码的各方面问题", "desc": "做前端开发有一段时间了，在这段时间里面，对于自己的要求，不仅仅是项目能完成，功能正常使用这一层面上。还尽力的研究怎么写出优雅的代码，性能更好，维护性更强的代码，通俗一点就是重构。这篇文章算是我一个小记录，在此分享一下。该文章主要针对介绍，例子也简单，深入复杂的例子等以后有适合的…"}, {"id": "7000271129969426446", "title": "LeetCode11-盛最多水的容器 | 算法练习系列", "desc": "这是我参与8月更文挑战的第25天，活动详情查看：8月更文挑战 前言 今天来一道有意思的算法题--盛最多水的容器，看到这个题目我就想到了以前看到过的短板效应也叫做木桶原理，这个原理就是你盛水的最大量不取"}, {"id": "6844903615300108302", "title": "JavaScript 内存机制（前端同学进阶必备）", "desc": "每种编程语言都有它的内存管理机制，比如简单的C有低级的内存管理基元，像malloc(),free()。同样我们在学习JavaScript的时候，很有必要了解JavaScript的内存管理机制。 JavaScript的内存管理机制是:内存基元在变量（对象，字符串等等）创建时分配，…"}, {"id": "6999920491041390622", "title": "前端刷题路-Day90：回文子串（题号647）", "desc": "给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串..."}, {"id": "7006128036756062244", "title": "力扣--100.相同的树", "desc": "给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的"}, {"id": "7001862751454756894", "title": "刷完这 15 道 dp 题，只能碰运气押题进大厂了", "desc": "前言 某个男人 动态规划,而我作为一个致力称为厨师界最会写算法的前端，总得刷上一部分题，有那么一点发现吧，现在我们就来聊聊，菜鸡如我，发现了什么。"}, {"id": "6993679779618619428", "title": "LeetCode回文数 | 算法练习系列", "desc": "这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 前言 回文数是一个神奇的存在，它体现了一种对称美，在大自然中到处都是对称的例子，猎豹的四肢，狮子的面部，漂亮的蝴蝶翅膀，等等，从古之前，我们"}, {"id": "7000939851704958990", "title": "算法入门及简单练习——队列", "desc": "队列 什么是队列 队列是一种特殊的线性表，只允许在队列的头部删除节点，在末尾添加新的元素。 常见的方法 enqueue 从队列尾部添加一个元素（我也结账了，过来排队） dequeue 从队列头部删除一"}, {"id": "6844903632966516749", "title": "2018年6月前端面试经历(中)", "desc": "二分查找法主要是解决「在一堆有序的数中找出指定的数」这类问题，不管这些数是一维数组还是多维数组，只要有序，就可以用二分查找来优化。 深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，…"}, {"id": "6976827207335280653", "title": "前端刷题路-Day59：最长有效括号（题号32）", "desc": "给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（ 格式正确且连续 ）括号子串的长度..."}, {"id": "6979008666721189924", "title": "数据结构之树（操作树的节点）", "desc": "这是我参与更文挑战的第29天，活动详情查看：更文挑战 本篇文章中，我们来实现树的remove方法。 remove(key): 从树中移除某个键。"}, {"id": "6844904134341033998", "title": "前端进阶算法5：全方位解读前端用到的栈结构（+leetcode刷题）", "desc": "栈结构很简单，我们可以通过数组就能模拟出一个栈结构，但仅仅介绍栈结构就太不前端了，本节从栈结构开始延伸到浏览器中 JavaScript 运行机制，还有存储机制上用到的栈结构及相关数据结构，一文吃透所有的前端栈知识。 以后再提到栈时，我们不再仅限于 LIFO 了，而是一个有深度的…"}, {"id": "6996990107966242847", "title": "面向前端的算法——链表结构", "desc": "这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 1. 前端js构建链表结构 1.1 单向链表结构 这里我按书上标准的，复制粘贴：线性表的链式存储，指通过任意的存储单元来存储线性表中的数据元"}, {"id": "6988713306127564808", "title": "LeetCode算法学习之--链表--环形链表", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目 [环形链表](https://leetcode-cn.com/problems/3sum/) 题目 分析 解法一：快慢指针 解法二：Se"}, {"id": "6997782740531675143", "title": "JS算法之斐波那契及青蛙跳台阶", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 斐波那契数列 写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项（即F(N)）。"}, {"id": "6991865877990342669", "title": " LeetCode算法学习之--数组--合并两个有序数组", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目合并两个有序数组 题目 分析 解法一：迭代法 解法二：sort 解法三：逆向双指针 总结 这道题考察的如果通过迭代 双指针和原生的方法来 "}, {"id": "6993245574367543327", "title": "一个算法“拿下”两个榜单！爱奇艺ICCV 2021论文提出人手三维重建新方法", "desc": "目前，研究员们正在尝试将该技术应用到爱奇艺下一代VR设备中，从而减少对手柄依赖，打造出更轻、更快、更舒适的VR设备。"}, {"id": "6997993374342971422", "title": "磨刀霍霍向猪羊 - 剑（js）来！", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 8.19 - 345. 反转字符串中的元音字母 题意 分析 复杂度分析 时间复杂度：O（n），n 是 s 的长度，虽然遍历两次，但是加起来"}, {"id": "6995363933443850254", "title": "前端刷题路-Day78：对称二叉树（题号101）", "desc": "给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像..."}, {"id": "6978821271702224909", "title": "数据结构之树（搜索树中的值）", "desc": "这是我参与更文挑战的第28天，活动详情查看：更文挑战 通常来讲，在树中会有三种搜索类型： 搜索最小值 搜索最大值 搜索特定的值 我们都知道二叉树左侧的子节点值父节点，右侧的子节点值大于等于父节点。"}, {"id": "6986904449750925326", "title": "LeetCode 18 4Sum (Tag:Array Difficulty:Medium)", "desc": "题目描述 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？"}, {"id": "6982482461305339911", "title": "ShowMeBug 自动补全功能原理大揭秘", "desc": "经常有读者问小编，说用 ShowMeBug 做笔面试编程题时代码自动补全功能体验特别好，想知道是怎么实现的。今天就跟小编来了解一下自动补全的原理吧～"}, {"id": "6994042219258707975", "title": "前端算法必刷题系列[82]", "desc": "这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 前面连续的难题，来几个简单点放松下 151. 复写零(duplicate-zeros) 标签 简单 题目 leetcode 传送门 给你一个"}, {"id": "6997411194747224100", "title": "前端之算法（九）回溯算法", "desc": "今天我们要聊的是回溯算法这种方法，它和贪心算法、分而治之、动态规划一样，也是算法设计中的一种方法，你同样可以把它当作解决问题的一"}, {"id": "6997039793863393294", "title": "LeetCode算法学习之--HashMap--有效的字母异位词", "desc": "这是我参与8月更文挑战的第13天，活动详情查看：8月更文挑战 大家好今天给大家分享下一道 LeetCode 简单难度 的题目[有效的字母异位词](https://leetcode-cn.com/pro"}, {"id": "6941003131891220517", "title": "从希卡文翻译谈谈 OCR 的简单实现", "desc": "塞尔达玩家一定不会陌生，希卡文是游戏《塞尔达传说旷野之息》中一种虚构的文字，在希卡族的建筑上都能找到它的影子，之前实现了一个简单的希卡文生成与翻译的工具，不过关键的文字解析实现的并不优雅，使用隐藏水印的方式将一些关键信息隐藏在导出的图片中，图片压缩后隐藏信息很容易丢失，导致解析…"}, {"id": "6992763221794881543", "title": "15天算法入门(四）", "desc": "反转字符串 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决"}, {"id": "7001510659640786957", "title": "前端算法必刷题系列[92]", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 167. 寻找重复数 (find-the-duplicate-number) 标签 中等 题目 leetcode 传送门 给定一个包含 n"}, {"id": "6999820563761856526", "title": "前端常考的算法题", "desc": "关于算法的误解 前端没有算法？ 「前端没有算法」这种认知是错误的。前端不仅有算法，而且算法在前端开发中占据的地位也越来越重要。我们常提到的 Virtual dom diff、webpack 实现、Re"}, {"id": "6844903582622285831", "title": "React Fiber", "desc": "react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。 为了解决这个问题，react团队经过两年的工作，重写了r…"}, {"id": "6844903938068578311", "title": "面试官: 100万个成员的数组取第一个和最后一个有性能差距吗?", "desc": "数组几乎可以是所有软件工程师最常用到的数据结构,正是因为如此,很多开发者对其不够重视. 希望大家带着以上的问题我们进行讨论. 数组是计算机科学中最基本的数据结构了,绝大多数编程语言都内置了这种数据结构,也是开发者最常见的数据结构. 数组（英语：Array），是由相同类型的元素（…"}, {"id": "6846687592532934669", "title": "一道字节面试题，拿走不谢~", "desc": "编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 所有输入只包含小写字母 a-z 。 分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问…"}, {"id": "6989856354479374372", "title": "每天一题，forEach", "desc": "今天要实现的是forEach函数，既可以遍历数组，也可以遍历对象，还有一个\"小众\"功能，改变函数内this的指向。 问题 具体实现 实现思路 参数： obj（Array | Object）：需要遍历的"}, {"id": "7003516005846630408", "title": "手写一个min-vue", "desc": "手动模拟一个min-vue 通过手动实现一个min-vue，来掌握vue中数据响应式原理。 准备html 写好html方便我们验证每次写的功能是否正确。 vue 在index.html中我们引入了js"}, {"id": "6996127305919627277", "title": "刷完这 20 道链表题，可能还是手撕不了大厂面试", "desc": "前言 某个男人 几乎刷完了力扣所有的链表题，我发现了这些东西。。。,而我作为一个致力称为厨师界最会写算法的前端，总得刷上一部分题，有那么一点发现吧，现在我们就来聊聊，菜鸡如我，发现了什么。"}, {"id": "6997584076404162574", "title": "前端刷题路-Day84：打家劫舍（题号198）", "desc": "你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入..."}, {"id": "6992546366526324750", "title": "算法之前", "desc": "数据结构与算法的关系 数据结构：计算机存储，组织数据的方式，就像锅碗瓢盆。 算法：一系列解决问题的清晰指令，就像食谱。 程序 = 数据结构 + 算法"}, {"id": "7000182433807237151", "title": "前端刷题路-Day91：每日温度（题号739）", "desc": "请根据每日 气温 列表 temperatures，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替..."}, {"id": "7001141883330101262", "title": "LeetCode算法学习之--Heap--出现频率最高的 k 个数字", "desc": "这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 大家好今天给大家分享下一道 LeetCode 中等难度 的题目[剑指 Offer II 060. 出现频率最高的 k 个数字] 题目 分析"}, {"id": "6976624204821037087", "title": "六个排序比较", "desc": "不基于比较的排序，对样本数据有严格要求，不易改写；基于比较的排序只要规定好两个样本怎么比较大小就直接可以复用；基于比较排序的时间复杂度极限是O(nlogn)。。。"}, {"id": "6844903642059767816", "title": "面试图谱：前端基础技术知识讲解", "desc": "金九银十的秋招季近在眼前，想必大家也都心痒难耐，准备挑战更好的工作机会。那么，面试肯定是最大的挑战。 对于面试来说，平时的积累肯定是必须的，但是在面试前的准备也是至关重要的。 在几月前我个人组建了一个小团队，花了将近半年的时间寻找大厂的面试题，筛选出了近百个知识点然后成文，并全…"}, {"id": "6983616666387087391", "title": "前端小算法之字符串操作(一)", "desc": "作为前端开发工程师，日常需要面对一些字符串的数据做一些处理。本文主要是介绍了其中一些比较常见的字符串操作、公共前缀、KMP算法等事例。"}, {"id": "7001294842756087845", "title": "前端刷题路-Day94：字母大小写全排列（题号784）", "desc": "给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 示例： 提示： S 的长度不超过12。 S 仅..."}, {"id": "6995076648940879908", "title": "前端必刷手写题系列 [15]", "desc": "这是我参与8月更文挑战的第10天，活动详情查看：8月更文挑战 25. 随机打乱数组 问题是什么 问题很清晰，就是给你个数组，让你随机打乱顺序。 分析 有一个常用写法是这个, 利用 Math.rando"}, {"id": "7002821734260817957", "title": "学习笔记：剑指 Offer 05. 替换空格", "desc": "题目描述 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 题目示例 题目分析 这个题目非常简单，利用JS原生api就可以实现，这里不多赘述 代码实现一 代码实现二 题目来源 剑指 Off"}, {"id": "7001506528909869064", "title": "优化技巧：项目中利用扩展运算符优化代码", "desc": "今天周末，事情有点多，差点想断更了，想想还是更一下吧哈哈！今天简单来总结一下我们日常工作中可能会遇到的业务场景，然后我们是如何去巧妙处理冗"}, {"id": "6997602204525805576", "title": "前端算法入门之路（十三）（单调队列及经典问题）--开课吧门徒计划历程", "desc": "单调队列 单调队列是一个递增或递减的队列，可以用来维护滑动窗口区间的最值，即RMQ问题 入队操作：队尾入队，会把前面破坏单调性的元素删除（维护单调性） 出队操作：如果队首元素超出区间范围，就将队首元素"}, {"id": "6844903641778749447", "title": "js实现敏感词过滤算法", "desc": "最近弄了一个用户发表评论的功能，用户上传了评论，再文章下可以看到自己的评论，但作为社会主义接班人，践行社会主义核心价值观，所以给评论敏感词过滤的功能不可少，在网上找了资料，发现已经有非常成熟的解决方案。 全文搜索，逐个匹配。这种听起来就不够高大上，在数据量大的情况下，会有效率问…"}, {"id": "6844903565043957773", "title": "基于时间序列检测算法的智能报警实现", "desc": "服务的高可用离不开稳定的监控，如果服务出现了问题，作为开发者能第一时间发现问题，修复上线是业务止损的最好方法，随着业务飞速发展，对系统的稳定性有了更高的要求，传统的基础告警指标和触发器设计方案，在使用上存在很多限制，报警规则配置依赖开发人员主观经验，配置一条高可用规则需要多次实…"}, {"id": "6979246113723252743", "title": "如何优雅地反转有符号整数", "desc": "如何反转一个有符号整数，大部分人会直接想到用字符串反转来实现，这种要考虑负数的特殊情况，有没有更漂亮的解法呢？"}, {"id": "6992958075279769631", "title": "探究Diff 算法的执行过程", "desc": "渲染真实DOM的开销很大，dom操作会引起浏览器的重排和重绘，也就是浏览器重新渲染。浏览器重新渲染是非常耗费性能的，因为要重新绘制整个页面。当数据变化后，尤其是大量的数据变化后，例如列表中的数据，如果"}, {"id": "6979023271580663822", "title": "前端刷题路-Day65：山脉数组的峰顶索引（题号852）", "desc": "符合下列属性的数组 arr 称为 山脉数组 ： arr.length >= 3 存在 i（0 < i < arr.length - 1）使得..."}, {"id": "6844903714356985870", "title": "React 重要的一次重构：认识异步渲染架构 Fiber ", "desc": "熟悉 react 的朋友都知道，在 react 中有个核心的算法，叫 diff 算法。web 界面由 dom 树组成，不同的 dom 树会渲染出不同的界面。react 使用 virtual dom 来表示 dom 树，而 diff 算法就是用于比较 virtual dom 树的…"}, {"id": "6873436480430309390", "title": "寻找数组中的重复数字", "desc": "前面一系列文章分享了数据结构与算法的基础知识，接下来分享一些算法题的解题思路与实现。欢迎各位感兴趣开发者阅读。 有一个数组，现要找出数组中任意一个重复的元素。它的规则如下： 接下来，我们来一一讲解下这三种实现思路。 遍历排序好的数组，如果其相邻的两个元素相等就代表数组中有重复的…"}, {"id": "6999988010993319949", "title": "「前端刷题」23. 合并K个升序链表", "desc": "给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。   示例 1： 输入： lis"}, {"id": "6987581573545754638", "title": "福彩33选6，筛选算法", "desc": "题目 福彩1-33，共33个数字的6个数组合，共110万多，通过排除、筛选、自定义，输出剩余组合 可输入的变性筛选： 可自定义一个起始数，然后可输入6个数字来筛选排列组合，囗代表空格，例如输入1.1."}, {"id": "6844903613303635976", "title": "详解动态规划最少硬币找零问题--JavaScript实现", "desc": "硬币找零问题是动态规划的一个经典问题，其中最少硬币找零是一个变种，本篇将参照上一篇01背包问题的解题思路，来详细讲解一下最少硬币找零问题。如果你需要查看上一篇，可以点击下面链接： 下面让我们开始吧。 给定4种面额的硬币1分，2分，5分，6分，如果要找11分的零钱，怎么做才能使得…"}, {"id": "6987396773689950239", "title": "LeetCode算法学习之--二分查找--搜索旋转排序数组2", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[搜索旋转排序数组 II](https://leetcode-cn.com/problems/count-of-range-sum/) 题"}, {"id": "6968624002025652232", "title": "前端刷题路-Day37：搜索旋转排序数组（题号33）", "desc": "整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了旋转..."}, {"id": "6844903639891329031", "title": "一个拖拽框背后的高中数学", "desc": "很多时候一个看似简单的 bug 背后，都可能有着完全在作者意料之外的成因。这时候一路排查、调试和给出 fix 的过程往往可以相当神奇。最近我就遇到了个这样的问题，在此分享一下 :) 最近我在维护一个用于平面设计的编辑器项目。在编辑器的画布上，图片是支持拖拽、旋转和裁切的，像这样…"}, {"id": "6968876910113718286", "title": "踩坑日记 - “快乐”的二叉树 （递归即栈）", "desc": "作为一个叛逆的程序员，刷题竟然没有从二叉树开始，然后再去刷动态规划。 而是先刷的动态规划基础，觉得有点对不起labuladong的算法小抄的作者。 引子 刷题以来，最开始接触树是从斐波那契数列这类题目"}, {"id": "6974558692989468702", "title": "时间复杂度解析", "desc": "算法的复杂度算是我们入门算法的第一课了，之前了解的有限，现在综合整理一下相关的概念： 算法复杂度分为时间复杂度和空间复杂度。 其作用： 时间复杂度是指执行算法所需要的计算工作量； 而空间复杂度是指执行"}, {"id": "6994447441143529485", "title": "【温故知新】`518. 零钱兑换 II`  完全背包问题组合解-动态规划实现", "desc": "题目描述 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一"}, {"id": "6952003619734421541", "title": "手撕代码系列：LRU算法", "desc": "前言LRU是一个操作系统的页面置换算法，它是 Least Recently Used(最近最少使用) 的缩写，用来淘汰上次使用距当前时间最长的页。"}, {"id": "6994409228307791885", "title": "二叉树刷题(三）", "desc": "这是我参与8月更文挑战的第9天，活动详情查看：8月更文挑战 前面写了比较基础的二叉树题目，有需要的童鞋请冲 二叉树刷题(一）， 二叉树刷题(二），这篇继续刷几道二叉树的题。 一、完全二叉树的节点个数 "}, {"id": "6844903512359305229", "title": "如何用 3KB 不到的 JavaScript 实现微机模拟器", "desc": "不知道有多少同学小时候玩过小霸王、GBA 之类游戏主机的模拟器呢？模拟器不仅仅是上面的游戏好玩，编写它的过程也是很有意思的。下面我们会介绍怎样拿 JavaScript 从头做一个带 CPU、内存、输入输出、能玩老游戏，体积还不到 3KB 的模拟器。 如果你觉得下面的理论有些枯燥…"}, {"id": "6974705224858632223", "title": "二叉堆与优先队列", "desc": "二叉堆 定义 二叉堆是完全二叉树，且满足所有节点都≥（最大堆）或者≤（最小堆）其子节点的条件。 特点 所有节点都≥（最大堆）或者≤（最小堆）其子节点 存储方式 使用数组来存储二叉堆，从根节点出发，按根"}, {"id": "6844903972713562125", "title": "有序数组能否分割为连续子序列的一种算法实现", "desc": "子序列退出时,立即判断是否满足,不满足即可提前终止判断."}, {"id": "6878623822552137735", "title": "翻转一个整数", "desc": "相信我，知识点so so so easy……，并且很容易理解。 好了，闲话咱们就不多说了，直接开始今天的正题吧。 首先先来看下题目是什么。 首先不看答案，按照自己的想法来解答一遍。 1. 第一版 之后将得到的数组进行 reverse 。 最后得到正确答案。 最后转换为数字。 并…"}, {"id": "6911574885470994439", "title": "算法基础——异或运算符（^）的骚操作", "desc": "这是百度百科给出的解释对于程序算法来说归零律1^1输出0相同的输出0，恒等律1^0输出1二进制异或运算|2|1|0|number||---|---|---|---||1|0|1|5||1|1|0|6|"}, {"id": "6844903556772790279", "title": "盘点二叉树的基本操作", "desc": "之前写过相关的文章，是关于如何创建及遍历二叉树的，这里不再赘述。提供链接给各位感兴趣的小伙伴，点此跳转 可以看出，无论是只有左子树还是只有右子树都可以进行翻转。这句话等价于，为空的子树可以和不为空的子树进行交换，也就是不对为空的子树进行特殊处理 其实这样我们还是不知道二叉树是如…"}, {"id": "6914627825404215304", "title": "前端就该用 JS 刷算法6", "desc": "最后还是没能自己想出结果来，明天再看看二分如何处理吧，继续做今天需要做的事情了。"}, {"id": "6935316262763364360", "title": "20210303 LeetCode 每日一题，冲！｜刷题打卡", "desc": "Leetcode 链接：338. 比特位计数（medium） 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可…"}, {"id": "6844903648913440776", "title": "简单易懂的现代魔法-递归", "desc": "平时在前端开发中，好像也没啥用到递归的地方。不过这并不代表递归不重要，如果你看过一些框架的源码，就会经常见到它的影子：比如渲染虚拟DOM的render函数，webpack中require依赖分析，Koa2洋葱式的中间件模型，其实都运用到了递归算法。 代码在运行过程中，会有一个叫…"}, {"id": "6924979022963310606", "title": "《算法导论》第四部分-动态规划浅析及其Javascript实现", "desc": "动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合…"}, {"id": "6950933040671490062", "title": "算法&数据结构---入门", "desc": "一、导论算法&数据结构，一听这两个词就有点望而生畏，一是觉得工作上接触少之又少，二是觉得学习成本较高，所以平时用不到，又难啃的知识必然提不起学习的兴趣。所以首先要了解它们存在的意义，以及在工作中实际的"}, {"id": "6951598374000951303", "title": "数组之快慢指针", "desc": "主要思想实现步骤：从同一起点出发，当碰到某一条件的时候，快指针继续走，慢指针不动，知道满足另外一个条件时，快指针对慢指针所处的位置值进行赋值。"}, {"id": "6844904064682049550", "title": "前端算法题目解析（二）", "desc": "虽然疫情还是严峻，但总会过去。在此居家办公之际，应该趁这个时机好好提升下自我，多读书多看报，少吃零食多运动哈哈。 最近看一些文章和题目有接触一些算法题，我整理了一下收录daily-question 的 algorithm 文件夹中，后续会继续增加，本文分享我整理的十个算法题目。…"}, {"id": "6844903817016770567", "title": "每日一算--零钱兑换", "desc": "给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 有1、2、5三种类型的硬币，选择第一枚硬币的时候有两种方式，选择1元或者不选择1元。 依次对每种类型的硬币就像这样选择，直到amount为0的选择，就是其中之一的解。 解法…"}, {"id": "6898089650766774279", "title": "10 张图聊聊线程的生命周期和常用 APIs", "desc": "上一篇文章我们聊了多线程的基础内容，比如为什么要使用多线程，线程和进程之间的不同，以及创建线程的 4 种方式。本文已收录至我的 Github: https://github.com/xiaoqi666"}, {"id": "6956047502449573924", "title": "ChaCha20-Poly1305 算法", "desc": "简介： ​ ChaCha20-Poly1305是由ChaCha20流密码和Poly1305消息认证码（MAC）结合的一种应用在互联网安全协议中的认证加密算法，由Google公司率先在Andriod移动"}, {"id": "6844903697776902158", "title": "半小时轻松玩转WebGL滤镜技术系列（一）", "desc": "要想做到封面中的效果，我们需要掌握大量的WebGL知识和图像算法，作为系列的第一篇，我希望通过本文先让大家对滤镜有一个初步的认识，能够做到以下两点。 1. 理解如何绘制图片 2. 理解如何添加滤镜及动态控制滤镜效果 4. 设置顶点位置 可以看到，相比于灰度处理中，除了main(…"}, {"id": "6844903569053712398", "title": "深入理解React源码 - 界面更新（DOM树）IX", "desc": "上次我们走完了从setState()到单个DOM更新的流程，并简单的分析了diffing算法。这个分析显然不够，因为diffing算法是为更为复杂的情况而设计。"}, {"id": "6919103631384018958", "title": " javascript 算法之 算法设计思想  分而治之", "desc": "4、 LeetCode：100. 相同的树"}, {"id": "6914639899098529805", "title": "js算法之集合", "desc": "第一种遍历方法 for ... of"}, {"id": "6913474997013086221", "title": "寻路算法", "desc": "在正式介绍这篇寻路算法文章之前，我想先简单讲讲两个经典的算法：深度优先搜索算法和广度优先搜索算法。 深度优先搜索(Depth-First-Search，DFS)，是一种用于遍历搜索树或图的算法。这个算法会尽可能深的搜索树的分支。我们一般使用堆数据结构来辅助实现 DFS 算法。 …"}, {"id": "6844903721155952647", "title": "【一起学习排序算法】3 选择排序", "desc": "本系列的文章列表和相关说明，请查看序言。具体列表如下： 本篇为此系列第三篇。 把列表分为两个部分，一部分是已经排好序，一部分待排序。 初始有序子列为空，然后遍历待排序子列，找出最小的元素，然后和待排序子列的第一个元素互换。然后游标右移一个。这样有序子列增加一个元素。 重复以上步…"}, {"id": "6844903630345076744", "title": "virtual dom和diff算法", "desc": "结合代码，理解virtual dom和diff算法"}, {"id": "6844903718333186055", "title": "【图解数据结构】 一组动画演示选择排序", "desc": "由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 -----《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。 选择排序是一种简单直观的排序…"}, {"id": "6844903602616533005", "title": "react 版跳棋", "desc": "最近在学校闲着也是闲着，打算复习一下react，想写点什么东西，最后决定写一个跳棋打发闲暇的时光。最后按照自己设想的写完了，由于是基于create-react-app的架子，不能放在codepen上有一点遗憾，不过本文最后给了线上地址和github地址，大家感兴趣可以看看，欢迎…"}, {"id": "6914121077685747725", "title": "算法之散列表", "desc": "散列表就类似于键值对的形式一一对应，将输入映射到数字，并且每次输入输出都是一致的。 原因是，在查找的情况下，散列表只需要输入并返回对应的数字即可，而在链表中查询的话需要一个一个去遍历。 同理，这里的删除和插入原理一样，输入并返回对应的数字就即可。 假设你的散列表有26个位置，散…"}, {"id": "6844903506269175815", "title": "石墨文档的云端表格实时压缩策略", "desc": "多人实时协作是石墨文档吸引人的一大特性之一。使用石墨文档，你可以和同事、朋友同时编写一篇文档或表格，每个人的修改都会实时的同步给其他人。你可以看到每个人光标的跳动，每一个键入的文字。一篇篇运营文案、一份份产品头脑风暴，伴着一杯杯茶与咖啡，就这样在石墨文档上诞生了。 美好的事物背…"}, {"id": "6844904050371067912", "title": "【译】算法的记录", "desc": "为了搜索一个目标元素，从数组的左侧到右侧遍历。 如果目标元素在数组的最后一个或不在数组中，需要遍历整个含有n个元素的数组。 用大O表示法，这会被转换成O(n)。 目标元素是第一个元素。 用大O表示法，这会被转换成Ω(1)。 为了找到目标元素，每次可以通过减少搜索区域的一半来查找…"}, {"id": "6909703648595410957", "title": "字符串算法题", "desc": "给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 '?' 字符。 题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换…"}, {"id": "6924636620805111815", "title": "LeetCode.13: 罗马数字转整形", "desc": "当时看完题之后的第一直觉写了个暴力解法，思路是把 I/X/C 这三个字母左边引起的变化都编成字典，然后利用条件判断的三目运算来完成题解。但是运算时间和效率上是有很大的缺陷。 后来看了其他人的思路就有了下面的解法，利用reduce累加的特性，最关键的一点是抓住了罗马字变化的规律。…"}, {"id": "6911294045599825928", "title": "每日算法-路径总和(树-简单）", "desc": "给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 递归。转为判断：左、右子树中能否找出…"}, {"id": "6844903645272604686", "title": "React从零实现-介绍和准备", "desc": "在React的实现中，有几种写法需要了解。 我们这里使用直接赋值的方法，而不是使用setAttribute来给dom添加Attribute，是为了保证只有有效的Attribute才能被赋值。这里涉及到attribute和property的区别。 这里的name是property…"}, {"id": "6844903757952581645", "title": "聊聊前端排序的那些事", "desc": "貌似前端[1]圈一直以来流传着一种误解：前端用不到算法知识。[2] 长久以来，我也曾受这种说法的影响。直到前阵子遇到一个产品需求，回过头来看，发现事实并非如此。 前端将排序条件作为请求参数传递给后端，后端将排序结果作为请求响应返回前端，这是一种常见设计。但是对于有些产品则不是那…"}, {"id": "6940647621295865870", "title": "上岸算法 I LeetCode Weekly Contest 231解题报告", "desc": "符合要求的字符串即前缀全是 1，后缀全是 0 的字符串。 贪心即可，每次都添加绝对值尽可能大的。注意总和可能溢出 int，所以中间运算要使用 long。"}, {"id": "6949349655935188999", "title": "前端算法复习--二叉树", "desc": "本篇文章主要讲述了在算法复习过程中的知识方法和二叉树的概念和常见算法实现，使用javascript语言实现"}, {"id": "6844903715938254856", "title": " 从规范看赋值表达式的解析", "desc": "显然，关键点在于最后一个语句的执行。这个语句的执行主要涉及了 属性获取表达式 和 赋值表达式，先去规范里看对于这两种语法及其执行的规定。 1. 赋值表达式 a.x = a = a.y = {n: 2}; 是其中的第二种形式 (第三种形式中的AssignmentOperator在…"}, {"id": "6844903605300887566", "title": "虚拟dom算法解析", "desc": "前言snabbdom是一个虚拟dom算法库，它的特点是效率高、可扩展，许多开源项目采用了这种算法，例如vue。本文试图还原虚拟dom的diff原理（仅限于snabbdom算法）。虚拟dom什么是虚拟d"}, {"id": "6844903504327213070", "title": "JS中如何进行对象的深拷贝", "desc": "上述代码中，使用了=进行赋值，于是b指向了a所指向的栈的对象，也就是a与b指向了同一个栈对象，所以在对b.name赋值时，a.name也发生了变化。为了避免上面的情况，可以对对象进行拷贝，代码如下： 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候a与b指向的…"}, {"id": "6884214358860120077", "title": "我的js算法爬坑之旅-有序数组的平方", "desc": "第九天：力扣第977题，有序数组的平方地址：https://leetcode-cn.com/problems/squares-of-a-sorted-array/思路：先用绝对值排序，然后进行平方操作"}, {"id": "6844903600003481608", "title": "IM应用中如何计算富文本的高度", "desc": "在开发IM的项目过程中，经常会有出现一些需要计算DOM高度，然后超出若干行隐藏等需求。很多时候，需要计算高度的DOM元素都是动态生成的，我们无法在数据渲染前获取到它的高度。 如果没有任何交互，我们可以通过CSS来实现这个需求。但是，如果我们需要使用JavaScript来实现一些…"}, {"id": "6948330242121416741", "title": "leetcode 81. 搜索旋转排序数组 II ｜刷题打卡", "desc": "leetcode 81. 搜索旋转排序数组 II 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k``（0 &#x3C;= k &#x3C; nums.length）上进行了 旋转 ，使数组变为 [n…"}, {"id": "6909269714380275719", "title": "蒲公英 · JELLY技术周刊 Vol.35: Flash 四宗罪？", "desc": "随着5G网络的普及，直播行业的火热，在h5上多媒体的场景也越来越多。对于video标签的使用，前端需要考虑加载时长以及各终端兼容，这篇文章给出了流媒体的解决方案，从HLS、DASH概念，自适应比特率流技术及流媒体加密技术，FLV文件格式、MSE API、视频播放器原理、MP4 …"}, {"id": "6891198809125650439", "title": "用 JavaScript 实现寻路算法 —— 编程训练", "desc": "同学们好，我是来自 《技术银河》的 💎 三钻 。 在我们的这个练习里面我们会制造一张 100 x 100 个格子的地图，并且在上面绘制我们的从起点到终点的路径。 在这么大规模的寻路问题当中，我们首选需要做一个地图编辑器。它的功能如下： 首先我们需要绘制我们地图的底盘，在绘制之…"}, {"id": "6964938694784450596", "title": "一道sort排序题到js中数组常见排序的学习（冒泡、快速、插入）", "desc": "sort排序 首先来看下w3c上对于**sort()**方法的解释（原理类似冒泡排序）。 冒泡排序 思路： 升序-将数组中的相邻两个元素进行比较，大的往后排，一轮过后，最大的值放在数组最后。降序反之。"}, {"id": "6993227703696490527", "title": "JavaScript_算法与数据结构之 栈 -＞ Stack -＞ Last In First Out", "desc": "@TOC 栈的方法 push(element) :添加一个新元素到栈顶位置. pop() ∶移除栈顶的元素，同时返回被移除的元素。 peek() :返回栈顶的元素，不对栈做任何修改(这个方法不会移除栈"}, {"id": "6844903648510607373", "title": "Hybrid App技术解析 -- 实战篇", "desc": "上一篇原理篇，我们已经详细地阐述了 Hybrid App 的基础原理，了解了 Native端 和 H5端 是如何通信的，还有 bridge 的设计和接入。而本篇文章将开始把这些原因进一步实践，用代码真正地去实现一套完整且稳定的 Hybrid 方案。如果对原理还有疑问的小伙伴，请…"}, {"id": "6992983531995529230", "title": "LeetCode算法学习之--stack--有效括号", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目有效的括号 题目 分析 解法一：stack 解法二：includes 总结 这道题主要考察的是对stack的应用 大家可以看看我分享的一个"}, {"id": "6980144621833682957", "title": "四种时间复杂度 O(nlogn) 级排序算法", "desc": "上一篇我们了解了 3种时间复杂度 O(n^2) 级排序算法;本文中我们将了解四种时间复杂度 O(nlogn) 级排序算法-希尔排序、堆排序、快速排序、归并排序。"}, {"id": "6943009671724826654", "title": "前端刷题路-Day3", "desc": "定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 每个next都包含着剩下所有的内容，比方说这是一个5组数据的链表，那么第一个元素的next包含着剩下四组的数据的所有内容，第二个元素的next包含着剩下三组元素的所有内容，这才是链表。 看看这个答案，明显…"}, {"id": "6958708693479194655", "title": "前端算法系列之数据结构基础", "desc": "抽象数据类型（Abstract Data Type，ADT）是一些操作的集合，抽象数据类型是数学的抽象，在 ADT 的定义中根本没涉及如何实现操作的集合，这可以看作是模块化设计的扩充。"}, {"id": "6997000476495446024", "title": "JavaScript链表刷题", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 今天用JavaScript来刷下链表题~~ 一、判断是否为环形链表 141. 环形链表 给定一个链表，判断链表中是否有环。 如果链表中有某"}, {"id": "6844903653011095566", "title": "来一次https原理到配置“一条龙”", "desc": "无论你是要看小姐姐/小哥哥，还是关注国家大事，想要第一时间掌握新鲜资讯和最新动态，网络都会成为你的第一选择。而网络协议中的http和https是我们最见到的。 这些隐患可不只是说说而已，你遇到过运营商劫持吗？三天两头给你插一段广告还有其他很恶心的操作，防不胜防。正是因为这些隐患…"}, {"id": "6844903717003608071", "title": "Google Photos 如何做到媲美原生的用户体验", "desc": "到目前为止也尚未出现能和 Google Photos 相媲美的产品。特别是在页面布局和图片比例上 Google 的工程师会分享他们是如何完成这些挑战，以及 Web 版的 Goolge Photos 中的一些技术细节。"}, {"id": "6976821716257341471", "title": "javascript leetcode刷题 - 第1题：两数之和各种解法", "desc": "这是我参与更文挑战的第23天，活动详情查看： 更文挑战 这里收集了两数之和的各种javascript解法 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标"}, {"id": "6844903602276827144", "title": "如何理解虚拟DOM?", "desc": "本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。"}, {"id": "6977981705076834340", "title": "leetcode top100挑战, 每天不鸽一道题之 反转链表(13/100)", "desc": "给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。这道题讲道理真的死背都要死背下来，你去面试的时候，万一面试官看你顺眼，觉得你是天命之子，立马给你一道反转链表作为送分题。"}, {"id": "6992586885902106638", "title": "LeetCode 41 First Missing Positive (Tag:Array Difficulty:Hard)", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉"}, {"id": "6876486050852634632", "title": "回溯算法总结（JavaScript实现）", "desc": "用于求解多阶段决策问题。多阶段决策问题即： 每一个步骤（阶段）可以有多种选择。 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果； 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度…"}, {"id": "6995175994487210020", "title": "「前端刷题」11. 盛最多水的容器", "desc": "给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i"}, {"id": "6995822038598287374", "title": "快速排序过程分析", "desc": "浅析过程 快速排序的原理是，通过定一种中间基准值。与这个基准值进行比较，即可区分成比该值大的一组，以及比该值小的一组。然后继续对区分好的数组进去取基准，在进行比较。直到该数组无法切分后，再将一层层向上"}, {"id": "6983929411657531423", "title": "LeetCode第86题：分隔链表", "desc": "题干 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 实例1"}, {"id": "6844903796766670861", "title": "微软前端社招笔试详解", "desc": "又到了每年的金三银四招聘旺季，有幸获得了微软的笔试机会，程序猿们应该都知道，老美的公司都喜欢怼数据结构与算法，微软肯定也不例外，个人觉得考数据结构对每一个应聘者都公平，我这次投的是微软苏研院，笔试考察的不难，是最最常见的数据结构算法裸题，这里记录一下，也给出解法。 快排应该是最…"}, {"id": "6998783067687452709", "title": "算法（leetode，附思维导图 + 全部解法）300题之（12）整数转罗马数字", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（12）整数转罗马数字 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码："}, {"id": "7003585611751751687", "title": "leetcode 215.数组中的第K个最大元素 | 刷题打卡", "desc": "题目链接 站在巨人的肩膀上 思路 直接用原生方法倒叙排序后取值，取巧的办法，哈哈。 代码 快排 利用快排的思想找出第k大的值 思路 快排基本思路： 随便找数组[i, j]里的一个基准值，假设q是该基准"}, {"id": "6997233921276510221", "title": "前端刷题路-Day83：相交链表（题号160）", "desc": "给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交..."}, {"id": "7000550364915171335", "title": "前端刷题路-Day92：和为K的子数组（题号560）", "desc": "给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例1： 说明： 数组的长度为 [1, 20,000]。 数组中元素的范围..."}, {"id": "6992760084560347144", "title": "前端算法必刷题系列[80]", "desc": "这是我参与8月更文挑战的第5天，活动详情查看：8月更文挑战 148. 接雨水 (trapping-rain-water) 标签 双指针 困难 题目 leetcode 传送门 给定 n 个非负整数表示每"}, {"id": "6893065166003372039", "title": "几乎刷完了力扣所有的链表题，我发现了这些东西。。。", "desc": "先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我后继续完善，将其他专题逐步完善起来。 大家好，我是 lucifer。今天给大家带来的专题是《链表》。很多人觉得链表是一个很难的专题。实际上，只要你掌握了诀窍，它并没那么难。接下来，我们展开说说。 链表标签在 le…"}, {"id": "6996496135309230116", "title": "前端刷题路-Day81：单词拆分（题号139）", "desc": "给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词..."}, {"id": "6977167352882266126", "title": "前端刷题路-Day60：在排序数组中查找元素的第一个和最后一个位置（题号34）", "desc": "给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值..."}, {"id": "6844903633012817927", "title": "吉他和弦推导算法", "desc": "当一个民谣小哥抱着吉他哼唱着《情非得已》时，他右手扫着音孔处的琴弦，左手变换着按着琴颈处的琴弦，一段简单的弹唱便看起来有模有样。在不看脸不看唱功的情况下，是什么原理才赋予这位小哥如此风骚的魅力呢？ 这就是吉他伴奏。 而他只是一个吉他初学者，还没办法给歌曲编配伴奏，只好从网上找来…"}, {"id": "7003146532216111117", "title": "刷完这 几 道位运算，等等再考虑手撕大厂面试吧", "desc": "前言 经常会有人问，作为前端，你在实际工作中用到过哪些算法，而我回答一般是，树和位运算； 想想 webpack 上的那些依赖的版本类型，想想 react 源码中的那些 flag 的定义和运算"}, {"id": "6991295578395115534", "title": "前端算法必刷题系列[76] ｜8月更文挑战", "desc": "今天来一些简单的二叉树问题，为后面二叉树更复杂情况做铺垫，二叉树一定要思考对称性，并利用递归做左右分治。 142. 合并二叉树 (merge-two-binary-trees) 标签 二叉树 简单 题"}, {"id": "6993966765877248013", "title": "【温故知新】`322. 零钱兑换` 动画演示-完全背包问题最小解-动态规划实现", "desc": "题目描述 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 "}, {"id": "6999824657494851591", "title": "JavaScript实现二分搜索树（递归）", "desc": "一文搞懂二分搜索树！ 还不来看看~ 二分搜索树相比于其他数据结构的优势在于有着高效的插入、删除、查找操作"}, {"id": "6999786475638226957", "title": "【温故知新】`101. 对称二叉树`  利用队列、递归实现二叉树的判断", "desc": "题目描述 解题思路 递归实现 镜像对称，就是左右两边相等，也就是左子树和右子树是相当的。 左子树和右子相等，意味着递归的比较左子树和右子树。 特殊情况处理： 如果根节点为null,则对称； dfs(r"}, {"id": "6844903959996399624", "title": "聊聊面试必考-递归思想与实战", "desc": "“递归”算法对于一个程序员应该算是最经典的算法之一，而且它越想越乱，很多复杂算法的实现也都用到了递归，例如深度优先搜索，二叉树遍历等。 作者简介：koala，专注完整的 Node.js 技术栈分享，从 JavaScript 到 Node.js,再到后端数据库，祝您成为优秀的高级…"}, {"id": "6988420304431218718", "title": "算法（leetode，附思维导图 + 全部解法）300题之（2）两数相加", "desc": "标题：算法（leetode，附思维导图 + 全部解法）300题之（2）两数相加 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： 3 方案3（方案2"}, {"id": "6999843615396593677", "title": "学习记录之算法篇——二叉树", "desc": "1. 二叉树的前序遍历 描述 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例： 递归解法 解题思路： 递归解法很容易理解，根据前序遍历的顺序：根 -> 左 -> 右；可以将二叉树的"}, {"id": "6992778387232129061", "title": "3周攻克数据结构[数组篇-矩阵Matrix]", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 DAY5 1. 有效的数独 示例： 方法1：双层遍历-[哈希表]; 【空间换时间】 2. 矩阵置零 示例1： 示例2： 方法1：数组标记法"}, {"id": "7004305536912982052", "title": "前端算法练习（持续更新）", "desc": "最近正在准备笔试，做了一下试卷里的两道编程题，发现啥也不会o(╥﹏╥)o，所以每天练几道，边练边做笔记，下次容易复习，太菜了，还是得从简单的开始"}, {"id": "6844904013801095176", "title": "图形算法（邻接矩阵）", "desc": "最近有些小伙伴在写表单联动关系是觉得非常复杂，不知道从何下手。大多数情况下会要求后端同学给到嵌套结构，但是这种结构有个致命的缺点，无法向上联动而且存在大量多余数据。推荐了一下邻接矩阵发现有好多同学不了解，写个简单的科普文章解释一下。 邻接矩阵是一个用来描绘顶点与边关系的数据结构…"}, {"id": "7003692676314824734", "title": "剑指 Offer 30. 包含min函数的栈", "desc": "剑指 Offer 30. 包含min函数的栈 题意 剑指 Offer 30. 包含min函数的栈 解法 这一题主要就是考虑怎么维护最小元素的位置。 进栈的时候情况比较简单，若发生交换一定是进栈的元素 "}, {"id": "7003692657373347848", "title": "剑指 Offer 09. 用两个栈实现队列", "desc": "剑指 Offer 09. 用两个栈实现队列 题意 剑指 Offer 09. 用两个栈实现队列 解法 栈是先进后出的，队列是先进先出的。 这里可以用一个栈来进行“入队”操作，用另一个栈来进行“出队”操作"}, {"id": "7000947247789637663", "title": "LeetCode26-删除有序数组中的重复项 | 算法练习系列", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 前言 今天来一道LeetCode上面简单难度的算法题，删除有序数组中的重复项，听起来好像很简单，有序并且是数组，直接for循环遍历把和前一"}, {"id": "6844903607452581896", "title": "JavaScript 中常见设计模式整理", "desc": "开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。 看完了上述设计模式后，把它们的关键词特点罗列出来，以后提到某种设计模式，进而联想相应的关键词和例子，从而心中有数。"}, {"id": "6998402996002357279", "title": "前端算法必刷题系列[88]", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 160. 搜索二维矩阵II (search-a-2d-matrix-ii) 标签 中等 题目 leetcode 传送门 编写一个高效的算法"}, {"id": "6994345536643923976", "title": "小五的算法系列 - 链表", "desc": "本文内容为链表。笔者将带领大家从 js 模拟其实现出发，逐步变化以探索链表的其它形式，最后附上几道习题加深理解及巩固所学。"}, {"id": "6911477791754027021", "title": "「算法与数据结构」时间与空间复杂度", "desc": "肯定不是，在计算机行业发展，不管是前端亦或是后端，算法都是进阶的一个绊脚石，可以说不会算法永远也成不了一个合格的高级工程师，想要进大厂确实要会些算法，但是它并不只是为了面试，它和我们的程序是息息相关的，有人说前端不需要算法？你把大名鼎鼎的 虚拟DOM (Virtual DOM)…"}, {"id": "6989097135857893407", "title": "小五的算法系列 - 栈与队列", "desc": "本文内容为栈和队列。笔者将带领大家从 js 模拟其实现出发，探索栈与队列在实际场景中的应用。其间会穿插讲解 程序调用栈 及 任务队列，使理解程序执行、递归、异步调用等易如破竹。"}, {"id": "7002243856968187911", "title": "【温故知新】`114. 二叉树展开为链表` 深度优先、前序遍历特性实现", "desc": "题目描述 给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开"}, {"id": "7000645893653266469", "title": "js for in 和for of的区别", "desc": "```js const myArr = [ { name:\"ss\", age:11, }, { name:\"aa\", age:12, }, { name:\"dd\", age:15, } ] const"}, {"id": "6985448063376556069", "title": "LeetCode刷题，设计前中后队列（1670）", "desc": "思路：使用两个双端队列来进行前中后插入，如queue1和queue2，当有插入时，判断两个队列元素数量是否相等。 不相等时往少的那个队列进行插入。始终保持两个队列元素相等或元素少一即可"}, {"id": "6981487855637889032", "title": "寻找旋转数组中的最小数字", "desc": "把一个数组最开始的若干个元素搬到数组的末尾，就称之为数组的旋转。有一个递增排序数组，将其开头的若干个元素移动至数组的末尾，寻找其中的最小值。 本文就跟大家分享下如何用最快的速度找到递增旋转数组中的最"}, {"id": "6998354448808411150", "title": "LeetCode49-字母异位词分组 | 算法练习系列", "desc": "这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 前言 今天的算法练习题是字母异位词分组，什么是异位词呢？异位词就是两个单词不同，但组成的单词的字母是完全相同的，就比如aet，eat，ta"}, {"id": "7002064163610574862", "title": "前端刷题路-Day96：Z 字形变换（题号6）", "desc": "将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"PAYPALISHIRING\" 行数为 3 时，排列..."}, {"id": "6997938236605595684", "title": "【LeetCode 233.数字1的个数 】- JavaScript（规律）", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 LeetCode 233.数字1的个数 - JavaScript 题目描述 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 "}, {"id": "6844904183007543310", "title": "「面试必问」leetcode高频题精选", "desc": "算法一直是大厂前端面试常问的一块，而大家往往准备这方面的面试都是通过leetcode刷题。 我特地整理了几道leetcode中「很有意思」而且非常「高频」的算法题目，分别给出了思路分析（带图解）和代码实现。 给定一个整数数组 nums 和一个目标值 target，请你在该数组中…"}, {"id": "6982032399580266510", "title": "前端重试策略 - 指数退避算法", "desc": "网络请求异常的场景避免不了重试策略，而重试策略的关键之处就在于如何设置重试等待时间，本文介绍的指数退避算法就是用来解决这样的问题。"}, {"id": "6844903639333470221", "title": "记一次凉凉的小米面试", "desc": "初入北京，人生地不熟的，找工作这种大事就直接到我脑袋上了。有幸小米的hr给我发了面试通知让我去快（bei）乐（shang）的面试。 4:请实现一个两边宽度固定中间自适应的三列布局。 从prototype、隐式的_proto_、constructor再到修改原型链的内容会导致的影…"}, {"id": "6996624987956183070", "title": "LeetCode 721.账户合并 - JavaScript", "desc": "这是我参与8月更文挑战的第15天，活动详情查看：8月更文挑战 LeetCode 721.账户合并 - JavaScript 题目描述 传题目送门 输入 输出 说明 题目分析 题目提到，用户可能会重名，"}, {"id": "6844903566910423047", "title": "结合kmp算法的匹配动画浅析其基本思想", "desc": "本次分享一下通过实现kmp算法的动画效果来试图展示kmp的基本思路。"}, {"id": "6844903501043073032", "title": "gif的故事：解剖表情动图的构成", "desc": "在现在表情包横行的年代，相信大家对表情动图已经不陌生了，这些动图通常就是我们使用的gif图（比如下图）。所谓动图就是会动的图片，而其会动的原理跟动画、影视剧一样，通过连续播放图片让我们从视觉感官上认为图片会动。那么gif图片又是如何将动图中的每一帧存储下来的呢，这下就需要我们动…"}, {"id": "6938644924724314143", "title": "[LeetCode 11. 盛最多水的容器] | 刷题打卡", "desc": "给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 …"}, {"id": "6938309181581557773", "title": "[LeetCode 560. 和为K的子数组] | 刷题打卡", "desc": "给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e…"}, {"id": "6936892338023170084", "title": "LeetCode 98 验证二叉搜索树 | 刷题打卡", "desc": "本题选自 LeetCode 98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 一棵二叉搜索树，任意节点的左子树小于其根节点，任意节点…"}, {"id": "6935993859138650126", "title": "二叉树中的最大路径和(分治法)｜刷题打卡", "desc": "题目描述题目来自LeetCode2021春招冲刺攻略题干样例提示:树中节点数目范围是[1,3*10^4^]-1000<=Node.val<=1000思路分析首先我们可以将问题简化为:在一棵非空二叉树的"}, {"id": "6844903507439386631", "title": "从拥挤的兔子到伪随机数算法", "desc": "从生态学问题延伸到混沌理论，再实际应用到计算机领域，实现一种简单的伪随机数算法"}, {"id": "6844903511012933645", "title": "触碰密码世界的大门", "desc": " "}, {"id": "6844903640201691144", "title": "【库】利用ES6 默认传参Default Parameters改善柯里化应用", "desc": "在同步运算的调用中进行函数处理，达到作用域层层共享的结果，除了嵌套的瑕疵，函数的执行过程还是相当别致的，这儿可以用eval以及typeof ‘function’进行一个递归判断执行，避免层层嵌套，因为有其他更优的写法，我这儿就懒得写了。 这儿的优势在于，将函数传参部分进行ret…"}, {"id": "6936369254631473165", "title": "剑指 Offer 03. 数组中重复的数字 | 刷题打卡", "desc": "找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在0～n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 用两个for循环暴力遍历，比较第i个数字与i后面的数字是否相等，如果相…"}, {"id": "6889963823273345038", "title": "数据结构与算法学习系列之 栈", "desc": "栈的定义栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。如图：基于数组的栈我们使用ES6的"}, {"id": "6844904039465877517", "title": "数据结构与算法：在有序但含有空的数组中查找字符串（javascript）", "desc": ""}, {"id": "6844903861908406279", "title": "LeetCode  分隔链表(No.725)", "desc": "root 的长度范围： [0, 1000]. 输入的每个节点的大小范围：[0, 999]. k 的取值范围： [1, 50]."}, {"id": "7008009947745091592", "title": "js非递归二叉树遍历", "desc": "一、树是什么？ 1.前端工作中常见的树包括： DOM树、级联选择、树形控件... 2.JS中没有树，但是可以用Object和Array构建树 3.树的常用操作：深度/广度优先遍历、先中后序遍历 二、什"}, {"id": "6990275842538471438", "title": "LeetCode题解：61. 旋转链表，闭合为环，JavaScript，详细注释", "desc": "原题链接：61. 旋转链表，https://leetcode-cn.com/problems/rotate-list/"}, {"id": "6924322557374136328", "title": "为什么v8引擎的sort排序函数会如此高效", "desc": "关于排序应该大家都不陌生，在我们平时写我们的业务代码时，会经常有对数据排序的需求，那我们前端所使用的排序函数就是js引擎所提供的sort函数，它可以直接调用，也可以通过传一个函数入参，来提供待排序数据的先后顺序依据。 但是js引擎所实现的排序和我们知道的那些经典的排序算法有什么…"}, {"id": "6844903778886352904", "title": "【JS面试向】选择排序、桶排序、冒泡排序和快速排序简介", "desc": "新年伊始，又到了金三银四的时候了。面对前端越来越多的算法面试题，我简单的整理了一下几种比较常见的数组排序方式，分别介绍其基本原理和优劣势。（ps：才疏学浅，希望大家可以在issues下面指出问题） 选择排序从数组内遍历出最大值，加入新数组，将最大值从原数组中删除，重复上述操作，…"}, {"id": "6948293876889157662", "title": "678. 有效的括号字符串｜刷题打卡", "desc": "给定一个只包含三种字符的字符串：( ，) 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) …"}, {"id": "7003920735840239653", "title": "递推算法", "desc": "递推算法相关内容 ----------------------- 解题思路，例题及与动态规划之间关系"}, {"id": "6970825142112878600", "title": "“我要做太空人”----太空人表盘制作", "desc": "“这是我参与更文挑战的第4天，活动详情查看： 更文挑战” 需求 有智能手表的人都知道，前段时间的“太空人表盘”非常火热。那么我们也可以自己动手来制作一款太空人表盘。 准备 Visual Studio "}, {"id": "6998880136422490125", "title": "「前端刷题」20. 有效的括号", "desc": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须"}, {"id": "6992772589441515550", "title": "前端刷题路-Day71：合并区间（题号56）", "desc": "以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖.."}, {"id": "6948718907918123044", "title": "大白话理解递归本质，可视化递归过程", "desc": "于是你开始展示你智慧的一面了，先问前排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。 但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问~ 直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。 直到你前面的人告诉你他在哪一排，…"}, {"id": "6971603906765946916", "title": "前端刷题路-Day45：解码异或后的数组（题号1720）", "desc": "未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1]..."}, {"id": "6943924805196496903", "title": "有序的数组，试试用指针法遍历", "desc": "数组上，单个指针的话，先将指针指向开始(或末尾)，然后指针移动，当移动到数组之外，就表示数组遍历完毕。 数组上，两个指针的话，如果出现在两端，随着两边指针移动，未遍历中间的元素范围就慢慢变小，直到指针相邻或者重合表示，遍历完毕，也叫对撞指针法。 遇到求和或者比大小问题的时候，如…"}, {"id": "6969742908211593229", "title": "【LeetCode刷题--剑指Offer】=>58-|| 左旋字符串", "desc": "题目概述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cde"}, {"id": "6994439738253901837", "title": "LeetCode算法学习之--Queue--滑动窗口最大值", "desc": "这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 大家好今天给大家分享下一道 LeetCode 困难难度 的题目滑动窗口最大值 题目 分析 解法一：暴力双指针(超时) 解法二：双端队列 代码"}, {"id": "6949099380670464036", "title": "【得物技术】算法入门一：算法的好坏？复杂度告诉你", "desc": "一个问题既然可以通过多种算法来解决，那么如何衡量哪个算法更好呢？ 显然一个算法执行时间越短，占用的内存空间越小，那么它就是更好的算法。"}, {"id": "6844903894414262280", "title": "深度优先遍历 (DFS) 与广度优先遍历 (BFS)", "desc": "看了很多前辈的分享后，笔者今天想整理下所理解的图的遍历算法。 图的遍历算法分为深度优先遍历与广度优先遍历，这两种算法从字面上了解的话，可以很清楚的知道。 一种是以深度，不断去查找是否有下级节点，如果有就继续递归向下查找，否则回到上级，再由未遍历的下级节点进入。 另一种是以广度，…"}, {"id": "6872486892625985544", "title": "有关 HashMap 面试会问的一切", "desc": "前言大家好，本篇文章是《齐姐说数据结构》系列的第三篇，更多数据结构和算法的文章已经整理在我的 Github 上了：https://github.com/xiaoqi6666/NYCSDEHashMap"}, {"id": "6921946575639937038", "title": "算法之由斐波那契数列深入递归", "desc": "递归体：数列的第3项开始每一项都是前两项之和，所以比如传传入的 n 为5时，第5项的结果为第4项和第3项之和，而第4项又是第3项和第2项之和，以此类推。 时间复杂度：可以从图中看出我们要求第5项的话可以分解为第4项和第3项之和，由此类推。每一个父项都会裂变为2个子项。而树的高度…"}, {"id": "6992214302690115615", "title": "【温故知新】`16.最接近的三数之和` 排序+双指针实现", "desc": "题目描述 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。  "}, {"id": "6844904187247984654", "title": "算法小白如何高效、快速刷 leetcode？", "desc": "我本身刷了大概 600 道左右的题目，总结 200 多篇的题解，另外总结了十多个常见的算法专题，基本已经覆盖了大多数的常见考点和题型，全部放在我的 Github https://github.com/azl397985856/leetcode 。 然而作为一个新手，看着茫茫多的…"}, {"id": "6992193598179508254", "title": "LeetCode算法学习之--二分查找--水位上升的游泳池中游泳", "desc": "大家好今天给大家分享下一道 LeetCode 困难难度 的题目[水位上升的泳池中游泳](https://leetcode-cn.com/problems/merge-sorted-array/) 题目"}, {"id": "7004491721073508360", "title": "用通俗易懂的方式讲解动态规划", "desc": "动态规划是一种比较难以理解的算法思想，本文结合自己的理解采用通俗易懂的方式来讲解下动态规划，欢迎各位感兴趣的开发者阅读本文。"}, {"id": "6999307229752983582", "title": "(算法入门)人人都能看懂的时间复杂度和空间复杂度", "desc": "本文适合对于算法复杂度不明白，或者准备学习算法的朋友，结合大量代码例子，助你快速入门算法，不断突破自己"}, {"id": "7004616375591239711", "title": "用 JavaScript 做数独", "desc": "最近看到老婆天天在手机上玩数独，突然想起 N 年前刷 LeetCode 的时候，有个类似的算法题（37.解数独），是不是可以把这个算法进行可视化。 说干就干，经过一个小时的实践，最终效果如下： 怎么解"}, {"id": "7000909761336049671", "title": "不懂动态规划？21道 LeetCode题目带你学会动态规划！", "desc": "本文21道动态规划相关的LeetCode题目节选自CodeTop中考察频率较高的动态规划题目，文章较长，全文约15000字，可以收藏一波嗷~~"}, {"id": "7005496623488827428", "title": "彻底弄懂base64的编码与解码原理", "desc": "背景 base64的编码原理网上讲解较多，但解码原理讲解较少，并且没有对其中的内部实现原理进行剖析。想要彻底了解base64的编码与解码原理，请耐心看完此文，你一定会有所收获。"}, {"id": "7005188929804582919", "title": "图解数据结构js篇-链表结构（Linked-list）", "desc": "通过22张图带你彻底了解链表，就差把内存晶体管扒开来看了。当我写完这篇文章的标题后，我就知道这篇文章不会短。原创码字画图都不易，还请点赞鼓励一下。🤭"}, {"id": "6995349923793698847", "title": "手撸二叉树之将有序数组转换为二叉搜索树", "desc": "Hello, 大家好，今天是我参加8月更文的第 12 天，今天给大家带来的关于二叉树相关的算法题是将有序数组转换为二叉搜索树，正文如下： 题目 给你一个整数数组 nums，其中元素已经按升序 排列，请"}, {"id": "6944632786724585502", "title": "猛增 110K Star！年增长数最多的 10 大顶级前端学习资源项目！", "desc": "1. javascript-algorithms 该仓库包含了多种基于 JavaScript 的算法与数据结构。 每种算法和数据结构都有自己的 README，包含相关说明和链接，以便进一步阅读 (还有 YouTube 视频) 。 算法包含了 算法主题 和 算法范式。 其中算法主…"}, {"id": "6984990913118339085", "title": "工作中可能会使用到的数据结构和算法", "desc": "背景 我们日常的开发工作避免不了和数据打交道。展示数据时，接口返回的数据结构可能没办法直接拿来使用，需要做一层转换；保存数据时，通过表单拿到的数据结构和接口定义的数据结构也可能不一致，需要做一层转换；"}, {"id": "6984925268754317320", "title": "卡牌大师：玩转“洗牌算法”，幸运女神在微笑 (*^_^*)", "desc": "我们看过太多排序算法，殊不知“洗牌”这种乱序算法也是门技术活~本篇透析洗牌算法，从青铜到王者，从愣头青到与神共舞！超神！来劲德瑞。。。"}, {"id": "6994236862260854792", "title": "手撸二叉树之二叉搜索树中的搜索", "desc": "Hello, 大家好，今天是我参加8月更文的第 9 天，今天给大家带来的关于二叉树相关的算法题是二叉搜索树中的搜索，正文如下： 题目： 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到"}, {"id": "7005018792136802334", "title": "数据结构与算法之 —— 图 Graph", "desc": "0x01 基本概念 核心概念 图：一组由边连接的节点（或顶点）| 一些离散的节点和若干连接它们的边的集合，是网络结构的抽象模型。 边：连接两个节点的线段。 权重：边的权值 路径：若干个节点的连续序列，"}, {"id": "6900698814093459463", "title": "「算法与数据结构」你可能需要的一份前端算法总结", "desc": "最近好多事情，最近前端分享会也如期而至，有幸这次分享会，正好周末有时间，做个总结吧。 这次想分享的就是算法与数据结构，刷了一段时间题目，逛了逛LeetCode，看了很多关于这个方面的文章，有所感悟，准备做个记录吧。 当你想花时间去了解学习一件对你来说，很苦难的事情的时候，我们需…"}, {"id": "6847009772500156429", "title": "写给前端的算法进阶指南，我是如何两个月零基础刷200题", "desc": "最近国内大厂面试中，出现 LeetCode 真题考察的频率越来越高了。我也观察到有越来越多的前端同学开始关注算法这个话题。 但是算法是一个门槛很高的东西，在一个算法新手的眼里，它的智商门槛要求很高。事实上是这个样子的吗？如果你怀疑自己的智商不够去学习算法，那么你一定要先看完这篇…"}, {"id": "7005395411976323102", "title": "【冲冲冲】贪心来当leetcode CEO（算法+优先队列）", "desc": "你是 LeetCode CEO，将要走向巅峰 IPO，为了想拉高股票价格多（割）赚（韭）钱（cai），你要在限定项目次数内尽可能的多挣钱。你的初始资本为 w，做项目空手套白狼不花钱。需要注意的是你"}, {"id": "6998410432780189726", "title": "毫末科技前端团队居然用 imgcook 开发 2000+ 模块？", "desc": "毫末科技 是一家行业软件定制开发公司，涉及行业有办公协作类、区块链、数据可视化、零售电商、智慧环保、智慧水务、智慧环卫 、智慧检务、智慧政务、智慧物流、智慧教育、智慧制造、物联网、数据分析、网络及安全"}, {"id": "7005945841051516936", "title": "【温故知新】`714. 买卖股票的最佳时机含手续费` 贪心算法、动态规划实现", "desc": "题目描述 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买"}, {"id": "7000504725883846693", "title": "手撸二叉树之二叉树的直径", "desc": "Hello, 大家好，今天是我参加8月更文的第 26 天，今天给大家带来的关于二叉树相关的算法题是二叉树的直径，正文如下： 题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个"}, {"id": "6986551174426001416", "title": "6月份历经大厂的笔试题 一（亲身经历总结）。", "desc": "身先士卒，替各位有需要的童鞋们去踩了一遍吭。看看大厂面试题都有哪些隐藏的门道在其中。 认真写文，认真内容，请不要轻易举报一个高质量图的作者。"}, {"id": "7003155713350451213", "title": "数据结构与算法一：「数据结构介绍」", "desc": "前前言 hello 大家好，我是来自推啊前端团队的刘爽，今天给大家带来【数据结构与算法】的第一篇，基础介绍。"}, {"id": "6960692951924080648", "title": "剑指offer 二进制中1的个数（JavaScript）", "desc": "剑指offer面试题10JavaScript版本，对剑指offer上的不太好理解的部分做了一些js相关的知识补充和解释。 另外补充解释了常规方法循环中止条件（小白看剑指offer可能会不太理解"}, {"id": "6994797306344112159", "title": "数据结构之图的创建", "desc": "创建图 之前的系列文章，我们已经了解到了图是什么，接下来，我们一起来看看图的创建。 按照惯例，首先声明图类的骨架，我们采用邻接表来实现 在上述我们创建的类中，我们使用一个数组来存储图中所有顶点的名字，"}, {"id": "6991645928998305799", "title": "前端刷题路-Day68：皇位继承顺序（题号1600）｜ 8月更文挑战", "desc": "一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。 这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义"}, {"id": "6947985231547170853", "title": "反复遍历链表，尝试快慢指针和多指针", "desc": "链表里遍历，只能从前往后，所以删除倒数第 n 个结点，就是删除第len+1-n个，比如总共 5 个结点，删除倒数第 1 个结点，其实就是第 5 个结点，当然链表里删除节点需要知道前置节点，也就是知道倒数第n+1个结点。 于是遍历链表知道链表的长度，然后再遍历链接到第len-n个…"}, {"id": "6933235776142442509", "title": " 二叉树的遍历总结", "desc": "我觉得二叉数就是在链表的基础上，增加了带有左右的next结点，也是就是左右子节点，通过左右子节点串联出一颗二叉数。根节点下的左右结点的组成的树，也叫做左右子树。 后续：先依次递归左右子树，左右数递归结束后，将当前结点加入结果。 给定一个二叉树，返回其按层序遍历得到的节点值。 层…"}, {"id": "6974655585258209287", "title": "leetcode top100挑战, 每天不鸽一道题之 电话号码的字母组合(8/100)", "desc": "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br/><br/>给出数字到字母的映射如下（与电话按键相同）。"}, {"id": "6844903687895138317", "title": "React HOC高阶组件详解", "desc": "High Order Component（包装组件，后面简称HOC），是React开发中提高组件复用性的高级技巧。HOC并不是React的API，他是根据React的特性形成的一种开发模式。 在React的第三方生态中，有非常多的使用，比如Redux的connect方法或者Re…"}, {"id": "6962531609094389768", "title": "JavaScript算法 + leetcode - 分而治之", "desc": "本文记录分而治之的算法设计思想。 分而治之 分而治之是算法设计中的一种方法。 它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题。"}, {"id": "6970212072994930725", "title": "每天一种算法（三） --双指针算法", "desc": "双指针算法 什么是双指针算法？ 双指针算法是一种常见的算法，核心理念是使用两个指针，分别指向不同的元素，通过对比指向的元素来协同完成任务。我们还补充了双指针算法的常用场景，包括快慢指针、滑动窗口。"}, {"id": "6998167428177854500", "title": "「前端刷题」18. 四数之和", "desc": "给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [num"}, {"id": "6982047389259399204", "title": "LeetCode第83题：删除排序链表中的重复元素", "desc": "题干 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 返回同样按升序排列的结果链表。 示例 1： 解法 我们需要三个指针，分别是当前指针"}, {"id": "6844903718421266445", "title": "前端监控实践——FMP的智能获取算法", "desc": "而我们今天讨论的FMP（first meaningful paint），其实就是回答 is it useful,加载的内容是否已经足够，其实这是一个很难被定义的概念。每个网页都有自己的特点，只有开发者和产品能够比较确定哪个元素加载的时间点属于FMP,今天我们就来讨论一下，如何比…"}, {"id": "6844903639287332872", "title": "JavaScript中的垃圾回收和内存泄漏", "desc": "之前接触的js的内存管理方面的内容一直比较零散,最近在这一块做了一些系统的学习.学习过程中的一些总结在这里分享给大家.欢迎批评指正,共同学习,共同进步. 在一部分语言中是提供了内存管理的接口的,例如C语言中的 malloc()和 free(); 而在 JavaScript 中会…"}, {"id": "6844903687614103566", "title": "正则表达式和NFA", "desc": "作为前端大佬的你，想必对于 JavaScript 的正则表达式非常熟悉了，甚至随手就能利用正则表达式写出一些惊世骇俗的代码。只是不知道你是否有和我一样的疑惑：正则表达式是怎么执行的呢？ 接下来，我试着用我自己的方式来介绍，希望也能帮助对此感兴趣的你。 NFA 是指 Nondet…"}, {"id": "6844903688054505486", "title": "浅析Vue源码（九）——VirtualDOM与path", "desc": "在未出现双向绑定之前，我们需要在各个触发事件方法中直接操作DOM节点来达到修改相应视图的目的。但是当应用一大就会变得难以维护，reflow(回流)很影响性能的。 因此就有人提出来，那我们是不是可以把真实DOM树抽象成一棵以JavaScript对象构成的抽象树，在修改抽象树数据后…"}, {"id": "6938310594298642468", "title": "11. 盛最多水的容器｜刷题打卡", "desc": "11. 盛最多水的容器｜刷题打卡 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最…"}, {"id": "6970477307544272904", "title": "LeetCode第20题：有效的括号", "desc": "题干 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 实例："}, {"id": "6844903815716536333", "title": "最简单的冒泡排序还能怎么优化?", "desc": "本文首先介绍了 3 种对经典冒泡排序的改进思想, 然后将这 3 种思想结合起来, 实现综合了各自优点的方法. 不再用很多篇幅来讨论冒泡排序的思想, 简而言之它是通过两两比较并交换而将最值放置到数组的最后位置. 具体实现可以用双层循环, 外层用来控制内层循环中最值上浮的位置, 内…"}, {"id": "6938234807327555620", "title": "[LeetCode94题二叉树的中序遍历] | 刷题打卡", "desc": "在做题之前我们先来大概了解下二叉树的遍历方式。 一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上…"}, {"id": "6844903859689619469", "title": "[译] JavaScript 线性代数：向量", "desc": "本文是“JavaScript 线性代数”教程的一部分。 向量是用于精确表示空间中方向的方法。向量由一系列数值构成，每维数值都是向量的一个分量。在下图中，你可以看到一个由两个分量组成的、在 2 维空间内的向量。在 3 维空间内，向量会由 3 个分量组成。 我们可以为 2 维空间的…"}, {"id": "6934700390428934152", "title": "队列实现栈&栈实现队列", "desc": "给你两个栈你如何实现一个队列，给你两个队列你如何实现一个栈。 本文就跟大家分享下这两个问题的解决思路与实现过程，欢迎各位感兴趣的开发者阅读本文。 执行入队操作时，我们元素放进栈1。"}, {"id": "6977290291090817055", "title": "js - 两数之和并返回各自下标", "desc": "两数之和并返回各自下标分别获取`目标值`与`当前遍历元素的差值`，如果这个`差值`作为哈希表的`索引`，能访问到有效元素，那么就说明当前遍历的`i`与`temp[dif]` ,就是要找的`索引`"}, {"id": "6936377651775045640", "title": "20210306 LeetCode 每日一题，冲！｜刷题打卡", "desc": "Leetcode 链接：503. 下一个更大元素 II（medium） 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一…"}, {"id": "6844903548963012616", "title": "你不知道的前端算法之文字避让", "desc": "inMap 是一款基于 canvas 的大数据可视化库，专注于大数据方向点线面的可视化效果展示。目前支持散点、围栏、热力、网格、聚合等方式；致力于让大数据可视化变得简单易用。 要显示的文字空间不够时，就会造成文字重叠显示混乱，用户体验很不友好。 怎么解决这个问题呢？我们采用文字…"}, {"id": "6992433638721716237", "title": "LeetCode题解：173. 二叉搜索树迭代器，栈，JavaScript，详细注释", "desc": "原题链接：173. 二叉搜索树迭代器，https://leetcode-cn.com/problems/binary-search-tree-iterator/"}, {"id": "6990730183833567263", "title": "LeetCode算法学习之--二分查找--供暖器", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目[供暖器](https://leetcode-cn.com/problems/linked-list-cycle-ii/) 题目 分析 解"}, {"id": "6973827961057673224", "title": "前端刷题路-Day51：无重复字符的最长子串（题号3）", "desc": "无重复字符的最长子串（题号3） 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度..."}, {"id": "6972708275955433503", "title": "前端刷题路-Day48：前K个高频单词（题号682）", "desc": "给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序..."}, {"id": "6844903712285016071", "title": "浅析 React Fiber", "desc": "在 react 进入大家视野之初，Virtual DOM（VDOM）的概念让人眼前一亮，在操作真正的 DOM 之前，先通过 VDOM 前后对比得出需要更新的部分，再去操作真实的 DOM，减少了浏览器多次操作 DOM 的成本。这一过程，官方起名 reconciliation，可翻…"}, {"id": "6844903814340804615", "title": "**超详细的**10种排序算法原理及 JS 实现", "desc": "本文介绍了常见的 10 种排序算法的原理、基本实现和常见的优化实现，并有（个人认为）足够详细的代码注释。 实在是居家工作，面试笔试必备良药。 这里只给出基于其原理的一般实现，很多算法都有逻辑更复杂的或代码量更少的精简版，像遍历的改成递归的，两个函数实现的改成一个函数等等，就不再…"}, {"id": "6902680760533778439", "title": "重学前端（四）-数据结构与算法", "desc": "最近在撸vue 和react的源码，虽然晦涩难懂，但是却发现新大陆，发现了数据结构和算法在前端的重要性，比如在react中，发现react的fiber树，对应的实际上是一个叫链表的数据结构，我们es6中新出的Map的数据结构其实就是对应字典的数据结构而Set对应的就是集合的数据…"}, {"id": "6844904144566747149", "title": "「时间管理」JavaScript算法时间、空间复杂度分析", "desc": "经过数据结构与算法先导篇的洗脑，不知道大家对数据结构与算法重要性的认知有没有上了一层台阶。(虽然阅读量少的可怜)。没看过的建议先去看先导篇前端如何搞定数据结构与算法(先导篇) 不过没关系，至少是有同学在评论区反馈期待下一篇的，那就要坚持把这个系列写下去，今天来给大家聊一聊在数据…"}, {"id": "6948696440935809031", "title": "浅析react应用中的DOM DIFF算法", "desc": "对我们搞前端的来说，目前最流行的两大前端框架毫无疑问当属React和Vue，对于这两大框架，想必大家也是再熟悉不过了。然而，这两大框架无一例外的全部放弃使用传统的DOM技术，却采用了以JS为基础的Virtual DOM技术，也可称作虚拟DOM。所以，到底什么是Virtual D…"}, {"id": "6844903682501246983", "title": "通过一个案例理解 JWT", "desc": "JWT（json web token）是为了在网络应用环境之间传递声明而基于 json 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。 JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下…"}, {"id": "6844903604944371726", "title": "如何加密传输和存储用户密码", "desc": "近期，Github被爆出，在内部日志中记录了明文密码。 虽然据说影响面很小，但是网络和数据安全问题又一次被放到台面上。大多数用户的常用密码就那么几个，一旦被黑客拿到，去其他网站“撞库”，可能会造成用户的财产损失。 本篇文章主要介绍如何加密传输和存储用户密码，并讲解相关原理。 加…"}, {"id": "6994336425042771975", "title": "题4：最长回文子串", "desc": "题4：最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 示例 2： 示例 3： 示例 4： 提示： 解题思路： 处理边界情况，如果字符长度小于2，则直接返回原字符串 定义两个"}, {"id": "6844903624565325832", "title": "对React、Redux、React-Redux详细剖析", "desc": "相信很多新手朋友们对于React、Redux、React-Redux这三者之间的关系和区别肯定有很多不解和疑惑。这里我们就来详细的剖析一下它们吧。 React-Redux：连接组件和数据中心，也就是把React和Redux联系起来。 React主要就是用来实现UI界面的，是一个…"}, {"id": "6980250592560021518", "title": "Leetcode 79. 单词搜索 --javascript DFS", "desc": "79. 单词搜索 描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，"}, {"id": "6844903497603760135", "title": "未来布局之星Grid", "desc": "Grid-layout不是为了取代flex-layout，它是flex的补充。grid擅长二维布局，flex擅长一维布局。他们需要各司其职。 千呼万唤始出来的grid-layout终于在2017年3月开始支持得到了部分浏览器的支持。 flex并不能满足我们对于页面整体布局的需求…"}, {"id": "6844903647915016199", "title": "[译文] 初学者应该了解的数据结构： Graph", "desc": "在这篇文章中，我们将要探索非线性的数据结构：图，将涵盖它的基本概念及其典型的应用。 你很可能在不同的应用中接触到图（或树）。比如你想知道从家出发怎么去公司最近，就可以利用图的（寻路）算法来得到答案！我们将探讨上述场景与其他有趣的情况。 在上一篇文章中，我们探讨了线性的数据结构，…"}, {"id": "6936453154422652942", "title": "求最大子矩阵的大小 | 刷题打卡", "desc": "一、题目描述💯求最大子矩阵的大小二、代码实现🌂三、简单测试🧪代码下载地址感谢🙇‍给你的前端开发加个速吧🚀手写vue的几个流程✍如果感觉对您的学习工作有帮助，请将它分享给需要的人，或者点赞鼓励一下，感谢"}, {"id": "6844903518906777614", "title": "定时任务高效触发", "desc": "圆通处事，方能达到目的! 开发中我们经常会遇到一些需要定时来解决的业务场景。比如，有这样一个需求：“如果连续30s没有请求包（例如登录，消息，keepalive包），服务端就要将这个用户的状态置为离线”。 将所有任务都添加到某集合中，定时轮询扫描，如果达到条件则进行相关处理； …"}, {"id": "6989061963682676744", "title": "对象的遍历", "desc": "对象的遍历 和遍历数组类似，对象也可以被遍历，遍历对象需要使用for...in...循环 使用for...in...循环可以遍历对象的每一个键 在ES6课程中，会学习新的对对象的遍历方法 案例演示"}, {"id": "6844903608123654158", "title": "js实现封装MP4格式文件并下载", "desc": "在MP4文件格式中，整个视频容器都是由多个box和子box组成，根据box类型主要分为3大类：视频类型（ftyp）、视频数据（mdat）、视频信息（moov）。视频信息（moov）用来描述视频数据（mdat）。（注：还有一个主要box为moof box，因这里仅解释普通MP4格…"}, {"id": "6938330866200346637", "title": "LeetCode239.滑动窗口的最大值 | 刷题打卡", "desc": "给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 这道题主要有两种方法，第一种方法就是利用扩展运算符，将窗口内的值都提取出来，然后用Math.…"}, {"id": "6844904128615809031", "title": "前端工程师的 LeetCode 之旅 -- 周赛 184", "desc": "给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words…"}, {"id": "6887137383050838023", "title": "1024 奇妙冒险全结局 + jsliang 自定义算法题目", "desc": "这个活动有 5 个好结局，其他都是 Bad End，Bad End 需要做 LeetCode 的第 1024 题才能解脱。 觉得文章不错的小伙伴欢迎点赞/点 Star。"}, {"id": "6844903592499888135", "title": "记录自己用的常见的一些方法", "desc": "浅拷贝只是把对象的第一层属性拷贝下来，如果第一层中有复杂数据类型，只是拷贝的指针，如果父属性的属性变化也会导致拷贝的子对象的属性变化，这有时是不需要的。 上面的代码实现的是使用递归实现的深拷贝，也可以使用JSON.stringfy先转成简单类型，再使用JSON.parse转换成…"}, {"id": "6844903671394729992", "title": "React源码分析与实现(三)：实操DOM Diff", "desc": "众所周知，React中最为人称赞的就是Virtual DOM和 diff 算法的完美结合，让我们可以不顾性能的“任性”更新界面，前面文章中我们有介绍道Virtual DOM，其实就是通过js来模拟dom的实现，然后通过对js obj的操作，最后渲染到页面中，但是，如果当我们修改…"}, {"id": "6925735126571679757", "title": "面试常见算法题", "desc": "算法题转自https://juejin.cn/post/6844903575538106376#heading-5解析URLParams为对象实现一个简单的模版渲染数组同字符串对象无splice(改变"}, {"id": "6844903647218761736", "title": "从 0 到 1 实现 React 系列 —— 3.生命周期和 diff 算法", "desc": "本系列文章在实现一个 (x)react 的同时理顺 React 框架的主干内容(JSX/虚拟DOM/组件/生命周期/diff算法/...)"}, {"id": "6935086070560194568", "title": "[LeetCode11题盛最多水的容器] | 刷题打卡", "desc": "今天上午写了一篇[LeetCode0304题二维区域和检索 - 矩阵不可变] | 刷题打卡的文章。为了能够用最简单明了的话来表达，真的是每一句都要想一下意思对不对、合理不合理，所以写的比较慢，但是也能让自己更清晰的理解，刚才看见掘金小姐姐发的建议题决定再写一篇😊！如果你觉得不…"}, {"id": "6844903513823133709", "title": "二叉搜索树的简明实现（ES5 & ES6）", "desc": "二叉树（Binary Tree）是 n（n >= 0）个节点的有限集合，集合为空集时，叫作空二叉树；不为空时，由根节点及左子树、右子树组成，左子树、右子树也都是二叉树。 从这个描述，可以看出树的结构与递归之间存在密切关系，这种密切关系在树的遍历时能够得到充分体现。 二叉搜索树（…"}, {"id": "6972464121253986312", "title": "LeetCode第744题：寻找比目标字母最小的字母", "desc": "题干 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子"}, {"id": "6938298362366001182", "title": "在矩阵中寻找一个字符串应该怎么找？｜刷题打卡", "desc": "原题链接剑指 Offer 12. 矩阵中的路径 相同解法主站链接：79. 单词搜索 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径…"}, {"id": "6937157262234353678", "title": "刷 leetcode有效的括号 | 刷题打卡", "desc": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 其实典型的栈思路。"}, {"id": "6909644982596927502", "title": "javascript数据结构与算法学习笔记之“树”", "desc": "前端工作中常见的树包括： DOM 树、级联选择（省市区三级，日期。。。）、树形控件... 1. 深度优先遍历：尽可能深的搜索树的分支 2. 广度优先遍历： 先访问离根节点最近的节点 3. 二叉树的先中后序遍历"}, {"id": "6844903905923432462", "title": "LeetCode 7. 整数反转：JavaScript 解法之溢出判断你真的考虑全面了吗？", "desc": "看到整数反转这个题，最先联想到先对数值取绝对值，然后除十取余以对整数进行反转，之后再考虑是否需要取负数以及数值范围问题。 写到这，本以为就完成了，测试用例也都通过了。但是！你回想一下题目中的说明： 我们测试上面程序的时候并非在这么苛刻的环境下，所以先得到 result，再判断其…"}, {"id": "6844904085951365133", "title": "前端工程师的 LeetCode 之旅 - 夜喵专场（21）", "desc": "1、从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 2、从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 3、重复步骤 2 ，直到你没法从 s 中选择字符。 4、从 s 中选出 最大 的字符，将它 接在 结果字符串的…"}, {"id": "6844903650205286413", "title": "干货 | 一份我的前端技术进阶指南", "desc": "近十年来，前端的发展势头迅猛，每年都会出现不少新的技术和标准。「If you are not growing，then you are dying.」这句名言对于前端工程师同样适用。维持现状就是落后的开始，不断地学习才是必修课。 话说回来，在时间和精力有限的情况下，那么多技术到…"}, {"id": "6979004111295365157", "title": "【算法】懂点算法02——顺序表", "desc": "对于开发而言，数组是我们经常打交道的数据类型，那么它的内部存储结构是怎样的呢？我们将进行详细介绍。线性表是最基本、最简单，也是最常用的一种数据结构，线性表就是n个具有相同特性的数据元素的有序数列。"}, {"id": "6979078288949903367", "title": "leetcode top100挑战, 每天不鸽一道题之 每日温度(16/100)", "desc": "请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。"}, {"id": "6844903650427404295", "title": "inMap 2.0 重磅发布！", "desc": "忙忙活活了两个月，inMap 2.0终于正式对外发布啦！本次更新发布涉及到多个重要的图层以及新特性，API重新设计，更加简洁，接口采用标准的地理数据格式，使用成本更低。这次升级了文档，换了一种方式描述接口，更加详细，里面有很多示例，都可以在线编辑预览，以下是inMap demo…"}, {"id": "6935803468519047199", "title": "leetcode 滑动窗口 ｜ 刷题打卡", "desc": "题目描述思路定义一个对象map思路二思路尽在注释中"}, {"id": "6844903700717109261", "title": "React的新引擎—React Fiber是什么？", "desc": "当浏览器的主线程长时间忙于运行一些事情时，关键任务的执行可以能被推迟。 为了展示这个问题，我做了一个demo，为了使星球一直转动，主线程需要每16ms被调用一次，因为animation是跑在主线程上的。如果主线程被其他事情占用，假如占用了200ms，你会发现animation会…"}, {"id": "6949317326785216525", "title": "前端刷题路-Day12｜刷题打卡", "desc": "给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 这题其实感觉比较简单，就是一层层的循环跟节点，逻辑上没有什么需要注意的，就是代码的书写上有一些需要注意的问题，看看👇的代码就知道了。 arr1用来存储节点，arr2用来存储最后的值。…"}, {"id": "6974790868209238023", "title": "十分钟分析快慢指针法", "desc": "链表在我们的日常开发中很少用到，但从中我们可以掌握很多解题思路，现在十分钟教你快速掌握链表的快慢指针法，相信你能学会"}, {"id": "6896481491740524551", "title": "前端学数据结构与算法（十二）：有趣的算法 - 多指针与滑动窗口", "desc": "如果说如何用算法高效有趣的解决某些问题，那多指针和滑动算法绝对是算其中的佼佼者。这也是笔者最初接触算法时觉得最有意思的一点，因为解决的问题是熟悉的，但配方却完全不同，本章我们从一个简单的交集问题出发，一步步的认识到多指针及滑动窗口解决某些问题时的巧妙与高效，本章主要以解Leet…"}, {"id": "6844903506927697928", "title": " 计算机网络概念和结构", "desc": "我们学习《计算机网络》，重要的是培养网络化的思维。 计算机网络=通信技术+计算机技术，计算机网络就是一种通信网络。 定义：计算机网络就是互连的、自治的计算机集合。 互连--互连互通，即通过信道相连。 用直接链路去连，不可行！！☞引入“交换网络”。 交换网络里一个非常重要的设备-…"}, {"id": "6971031179742937096", "title": "开始学算法", "desc": "在这篇文章中，分为九类算法内容（栈、队列、链表、集合、字典、数、图、堆、搜索排序），四类算法思想（分而治之、动态规划、贪心算法、回溯算法）"}, {"id": "6950627740827516959", "title": "「算法」对称二叉树 | 刷题打卡", "desc": "一、题目描述：原题链接 👉 101. 对称二叉树示例 1:给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。但是下面这个 [1,2,2,null,3,nu"}, {"id": "6844903682555772936", "title": "微信小游戏开发技巧（大会演讲内容整理）丨掘金开发者大会", "desc": "在一些时间以前，比如2012年之前，做web游戏的人还不是很多（就是用javascript写游戏的人）。 当时也没想那么多，就是为了制作一个「不需要下载，点开就能玩的游戏」，所以就投入到web游戏制作的大海中。 但那时很多人都说，「你这些东西看着蛮好玩的，但感觉没什么用啊」。 …"}, {"id": "6844903496592916494", "title": "你需要知道的HTTP常识", "desc": "标准的HTTP协议共有GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 从字面上理解GET、POST，一个是获取，一个是发送，所以一般情况下我们在想读取一个服务器资源的时候我们会用GET请求，当需要修改服务器数据的时候，用POST提交操…"}, {"id": "6936435672739741703", "title": "LeetCode20. 有效的括号(面试高频题)｜刷题打卡", "desc": "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 先观察给定的有效字符串示例中的输入，将他们按照顺序来处理，在某一刻他们都是对称的。 根据栈的后进先出原则，一组…"}, {"id": "6917871108335075341", "title": "不知道蓄水池抽样算法？那就进来看看吧~", "desc": "力扣中关于蓄水池抽样问题官方标签是 2 道，根据我的做题情况来看，可能有三四道。比重算是比较低的，大家可以根据自己的实际情况选择性掌握。 蓄水池抽样的算法思维很巧妙，代码简单且容易理解，就算不掌握它，作为了解也是很不错的。 给出一个数据流，我们需要在此数据流中随机选取 k 个数…"}, {"id": "6844903778974597134", "title": "图解JavaScript算法排序", "desc": "比较相邻的两个元素,如果前一个比后一个大，则交换位置。 第一轮把最大的元素放到了最后面。 由于每次排序最后一个都是最大的，所以之后按照步骤1排序最后一个元素不用比较。 设置一个标志，如果这一趟发生了交换，则为true。否则为false。如果这一趟没有发生交换，则说明排序已经完成…"}, {"id": "6974355774118199309", "title": "leetcode top100挑战, 每天不鸽一道题之 盛最多水的容器(7/100)", "desc": "盛最多水的容器：每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。"}, {"id": "6844903994070941709", "title": "LeetCode 204. 计数质数：JavaScript  实现埃拉托斯特尼筛法", "desc": "看到这个题目，一般人很容易就能想到使用循环，通过暴力遍历的方式检查每一个数是否为质数，并进行计数。 但是这种方法的算法复杂度过高，对于小范围搜索还好，如果是从百万甚至千万的数字中找出所有的质数，这种方法的劣势将极其明显。那我们可以使用埃拉托斯特尼筛法进行质数的查找。 埃拉托斯特…"}, {"id": "6844903501298958349", "title": "JS中的算法与数据结构——字典(Dictionary)", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6938363420932571167", "title": "双指针算法与应用", "desc": "其实我开始是只想分享字符串回文相关内容的，看着看着发现了左右指针算法，看着看着又发现了快慢指针算法。这两天我(╯‵□′)╯︵┻━┻ ，今天分享给哥哥们双指针算法。 快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些…"}, {"id": "6844904115080806414", "title": "前端工程师的 LeetCode 之旅 -- 周赛 182", "desc": "在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。 给你一个整数数组 arr，请你从中找出并返回一个幸运数。 如果数组中存在多个幸运数，只需返回 最大 的那个。 如果数组中不含幸运数，则返回 -1 。 解释：数组中的唯一幸运数是 2，因为数值…"}, {"id": "6937944127577260062", "title": "[LeetCode75题颜色分类] | 刷题打卡", "desc": "这道题是LeetCode75. 颜色分类，难度medium。 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 根据题目的要求，…"}, {"id": "6949413778278744095", "title": "[LeetCode-141题环形链表] | 刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情题目描述给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的"}, {"id": "6938369860430725151", "title": "125. 验证回文串｜刷题打卡", "desc": "125. 验证回文串｜刷题打卡 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 说起回文，想到一首回文诗。苏东坡的《菩萨蛮·回文夏闺怨》： 所谓回文，就是正反一样。只考虑字母和数字且不区分大小写…"}, {"id": "6901296829342842888", "title": "【js算法】leetcode习题", "desc": "学习算法对于前端人来说也是十分重要的，本文主要记录在做leetcode经典习题的js解答方法，会不定期进行更新和补充，欢迎大家讨论和指教。 思路：对于一个回文子串，例如cbabc，去掉首尾的c，它依旧是一个回文子串。因此我们可以通过P(i,j)表示从下标i到j是否是回文字符串，…"}, {"id": "6977771014612582414", "title": "算法复杂度", "desc": "原文链接：https://blog.csdn.net/weixin_39640298/article/details/85641782 一、算法概念 算法是指对特定问题求解步骤的一种描述。它不依赖于任"}, {"id": "6945349048916246564", "title": "字符串看到 ”回文“ 尝试双指针", "desc": "同理，对于字符串来说，如果是回文，有着天然的对称性，非常适合用指针法缩小遍历范围。 回文：正着读和倒着读都一模一样的字符串。 当然如果不知道对称性的情况，可能会暴力的从第一个字符串开始试着删除，然后判断剩下的是不是回文，方法肯定可行，但没有利用好对称性。 其实这里，和判断是不是…"}, {"id": "6844904039725940749", "title": "算法学习in js：快速排序", "desc": "快速排序应该是排序中最出名的算法了，也可能是应用最广泛的排序算法了。他之所以流行，是因为实现简单，同时适用于各种数据，且一般比其他排序算法要快。 快排是对冒泡排序的一种改进，它之所以快是因为一次交换能改变多个逆序对，而冒泡排序只能改变一个逆序对。 而快排的基本思想即是：通过一趟…"}, {"id": "6844903725094420493", "title": "前端进阶（第一期）-调用堆栈笔记", "desc": "值类型数据是值的复制，开辟新的存储空间来存储值，复制前后的数据之间无联系。 引用类型数据仅仅是地址的复制，开辟新的存储空间来存储地址指针，复制前后的地址指针指向堆中同一个值。 在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，a=null是一…"}, {"id": "6844903645125804040", "title": "用 Promise + 递归实现灌酒动画", "desc": "世界杯期间公司拉了一批啤酒的赞助，有一个邀请（pian）好友来领（mai）会员灌啤酒的分享活动，达到8瓶酒就可以得一箱。听起来很是诱人，毕竟世界上最惬意的事情莫过于看看球，喝喝酒，撩撩妹（并没有）。 我的任务呢就是把灌酒的这个操作弄的炫酷一点，毕竟我也是个有艺术细菌的人，立马就…"}, {"id": "6844903510446702599", "title": "使用canvas寻路最小生成树", "desc": "onlinesource问题引入在学习了加权无向图寻找最小生成树的算法之后，想通过可视化的方式来表示一个图的构造和最小生成树的寻路过程，就使用canvas来模拟了图的构造，连接边和加重显示最小生成树组"}, {"id": "6977390621354885127", "title": "算法学习笔记——数据结构", "desc": "这是我参与更文挑战的第21天，活动详情查看： 更文挑战。 前言 数据存储于计算机的内存中。内存如右图所示，形似排成1列的箱子，1个箱子里存储1个数据。数据存储于内存时，决定了数据顺序和位置关系的便是“"}, {"id": "6844903998806294536", "title": "从libuv源码中学习最小二叉堆", "desc": "接下去，我们开始从libuv的源码中学习最小二叉堆的知识，为了让大家不至于那么陌生，将C语言实现版本转换为Js版本，我们会一遍讲解理论，一边代码实现。 首先我们得知道二叉堆的定义：二叉堆是一棵完全二叉树，且任意一个结点的键值总是小于或等于其子结点的键值。 正因为完全二叉树的独特…"}, {"id": "6903152293114281997", "title": "前端学数据结构与算法（十四）：01执行的艺术 - 回溯算法(下)", "desc": "书接上文，上个章节从递归到回溯的做了递进式介绍，相信已经对回溯有了初步的理解，接下来主要介绍更多与回溯相关的题目，从广度上加深对其理解。 这个求解全排列问题和组合问题不同的地方在于，每一次遍历我们都需要从数字序列的开头遍历，而在进入下一层递归时，需要告知下一层我已经被访问过了。…"}, {"id": "6844903568659447822", "title": "关于一道前端笔试题的思考", "desc": "对其中一道笔试题产生了兴趣，特地把思考过程付诸于文字。 原文作者给出了一个解法，实现方式比较巧妙，而且在临场发挥的场景下，更加显得难得，感兴趣的可以去原文看一下。 现在拿到这个题，有充裕时间的去考虑。 本文的目标就是要跑通以上的case. 我在探索这道题解法的过程中，首先思考面…"}, {"id": "6904044135586463758", "title": "小齐读者拿到快手、百度、网易等 offer 的独门秘籍！", "desc": "小齐说：这篇文章来自读者冰红茶，他刚结束了秋招，拿了很多家 offer。和他聊完之后，我觉得他的备考思路也完全适用于美国的面试，只是分值要调整一下，但是具体每一块的内容，地球村通用。所以分享给大家一起"}, {"id": "6844904101021499399", "title": "前端工程师的 LeetCode 之旅 - 夜喵专场（22）", "desc": "给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。 「距离值」 定义为符合此描述的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。 本道题主要考察数组的基本循…"}, {"id": "6937141049144377351", "title": "情人节之情侣👫牵手的问题 | 刷题打卡", "desc": "N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。 人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此…"}, {"id": "6912589164584108045", "title": "前端就该用JS写算法1", "desc": "本来今天做完 2021 年的第一天，早起第一天，算法第一天，应该来个比较的好的结果才对的，但是实际情况是，题把我卡住了。超时了，然后继续搞，解答错误了。 分析了一下就是每一层的 pos 都是 2 的指数级别的，当树以单个节点一直往下传递，层数比较大的时候，左右节点的 pos 就…"}, {"id": "6844904052837318669", "title": "【重学数据结构与算法(JS)】字符串匹配算法(四)——Sunday算法", "desc": "Sunday算法也许是三种里面最好理解也最好写的一种了，它的思路也是在于失配时如何跳过尽可能多的字符，具体的说，主要是优化了第3步，失配时，在主串中找到一个合适的位置，重新与模式串进行比较。 如果移动后， m > slen ，说明 S 已经遍历一遍，仍然没有找到目标，模式串 匹…"}, {"id": "6993096471792844813", "title": "图解算法 | LeetCode第 70 题爬楼梯问题", "desc": "假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？"}, {"id": "6998724065288519694", "title": "【LeetCode 137.只出现一次的数字II】 - JavaScript(哈希表+数学技巧+位运算)", "desc": "这是我参与8月更文挑战的第21天，活动详情查看：8月更文挑战 【LeetCode 137.只出现一次的数字II】 - JavaScript(哈希表+数学技巧+位运算) 题目描述：给定一个非空整数数组，"}, {"id": "7003537972565901348", "title": "【温故知新】`2. 两数相加` 单向列表操作", "desc": "题目描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表"}, {"id": "6997605748544913415", "title": "LeetCode 79.单词搜索 - JavaScript（深度优先遍历 + 回溯）", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 LeetCode 79.单词搜索 - JavaScript 题目描述 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按"}, {"id": "6997282118980075528", "title": "LeetCode 53.最大子序列和 - JavaScript(DP+原地DP+贪心+分治)", "desc": "这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 LeetCode 53.最大子序列和 - JavaScript 题目描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子"}, {"id": "7006286256581640229", "title": "剑指 Offer 06. 从尾到头打印链表", "desc": "剑指 Offer 06. 从尾到头打印链表 题意 剑指 Offer 06. 从尾到头打印链表 解法 这里输出是以数组的形式返回。首先是顺序遍历+反序输出。这里的反序输出可以有三种做法。 1. 遍历加数"}, {"id": "7002016650127999007", "title": "小五的算法系列 - 集合与字典 (Set & Map)", "desc": "此系列文章以《算法图解》和《学习JavaScript算法》两书为核心，其余资料为辅助，并佐以笔者愚见所成。力求以简单、趣味的语言带大家领略这算法世界的奇妙。"}, {"id": "7002780759794647077", "title": "Leetcode165.比较版本号", "desc": "每日leetcode之165比较版本号。列了三种解题方法，双指针一次遍历、atoi函数、stringstream。欢迎怒赞或吐槽之"}, {"id": "7005564899229171719", "title": "前端仔的“数据结构与算法”——二分查找", "desc": "你我都懂的二分思想 它是一种查找数据的算法，技巧。整体的过程简直就是和名字一模一样，大概意思就是，“数据分一半，然后再找”。 万能例子，猜数字～！ 你心里想一个0～1000的数字。我来猜。"}, {"id": "6999285174731030559", "title": "【LeetCode 211.添加与搜索单词(数据结构设计)】 - JavaScript（正则+Trie+DFS）", "desc": "这是我参与8月更文挑战的第23天，活动详情查看：8月更文挑战 【LeetCode 211.添加与搜索单词(数据结构设计)】 - JavaScript（正则+Trie+DFS） 题目描述 设计一个支持以"}, {"id": "6998280255261638664", "title": "手撸二叉树之二叉树的层平均值", "desc": "Hello, 大家好，今天是我参加8月更文的第 20 天，今天给大家带来的关于二叉树相关的算法题是二叉树的层平均值，正文如下： 题目 给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 示例："}, {"id": "6993592517090361358", "title": "手撸二叉树之二叉树中第二小的节点", "desc": "Hello, 大家好，今天是我参加8月更文的第7天，今天给大家带来的关于二叉树相关的算法题是求二叉树中第二小的节点，正文如下： 题目 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数"}, {"id": "6994366152990261261", "title": "浅谈Vue的diff算法", "desc": "概述 diff算法，可以说是Vue的一个比较核心的内容，之前只会用Vue来进行一些开发，具体的核心的内容其实涉猎不多，最近正好看了下这方面的内容，简单聊下Vue2.0的diff算法的实现吧，具体"}, {"id": "6994601357411876872", "title": "手撸二叉树之最小深度", "desc": "Hello, 大家好，今天是我参加8月更文的第 10 天，今天给大家带来的关于二叉树相关的算法题是二叉树的最小深度，正文如下： 题目： 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节"}, {"id": "7001255077369348103", "title": "手撸二叉树之二叉搜索树中的众数", "desc": "Hello, 大家好，今天是我参加8月更文的第 28 天，今天给大家带来的关于二叉树相关的算法题是二叉搜索树中的众数，正文如下： 题目 给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众"}, {"id": "7003322610888998943", "title": "算法-动态规划", "desc": "动态规划 我自己的理解，核心是贪心策略，其结果依赖于前一步操作或者其子结构 其主要思路就是找到最优子结构 斐波拉契数列 先来看看一个简单的斐波拉契数列 1 1 2 3 5 8......比如求第n个数"}, {"id": "6998914503844823076", "title": "【LeetCode 208.实现Trie(字典树)】 - JavaScript", "desc": "这是我参与8月更文挑战的第22天，活动详情查看：8月更文挑战 LeetCode 208.实现Trie(字典树) - JavaScript 实现一个 Trie (前缀树)，包含 insert, sear"}, {"id": "6993874125202653192", "title": "手撸二叉树之二叉树的最大深度", "desc": "Hello, 大家好，今天是我参加8月更文的第 8 天，今天给大家带来的关于二叉树相关的算法题是求二叉树的最大深度，正文如下： 题目： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子"}, {"id": "6872115031501340679", "title": "「算法与数据结构」一张脑图带你看动态规划算法之美", "desc": "算法中有个专题，动态规划，它十分的重要，大厂面试中或多或少有所涉及，来网易之前，刷了部分dp，这次正好再次梳理一遍，希望对你们有一点点帮助。 如果你已经懂了dp思路，或者已经掌握了常见的dp解法，可以直接跳过。 如果你还不了解，或者知道动态规划，但是还没有开始刷题的话，可能这篇…"}, {"id": "7001478545193041934", "title": "列表结构转树结构的最优算法", "desc": "数据结构 源数据 目标数据 递归实现 根据 pid 和 id 的对应关系筛选出根结点 遍历根节点调用自身匹配子节点 缺点 容易造成堆栈的溢出；消耗大量的内存 循环实现 引用数据类型的浅拷贝 通过 id"}, {"id": "6991857797306515470", "title": "JS算法之最长不含重复字符的子字符串｜ 8月更文挑战", "desc": "最长不含重复字符的子字符串。请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。"}, {"id": "6844904116620099591", "title": "前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法", "desc": "缓存在计算机网络上随处可见，例如：当我们首次访问一个网页时，打开很慢，但当我们再次打开这个网页时，打开就很快。 这就涉及缓存在浏览器上的应用：浏览器缓存。当我们打开一个网页时，例如 https://github.com/sisterAn/JavaScript-Algorithm…"}, {"id": "7003594645485649951", "title": "学习笔记：剑指 Offer 11. 旋转数组的最小数字", "desc": "题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的"}, {"id": "6974931051575509023", "title": "前端刷题路-Day54：电话号码的字母组合（题号17）", "desc": "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字..."}, {"id": "6844903687597342728", "title": "[探索] 在开发中尽量提高代码的复用性", "desc": "相信很多人和我一样，在开发项目的时候，因为项目赶，或者一时没想到等原因。频繁使用 ctrl+c 和 ctrl+v ，导致代码很多都是重复的。这几天，也看了自己以前写的代码，简单的探索了一下，挑选几个实例，分享下如何在特定场景下，保证代码质量前提下，提高代码复用性。 在做项目的时…"}, {"id": "6997955173452611620", "title": "前端刷题路-Day85：打家劫舍 II（题号213）", "desc": "你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有..."}, {"id": "6993871660117917710", "title": "前端刷题路-Day74：颜色分类（题号75）", "desc": "给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列..."}, {"id": "6977900081156620295", "title": "前端刷题路-Day62：全排列（题号46）", "desc": "给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案..."}, {"id": "6844904073632677902", "title": "前端也能学算法：由浅入深讲解贪心算法", "desc": "贪心算法是一种很常见的算法思想，而且很好理解，因为它符合人们一般的思维习惯。下面我们由浅入深的来讲讲贪心算法。 这个问题在生活中很常见，买东西的时候经常会遇到，那我们一般是怎么思考的呢？假设我们需要找零126元，我们先看看能找的最大面值是多少，我们发现126比100大，那肯定可…"}, {"id": "7000532802881978404", "title": "时间复杂度、空间复杂度", "desc": "常用时间复杂度 O(1):没有循环和递归的，都是O(1) O(n):只有一层循环或递归的，都是O(n) O(n²):里面循环执行n次，外层循环执行n次，总执行次数就是n X n,时间复杂度就是n的平方"}, {"id": "6927604441415680014", "title": "JavaScript 算法之树的深度优先与广度优先", "desc": "在前端的工作中，如果遇到树形 DOM 结构、树型控件、级联选择等等需求，都需要使用到深度优先遍历（简称 DFS）和广度优先遍历（简称 BFS）。 DFS 和 BFS 可能也是前端处理复杂需求用到最多的算法之一了。今天就让我们来好好学习它。 树是一种分层数据的抽象模型，树可以看做…"}, {"id": "6986601715382353934", "title": "SAT分离轴碰撞原理分析", "desc": "SAT分离轴碰撞原理！当我们遇到不规则凸多边形碰撞的场景时如何处理？本篇文章将从核心到代码讲解SAT分离轴处理不规则凸多边形碰撞场景。"}, {"id": "6983191432806809613", "title": "【算法】刻意练习之经典动态规划之最小路径三角形", "desc": "动态规划的刻意练习，那这个题目当然是用动态规划来进行解答。首先我们来分析一下为什么看到这道题，会第一时间想到动态规划。主要是因为这个题目有以下几个特点："}, {"id": "7000318914253045774", "title": "DIff算法看不懂就一起来砍我(带图)", "desc": "前言 面试官:\"你了解虚拟DOM(Virtual DOM)跟Diff算法吗,请描述一下它们\"; 我:\"额,...鹅,那个\",完了😰,突然智商不在线,没组织好语言没答好或者压根就答不出来; 所以这次我总"}, {"id": "7000015974900432932", "title": "JS算法之链表中倒数第k个节点及反转链表", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。"}, {"id": "6991022129613373447", "title": "leetcode每日一题题解—— 987.二叉树的垂序遍历 （2021年7月31日）", "desc": "987.二叉树的垂序遍历 Title Description Given the root of a binary tree, calculate the vertical order travers"}, {"id": "6844904063176278024", "title": "一个简单的例子提高你的算法能力", "desc": "你不需要成为一个数学天才才能成为一个优秀的程序员，但是有一些技巧你可以添加到你的问题解决包中，以提高你的算法的性能，并在技术面试中给人留下深刻的印象。 在本教程中，您将学习如何用一个简单且容易记住的等式来求和一系列从 1 到 n 的连续整数。这个等式对于将一个函数从 O(n)重…"}, {"id": "6992116968526446606", "title": "leetcode每日一题题解—— 581. 最短无序连续子数组——2021年8月3日｜8月更文挑战", "desc": "581. 最短无序连续子数组 Title Description Given an integer array nums, you need to find one continuous subarr"}, {"id": "6844903785744056333", "title": "HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的", "desc": "聪明的你可能会马上想到，用 HashMap 这种数据结构就可以了，也满足了去重。的确，这是一种解决方法，除此之外还有其它的解决方案。 问题虽不难，但当参与问题中的变量达到一定数量级的时候，再简单的问题都会变成一个难题。假设 APP 中日活用户达到百万或千万以上级别的话，我们采用…"}, {"id": "6844904031396036622", "title": "用60行代码实现一个高性能的圣诞抽抽乐H5小游戏(含源码)", "desc": "今天圣诞节,先预祝大家节日快乐.既然是圣诞节,那我们就来学点有意思的,用几十行代码来实现一个高性能的抽奖小游戏.也基于此,来巩固我们的javascript基础,以及前端一些基本算法的应用. 由于目前已有很多方案可以实现九宫格抽奖动画,比如使用动态active实现边框动画,用随机…"}, {"id": "6844904154066845703", "title": "前端进阶算法7：小白都可以看懂的树与二叉树", "desc": "不同于我们上面介绍的线性结构，树是一种非线性结构。 二叉树中，每一个节点的左右子树的高度相差不能大于 1，称为平衡二叉树。 1. 链式存储法 一棵二叉树可以由根节点通过左右指针连接起来形成一个树。 2. 数组存储法（适用于完全二叉树） 如果我们把根节点存放在位置 i=1 的位置…"}, {"id": "6934840493352157197", "title": "力扣 (LeetCode)-两数之和,有效的括号,两数相加｜刷题打卡", "desc": "哪吒人生信条：如果你所学的东西 处于喜欢 才会有强大的动力支撑。 1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能…"}, {"id": "6984450123262591012", "title": "回溯算法 - 寻找矩阵中的路径", "desc": "给定一个矩阵和一个字符串，如何从矩阵中寻找出这个字符串在矩阵中的路径？本文就跟大家分享下如何使用回溯法来解决这个问题，欢迎各位感兴趣的开发者阅读本文。"}, {"id": "7002454558785929246", "title": "学习笔记：剑指 Offer 06. 从尾到头打印链表", "desc": "题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 题目示例 题目解析 链表的特点：链表中的每一个元素由一个存储元素本身的节点（即元素的value）和一个指向下一个元素的引"}, {"id": "6844903946222321671", "title": "面试官: 既然已经有数组了,为什么还要链表", "desc": "对于不少开发者而言,链表(linked list)这种数据结构既熟悉又陌生,熟悉是因为它确实是非常基础的数据结构,陌生的原因是我们在业务开发中用到它的几率的确不大. 链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指…"}, {"id": "7002846792098250789", "title": "学算法刷LeetCode【剑指offer专题】：22. 链表中倒数第k个节点", "desc": "题目描述 解题思路 思路一： 遍历，将倒数第k个节点变成正数第 n-k 个节点 单链表算倒数第 K 个节点的难处在于无法从尾向头遍历，只能从头向尾遍历，但是如果我们知道链表的长度 n，知道要返回倒数第"}, {"id": "7001503493664014367", "title": "JS算法之二叉搜索树的后序遍历序列及二叉树中和为某一值的路径", "desc": "这是我参与8月更文挑战的第28天，活动详情查看：8月更文挑战 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。"}, {"id": "6992398511471853582", "title": "3周攻克数据结构[数组篇-3]", "desc": "这是我参与8月更文挑战的第3天，活动详情查看：8月更文挑战 DAY4 1. 重塑矩阵 方法1：双循环 方法2：二维数组一维表示 2. 杨辉三角 方法1：2层遍历求解 科普篇：杨辉三角 规律 对称 每行"}, {"id": "6844904112400629773", "title": "前端进阶算法2：从Chrome  V8源码看JavaScript数组（附赠腾讯面试题）", "desc": "数组、链表、栈、队列都是线性表，它表示的结构都是一段线性的结构，与之对应的就是非线性表，例如树、图、堆等，它表示的结构都非线性。 我们知道在 JavaScript 中，可以在数组中保存不同类型值，并且数组可以动态增长，不像其它语言，例如 C，创建的时候要决定数组的大小，如果数组…"}, {"id": "6999053946807386119", "title": "刷完这 20 道二分题，可能还是手撕不了大厂面试", "desc": "前言 某个男人 几乎刷完了力扣所有的二分题，我发现了这些东西。。。,而我作为一个致力称为厨师界最会写算法的前端，总得刷上一部分题，有那么一点发现吧，现在我们就来聊聊，菜鸡如我，发现了什么。"}, {"id": "6975279347905069086", "title": "一文了解贪心算法和回溯算法在前端中的应用", "desc": "一文了解贪心算法和回溯算法在前端中的应用 一、贪心算法 1、贪心算法是什么？ 贪心算法是算法设计中的一种方法。 期盼通过每个阶段的局部最优选择，从"}, {"id": "6992494336759824421", "title": "leetcode每日一题题解—— 611. 有效三角形的个数——2021年8月4日", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 611. 有效三角形的个数 Title Description Given an integer array nums, return th"}, {"id": "6986317514267426853", "title": "前端必知的十大排序算法", "desc": "前端必知的十大排序算法，周末梳理了十种排序算法当作复习，给大家也一起重温一下，下面将讲解10种应用较多的排序算法，其代码实现使用了JavaScript。"}, {"id": "7000936119059628045", "title": "前端刷题路-Day93：钥匙和房间（题号841）", "desc": "有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i..."}, {"id": "6994725719540498463", "title": "前端算法必刷题系列[84]", "desc": "这是我参与8月更文挑战的第9天，活动详情查看：8月更文挑战 前面连续的难题，来几个简单点放松下 154. 和为K的子数组(subarray-sum-equals-k) 标签 中等 hash 题目 le"}, {"id": "6984396436712456223", "title": "扁平数据结构化算法实现和复杂度浅析", "desc": "一般前端需要处理的数据量非常小，几百条就了不起了，所以前端开发对算法敏感度比较低。本文缘起另一篇文章，看内容确实有启发，所以也来凑个热闹。"}, {"id": "7002035008609189924", "title": "算法（leetode，附思维导图 + 全部解法）300题之（17）电话号码的字母组合", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（17）电话号码的字母组合 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代"}, {"id": "6994602781776543752", "title": "前端刷题路-Day76：柱状图中最大的矩形（题号84）", "desc": "给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。"}, {"id": "6991396015400517662", "title": "最好时间复杂度、最坏时间复杂度、平均时间复杂度、均摊时间复杂度", "desc": "代码： 一、最好时间复杂度 最好情况就是，arrary数组的第一个元素就是要查找的x，所以最好时间复杂度就是O(1)。 二、最坏时间复杂度 最坏的情况就是，这个数组中没有查找的这个元素，那么它会把这个"}, {"id": "6968996925370531877", "title": "前端刷题路-Day38：移除元素（题号27）", "desc": "给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空并 原地 修改输入数组。"}, {"id": "6844903521402241031", "title": "图像与滤波", "desc": "我对图像处理一直很感兴趣，曾经写过好几篇博客（1，2，3，4）。 前几天读到一篇文章，它提到图像其实是一种波，可以用波的算法处理图像。我顿时有一种醍醐灌顶的感觉，从没想到这两个领域是相关的，图像还可以这样玩！下面我就来详细介绍这篇文章。 我们知道，图像由像素组成。下…"}, {"id": "6844903705825771528", "title": "排序检测算法", "desc": "有一列数据需要进行内容的校验，总共有三个，如果有第一个，第二第三可以为空；有第一第二，第三可以为空；有第一和第三，第二不能为空；有第二和第三，第一不能为空；三者可以同时为空，以此类推。如下表所示 总体就分这八种情况，四种可能，四种不可能。 通过这样来一层层判断，可是这实在是很没…"}, {"id": "6947679541695348749", "title": "算法打卡-leetcode-20210405", "desc": "1. 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1。 我最开始想的很…"}, {"id": "6844903506218844173", "title": "简化版angular-cli文件生成器", "desc": "是这个样子，就有人问我了，每次新建一个业务模块就要，新建6个对于的类型文件，就算ctrl+c和ctrl+v,在F2重命名，需要6下，那6个文件里面的内容，又需要多久时间改好了，能不能做一个模板生成器，类似强大angular-cli一样，ng g component new-co…"}, {"id": "6844903943068188686", "title": "算法题--二叉树重建", "desc": "根据二叉树的前序遍历{1,2,4,7,3,5,6,8}和中序遍历{4,7,2,1,5,3,8,6}，重新构建二叉树。 前序遍历：首先访问根，再先序遍历左子树，最后先序遍历右子树。 中序遍历：首先中序遍历左子树，再访问根，最后中序遍历右子树。 后序遍历：首先后序遍历左子树，再后序…"}, {"id": "6844903504331407368", "title": "算法 | 判断大括号是否闭合", "desc": "判断大括号是否闭合"}, {"id": "6844903881156083725", "title": "高级数据结构系列 —— poj 2352 题解（JS版本）", "desc": "好久没有刷题了，这两天在复习线段树，顺便就记录一下本题的解题过程。 ，要求输出在0~n-1等级各有多少个星星。注意给出的点的顺序很有讲究，是 所以其实我们只需关注每一个点在它之前出现的那些点是否在这个点与原点所围成的矩形中就行，在这个矩形中有几个点那么该点的level就是几。 …"}, {"id": "6844903508223721479", "title": "【图像缩放】双立方（三次）卷积插值", "desc": "本文的契机是某次基于canvas做图像处理时，发现canvas自带的缩放功能不尽人意，于是重温了下几种图像插值算法，并整理出来。 可能是某文中漏掉了分母的PI，亦或是这个公式只是某文自己实现的一个采样公式，与sin无关，然后被误传了。 这里都无从考据，仅此记录，避免疑惑。 本质…"}, {"id": "6844903556768595981", "title": "JavaScript30秒， 从入门到放弃之Array（五）", "desc": "从给定的数组中随机选出指定个数的数组元素。 用 Fisher-Yates 算法将数组洗牌（打乱顺序）。然后使用Array.slice() 来截取数组的前n个元素。如果省略第二个参数n，按n=1处理，即仅取一个随机元素。 关键点是这个while循环，按数组初始长度m每次递减1循环…"}, {"id": "6844904106084024333", "title": "每天一道算题题: 24. 两两交换链表中的节点", "desc": "给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 时间复杂度：O(N)。 空间复杂度：O(1)。 时间复杂度：O(N)。 空间复杂度：O(N)，因为使用了递归。 PS: 有兴趣欢迎关注我的公众号。"}, {"id": "6944706713211633694", "title": "JS 数据结构[数组]实现", "desc": "数据排成一列，每个数据最多有前后两个方向。数组、链表、队列、栈都是线性表。 因为连续内存空间，获得随机访问特性。但是写入速度慢。注意：随机访问的时间复杂度是O(1)，查找时间复杂度是O(n)。 不过也因为连续内存空间，需要向系统申请固定长度内存空间来存储。过长或过短时可以启用扩…"}, {"id": "6899398735466823694", "title": "【动态规划】LeetCode 97.交错字符串-Hard", "desc": "给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。 dp数组横向长度为s1的长度+1，吗，默认索引0为不使用s1，表示的含义是空字符，即\"\";宽度同理。 还是需要慢慢分析，对于二维数组dp，需要理清dp[i][j]和dp[i-1][j…"}, {"id": "6898566350461992973", "title": "【动态规划】LeetCode 91 解码方法-Medium", "desc": "给定一个只包含数字的非空字符串，请计算解码方法的总数。 题目数据保证答案肯定是一个 32 位的整数。 定义dp 数组，第 i 个元素表示从第一个字符到第i个字符的解码数。 第一次思路清晰的做对了动态规划的题目，需要做的是冷静思考，慢慢分析，得到状态转移方程。"}, {"id": "6844903799769792520", "title": "小前端学算法之复杂度分析", "desc": "数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行的更快，如何让代码更省储存空间。 所以复杂度分析是整个算法学习的精髓。 算法的执行效率，就是算法代码执行的时间。来估算一下下面代码的执行时间。 假设每行代码执行的时间都一样，都是unit_time。 第 2 行代码…"}, {"id": "6844903503337373703", "title": "Luy 1.0 ：一个React-like轮子的诞生", "desc": "前言在过去的一个多月中，为了能够更深入的学习，使用React，了解React内部算法，数据结构，我自己，从零开始写了一个玩具框架。 截止今日，终于可以发布第一个版本，因为就在昨天，我跑通了之前的一个小项目。 详情请阅读原文"}, {"id": "6924595610012598286", "title": "剑指Offer36 js 二叉搜索树与双向链表 两种解法", "desc": "输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一…"}, {"id": "6894224899738042382", "title": "数据结构与算法学习之队列", "desc": "队列的定义队列是一种遵循先进先出原则的线性表。队列只允许在队列的尾部添加元素，在队列的头部删除元素。新添加的元素必须排在队列的末尾。在现实生活中，最常见的队列的例子就是排队，例如超市里顾客在排队结账。"}, {"id": "6844903569502502925", "title": "JavaScript 作用域链 难不难？", "desc": "介绍在变量对象中已经介绍过，执行上下文（变量，函数声明和函数形式参数）的数据被存储为变量对象的属性此外，我们知道每次进入上下文时都会创建变量对象并填充初始值，并且它的更新发生在代码执行阶段举个栗子🌰这"}, {"id": "6844903998256840712", "title": "JavaScript闭包使用姿势指南", "desc": "这段代码和之前的代码执行结果完全一样,其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。你很可能认为它无法执行,那么我们再改变一下代码 答案是,**JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法…"}, {"id": "6844903633960747021", "title": "条件型 CORS 响应下因缺失 Vary: Origin 导致的缓存错乱问题", "desc": "CORS，全名为跨域资源共享，是为了让不同网站的页面之间互相访问数据的机制。简单来说，CORS 的工作机制是这样的：网站 A 请求网站 B 的资源，网站 A 发起的请求会在 Origin 请求头上带上自己的源（origin）信息，如果网站 B 返回的响应头里有Access-Co…"}, {"id": "6939148656641572900", "title": "【魅力算法】'链表的中间结点'单指针法&快慢双指针法实现 ｜刷题打卡", "desc": "题目描述解题思路单指针法对链表进行两次遍历：第一次遍历我们统计元素个数size;然后计算mid=size/2;第二次遍历：step=0;遍历循环条件为：step<size/2;代码复杂度分析快慢指针定"}, {"id": "6939088602764836872", "title": "[LeetCode：Check If a String Contains All Binary Codes of Size K] | 刷题打卡", "desc": "题目很短也很好理解，看完后思路应该很快就有了：先求所有长度为 k 的二进制串，然后判断所有的二进制串是不是都是 s 的字串。 不用多想，一定是个回溯问题！长度为 k 的字符串的每一位都有 0 和 1 两种填充可能，一共有 $2^{k}$ 种结果。写出如下回溯代码： ，最后用数组…"}, {"id": "6939149352396914702", "title": "【魅力算法】'旋转链表' 将每个节点向右移动k位 ｜刷题打卡", "desc": "将尾节点作为移动点。每次循环将当前尾节点移动到链表head;"}, {"id": "6942454921375514632", "title": "位1的个数 逻辑位运算符", "desc": "位运算就是对二进制数执行计算，是整数的逐位运算。 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。 两个相应的二进制位中只要有一个为1，该位的结果值为1。 若参加运算的两个二进制位值相同则为0，否则为1。 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1…"}, {"id": "6948201995681398821", "title": "前端刷题路-Day9｜刷题打卡", "desc": "给定一个二叉树，判断其是否是一个有效的二叉搜索树。 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 这就涉及到了二叉搜索树的基本定义了，定义很简单，所有左子树的值一定比当前节点的值小，同时所有右子树的值一定…"}, {"id": "6893934137917308936", "title": "命令行错误提示—谈谈模糊集", "desc": "在开发的过程中，我们会使用各种指令。有时候，我们由于这样或者那样的原因，写错了某些指令。此时，应用程序往往会爆出错误。 可以看到，当前代码不仅仅提示了当前你输入的配置错误。同时还提供了类似当前输入的近似匹配指令。非常的智能。此时，我们需要使用算法来计算，即模糊集。 事实上，模糊…"}, {"id": "6947955090296668167", "title": "贪心范围覆盖算法总结 | 刷题打卡", "desc": "★★45. 跳跃游戏 II 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 **时间复杂度：$O(n^2)$，**因为最坏的情况…"}, {"id": "6844903919848521736", "title": "车载多传感器融合定位方案：GPS +IMU+MM", "desc": "高德定位业务包括云上定位和端上定位两大模块。其中，云上定位主要解决Wifi指纹库、AGPS定位、轨迹挖掘和聚类等问题；端上定位解决手机端和车机端的实时定位问题。近年来，随着定位业务的发展，用户对在城市峡谷（高楼、高架等）的定位精度提出了更高的要求。 特别是车机端定位，由于定位设…"}, {"id": "6844903753376612360", "title": "使用 React + Redux 制作兰顿蚂蚁演示程序", "desc": "最早接触兰顿蚂蚁是在做参数化的时候，那时候只感觉好奇，以为是很复杂的东西。因无意中看到生命游戏的 React 实现，所以希望通过兰顿蚂蚁的例子再学习一下 React。 如果蚂蚁位于白色方块，则向右旋转 90°，反转方块的颜色，然后向前移动一步。 如果蚂蚁位于黑色方块，则向左旋转…"}, {"id": "6910026747350089736", "title": "【动态规划】LeetCode321 拼接最大数-Hard", "desc": "定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &#x3C;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。 求满足该条件的最大数。结果返回一个表示该最…"}, {"id": "6979499156251344926", "title": "整数反转", "desc": "整数反转 题目链接 整数反转 题目内容 给你一个32位的有符号整数x，返回将x中的数字部分反转后的结果。 如果反转后整数超过32位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回0。 "}, {"id": "6885865577777381383", "title": "排序算法入门之「选择排序」", "desc": "选择排序选择排序也是利用了“挡板法”这个经典思想。挡板左边是已排序区间，右边是未排序区间，那么每次的“选择”是去找右边未排序区间的最小值，找到之后和挡板后面的第一个值换一下，然后再把挡板往右移动一位，"}, {"id": "6844903893751562253", "title": "【数据结构与算法JavaScript实现与应用】查找算法 —— 顺序查找 PK 二分法+排序", "desc": "在列表中查找数据有两种方式：顺序查找和二分查找。对于一个已排序的列表，二分法无疑效率更高，因为每次可排除一半的元素，但若是对于一个无序的列表，如果先对其排序，再用二分法查找和直接用顺序查找对比哪种效率更高呢？最近在看的《数据结构与算法Javascript描述》一书正好也有这样一…"}, {"id": "6938661002053419022", "title": "[ 力扣118 ] 杨辉三角（数学公式极简解法） | 刷题打卡", "desc": "给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 本题解已同步leetcode-js-simple/08.[ 118 ] 杨辉三角，可以复制代码进行调试。"}, {"id": "6936507733638119431", "title": "leetcode 查找元素小组合｜ 刷题打卡", "desc": "主题列表：juejin,github,smartblue,cyanosis,channing-cyan,fancy,hydrogen,condensed-night-purple,greenwillo"}, {"id": "6972159407681437726", "title": "数组-合并两个有序数组", "desc": "描述 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 输入：nums1 = [1,2,3]，nums2 = [2,5,"}, {"id": "6844904013486358541", "title": "前端算法实战-利用贪心递归切蛋糕的小栗子", "desc": "本篇文章重点分享解决问题的思想，描述业务是真实项目遇到问题，为了简单明了侧重算法思想，会抛去一些业务介绍，重注思想。下面我们一起看一看这个小栗子吧！ 在项目中遇到了这样的问题，在电子表格中存在隐藏行和合并单元格这两个概念，当和合并单元格包含在隐藏行的单元格时，就会出问题。例如，…"}, {"id": "6844904205933772807", "title": "你的衣服我扒了 - 《最长公共子序列》", "desc": "之前出了一篇穿上衣服我就不认识你了？来聊聊最长上升子序列，收到了大家的一致好评。今天给大家带来的依然是换皮题 - 最长公共子序列系列。 最长公共子序列是一个很经典的算法题。有的会直接让你求最长上升子序列，有的则会换个说法，但最终考察的还是最长公共子序列。那么问题来了，它穿上衣服…"}, {"id": "6844903696904486925", "title": "图形算法可视化", "desc": "最近看了一些和图形、算法可视化相关的文章和代码，挺有意思，于是自己也学着做了些东西。 迷宫小时候玩过，但从来没琢磨过迷宫是怎么设计的，以为就是有人慢慢画出来的。看过网上这篇文章后，才知道，原来还可以随机生成： 自己找了些资料参考，试着实现了几种之后，才慢慢领会到其中的一些原理。…"}, {"id": "6844903520588529678", "title": "javascript的内存管理以及3种常见的内存泄漏", "desc": "尽管我们正在越来越多的编写Javascript代码，但是我们不一定真的了解它。编写本系列专栏的目的就是深入到javascript的底层，了解其运行原理，帮助我们写出更高效的代码，减少一些不必要的bug. 在这篇文章中我将主要探讨javascript内存管理，调用栈以及如何处理内…"}, {"id": "6983929418666213406", "title": "LeetCode第328题：奇偶链表", "desc": "题干 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1"}, {"id": "6960930227895664654", "title": "算法学习中总结归纳的几种背包问题的解题思路", "desc": "前言 笔者最近的算法学习到了动态规划的阶段，刷了不少动态规划的题，对于动态规划中的背包问题，刚开始真的非常头痛，很多题可能只是稍稍更改了一些约束条件，我就答不出来了。这类题虽然解题的方法都是类似，但是"}, {"id": "6844904160878395399", "title": "洗牌算法的实现", "desc": "相信大家都写过很多排序算法,但是你对乱序算法熟悉吗？现在就让小白带你走进乱序算法的世界。 首先,我们需要理解在这道题目中随机的真正含义是什么？随机的真正含义应该是每个数字,在每个位置出现的几率都相等。也就是说，0在这十个位置中出现的几率是相等的，1在这十个位置中出现的几率是相等…"}, {"id": "6844903655003389959", "title": "[译文] 初学者应该了解的数据结构： Tree", "desc": "Tree 是很多（上层的）数据结构（如 Map、Set 等）的基础。同时，在数据库中快速搜索（元素）也用到了树。HTML 的 DOM 节点也通过树来表示对应的层次结构。以上仅仅是树在实际应用中的一小部分例子。在这篇文章中，我们将探讨不同类型的树，如二叉树、二叉搜索树以及如何实现…"}, {"id": "6844903992359649288", "title": "从libuv源码中学习红黑树", "desc": "本身红黑树就是很难搞懂的概念，加上C语言，所以太不友好了。于是我根据C语言的实现，改写成Js版本的，下面的讲解都是基于js语言的，所以大家勿慌~ 红黑树的基础是二叉搜索树，那么二叉搜索树不好吗？非要再整这么一个复杂的出来？二叉搜索树原本已经是个很好的数据结构，可以快速地找到一个…"}, {"id": "6924979557015486477", "title": "算法刷题——二分法", "desc": "给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 暴力解决的话就是从头开始遍历数组，但由于这个数组是有序的，所以可以优化成二分查找。即从中间开始查找，根据结…"}, {"id": "6976129788121939999", "title": "漫画算法:小灰的算法之旅学习 - 第1章 算法概述（时间复杂度？）", "desc": "这是我参与更文挑战的第21天，活动详情查看： 更文挑战 紧跟上篇，这篇主要是时间复杂度及相关 时间复杂度 算法的好与坏 怎么衡量一个算法的好与坏? 衡量算法的好坏有很多标准,其中最重要的两大标准是算法"}, {"id": "6992578180364124167", "title": "LeetCode算法学习之--数组--加一", "desc": "大家好今天给大家分享下一道 LeetCode 简单难度 的题目[加一] 题目 分析 解法一：迭代 总结 这道题考察的对数组中对迭代的应用 大家可以看看我分享的一个专栏（前端搞算法）里面有更多关于算法的"}, {"id": "6992564832587218951", "title": "LRU算法在接口缓存Cache中的应用", "desc": "翻了翻以前的代码，突然看到之前设计接口缓存的时候用到的一个小技巧，觉得挺有意思，分享一下。 古有谈缓存色变，而在早期前端开发心中大概有谈缓存色变的缘由。很多更改都不能立刻生效，造成了用户的体验以及测试"}, {"id": "6844903893118238733", "title": "【算法】前端遇到的广度/深度优先搜索", "desc": "在面试或者技术社区冲浪的时候，一不小心就会看到深度优先搜索、广度优先搜索这两个概念，这一次在项目中一个需求用到了相关的知识，故此在这里通过理论+实际来总结一下。 1. 示例 2. 深度优先搜索 深度优先搜索（depth first search），从图中也可以看出来，是从根节点…"}, {"id": "6992012937729114142", "title": "冒泡、快排、选择、插入算法思想的理解 | 8月更文挑战", "desc": "​ 排序是我们在开发过程当中经常会看到也是使用较为频繁的算法，因此掌握一些基本的排序算法对于我们的开发是会有很大的帮助的，以下针对常见的几种排序算法及其原理进行分别介绍。"}, {"id": "6983253684956168206", "title": "Leetcode  130. 被围绕的区域 --javascript dfs递归+dfs栈+bfs 队列", "desc": "130. 被围绕的区域 题目 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。 题解 这道"}, {"id": "6932341812573143053", "title": "布隆过滤器", "desc": "布隆过滤器（Bloom Filter） 是 1970 由布隆提出，它是一种多哈希函数映射的快速查找算法 (存储结构），可以实现用很小的空间和运算代价，来实现海量数据的存在与否的记录（黑白名单判断）。特点是高效的插入和查询，可以判断出一定不存在和可能存在 如果要将一个\"添加\"射到…"}, {"id": "6919519471077949448", "title": "原生JS知识点&&面试高频算法(一)", "desc": ""}, {"id": "6844903551953534989", "title": "三维坐标变换原理-平移, 旋转, 缩放", "desc": "给定一个二维点(x, y)，那么形如(kx, ky, k)的所有三元组就都是等价的，它们就是这个点的齐次坐标(homogeneous)。齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般 矩阵的线性变…"}, {"id": "6844903592889942023", "title": "HTTP从入门到放弃", "desc": "个人觉得只要了解请求首部及响应首部即可。其中响应首部中的range（可以做断点续传，会在下文提及），还有缓存（ETag），这些是必须要掌握的知识。 在上一篇的最后内容中，有提及req的一些属性，那么我们来看一下res有哪些方法吧。 它与writeHead的区别是：它不会真正的把…"}, {"id": "6987217727769280519", "title": "LeetCode 34 Find First and Last Position of Element  (Tag:Array Difficulty:Mid)", "desc": "前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉得有帮助的话，记得多多点赞关注哦，感谢！ 题目描述 给定一个"}, {"id": "6869785753958907912", "title": "食堂店小二儿教你学会栈", "desc": "前端食堂里的店小二儿对栈的理解很深刻，我们来听听他是怎样理解栈的。 店小二儿十分勤奋，前台后厨的活儿他都干，每天都要跑前跑后端顾客吃完的盘子。栈就像叠在一起的盘子，客人美滋滋的吃完饭，店小二去收拾桌子捡起盘子时，都是从下往上一个一个的放盘子。而他在后厨橱柜上取盘子给厨师时，是从…"}, {"id": "6844903703732813832", "title": "数据可视化：浅谈热力图如何在前端实现", "desc": "当我们需要用更直观有效的形式来展现各类大数据信息时，热力图无疑是一种很好的方式。作为一种密度图，热力图一般使用具备显著颜色差异的方式来呈现数据效果，热力图中亮色一般代表事件发生频率较高或事物分布密度较大，暗色则反之。 值得一提的是，热力图最终效果常常优于离散点的直接显示，可以在…"}, {"id": "6989965275374452766", "title": "最简单的长列表优化", "desc": "一. 长列表性能问题 做移动端h5项目，经常会遇到的问题就是长列表展示，数据较少的时候还好，如果数据量过大时就会出现明显的性能问题，加载特别慢甚至卡死。 所以长列表性能优化是很常见的问题，我们项目组件"}, {"id": "6967772574411390990", "title": "无序数组排序后的最大相邻值", "desc": "题目：无序数组排序后的最大相邻差值 解法1： 对数组进行 O(nlogn) 的算法排序，再对排序后的数组遍历，找出差值最大的两个相邻元素 解法2： 1. 利用计数排序思想，找到最大值和最小值的差值为区"}, {"id": "6992754895614902286", "title": "算法（leetode，附思维导图 + 全部解法）300题之（5）最长回文子串", "desc": "标题：算法（leetode，附思维导图 + 全部解法）300题之（5）最长回文子串 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： 3 方案3 1"}, {"id": "6955731828699463693", "title": "两道算法题，彻底弄懂动态规划", "desc": "动态规划 动态规划是算法设计中的一种方法。 它将一个问题分解为相互重叠的子问题， 通过反复求解子问题来解决原来的问题。 斐波纳契数列就是经典的动态规划问题 抽象成表达式， n >= 2, 第 n 个数"}, {"id": "6996522217668378632", "title": "前端必会数据结构与算法系列之回溯(十一)", "desc": "1. 什么是回溯 回溯法采用试错的思想，它尝试分步的去解决一个问题。 在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它"}, {"id": "6991376975193456677", "title": "leetcode每日一题题解—— 1337.矩阵中战斗力最弱的 K 行 （2021年8月1日）", "desc": "1337.矩阵中战斗力最弱的 K 行 Title Description You are given an m x n binary matrix mat of 1's (representing s"}, {"id": "6973821835397824548", "title": "分治思想：归并排序与快速排序", "desc": "大事化小、小事化了。是我对分治思想的理解总结，将一个大的分体不听向下拆分分割成一个个小问题，和故人总结的大事化小多么像啊。"}, {"id": "6992058249658761247", "title": "LeetCode题解：173. 二叉搜索树迭代器，递归，JavaScript，详细注释", "desc": "原题链接：173. 二叉搜索树迭代器，https://leetcode-cn.com/problems/binary-search-tree-iterator/"}, {"id": "6986206925851623461", "title": "如何实现一个包含min函数的栈", "desc": "题目： 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 难点 push 和 pop 的操作时间复杂"}, {"id": "6984672030092181517", "title": "LeetCode第739题：每日温度", "desc": "题干 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperat"}, {"id": "6988695171361669128", "title": "LeetCode刷题，移除无效的括号（1249）", "desc": "思路：我们只需要判断括号中出现的数量差值是否为0。如果左括号-右括号数量为0，那么代表能匹配所有括号，如果不能就删除括号即可"}, {"id": "6984224504188796964", "title": "阿里云罗小飞：阿里云边缘云，从资源到场景的产品演进", "desc": "​2021年7月1日，以“云集影从，融网聚生”为主题的GIDC全球互联网数据大会在上海成功举行。本次大会由中国信通院指导，艾迪网主办，邀请来自政府、产业等多领域的专家，围绕“新基建”、“绿色数据中心”"}, {"id": "6844903917705232397", "title": "数据结构 - 数组", "desc": "如果小伙伴刚好看到这篇文章，想了解下 算法与数据结构 中，关于 数组 的知识。 基本的 JavaScript 知识。 知道一点点的数组及其用法。 但是，jsliang 无法确定小伙伴是否真具备上面知识点（前置条件），所以前言会简略介绍下数组，希望能先小科普一下，方便后面共同探讨…"}, {"id": "6987407926541418532", "title": "leetcode 542. 01 矩阵 --javascript DP", "desc": "542. 01 矩阵 题目： 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 题"}, {"id": "6973080653172572196", "title": "前端刷题路-Day49：奇怪的打印机（题号664）", "desc": "有台奇怪的打印机有以下两个特殊要求： 打印机每次只能打印由 同一个字符 组成的序列。 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。给你一个字符串 `s` ，你的任务是计算这个打"}, {"id": "6844904181187215368", "title": "动态规划套路", "desc": "回想起当初学动态规划的时候，是真的难。动态规划的确很难，很考验逻辑思维能力、抽象能力、还有数学建模能力。 但是入门动态规划真的有这么难吗？我觉的其实真的不难，就是单纯的找规律；这里我想以一种比较野路子的方式帮助大家入门理解动态规划，这种方法真的是很简单且有效果，大神请忽略。 什…"}, {"id": "6988022306173878308", "title": "LeetCode刷题，棒球比赛（682）", "desc": "棒球比赛 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作， 思路：使用栈的方式来进行数据的获取和计算。"}, {"id": "6982477887303581733", "title": "算法复杂度", "desc": "算法复杂度 之前在学习算法或者是在看React文档中的diff算法时，总是提到复杂度这个关键词， 而且往往它们都是根据复杂度来评价算法的优劣， 那算法的复杂度到底是什么呢？ 以及它们如何计算出来的呢？"}, {"id": "6995002705869701156", "title": "一天一个知识点之线程与进程", "desc": "进程 进程是程序的一次执行过程，是程序在执行过程中的资源分配的基本单位，每个进程都有自己的地址空间,进程至少有 5 种状态：初始态、执行态、等待态、就绪态、终止态。 线程： 线程是CPU调度的基本单位"}, {"id": "7001856785027956750", "title": "JS实现归并排序和快速排序", "desc": "归并排序（稳定算法） 思路 先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。 复杂度 时间 O(nlogn) 空间 O(n) 实现 快速排序（非稳定算法） 思路 "}, {"id": "7002037971197100045", "title": "「前端刷题」29. 两数相除", "desc": "这是我参与8月更文挑战的第29天，活动详情查看：8月更文挑战 题目 https://leetcode-cn.com/problems/divide-two-integers/ 给定两个整数，被除数 d"}, {"id": "6844903873614741518", "title": "[译] 线性代数：矩阵基本运算", "desc": "本文是“JavaScript 线性代数”教程的一部分。 在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。 矩阵的加法与减法运算将接收两…"}, {"id": "6947296000792854541", "title": "你真的了解二叉树吗（树形结构基础篇）", "desc": "本系列所有文章都将会收录到GitHub中统一收藏与管理，欢迎ISSUE和Star。 树天生就是一个适合递归遍历的数据结构,因为每一次处理左子树和右子树的时候，其实就是递归遍历的过程。 看到这里，有一些小伙伴可能会感觉似曾相识，是不是在哪里看过树相关的一些知识呢。其实在之前我们学…"}, {"id": "6844903695721709581", "title": "JS垃圾回收机制笔记", "desc": "直到不久之前，对于JS的垃圾回收机制，还停留在‘所分配的内存不再需要’的阶段。问题来了，浏览器是怎么确定‘所分配的内存不再需要’了呢？ MDN：像C语言这样的高级语言一般都有底层的内存管理接口，比如 malloc()和free()。另一方面，JavaScript创建变量（对象，…"}, {"id": "6933275871276957709", "title": "单模式字符串匹配的5种常用算法（js实现）", "desc": "在一个字符串（记为主串/string）里面查找另一个或多个特定字符串(记为模式串/pattern)的行为。 单模式串匹配，是在一个主串中查找一个模式串。 多模式串匹配，是在一个主串中查找多个模式串。 因篇幅原因，本篇内容只涉及单模式串匹配，多模式串匹配的方法以后有机会再写。 移…"}, {"id": "6950850975326634021", "title": "[打卡5：leetcode3-无重复字符的最长子串]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第五题题目描述题目链接：无重复字符的"}, {"id": "6844903629992755213", "title": "浅解前端必须掌握的算法（五）：堆排序（上）", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去比如像腾讯一样的大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，轻松了解基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎…"}, {"id": "6844903603329564686", "title": "vue实现2048", "desc": "因为一轮移动中，一个数只能合并一次，所以每个格子要有merged参数来记录是否已经合并过。 因为上移，下移，左移，右移实际上是相同的，写4遍也可以，但是容易出错，所以我直接旋转将矩阵旋转，再进行移动。 以上移为例，只要将矩阵逆时针旋转一次，上移就变成了左移，移动合并成之后，只要…"}, {"id": "6854573210761003022", "title": "「数据结构」在JavaScript中实现堆", "desc": "堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。 反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（MaxHeap）。 在堆中最顶端的那一个节…"}, {"id": "6978082134565060622", "title": "Leetcode - 滑动谜题", "desc": "这是我参与更文挑战的第 26 天，活动详情查看更文挑战https://juejin.cn/post/6967194882926444557"}, {"id": "6844903667934429197", "title": "js实现数据结构及算法之散列表(Hashtable)", "desc": "散列表也被称为哈希表，Hash表是一种特殊的数据结构。 线性探测法属于开放寻址散列，查找散列位置如果当前位置没有继续寻找下一个位置。存储数据较大较适合。数组大小>=1.5*数据（开链法），数组大小>=2*数据（线性探测法） 在创建存储散列过的键值数组时，创建一个新的空数组，然后…"}, {"id": "6914593112321228814", "title": "【每日一荐月刊】2020-12", "desc": "每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 电子书文件太大， 大家可到我的公众号《脑洞前端》回复“每日一荐”获取。 管道和重定向是 shell 中两个非常重要的概念，搞不懂它那么就无法精通 shell，很多高阶操作都依赖于 ta。 这篇文章讲解地非常细致，…"}, {"id": "6950287576628461599", "title": "前端算法面试必刷题系列[36]", "desc": "63. 每日温度 (daily-temperatures) 64. 柱状图中最大的矩形 (largest-rectangle-in-histogram)"}, {"id": "6909759311950381064", "title": "[算法实践] 二叉树的遍历类型题实践（一）", "desc": "挂上leetcode链接，可以用来查看更多示例和测试，并最后通过它。翻转二叉树 很显然题意就是 镜像翻转一棵二叉树。 我们判断每个节点该做什么事。 这个问题比较简单所以比较容易看出: 我们要镜像翻转二叉树，也就是每个节点它的左右子节点进行交换，就翻转了。 这里思考，当我们遍历到…"}, {"id": "6916163226187415559", "title": "「刷题专栏」起航 - 五分钟构建自己的刷题仓库 | 七日打卡", "desc": "拥有自己的刷题仓库能够帮助自己记录刷题历程 &#x26; 刷题知识，如果偶尔学习到新的解法还能够补充记录到之前的解法后面。Github 上搜索 leetcode 就能看到各种大神的 leetcode 刷题仓库，准备刷题的你也可以五分钟拥有一个属于自己的刷题仓库. 一. 五分钟构…"}, {"id": "6844904045795098632", "title": "JavaScript实现康威生命游戏", "desc": "康威生命游戏（英语：Conway's Game of Life），又称康威生命棋，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 它最初于1970年10月在《科学美国人》杂志上马丁·葛登能的“数学游戏”专栏出现。 当前细胞为存活状态时，当周围的存活细胞低于2个时（不…"}, {"id": "6854573220004118535", "title": "一文带你看懂二叉树的序列化", "desc": "可见，序列化和反序列化在计算机科学中的应用还是非常广泛的。就拿 LeetCode 平台来说，其允许用户输入形如： 其实序列化和反序列化只是一个概念，不是一种具体的算法，而是很多的算法。并且针对不同的数据结构，算法也会不一样。本文主要讲述的是二叉树的序列化和反序列化。看完本文之后…"}, {"id": "6951545827374727199", "title": "前端刷题路-Day18｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情单词搜索（题号79）题目给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 tru"}, {"id": "6844903508261470216", "title": "H5游戏开发：一笔画", "desc": "H5游戏开发：一笔画"}, {"id": "6935041288928493581", "title": "简单介绍下广度优先遍历BFS和深度优先遍历DFS", "desc": "假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到…"}, {"id": "6844903503928754189", "title": "js用SHA1withRSA加签", "desc": "最近开发项目中无意用到SHA1withRSA签名算法，纵观百度了下，资料比较少，通过源码例子查询使用方法，对此有些了解，所有多此总结下。 SHA1WithRSA:用SHA算法进行签名，用RSA算法进行加密。 具体的对于SHA和RSA算法这里不做详细介绍，只简单的介绍如何使用SH…"}, {"id": "6920369145422807053", "title": "前端就该用 JS 刷算法22", "desc": "1530. 好叶子节点对的数量 1530. 好叶子节点对的数量"}, {"id": "6981669301665136653", "title": "LeetCode第160题:相交链表", "desc": "题干 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个"}, {"id": "6988137634421800997", "title": "leetcode 279. 完全平方数 -- javascript dp", "desc": "279. 完全平方数 题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为"}, {"id": "6844903720610693127", "title": "了解JavaScript中的Memoization以提高性能,再看React的应用", "desc": "我们渴望提高应用程序的性能，Memoization是JavaScript中的一种技术，通过缓存结果并在下一个操作中重新使用缓存来加速查找费时的操作。 在这里，我们将看到memoization的用法以及它如何帮助优化应用的性能。 如果我们有CPU密集型操作，我们可以通过将初始操作…"}, {"id": "6844904117563834382", "title": "前端工程师的 LeetCode 之旅 -- 周赛 183", "desc": "给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在…"}, {"id": "6910060785620221959", "title": "BF,BM,KMP看完不懂，我就去剪光头！", "desc": "注：如果文中视频不可播放，大家可以去查看原文，我觉得即使不看视频应该也可以读懂。 皇上生辰之际，举国同庆，袁记菜馆作为天下第一饭店，所以被选为这次庆典的菜品供应方，这次庆典对于袁记菜馆是一项前所未有的挑战，毕竟是第一次给皇上庆祝生辰，稍有不慎就是掉脑袋的大罪，整个袁记菜馆内都在…"}, {"id": "6974320430538883108", "title": "判断两个旋转矩形是否有重叠（碰撞）", "desc": "先构建两个矩形： 加入旋转： 此刻我们得到了两个旋转过的矩形，下面来判断它两是否有重叠部分 首先我们将坐标系变换为以a矩形的旋转为基准的坐标系，这样做可以让a矩形变为横平竖直方便后续计算 接下里将b矩"}, {"id": "6926408162425864199", "title": "算法刷题——二叉树", "desc": "100相同的树https://leetcode-cn.com/problems/same-tree/递归解法BFS解法113路径总和112路径总和257二叉树的所有路径129求根到叶子节点数字之和43"}, {"id": "6844903498027368462", "title": "JS中的算法与数据结构——队列(Queue)", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6844903774427807751", "title": "算法学习之二进制的妙用", "desc": "有一个笑话，世界上有10种人，一种是看得懂二进制的，一种是看不懂的。 leetcode 上有一道这样的题，Single Number，题目是要你要找到数组中唯一只存在一个的数字，其他数字都出现两次。这道题目非常的简单，我们可以用 hash 表来记录所有数字的次数，然后找到次数为…"}, {"id": "6844903550204510222", "title": "JavaScript从反转数组到链表反转", "desc": "众所周知，JavaScript的数组提供了很多有用的操作数组的方法，其中Array.prototype.reverse方法就可以将数组里面的数字反转。用reverse这个函数反转数组很简单，这里看下代码如何操作： 这样的代码很简单，但是我们依旧不知道是怎么反转的。下面来看下一种…"}, {"id": "6984773596832858120", "title": "栈", "desc": "栈定义 栈是一种线性结构，可以用装羽毛球的筒子类比，先入后出(FILO). 特点: 最早进入的元素存放的位置叫做栈底, 最后进入的元素存放的位置叫做栈顶. 表现形式: 栈这种数据结构可以用数组来实现，"}, {"id": "6844903576037244935", "title": "快速排序算法的优化思路总结", "desc": "前两天在知乎上看到了一个关于快速排序算法性能的问题，我简单总结了一个优化思路，现在在自己的博客里也贴一下吧，版权都是我的。 快速排序水很深啊。我不贴代码，主要讲讲优化思路和手段吧。 1. 合理选择pivot 你就直接选择分区的第一个或最后一个元素做 pivot 肯定是不合适的。…"}, {"id": "6875966041604751368", "title": "背包问题(Knapsack)全解析(上)", "desc": "导读背包问题(KnapsackProblem)是动态规划中非常经典的一类，一般的解题思路是：状态为前i中物品在容量为j的背包下，最多可以装的物品总价值，然后遍历物品和背包容量，根据之前的状态不断更新当"}, {"id": "6844903687911899143", "title": "Shader 高斯模糊（Gaussion Blur）", "desc": "只要我们把 3x3 的网格放大，如 9x9 / 16x16，或者直接放大像素间距，都可以增加模糊效果。 然而上面的实现方式性能是比较差的。因为遍历的成本太高了。通常拆成两个一维向量，这样时间复杂度就由NxNxWxH下降为2xNxWxH（W为图像的宽，H为图像的高）。 让图片更加…"}, {"id": "6844903700209598477", "title": "笔记：React 中关于 key 的一点总结", "desc": "译 ：当您使用React时，您可以在单个时间点将该render()函数视为创建React元素树。在下一个状态或道具更新时，该render()函数将返回一个不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。 react中的key属性是一个特殊的属…"}, {"id": "6997770553918488590", "title": "「前端刷题」17. 电话号码的字母组合", "desc": "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键"}, {"id": "6844903599076540423", "title": "小程序中神秘的用户数据", "desc": "上一篇文章手把手教会你小程序登录鉴权介绍了小程序如何进行登录鉴权，那么一般小程序的用户标识可以使用上文所述微信提供的jscode2session接口来换取，小程序还提供了一个getUserInfo的API来获取用户数据，这个用户数据里面也可以包含当前的用户标识openid。本文…"}, {"id": "6938949228689358885", "title": "剑指 Offer 33. 二叉搜索树的后序遍历序列 | 刷题打卡 ", "desc": "已经刷了将近20道题，凭空想象出思路，还不通过想想前几道做题总结的经验。所以我觉得应该停下来去复习一下前面的题目，整理一下做题的套路。温故而知新。 后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。 二叉搜索树定义： 左子树中所有节点的值…"}, {"id": "6994022430888951816", "title": "「前端刷题」8. 字符串转换整数 (atoi)", "desc": "请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi"}, {"id": "6935724755865567268", "title": "这也能运行？!响应号召做掘金每日好题3.3.3｜刷题打卡", "desc": "这题最开始我以为就是区间DP，看起来和之前讲的石子合并没区别,就是在计算状态转移方程时因地制宜下就好，怎么也没做出来，有种“这为啥会做错的感觉”，后来慢慢发现这题坑挺多的。 第二个坑隐藏在示例中，我们发现气球被戳爆后就不存在了，这和我们的石子合并是完全不一样的，而这种方式就让我…"}, {"id": "6972149845901443080", "title": "数组 - 两数求和问题", "desc": "题目描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 输入：nums = [2, 7, 11, 15], target "}, {"id": "6844903689220521998", "title": "房间和迷宫：一个地牢生成算法", "desc": "微博上的 @大城小胖（indienova 个人资料）向我们推荐了这篇文章，在此表示感谢。 本文的作者是：Bob Nystroms，本文的转载和翻译已经获得了他的授权。 原文地址在：Rooms and Mazes: A Procedural Dungeon Generator，有…"}, {"id": "6938073896495087652", "title": "找数组中两个不同的数字也可以用位运算？｜刷题打卡", "desc": "在数组中找不同的数字可以说是一道很基础的题目，寻常来说只需要遍历一次就行，一次不行，那就两次，总是可以的。 原题链接：剑指 Offer 56 - I. 数组中数字出现的次数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求…"}, {"id": "6844903826751766541", "title": "每日一算--最长回文子串", "desc": "给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。 改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道“ba…"}, {"id": "6844903495942799373", "title": " W3C CSS Transforms摘译", "desc": "CSS Transforms可以对一个元素进行二维平面或三维空间的变换，如translate, rotate, scale和skew等变换。 下面是对W3C官网CSS Transforms模块的部分摘译，为了理解的连贯性，调整了W3C规范中相关章节的顺序。 用户浏览器（UAs）…"}, {"id": "6844903860700446727", "title": "前端小白的算法之路（一）", "desc": "曾经有一个年少轻狂的职场小白，在前端圈子里摸爬滚打将近两年，本计划在js的道路上越走越远，以至于每天沉浸在js红皮书里不能自拔，突然有一天脑抽想找leader比划两下，于是出现了下面的对话：小白：leader，您最近在干嘛？手里有需要亟待解决的难题吗？leader：咦，确实有哎…"}, {"id": "6844904181858304007", "title": "一篇文章带你了解【图】的结构及相关【算法】", "desc": "几天没更新了, 最近比较多事情做,题目有做就是没时间写文案。现在回来更新一篇理论+算法 今天呢,我只来讲解「图」的结构,毕竟在数据结构中「树和图」比较常用, 当然了这也是建立与链表的基础上才能比较容易的去理解「图和树」 所以还不懂这些数据结构的小伙伴建议先补补知识，再回来看我这…"}, {"id": "6948771509984821256", "title": "leetcode 153. 寻找旋转排序数组中的最小值 ｜刷题打卡", "desc": "153. 寻找旋转排序数组中的最小值 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 注意，数组 [a[0], a[1], a[2], ..., a[n-…"}, {"id": "6844903700645822471", "title": "初探SEO关键词竞争程度的智能算法思路", "desc": "在seo优化过程中，关键词尤其重要。一个恰当的关键词往往可以给网站导入非常大的流量，提升网站的曝光量，带来更多目标用户，使网站产品更好的实现价值。 那么如何找到一个恰当的关键词呢？我们要先了解下关键词竞争程度含义：是指关键词的竞争力大小程度。当我们在搜索引擎中搜索某个关键词时，…"}, {"id": "6844903540679245837", "title": "一些算法和封装的代码", "desc": "平时遇到的一些算法和封装的一些函数，总结出来方便自己以后阅读整理。 字符串中各个字符串出现的次数 reduce 对于低版本兼容性不是很好， 可以用下面的方法 阻止事件冒泡 判断数据类型， typeof typeof 变量 返回的是变量的数据类型，但是不能区分数组和对象 ins…"}, {"id": "6969878372918755336", "title": "前端数据结构与算法之树的基础部分（js 实现）", "desc": "普通树 现实中的树是往上生长的，但是在计数据结构中图例中的树形结构一般是倒过来长的，因为这样从上到下比较好看一些。 一棵普通的树长这样： 从树的这种结构我们可以总结出以下几点相关概念 树结构的一些基础"}, {"id": "6942640884240367646", "title": "剑指 Offer 38. 字符串的排列 js", "desc": "剑指 Offer 38. 字符串的排列 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 分析题目，我们可以很容易地看出可以使用遍历的方法进行求解，即为树形问题，使用回溯法。在该题中，题目没有说明字符串中字符不重复，故…"}, {"id": "6844903850579607566", "title": "FreeCodeCamp 算法题 2", "desc": "上面的是反向截取，如果我们要正向截取呢，那我们要知道从第几位开始。str.length 和 target.length 相减就 ok 了 str.slice(beginSlice[, endSlice]) 截取字符串的一部分，返回作为一个新的字符串，不影响原字符串。 begin…"}, {"id": "6844903495946993672", "title": "回敬尾巴是阿里的某资深：手撸一个基于html字符串模板的Virtual DOM", "desc": "之前发表了HTMLStringParser，但是撸完之后觉得没完，顺着逻辑可以撸出一个Virtual DOM，于是就继续撸了。这篇文章在HTMLStringParser的基础上，全面阐释了撸一个Virtual DOM的全部逻辑思路，并且有源码可以参考。"}, {"id": "6844903668458717198", "title": "使用WebAssembly实现前端运行Kociemba算法自动解魔方", "desc": "Kociemba算法，又称为Two-Phase算法或者二阶段算法；本质上是利用搜索算法来还原魔方； 当然这里并不准备仔细聊这个算法的实现，毕竟我也不是很清楚！ 接下来的内容是怎么使用WebAssembly技术让C语言实现的Kociemba算法在浏览器环境中也能运行起来。"}, {"id": "6844903619943202830", "title": "小白的diff算法试试水之旅", "desc": "1. 主角1：Element构造函数 先介绍一下虚拟dom的数据结构，我们都知道源码里面有createElement函数，通过他创建虚拟dom，然后调用render函数。还记得VUE脚手架住入口文件那句足够装逼的h=>h(App)吗，其实就是类似createElement(Ap…"}, {"id": "6915389791919013895", "title": "javascript算法之字典 必出精品", "desc": "给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 6、 leetcode 76. 最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意：如果 s…"}, {"id": "6844903863816814605", "title": "05|数组:为什么很多编程语言中数组都从0开始编号?", "desc": "数组，是日常开发中用到的最多的数据结构之一，自己一度认为数组太简单了，不就是通过下标拿元素，遍历数组，查找排序等操作。对数组的理解太浅显了，直到看了大佬对数组的介绍，才发觉自己真是坐井观天，今日就来聊一聊数组。 数组专业一点来说是属于“线性表”的一种，它用一组连续的内存空间来存…"}, {"id": "6844904117295382541", "title": "教练我想之<复杂度分析>", "desc": "是的，对于大部分开发来说，网上的现有框架已经足够我们平时的开发了,很多现成的框架，封装使用方便，拿来就用，还不用太担心性能的问题。而我们已经很少需要自己实现数据结构和算法。 不需要自己实现，并不代表什么都不需要了解。如果不知道这些类库背后的原理，不懂得时间、空间复杂度分析，你如…"}, {"id": "6978077713638621197", "title": "JSMS26-反转链表-剑指offer16", "desc": "题目描述，给定一个单链表的头结点，返回逆置之后的头结点。 分析：逆置单链表我已经写烂了，说句实话逆置单链表还是有点点难度的。直接上代码了 核心代码就上面那些，传进去的是带头结点的单链表。其中p是头结点"}, {"id": "6844903710674386957", "title": "一些常用的算法技巧", "desc": "例：在统计一个字符串中字幕出现的次数时，我们就可以把这些字母当做数组下标，在遍历的时候，如果字母A遍历到，则arr['a']就可以加1了。 其实这两种方法的思想是一致的。 例：给你n个无序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复…"}, {"id": "6938643505657053192", "title": "[LeetCode1281题整数的各位积和之差] | 刷题打卡", "desc": "原题地址: 1281. 整数的各位积和之差 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 把n转成字符串str。 循环字符串str，每个值str[i]依次相加、相乘(注意对str[i]的处理)。 然后就可以得到题目中所要求的积和和了，然后返…"}, {"id": "6890086646973202439", "title": "前端必会数据结构与算法系列之树(六)", "desc": "1. 什么是树 位于树顶部的节点叫作根节点。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖父节点等。…"}, {"id": "6920011093788065800", "title": "  算法进阶—[leetcode] 27.移除元素", "desc": "给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 函数应该返回…"}, {"id": "6844903684866834440", "title": "基于 Generator 和 Iterator 的惰性列表", "desc": "上面的几个表达式产生的都是无限列表。对于习惯了主流编程语音的朋友可能感到困惑，在有限的内存里面如何能表达无限的概念。主要的原因就是 Haskell 是一门默认采用惰性求值策略的语言，没有用到的部分，在内存里面只是一个表达式，并不会真正的去做计算。 如果\b只看上面的几个表达式，很…"}, {"id": "6844903633788600333", "title": "浅析node中流应用(一)  可读流(fs.createReadStream)", "desc": "当我们学习新知识的时候，首先我们知道为什么要学习，那我们为什么要学习流?因为在在node中读取文件的方式有来两种，一个是利用fs模块，一个是利用流来读取。如果读取小文件，我们可以使用fs读取，fs读取文件的时候，是将文件一次性读取到本地内存。而如果读取一个大文件，一次性读取会占…"}, {"id": "6878162852637573133", "title": "【西法带你学算法】一次搞定前缀和", "desc": "我花了几天时间，从力扣中精选了五道相同思想的题目，来帮助大家解套，如果觉得文章对你有用，记得点赞分享，让我看到你的认可，有动力继续做下去。 467. 环绕字符串中唯一的子字符串(中等) 795. 区间子数组个数(中等) 904. 水果成篮(中等) 992. K 个不同整数的子数…"}, {"id": "6844903810599485454", "title": "二叉搜索树的前驱和后继", "desc": "已删！"}, {"id": "6922958419099910157", "title": "前端就该用 JS 刷算法28（待补）", "desc": "313. 超级丑数 313. 超级丑数"}, {"id": "6937591180527927333", "title": "刷leetcode-用队列实现栈 | 刷题打卡", "desc": "请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。 void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean…"}, {"id": "6938258160113156103", "title": "「算法」714. 买卖股票的最佳时机含手续费 | 刷题打卡", "desc": "给定一个整数数组 prices，其中第 i 个元素代表了第i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意： 这…"}, {"id": "6844903496727134221", "title": "去哪儿网迷你React的研发心得", "desc": "去哪儿网迷你React是年初立项的新作品，在这前，去哪儿网已经深耕多年，拥有QRN（react-native的公司制定版），HY（基于React的hybird方案）， yo(基于React的移动UI库)，QRN-web(基于React的三端合一移植方案)，此外，像机票等部门也大规"}, {"id": "6938590127409070110", "title": "[LeetCode 146. LRU缓存机制] | 刷题打卡", "desc": "缓存在计算机网络上随处可见，例如：当我们首次访问一个网页时，打开很慢，但当我们再次打开这个网页时，打开就很快。 这就涉及缓存在浏览器上的应用：浏览器缓存。当我们打开一个网页时，它会在发起真正的网络请求前，查询浏览器缓存，看是否有要请求的文件，如果有，浏览器将会拦截请求，返回缓存…"}, {"id": "6972165519952576526", "title": "LeetCode第665题：非递减数列", "desc": "题干 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)"}, {"id": "6896614242980462599", "title": "字典树 —— 字符串分析算法", "desc": "这里我们继续来编程训练，在《前端进阶》这个系列里面我们已经讲过一些字符串的算法了。然后这篇文章我们就来一起学习，剩下的几个字符串中比较细节的算法。 在开始之前我们先来看看字符串算法的一个整体目录。这里我们从简单到难的算法来排列，大概就分成这样一个顺序： 它跟字典树最大的区别就是…"}, {"id": "6977663197360685093", "title": "前端算法与数据结构之算法思想（四）", "desc": "前端算法与数据结构之栈、队列、链表（一） 前端算法与数据结构之集合、字典、树（二) 前端算法与数据结构之图、堆、搜索排序（三） 14、 算法思想之“分而治之” 14-1分而治之是什么? 分而治之是算法"}, {"id": "6844903599768600589", "title": "js版本的（广、深）度优先搜索", "desc": "0. 前言 广度优先搜索(BFS)和深度优先搜索(DFS)，大家可能在oj上见过，各种求路径、最短路径、最优方法、组合等等。于是，我们不妨动手试一下js版本怎么玩。 队列是先进先出，后进后出，常用的操作是取第一个元素（shift）、尾部加入一个元素（push）。 栈是后进先出，…"}, {"id": "6844903504876683277", "title": "React作者的构思和演绎（翻译）", "desc": "我通过这篇文章试图阐述我对React模型的理解，阐述我们是如何用【演绎推导】来帮助我们得到最后的设计。当然，这里有很多的前置条件是有争议的，而且这篇文章中的例子是有缺陷和漏洞。但这是我们正式地去规范化"}, {"id": "6972085866642702372", "title": "leetcode top100挑战, 每天不鸽一道题之 寻找两个正序数组的中位数(2/100)", "desc": "题目描述 寻找两个正序数组的中位数 标签 暴力枚举 双指针 解题分析 1. 暴力枚举 直接直向思维，两个有序的数组，求中位数。把他变成一个有序的数组就行了。 然后求中位数，当一组数据的数量为奇数时， "}, {"id": "6922805966828208141", "title": "Leetcode之买卖股票题目总结", "desc": "关于股票买卖的题目，都可以用动态规划来解决，我们要根据具体题目，分析不同的初始条件以及转移方程。在接下来的每一道题目中，我都会提供使用动态规划方法的解答，以及一些针对某道特定的题目，更为简单的解答思路。 假设以dp[i]来表示第i天的最大利润，我们以dp[i][0]和dp[i]…"}, {"id": "6844903646552047629", "title": "用遗传算法求解旅行商问题（JavaScript版）", "desc": "来自 oldj's blog，一位旅行商人需要辗转若干个城市卖东西，每个城市只去一次，最终需要回到出发的城市，问如何规划路线，使得总旅程最短…"}, {"id": "6971286254738472990", "title": "LeetCode第406题：根据身高和序号重组队列", "desc": "题干 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 "}, {"id": "6847902221770686477", "title": "面试时写不出排序算法？看这篇就够了（下）", "desc": "递归是一种解决问题的方法，它解决问题的各个小部分，直到解决最初的大问题。通常涉及函数调用自身。 假设现在必须要执行recursiveFunction，结果是什么？单单就上述情况而言，它会一直 执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件（停止点）， …"}, {"id": "6971037179074052133", "title": "LeetCode第435题：无重叠区间", "desc": "题干 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 "}, {"id": "6971036346563428365", "title": "LeetCode第452题：用最少数量的箭引爆气球", "desc": "题干 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标"}, {"id": "6971036346076889102", "title": "LeetCode第455题：分发饼干(贪心思想)", "desc": "题干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一"}, {"id": "6844903603929350158", "title": "排序算法-N个正整数排序", "desc": "重复地比较要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。比较数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。每比较一整轮,最大的都会出现在最后故名---冒泡排序 2. 选择排序(SELECT) 每一次从待排序的数据元素中选出最小（或最…"}, {"id": "6914828089851641869", "title": "前端就该用 JS 刷算法7", "desc": "然后就是再次中序遍历树，这次只有找到改变值，然后将另外的值赋值过去即可。 547. 省份数量 初始化是将每个城市都是一个集合，当遍历结束了，那么同一个省的城市已经合并成了一个集合，最后剩下来的集合就是省份隔离，就是省份的数量了。"}, {"id": "6893473217589280781", "title": "Leetcode 鸡蛋掉落多解法 ", "desc": "2. 动态规划 3. DP + 二分查找 Leetcode-887. 鸡蛋掉落"}, {"id": "6944549725345579016", "title": "力扣本周每日一题回顾 456.132模式", "desc": "本周力扣题目中等简单为主，后几天主要考察链表（中等难度），总体难度都不难，个人感觉周三的132模式这题解题比较巧妙，拓展思维，下面来分享解题思维。 题目：给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 …"}, {"id": "6844903613479796750", "title": "完全理解HTTPS如何做到传输安全", "desc": "HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。"}, {"id": "6936426323363495973", "title": "[ 力扣121 ] 买卖股票的最佳时机（图解）| 刷题打卡", "desc": "给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 5 天（股票价格…"}, {"id": "6844903905420115975", "title": "LeetCode 1. 两数之和：JavaScript 的三种解法", "desc": "看到题目后最先想到的就是两个循环嵌套，遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。 为了对运行时间复杂度进行优化，我们可以使用哈希表。一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，…"}, {"id": "6935445969613881358", "title": "剑指Offer系列算法-JavaScript解法-2｜刷题打卡", "desc": "输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 树的前中后序遍历都属于算法基础，不懂的请自行反思。 这种解法算是最普通的解法，由于多次使用了slice()方法，创建了多个数组，因此在时间和空间耗费上大幅增加，非常糟…"}, {"id": "6844904175323594765", "title": "LeetCode 18 - 4数之和 - 解题思路记录 - Golang", "desc": "我们再来介绍一道题目, 是建立在以前的基础上的, 那就是3数之和的基础上,如果你没看过这个教程的话,记得先补一下 LeetCode 15 - 3数之和 - 解题思路记录 - GoLang 在这道题的基"}, {"id": "6844903762960580615", "title": "看过上百部片子的这个人教你视频标签算法解析", "desc": "随着内容时代的来临，多媒体信息，特别是视频信息的分析和理解需求，如图像分类、图像打标签、视频处理等等，变得越发迫切。目前图像分类已经发展了多年，在一定条件下已经取得了很好的效果。本文因实际产品需求，主要探讨一下视频打标签的问题。 查阅了部分资料，笔者拙见，打标签问题无论是文本、…"}, {"id": "6969588473434996772", "title": "动态规划问题—打家劫舍", "desc": "动态规划问题，打家劫舍。和爬楼梯问题类似，先判断能不能由子问题解决。在推出转移方程，按照方程式解决该类问题。"}, {"id": "6969587609395953695", "title": "leetcode: 525-连续数组", "desc": "每天做个总结吧，坚持就是胜利！ leetcode: 525-连续数组: 使用hashMap； 多做做类似的题。"}, {"id": "6934549158749732877", "title": " 删除排序数组中的重复项(初级算法)｜刷题打卡", "desc": "给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 数组完成排序后，我们可以放置两个指针 和 ，其中 是慢指针，而 是快指针。只…"}, {"id": "6844903521268203528", "title": "[面试∙网络] TCP/IP（五）：TCP 协议详解", "desc": "上一节 中讲过，TCP 协议是面向有连接的协议，它具有丢包重发和流量控制的功能，这是它区别于 UDP 协议最大的特点。本文就主要讨论这两个功能。 丢包重发的前提是发送方能够知道接收方是否成功的接收了消息。所以，在 TCP 协议中，接收端会给发送端返回一个通知，也叫作确认应答（A…"}, {"id": "6994827960922406920", "title": "行为委托", "desc": "[[prototype]]机制是指对象中的一个内部链接引用另外一个对象，其本质就是对象之间的关联关系(行为委托机制)； 面向类设计模式： ES6 class语法糖： 对象关联风格委托（行为委托模式）:"}, {"id": "6994827660052398111", "title": "树的遍历", "desc": "学习目标： 学习树的遍历； 练习python语法； leetcode学习资料树的遍历 遍历方式： 中序遍历 后续遍历 前序遍历 层序遍历 练习 二叉树的中序遍历 语言：JavaScript 语言:py"}, {"id": "6844904133292457997", "title": "前端工程师的 LeetCode 之旅 -- 夜喵 24", "desc": "给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startVal…"}, {"id": "6886255820275875847", "title": "有关链表的小技巧，我都给你总结好了", "desc": "链表链表是数据结构里一个很基础但是又很爱考的线性结构，链表的操作相对来说比较简单，但是非常适合考察面试者写代码的能力，以及对 corner case 的处理，还有指针的应用很容易引起 NPE (nul"}, {"id": "6844904191073189896", "title": "常见leetCode算法题目分享", "desc": "1. 前言 最近回顾了一下以前做过的leetCode题目，主要是字符串和数组相关为主，本文整理一下常见的题目，解题思路。本人是算法萌新，互相学习，大神勿喷。 这个题目还是比较简单的：循环一遍字符串，建一个空对象用来保存字符的数量即可。 这个题目只是上一个题目的变形而已，计算出出…"}, {"id": "6845166890944299022", "title": "LeetCode 1122. 数组的相对排序：JavaScript 计数排序解法", "desc": "这是一道排序的题目，那么我们首先应该想到一些常见的排序算法。主要分为两类，一类是基于比较的排序算法，例如快速排序和堆排序等。另一类是非基于比较的排序算法，包括计数排序和桶排序等。基于比较的排序算法的最优化时间复杂度也无法小于 。而非基于比较的排序算法则可以实现更低的时间复杂度。…"}, {"id": "6869185806976843790", "title": "vue的keep-alive算法实现——LRU", "desc": "当做组件切换时，可以使用keep-alive将组件包裹起来，可以起到保持这些组件的状态，以避免反复重渲染导致的性能问题。 简单一句话： keep-alive是做组件缓存用的，可以避免组件反复渲染。 LRU：Least Recently Used，最近最少使用，主要应用场景是缓存。"}, {"id": "6936194200459280415", "title": "226. 翻转二叉树｜刷题打卡", "desc": "226. 翻转二叉树｜刷题打卡 翻转一棵二叉树。 这也是一道简单题，不过对我们这些算法小白来说是个认识树这一数据结构的不错选择。 树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null 或 empty)树。一棵非空的树包括一个根…"}, {"id": "6891684098457206791", "title": "前端学数据结构与算法（十一）：看似简单又让人抓狂的二分查找算法", "desc": "二分查找法是一种高效的查找算法，它的思想非常好理解，但编写正确的二分查找并不简单。本章从最基础的二分查找实现开始，讲解其编写技巧，接下来介绍它的四个常见变种的编写，最后应用二分查找来解决真正的面试题，学以致用的同时更加深对其的理解，真正掌握它。 这是一种在有序的数组里快速找到某…"}, {"id": "6844903520022298638", "title": "归并排序与快速排序的简明实现及对比", "desc": "归并排序与快速排序是两种有实际应用的排序算法，它们有一些共同的特点，整体思路上也比较相近。本文会从更简单的一些排序算法开始，过渡到归并排序和快速排序的实现，并对它们做一些简单的对比思考和总结。在这之前，先简单介绍一下排序算法的意义。 排序算法就是将一串数据依照特定排序方式进行排…"}, {"id": "6981076496748118029", "title": "JSMS35-KMP算法的实现", "desc": "KMP算法理解之后实现比较容易的。 解析：Pattern是一个模式匹配串,也就是在字符串中找到Pattern第一次出现的位置。prefix是前缀表，也就是严蔚敏书上的next数组，最大公前缀，比如ab"}, {"id": "6936459996687237156", "title": "5种经典排序算法js实现 | 刷题打卡", "desc": "排序算法在工作和学习中很常见，今天主要用js实现冒泡排序，插入排序，选择排序，归并排序，快速排序。 注意： ① 空间复杂度一般指额外空间复杂度 ② 算法稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，则称这个算法稳定。 …"}, {"id": "6844903613790158862", "title": "简析Myers", "desc": "Myers差分算法是由Eugene W.Myers在1986年发表的一篇论文中提出，可以查看文末链接1。 diff结果有很多，譬如可以将一个字符串全部删除，再添加另一整个字符串。可以删一个字符添加一个字符…… 现在从(0, 0)点出发，这时字符串为a, 通过向右移动，即增加x值…"}, {"id": "6985407616553844750", "title": "LeetCode第543题：翻转二叉树", "desc": "题干 翻转一棵二叉树。 示例： 输入： 输出： 解法：深度优先搜索 首先使用二叉树的后序遍历，递归函数的结束条件是root==null时，说明root已经为叶子节点，接着记录当前节点的右子树于左子树，"}, {"id": "6918343693590249480", "title": "算法学习-代码效率优化方法论-七日打卡", "desc": "顾名思义，其实时间复杂度就是说这段代码的计算量所能消耗的时间，而空间复杂度就是这段代码所占据的内存空间。 总的策略就是降低代码的时间复杂度和空间复杂度。 但是对于一段代码来说往往时间和空间两个是互斥的，如果我们想要降低时间复杂度，那么无疑就会增加空间复杂度。 举一个生活中的🌰…"}, {"id": "6969199108724785188", "title": "两个动态规划问题", "desc": "动态规划是求解决策过程最优化的数学方法，后来沿用到了编程领域。本篇文章主要介绍两个基础问题：爬楼梯问题和挖金矿问题。"}, {"id": "6936930668551077925", "title": "[LeetCode155题最小栈] | 刷题打卡", "desc": "本来想着今天的题解写今天的每日一题131. 分割回文串来着，但是我还没有特别明白，所以就没有写，就用掘金刷题打卡活动群里今天的推荐题来写吧😄😄 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中…"}, {"id": "6844903712314359822", "title": "canvas像素画板", "desc": "最近项目上要实现一个类似像素风格的画板，可以像素小格子可以擦除，框选变色，可以擦出各种图形，这样一个小项目看似简单，包含的东西还真不少。 这样做看似完美，然而有一个巨大毙命，每画一个像素都回绘制到上下文中，每一次都在改变canvas的状态，这样做会导致渲染性能太差，因为像素点很…"}, {"id": "6844903753821224968", "title": "JavaScript 算法之最好、最坏时间复杂度分析", "desc": "上一篇--JavaScript 算法之复杂度分析文章中介绍了复杂度的分析，相信小伙伴们对常见代码的时间或者空间复杂度肯定能分析出来了。 接下来，稍微优化下这个 find 函数，如果查找到目标的话，就没必要再往后查找了。 现在代码的时间复杂度还为 O(n)吗？不确定，利用上一章的…"}, {"id": "6924192210489458702", "title": "算法刷题——map、位运算、贪心", "desc": "给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 用map存放s的各个字符的频率，然后遍历t的时候逐一减去，直到遇到减为0或者不存在的键就输出。 位运算,把两个字符串看成一个字符串…"}, {"id": "6876216057070092301", "title": "在市值破万亿美元的公司工作，是一种怎样的体验？", "desc": "这里是《齐姐聊大厂》系列的第 7 篇（前 6 篇见文末）每周五早上 8 点，与你唠唠大厂的那些事。小齐说：8 月 19 日，苹果公司股价飙升至 468 美元，总市值首次超过 2 万亿美元。虽然疫情影响"}, {"id": "6969957631973097486", "title": "图的最短路径算法-Dijkstra算法 ", "desc": "Dijkstra 的全名叫 Edsger Wybe Dijkstra（艾兹赫尔·韦伯·戴克斯特拉），Dijkstra算法便是由Dijkstra本人发明的求图最短路径的算法，中文名为[迪杰斯特拉]算法。"}, {"id": "6844903765036761101", "title": "算法篇 - 二叉搜索树", "desc": "在前端的工作当中，二叉搜索树不怎么常见，虽然没有快排、冒泡、去重、二分、希尔等算法常见，但是它的作用，在某些特定的场景下，是非常重要的。 上图是我从网上找的，最主要是让大家看一下，树长啥样。 在这里简单的介绍一下有关二叉搜索树的术语，在后续讨论中将会提到。一棵树最上面的节点称为…"}, {"id": "6995901881901924383", "title": "平衡二叉排序树", "desc": "AVL树 ------------------------ 平衡二叉树排序树 记插入删除调整操作"}, {"id": "6844903504507568135", "title": "前端性能优化之图片篇", "desc": "前端性能优化，不止于前端。"}, {"id": "6844903506994806791", "title": "每天一小时，我读完了第一本书《JavaScript设计模式与开发实践》", "desc": "内容不错的第一本书，喜欢的同学可以去我做的笔记上面进行简单的查阅，当然想要阅读更多内容的同学，一定要支持作者，购买正版书籍，是非常值得入手的一本书。"}, {"id": "6943380655384297508", "title": "前端刷题路-Day4", "desc": "给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数…"}, {"id": "6949804426374676488", "title": "14.队列合并排序｜刷题打卡", "desc": "14.队列合并排序｜刷题打卡 掘金团队号上线，助你 Offer 临门！ 多个队列，分别是从小到大排序。实现一个方程，把所有队列合并成一个从大到小排序的新队列"}, {"id": "6991663481086820388", "title": "算法面试", "desc": "- 不代表能够“正确”回答每一个算法问题，但是合理的思考方向其实更重要，也是正确完成算法面试问题的前提 - 算法面试优秀不意味着技术面试优秀 - 技术面试优秀不意味着能够拿到Offer"}, {"id": "6991659177957392420", "title": "3周攻克数据结构[数组篇-1] ｜8月更文挑战", "desc": "Day1 1. 存在重复元素 示例 👇🏻 方法1：Set结构 方法2：优化版暴力解法 2. 最大子序和 方法1：动态规划 DAY2 1. 两数之和 方法1：爆破 方法2：哈希表查询 2. 合并两个有序"}, {"id": "6874732891276836877", "title": "一文学懂递归和动态规划", "desc": "前言大家好，这里是《齐姐聊算法》系列之递归和DP问题。递归，是一个非常重要的概念，也是面试中非常喜欢考的。因为它不但能考察一个程序员的算法功底，还能很好的考察对时间空间复杂度的理解和分析。本文只讲一题"}, {"id": "6872131047032553486", "title": "多线程必考的「生产者 - 消费者」模型，看齐姐这篇文章就够了", "desc": "生产者 - 消费者模型 Producer-consumer problem 是一个非常经典的多线程并发协作的模型，在分布式系统里非常常见。也是面试中无论中美大厂都非常爱考的一个问题，对应届生问的要少一"}, {"id": "6991477741447020581", "title": "LeetCode 37 Sudoku Solver (Tag:Array Difficulty:Hard)｜8月更文挑战", "desc": "前言 关于 LeetCode 数组类型题目的相关解法，可见LeetCode 数组类型题目做前必看，分类别解法总结了题目，可以用来单项提高。觉得有帮助的话，记得多多点赞关注哦，感谢！ 题目描述 编写一个"}, {"id": "6991471028950007844", "title": "「前端刷题」1.两数之和｜ 8月更文挑战", "desc": "题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数"}, {"id": "6844903896687575053", "title": "JavaScript 字符串匹配算法", "desc": "字符串匹配算法，在日常开发中也常被频繁用到。当然，我们可以用正则匹配来完成字符串匹配，但是，学习和理解相关的字符串匹配算法，对于我们技术成长还是有很多好处的。 字符串匹配算法，是在实际工程中经常遇到的问题，也是各大公司笔试面试的常考题目。此算法通常输入为原字符串（string）…"}, {"id": "6979928188709240869", "title": "记一道算法题：最小覆盖子串", "desc": "题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意：如果 s 中存在这样的子串，我们保证"}, {"id": "6844904101927469063", "title": "前端工程师的 LeetCode 之旅 -- 周赛 181", "desc": "给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。 按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。 重复上一步，直到在 …"}, {"id": "6969763084818710559", "title": "常用树形结构算法分享", "desc": "1.树介绍： 树（英语：tree）是一种抽象数据类型（ADT），用来模拟具有树状结构性质的数据集合。 它是由n（n>=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂"}, {"id": "6898899034090504205", "title": "前端剑指offer算法题整理", "desc": "1、在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 2、请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为W…"}, {"id": "6844903721483108366", "title": "三行代码实现 JS 柯里化", "desc": "最近有看到一些柯里化的文章，怎么说呢，感觉很奇怪。一篇是阿里云的译文，文章末尾给出了这样一个 \"curry\"： 在我们自己实现之前，对柯里化没什么概念的同学可以看下 wiki（要看英文 wiki，中文 wiki 对柯里化的解释写得又乱又不准确，容易和部分应用混淆），简单来说柯里…"}, {"id": "6990532472279105572", "title": "刷完这几道堆题，可能还是手撕不了大厂面试", "desc": "前言 对于我与堆的渊源，那得从2年前说起，那时候我年少轻狂，意气风发，刚入前端之门就憧憬着1年打开大厂之门，3年P7 走上人生巅峰； 是他，那个男人，用那么的一道猥琐而又不失分寸的算法将我从云端拉回来"}, {"id": "6844903629573324807", "title": "GMTC 大前端时代前端监控的最佳实践", "desc": "本文为2018年6月21日，在北京举办的GMTC(全球大前端技术大会)，下午性能与监控专场，由阿里云前端监控团队前端技术专家彭伟春带来的演讲稿，现场反馈效果非常好，地上都坐了三圈，很多人反馈根本无法挤进去。先上现场照。 先做一个自我介绍，我叫彭伟春，英文名是Holden, 阿里…"}, {"id": "6981018609900322830", "title": "带你了解数据结构与算法。附leetcode练习", "desc": "数据结构基础知识 线性结构：线性表（数组、链表、队列、栈、哈希表） 树型结构：二叉树、AVL树、红黑树、B树、堆、Trie、哈夫曼树、并查集。 图形结构：邻接矩阵、邻接表。 leetcode中题目的思"}, {"id": "7002181445481398308", "title": "递归与栈刷题", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 之前写了JavaScript链表刷题，JavaScript链表刷题（二），JavaScript链表刷题（三），JavaScript链表刷题"}, {"id": "6999805246901846053", "title": "算法（leetode，附思维导图 + 全部解法）300题之（14）最长公共前缀", "desc": "零 标题：算法（leetode，附思维导图 + 全部解法）300题之（14）最长公共前缀 导读： 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： "}, {"id": "6989162108034220062", "title": "二叉树相关 - js描述", "desc": "起因 二叉树几乎是面试过程中必问的知识点，大多数描述过程都是通过C、C++、JAVA、python等语言实现，这里用js语言实现下一下类似的功能，前端、nodejs方向和全栈方向的同学可以作为参考。 "}, {"id": "6987658708016693278", "title": "进阶算法之“搜索与排序”", "desc": "### 排序算法 - 冒泡排序 - 选择排序 - 插入排序 - 归并排序 - 快速排序 ### 搜索算法 - 顺序搜索 - 二分搜索"}, {"id": "6844903609885261832", "title": "六种排序算法的JavaScript实现以及总结", "desc": "最近几天在系统的复习排序算法，之前都没有系统性的学习过，也没有留下过什么笔记，所以很快就忘了，这次好好地学习一下。 首先说明为了减少限制，以下代码通通运行于Node V8引擎而非浏览器，源码在我的GitHub，感兴趣的话可以下载来然后运行试试。 只需要输入数组长度，即可生成一个…"}, {"id": "6938385018267893767", "title": "🌲树+8道前端算法面试高频题解｜刷题打卡", "desc": "A 是 根节点。C、D、F、G 是 叶子节点。A 是 B 和 E 的 父节点。B 和 E 是 A 的 子节点。B、E 之间是 兄弟节点。 高度、深度、层 如上图所示。 为了方便理解记忆，高度就是抬头看，深度就是低头看。 与 高度、深度 不同，层 类比盗梦空间里的楼，楼都是从 1…"}, {"id": "6981286962338463774", "title": "【算法】击鼓传花游戏-动态规划之题解之题解", "desc": "阐明学习的误区，总结自己学习算法以来得到的一些思考。丢开晦涩难懂的状态转移公式，用简单的例子和复盘来剖析隐藏在公式中的简单逻辑。"}, {"id": "6844903630156333069", "title": "[译文] 初学者应该了解的数据结构：Array、HashMap 与 List", "desc": "当开发程序时，我们（通常）需要在内存中存储数据。根据操作数据方式的不同，可能会选择不同的数据结构。有很多常用的数据结构，如：Array、Map、Set、List、Tree、Graph 等等。（然而）为程序选取合适的数据结构可能并不容易。因此，希望这篇文章能帮助你了解（不同数据结…"}, {"id": "6987417948533030925", "title": "【算法学习】JavaScript数据结构与算法-栈", "desc": "前言 做程序员的第3个年头，从一名切图仔逐渐成为公司开发的主力，随着业务的深入和经验的积累，算法的学习提上了日程。 从今天开始，我将把平时项目中积累的经验和JavaScript算法结合起来出一个系列的"}, {"id": "6991491440706584589", "title": "小白的冒泡排序及优化方案｜ 8月更文挑战", "desc": "冒泡排序是我接触的第一种算法，最开始只是明白个大概，直到自己手写的时候才明白里面的思想，写下这篇文章，也是方便自己日后回顾。"}, {"id": "6991459784167784456", "title": "一文搞懂并查集", "desc": "并查集概念 并查集（Disjoint-set）是一种数据结构，从字面意思上看，“并”，“查”，“集”，可以简单地理解为：“合并”，“查找”，“集合”。"}, {"id": "6995077622317187085", "title": "前端切图仔，常用的21个字符串方法（上）｜8月更文挑战 ", "desc": "这是我参与8月更文挑战的第9天，活动详情查看： 8月更文挑战 字符串方法 更多方法实例可以参见：JavaScript String 对象。 方法 描述 charAt() 返回指定索引位置的字符"}, {"id": "6966046395728035854", "title": "前端刷题路-Day34：接雨水（题号42）", "desc": "现给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。"}, {"id": "6995538713866403871", "title": "前端算法必刷题系列[85]", "desc": "这是我参与8月更文挑战的第11天，活动详情查看：8月更文挑战 156. 移动零(move-zeroes) 标签 简单 双指针 题目 leetcode 传送门 给定一个数组 nums，编写一个函数将所有"}, {"id": "6971627869294788638", "title": "前端数据结构与算法之图的遍历", "desc": "图的遍历 从图中某个顶点出发，沿图中的路径依次去访问图中的所有顶点，使得每一个顶点刚好被访问一次，这一过程就叫做图的遍历。 对图进行遍历，最常见到的两个算法是广度优先搜索（BFS）和深度优先搜索（DF"}, {"id": "7002790878393827336", "title": "学算法刷LeetCode【剑指offer专题】：18. 删除链表的节点", "desc": "题目描述 解题思路 题目中提示这是个蛋链表，单链表的特征就是节点中有一个指向下一个节点的指针，如果要删除一个节点，直接这个节点的前一个节点指向它的下一个节点即可。跳过要删除的节点，这个节点就被删除了。"}, {"id": "6844903559582973959", "title": "RSA算法详解", "desc": "总括： 本文详细讲述了RSA算法详解，包括内部使用数学原理以及产生的过程。 相濡以沫。到底需要爱淡如水。 之前写过一篇文章SSL协议之数据加密过程，里面详细讲述了数据加密的过程以及需要的算法。SSL协议很巧妙的利用对称加密和非对称加密两种算法来对数据进行加密。这篇文章主要是针对…"}, {"id": "6844903594232119310", "title": "这可能是你学习ES7遗漏的知识点", "desc": "小云终于得到了自己预期的结果，而且还发现了底数的前面不能紧跟一元运算符，即使是+也不行。 哇！终于可以摆脱那个令人讨厌的!== -1了。 难道这两个方法仅仅是在返回值上有区别吗？小云这次决定不再瞎折腾，直接移步ES7文档。 数个小时之后，小云要开始他的表演了。 以至于遇到上述情…"}, {"id": "6844903929470255111", "title": "聊一聊前端算法面试——链表和数组", "desc": "今天来聊一聊前端面试中非常基础的两种数据结构——「数组」和「链表」。 你可以先思考一下如何回答上边的问题🤔，然后带着答案来阅览接下来的内容。 在聊这个问题之前，先看一下数据从逻辑结构上的分类。主要分为两类：线性表和非线性表。 线性表： 数据连成一条线的结构，今天要聊的链表和数…"}, {"id": "6844903878845022216", "title": "『多图警告』手撕排序算法 - 前端进阶必备", "desc": "算法（Algorithm） 已经是一个老生常谈的概念了，最早来自于数学领域。 算法（Algorithm） 代表着用系统的方法描述解决问题的策略机制，可以通过一定规范的 输入，在有限时间内获得所需要的 输出。 一个算法的好坏是通过 时间复杂度 与 空间复杂度 来衡量的。 鱼头跟方…"}, {"id": "6998697178193461261", "title": "前端刷题路-Day87：移动零（题号283）", "desc": "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数..."}, {"id": "6844903600515186702", "title": "ThreeJS简易魔方自动还原实现（一）层先法", "desc": "在ThreeJS四步制作一个简易魔方中介绍了怎么实现一个可以转动的简易魔方，接来下准备介绍下怎么让这个简易魔方具备自动还原的功能。 在210次自动测试中，平均步数为197步，平均时长为44秒，和代码中设定的0.2秒一步基本吻合，从自动测试数据来看，目前的实现还没有达到该算法的最…"}, {"id": "6844903889771167752", "title": "LeetCode 攻略 - 2019 年 7 月上半月汇总（55 题攻略）", "desc": "自 2019-05-16 开始，jsliang 每天折腾一道及以上 LeetCode 题目，并将其解题思路记录成文章，发布到 GitHub 和 微信公众号。 2019/08/15 前。LeetCode 简单难度题目 - 完成 100 道简单 LeetCode 题目的题解。 20…"}, {"id": "6844903793180557326", "title": "知多一点有限状态自动机", "desc": "hello~亲爱的观众老爷们大家好~最近 LeetCode 上的算法已经刷得差不多了（剩下都是 hard，不看答案是不会做了），是时候小结一下在刷题过程中，学到的一些有意思的知识点。相信大家对 React 都有一点了解，可能也看过类似的说法：“React 把组件看成是一个状态机…"}, {"id": "6844903630055669773", "title": "React Diff理解", "desc": "一提到React，学过的人都会想到提高性能的两大神奇特色：虚拟DOM & diff算法。React diff作为Virtual DOM的加速器，其算法的改进优化是React整的界面渲染的基础，以及性能提高的保障。虽然开发中不需要知道其运行机制，但是理解之后有助于更好的理解Rea…"}, {"id": "6938395524374953991", "title": "45. 跳跃游戏 II  | 刷题打卡 ", "desc": "前言“  贪心算法“是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策"}, {"id": "6972905244917252126", "title": "JS 实现二叉树遍历", "desc": "常见的二叉树遍历方式主要分为前序、中序、后序遍历和层序遍历。 层序遍历很容易理解，就是一层层地进行记录，而前序、中序和后序遍历中的「前」、「中」、「后」指的是二叉树的根节点被取值的先后，节点左右两边节"}, {"id": "6963054953812197384", "title": "前端刷题路-Day30：省份数量（题号547）", "desc": "省份数量（题号547） 题目 有n个城市，其中一些彼此相连，另一些没有相连。如果城市a与城市b直接相连，且城市b与城市c直接相连，那么城市a与城市c间接相连。 省份 是一组直接或间接相连的城市，组内不"}, {"id": "6885497035773247501", "title": "🔢【程序中的数学】利用德摩根定律简化布尔运算", "desc": "今天说说德摩根定律在编程中的实践，题目看的很吓人，其实只要有一点点的高中数学知识就能看懂，而且这部分知识掌握后可以很快的运用到项目中，投资收益比非常高。 短短一行的逻辑判断里，与或非三个运算符都用上了，尤其是最后那个小括号一圈全体取反的操作，我脑子直接炸了。要知道人脑是很不擅长…"}, {"id": "6989789225268805639", "title": "算法（leetode，附思维导图 + 全部解法）300题之（3）无重复字符的最长子串", "desc": "标题：算法（leetode，附思维导图 + 全部解法）300题之（3）无重复字符的最长子串 一 题目描述 二 解法总览（思维导图） 三 全部解法 1 方案1 1)代码： 2 方案2 1)代码： 3 方"}, {"id": "6983947290033520676", "title": "算法基础（冒泡排序跟快速排序）", "desc": "冒泡排序： 冒泡排序的原理：重复的遍历要排序的数组，每次遍历过程中从头至尾比较两个相邻的元素，若顺序错误则交换两个元素。 思路： 1.冒泡排序是比较相邻位置的两个数，而选择排序是按顺序比较，找最大值或"}, {"id": "7001012577526349832", "title": "前端算法入门之路（十五）（手撕AVL树）--开课吧门徒计划历程", "desc": "平衡二叉排序树 二叉排序树 二叉排序树又叫二叉搜索树、二叉查找树 性质：1、左子树小于根节点 2、右子树大于根节点 用途：解决与排名相关的检索需求 二叉排序树删除操作 叶子节点：可以直接删除 出度为1"}, {"id": "6902289520876584968", "title": "来和大家聊聊我是如何刷题的（第一弹）", "desc": "今天给大家聊聊怎么刷题， 预计分几篇文章来写，今天是第一篇。 话不多说，直接上干货。 我的做法是集中时间只刷某一类的题目。这样对某一类题目就很有心得，做题就有题感，不会做一道是一道，下次碰到类似的题，甚至原题都不会。其实很多算法都是息息相关的，等你攻克了足够多的专题之后，算法知…"}, {"id": "6922025046810558471", "title": "几乎刷完了力扣所有的堆题，我发现了这些东西。。。（第二弹）", "desc": "上次在我的公众号给大家做了一个小调查《投出你想要的题解编程语言吧~》。以下是调查的结果： 而关于其他，则大多数是 Go 语言。 由于 Java 和 Python 所占比例已经超过了 60%，这次我尝试一下 Java 和 Python 双语言来写，感谢 @CaptainZ 提供的…"}, {"id": "6988897221479497765", "title": "数据结构之“链表”", "desc": "链表简介 链表是什么？ 多个元素组成的列表。 元素存储不连续，用next指针连在一起 数组 vs 链表 数组：增删非首尾元素时往往需要移动元素 链表：增删非首尾元素，不需要移动元素，只需要更改next"}, {"id": "7000759457097449508", "title": "「前端刷题」25. Reverse Nodes in k-Group", "desc": "这是我参与8月更文挑战的第25天，活动详情查看：8月更文挑战 leetcode-cn好像又挂了，用英文吧 题目 Given a linked list, reverse the nodes of a "}, {"id": "6953579336519647269", "title": "善于利用 查找表 解决查找问题", "desc": "在算法里，经常会将在数组里的某种操作变成查找表，从而降低时间复杂度： - 快速找到数组中某个值的位置 - 快速找到数组中某个值出现的次数"}, {"id": "6844903593393258510", "title": "最考验换位思考的一道算法题", "desc": "最近在本站沸点上看到网友（@猫D）的一道数学题。仔细分析后，真心觉得那叫一个难啊，脑子很容易枯竭。。。 想了好久，终于想明白了，本文准备用JS解决它。 我们先看看正确答案：4 和 13。 因为正确答案是 4 和 13，那么甲知道的数字是52，甲又知道 52 可以写成 2 * 2…"}, {"id": "6844904190653775886", "title": "【数据结构与算法】用动图解说数组、链表、跳表原理与实现", "desc": "在学习数据结构与算法的过程中，感觉真的是一入算法深似海，但是越学越觉得有趣。不过我们会发现在终身学习的过程中，我们都是越学越多，不知的也越来越多，但是更渴望认知更多的知识，越是对知识感兴趣。 本期讲说最常见的数据结构类型分别有数组、链表、跳表。这一期我们一起来了解它们的原理与实…"}, {"id": "6880291677651599367", "title": "一分钟带你读懂什么是堆？", "desc": "上一篇的 「Java 集合框架」里，还剩下一个大问题没有说的，那就是 PriorityQueue，优先队列，也就是堆，Heap。什么是堆？堆其实就是一种特殊的队列——优先队列。普通的队列游戏规则很简单"}, {"id": "6844904177533992967", "title": "高频面试考题：荷兰旗问题", "desc": "因为荷兰旗就三种颜色嘛，那这道题的问题就是给你三种颜色，按照给定的顺序排好。 当然了，题目的问法各种各样，有的给数字，有的给字母，但本质都是一样的。 还是用我们经典的「挡板法」。 这里 j 放在未排序区间的左边和右边都行，但基本上大家都是放左边，所以我们也没必要“标新立异”。 …"}, {"id": "6993326145659912223", "title": "「前端刷题」6. Z 字形变换", "desc": "将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"PAYPALIS"}, {"id": "6972903613484302366", "title": "树形结构-二叉树", "desc": "这是我参与更文挑战的第5天，活动详情查看：更文挑战 至多2个分叉，如果有3个或以上，叫多叉树 生活上的树形结构 使用树形结构可以大大提高效率，也是面试中的重点。 树的基本概念 节点、根节点、父节点、子"}, {"id": "6883814964874100749", "title": "动态规划入门，你会了吗", "desc": "动态规划（Dynamic programming，简称DP）, 是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划算法通常用于求解具有某种最优性质的问题。动态规划算法与分治法类似，其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，然后依赖这些子问…"}, {"id": "6844904055391649806", "title": "BigPipe和微前端", "desc": "你可能听说过 BigPipe，这是一个十多年前的技术，而 BigPipe 通常都会跟“性能优化”同时被提起。微前端也是一个很早被提出的技术，但是最近几年才开始比较流行。而目前微前端能够解决的最大的问题恐怕就是遗留系统改造。我们可以将新技术构造的系统和旧技术构造的系统完美融合到一…"}, {"id": "6893409839423340552", "title": "[数据结构与算法-小白系列]第2️⃣天链表", "desc": "回顾第一天我们学习了栈和队列[数据结构与算法-小白系列]第1️⃣天栈、队列今天我们来学习下另外一种重要的数据结构链表,个人感觉链表理解起来比栈和队列要难,但不管咱们样干就完了链表和栈,队列有着本质不同"}, {"id": "6844904082637848589", "title": "前端工程师的 LeetCode 之旅 -- 178周赛", "desc": "给你一个数组 nums，对于其中一个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之m，对于每一个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i]。 以数组的形式返回答案。 本题数据规模…"}, {"id": "6987758961785044999", "title": "LeetCode算法学习之--二分查找--爱吃香蕉的珂珂", "desc": "大家好今天给大家分享下一道 LeetCode 中等难度 的题目 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/count-of-range-sum/) 题目 分析"}, {"id": "6844903921496899592", "title": "剑指offer JavaScript实现", "desc": "在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：选择最左下角的那个点作为起始点，也就是a[array.lenth][0],比它…"}, {"id": "6918930997531082765", "title": "算法与数据结构 - 递归 Recursion", "desc": "递归其实本质上类似于循环，只不过是调用本身循环体，来实现循环。 循环本身编译出来的汇编代码，和递归本身有异曲同工之处。 向下进入到不同到梦境当中；向上有回到原来一层。 是不是和递归一样，第三点，主角可以穿越不同的梦境，同时把自己和携带的东西带到不同的梦境中，同时可以携带回来。就…"}, {"id": "6914929940035010574", "title": "《JS玩算法系列》海王的鱼塘", "desc": "不知为什么，感觉2020年面试过程中算法题突然流行了起来，不论你是前端后端还是架构师，面试前都得先来两道算法题热热身。 如果你很干脆的回答不会，hr小姐姐就会吃惊地问你：什么？身为一个前端程序员竟然不会算法？？？ 语气口吻就好比你的亲戚问你：不会吧不会吧！身为一个程序员不会修电…"}, {"id": "6938591255710400519", "title": "LeetCode174. 地下城游戏 | 刷题打卡", "desc": "一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡…"}, {"id": "6995917914691862558", "title": "前端之算法（五）顺序和二分搜索", "desc": "前几章我们讲了冒泡，选择，插入，归并和快速排序，了解了一些比较熟知的排序算法，今天呢我们要聊的就是顺序和二分搜索，是两种搜索算法"}, {"id": "6992986805159100423", "title": "【温故知新】：`19、删除链表倒数第 n 个结点`快慢指针实现，两种不同的优先处理方式", "desc": "题目描述 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3"}, {"id": "6934660944475717646", "title": "[LeetCode1200. 最小绝对差] | 刷题打卡", "desc": "对于这次活动我是很乐意参加的，毕竟自己平常刷题都是刷出来然后提交就行了，对于过程和思路没有用文字来记录和复盘，这次活动可以培养自己一个思考、记录、复盘、优化的习惯。我这个活动的内容应该大部分都是easy，可能会有medium。主要是我太菜了，medium的我都要想好久还不一定对…"}, {"id": "6844903570584633351", "title": "巧用JS位运算", "desc": "位运算的方法在其它语言也是一样的，不局限于JS，所以本文提到的位运算也适用于其它语言。 位运算是低级的运算操作，所以速度往往也是最快的（相对其它运算如加减乘除来说），并且借助位运算的特性还能实现一些算法。恰当地使用运算有很多好处。下面举几个例子。 1. 使用按位非~判断索引存在…"}, {"id": "6987011458273902622", "title": "二叉搜索树", "desc": "二叉搜索树的定义 二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，二叉搜索树(Binary Search Tree)，又名二叉排序树(Binary Sort Tree) 二叉搜索树是具有有以下性"}, {"id": "6844903636082884622", "title": "您需要的前端面试算法(上)", "desc": "阅前说明1、数组遍历2、字符串替换3、链表逆序打印4、重建二叉树5、栈与队列的互相实现6、旋转数组的最小数字7、斐波那契数列8、位运算9、数值的整数次方10、删除链表节点11、调整数组顺序12、链表中"}, {"id": "6981810851254796295", "title": "Leetcode刷题：寻找两个正序数组的中位数", "desc": "前言 LetCode第4题 寻找两个正序数组的中位数 题目描述如下： 示例1： 示例2： 示例3： 一、解题思路 这个题目可能看起来不太好理解，中位数是指按顺序排列的一组数据中居于中间位置的数，此题中"}, {"id": "6844903866404700174", "title": "[译] JavaScript 线性代数：使用 ThreeJS 制作线性变换动画", "desc": "本文是“JavaScript 线性代数”教程的一部分。 最近我完成了一篇关于使用 JavaScript 进行线性变换的文章，并用 SVG 网格实现了 2D 的示例。你可以在此处查看之前的文章。但是，那篇文章没有三维空间的示例，因此本文将补全那篇文章的缺失。你可以在此处查看本系列…"}, {"id": "6844903558148521991", "title": "\"所谓\"的前端算法", "desc": "算法，这个题目有点大。 其实算法是一个很宽的概念，我们写的所有程序都可称之为算法，因为算法就是一个处理问题的逻辑，将问题进行归类，抽象出一个统一范式，然后为这个范式取个名字，比如：快速排序。 所以这里我们就来看下前端有哪些常用的算法。"}, {"id": "6995573183571034120", "title": "「前端刷题」12. 整数转罗马数字", "desc": "罗马数字包含以下七种字符： `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `"}, {"id": "6939797863085899784", "title": "聊一聊常见设计模式的 JavaScript 实现", "desc": "我们都知道 javascript 是一种基于原型的弱类型语言，拥有动态数据类型，灵活多变。因此，相比于传统的 java，c++ 来说， javascript 面向对象的设计模式会有点牵强。 但这也并不妨碍我们学习使用 javascript 来了解设计模式思想及其设计理念。因为在…"}, {"id": "6869289036503056398", "title": "尺取法---解决带关键字：\"连续、最、子\"问题---Javascript实现", "desc": "尺取法（What），又名滑动窗口法，常见于获取连续相关的最值算法问题。如下Demo中的：长度最小的子数组、无重复字符的最长子串、最大连续1的个数 III等。 关键词为（Where）：连续、最、子。 弄清楚上面三个关键点，问题便能迎刃而解，且时间复杂度远小于暴力破解。难点为关键点…"}, {"id": "6989803985007804429", "title": "leetcode笔记 | 977有序数组的平方 189旋转数组（JavaScript）", "desc": "双指针 【977】有序数组的平方 Easy (72.54%) 【189】旋转数组 Medium（45.38%）"}, {"id": "6992567373765017636", "title": "「前端刷题」4. 寻找两个正序数组的中位数", "desc": "题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。   示"}, {"id": "6974343078584778788", "title": "LeetCode第213题：打家劫舍Ⅱ", "desc": "题干 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相"}, {"id": "6844903508370718727", "title": "关于react diff 算法（译文）", "desc": "React是由facebook开发，用于构建用户界面的js类库，以提升性能为设计理念。在本文中，我将为大家介绍在React中的diff算法，以及它的渲染机制，以便于你能够更好的优化你的程序。 在深入了解实现细节之前，了解React如何工作是很重要的。 在任何时候，你可以将UI描…"}, {"id": "6844903698921947144", "title": "React 源码分析", "desc": "React 开发一年多，最近仔细研究了 React 源码，在这里总结一下原理。React 源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的 React，使得理解原理更加容易（本文基于 React v15）。包括： React 的代码还是非常复杂的，虽然这里是一个简化…"}, {"id": "6991478292561788935", "title": "算法概念 常用排序算法", "desc": "算法 算法(Algorithm): 是对特定问题求解步骤的一种描述，它是指令的有序序列，其中每一条指令表示一个或者多个操作。 5个重要特征 有穷性 执行有穷步骤后结束，有穷时间内完成 确定性 每一条指"}, {"id": "6978813987987128356", "title": "leetcode top100挑战, 每天不鸽一道题之 买卖股票的最佳时机(15/100)", "desc": "题目描述 买卖股票的最佳时机 标签 贪心算法 解题分析 1. 贪心算法 直接上讲解。 来人上代码！！！！！ 另外记一个厉害老哥的写法，学习学习。 最后 从今天开始不鸽，每天一道算法题并发布文章，首先想"}, {"id": "6992212433804722184", "title": "「前端刷题」3. 无重复字符的最长子串", "desc": "题目 给定一个字符串 s ，请你找出其中不含有重复字符的 **最长子串 **的长度。   示例 1: 输入: s = \"abcabcbb\""}, {"id": "6844903504817946637", "title": "表格布局display: table的妙用", "desc": "说到表格布局，相信大家首先想到的是<table>标签，其实，在CSS2中还提供了一种表格布局：display: table，今天刚好用到，就有必要来深究一下了！ 虽然CSS3已经出现了display： flex（Flex布局）和display: grid（CSS：Grid布局）…"}, {"id": "6986143088590880782", "title": "LeetCode 198. 打家劫舍 --DP", "desc": "198. 打家劫舍 问题描述： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，"}, {"id": "6844903657087959054", "title": "流程图——正交连线的算法的一种简单实现", "desc": "其实有很多库已经实现了流程图，比如 jointjs，gojs，jsplumb 等等。可惜都不是免费的。 如果要做的简单呢，就用贝塞尔曲线就好了，只需要提供起点终点两个点的坐标，就能用简单的算法生成一个svg 的path了。这样算法网上应该找得到。 但是如果要用正交连线来实现，这…"}, {"id": "6844903789456015374", "title": "前端面试题，写出一个快速找出两个数组不同值的函数。", "desc": "一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂…"}, {"id": "7000305391628189704", "title": "算法入门及简单练习——栈", "desc": "栈 先进后出（后进先出） push 添加一个元素到栈顶 pop 弹出栈顶的元素 top 返回栈顶的元素 isEmpty 判断是否为空 size 返回栈里元素的个数 clear 清空栈 使用js的数组实"}, {"id": "7001664672193576990", "title": "【LeetCode 235.二叉搜索树的最近公共祖先】JavaScript/C++实现（递归）", "desc": "这是我参与8月更文挑战的第28天，活动详情查看：8月更文挑战 【LeetCode 235.二叉搜索树的最近公共祖先】JavaScript/C++实现（递归） 题目描述：给定一个二叉搜索树, 找到该树中"}, {"id": "7000180538103300127", "title": "前端算法技巧锻炼之双指针法", "desc": "双指针：指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。"}, {"id": "6991450121137291271", "title": "手把手撸二叉树之叶子相似的树｜8月更文挑战", "desc": "算法与数据结构一直是我编程能力的短板，为了提高这方面的能力，我也开始了系统性的刷题，并且也将刷题的一些经验整理成了笔记，恰逢这次 8 月更文活动，就和大家来一起分享一下吧！ 题目： 今天是 8"}, {"id": "7003905672668512264", "title": "「每日一题」斐波那契数列", "desc": "1. 题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： 斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出"}, {"id": "6996466297210929165", "title": "手撸二叉树之二叉树的堂兄弟节点", "desc": "Hello, 大家好，今天是我参加8月更文的第 15 天，今天给大家带来的关于二叉树相关的算法题是求二叉树的堂兄弟节点，正文如下： 题目 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子"}, {"id": "6970860903092715550", "title": "精读《算法 - 动态规划》", "desc": "很多人觉得动态规划很难，甚至认为面试出动态规划题目是在为难候选人。动态规划不是魔法，它也是通过暴力方法尝试答案，只是方式更加 “聪明”，使得实际上时间复杂度并不高。"}, {"id": "7000930786375368741", "title": "【LeetCode 295.数据流的中位数 】- JavaScript（暴力+二分+最小堆和最大堆）", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 LeetCode 295.数据流的中位数 - JavaScript 题目描述 中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间"}, {"id": "6991661007693152264", "title": "手撸二叉树之最小高度树｜8月更文挑战", "desc": "今天是 8 月更文活动的第 2 天，咱们继续来刷二叉树，今天要讲的是如果构建最小高度的树。 题目 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。 示"}, {"id": "6992016082361909255", "title": "手撸二叉树之对称二叉树｜8月更文挑战", "desc": "今天是8月日更的第三天，今天带来的题目是对称二叉树的解法，正文如下 。 题目： 给定一个二叉树，检查它是否是镜像对称的。 Example: 思路分析: 如果一个树的左子树与右子树镜像对称，那么这个树是"}, {"id": "6996850346593107975", "title": "手撸二叉树之递增顺序搜索树", "desc": "Hello, 大家好，今天是我参加8月更文的第 16 天，今天给大家带来的关于二叉树相关的算法题是求二叉树的递增顺序搜索树，正文如下： 题目 给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递"}, {"id": "6993115537601462279", "title": "手撸二叉树之路径总和", "desc": "Hello, 大家好，今天是我参加八月更文活动的第 6 天，今天给大家带来的关于二叉树相关的算法题是求二叉树的路径总和，正文如下： 题目 给你二叉树的根节点 root 和一个表示目标和的整数 targ"}, {"id": "7006285881430671367", "title": "剑指 Offer 24. 反转链表", "desc": "剑指 Offer 24. 反转链表 题意 剑指 Offer 24. 反转链表 解法 1. 三指针（双指针） 大概的思路是对于三个连续的节点A->B->C，用三个指针pre，p，tep一一对应。 断开B"}, {"id": "6997895064554831886", "title": "手撸二叉树之第二小的节点", "desc": "Hello, 大家好，今天是我参加8月更文的第 19 天，今天给大家带来的关于二叉树相关的算法题是二叉树中第二小的节点，正文如下： 题目 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节"}, {"id": "7000291762962956301", "title": "LeetCode：198. 打家劫舍", "desc": "198. 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报"}, {"id": "7002152428715917320", "title": "前端算法：回文串", "desc": "对于回文数或者说是回文字符串，可以理解成一个字符串正着都和反着读结果是一样的，比如：上海自来水来自海上"}, {"id": "6994981149655678983", "title": "手撸二叉树之数据流中的第 K 大元素", "desc": "Hello, 大家好，今天是我参加8月更文的第 11 天，今天给大家带来的关于二叉树相关的算法题是数据流中的第 K 大元素，正文如下： 题目 设计一个找到数据流中第 k 大元素的类（class）。注意"}, {"id": "7003921226267623437", "title": "vue源码图解03-diff（patch）算法", "desc": "虚拟DOM概念 虚拟DOM（Virtual DOM）是对DOM的JS抽象表示，它们是JS对象，能够描述DOM结构和关系。应用 的各种状态变化会作用于虚拟DOM，最终映射到DOM上。 vue 1.x中有"}, {"id": "7000191611300741150", "title": "LeetCode 448.找到所有数组中消失的数字】 - JavaScript(哈希表+原地哈希)", "desc": "这是我参与8月更文挑战的第25天，活动详情查看：8月更文挑战 【LeetCode 448.找到所有数组中消失的数字】 - JavaScript(哈希表+原地哈希) 题目描述 题目分析 这一题和Leet"}, {"id": "7001639377008852999", "title": "手撸二叉树之左叶子之和", "desc": "Hello, 大家好，今天是我参加8月更文的第 29 天，今天给大家带来的关于二叉树相关的算法题是二叉树的左叶子之和，正文如下： 题目 计算给定二叉树的所有左叶子之和。 示例： 解题思路 根据题意，我"}, {"id": "6950995261250338830", "title": "最长公共前缀｜刷题打卡", "desc": "编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 \"\"。例如数组strs = [\"flower\",\"flow\",\"flight\"]，最长公共前缀是\"fl\""}, {"id": "6844903861493170189", "title": "JavaScript：Aho–Corasick算法实现敏感词过滤", "desc": "敏感词过滤应该是许多后端同事经常会遇到的需求，无论是评论、弹幕、文章，都需要做敏感词过滤处理来规避风险。在前端开发中，使用replace函数来替换字符串是我们的常规操作，在这之前我思考过如果用JavaScript来实现敏感词过滤该怎么做。在学习过程中，接触到了Trie树，瞬间有…"}, {"id": "6931972643726262279", "title": "什么是二维前缀和？", "desc": "前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。 通过一个例子来进行说明会更清晰。题目描述：有一个长度为 N 的整数数组 A，要求返回一个新的数组 …"}, {"id": "6844903745503887374", "title": "文字渲染的那些事（一）字体是如何存储的？", "desc": "在现代生活里，我们几乎每天都会和屏幕上的文字打交道——文字看起来是如此平凡，以至于不少与 UI 相关的专业人士都对其下的复杂性知之甚少。这个系列旨在以开发者的角度，介绍一些从文字的二进制数据到像素之间流程的科普知识，希望对感兴趣的同学能有一些启发。 喜欢折腾系统的同学，对于常见…"}, {"id": "6979472719809085470", "title": "数据结构-堆", "desc": "堆 在我看来，js中的堆就是一个比较特殊的数组，我们可以用这个数组中的元素，去生成一个完成的二叉树，同时需要满足，每一个节点的父节点，要大于等于或者小于等于，子节点。 全部大于等于子节点的称之为大根堆"}, {"id": "6979099143805337636", "title": "处理对象的招式", "desc": "最近在做一个xml配置的功能，在跟树形结构、xml结构和json结构的数据打交道，总的来都是对象，要把这三种结构进行互相转换，总结了一些处理对象的招式，尤其是深度处理嵌套对象。"}, {"id": "6844903633796988936", "title": "浅解前端必须掌握的算法（五）：堆排序（下）", "desc": "虽然前端面试中很少会考到算法类的题目，但是你去比如像腾讯一样的大厂面试的时候就知道了，对基本算法的掌握对于从事计算机科学技术的我们来说，还是必不可少的，每天花上 10 分钟，轻松了解基本算法概念以及前端的实现方式。 另外，掌握了一些基本的算法实现，对于我们日常开发来说，也是如虎…"}, {"id": "6844903504109109262", "title": "理解 JavaScript 中的策略模式", "desc": "策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 使用策略模式的优点如下： 优点：1. 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。 2. 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。 3. 策略模式中的代码…"}, {"id": "6950286775021469733", "title": "无重复字符的最长子串｜刷题打卡", "desc": "给定一个字符串，找出其中不含有重复字符的最长子串的长度。首先说一下什么是子串和子序列。子序列指字符串中不连续的子字符串。子串指字符串中连续的子字符串。"}, {"id": "6934303651414409229", "title": "一道算法小题的分析过程", "desc": "最近在看算法的问题比较多，希望能以一道小题，来记录算法分析的过程。 replace，replace 中尤其以正则不讲武德。 Review 上面👆代码，已经可以通过测试了，那么分析如何优化 。 第一种方法的结果来看，需要用到正则分组的方法来调换位置。 思路是分两组第一组是开头到…"}, {"id": "6844903727556460557", "title": "深入理解js内存机制", "desc": "js的内存机制在很多前端开发者看来并不是那么重要，但是如果你想深入学习js，并将它利用好，打造高质量高性能的前端应用，就必须要了解js的内存机制。对于内存机制理解了以后，一些基本的问题比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原…"}, {"id": "6844903497498886151", "title": "JS中的算法与数据结构——列表(List)", "desc": "主要是针对前端同学，我将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6844903637974515720", "title": "JavaScript数据结构与算法（链表）", "desc": "去年4，5月份得时候看过Vue得源码。没记错的话其中的Cache类应该就是用链表实现的. 虽然用得不多但是作为数据结构的的重要组成部分，掌握它也是非常有必要的,下面主要以单链表进行说明."}, {"id": "6914254584319836168", "title": "每日算法-只出现一次的数字(数学-简单）", "desc": "给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 你…"}, {"id": "6961605135172632584", "title": "《算法图解》读书笔记三", "desc": "第8章 贪婪算法 一、贪婪算法（近似算法） 贪婪算法（近似算法）：每步都选择局部最优解，最终得到的就是全局最优解。 近似算法优劣的标准如下： 速度有多快； 得到的近似解与最优解的接近程度。 第一个例子"}, {"id": "6844903799732060167", "title": "数据结构的故事之二叉树, 前缀树, N叉树", "desc": "数据结构和算法的知识博大精深, 这里只是对这几种数据结构做一些简单的介绍。并对leetcode上部分相关的简单和中等题做出解答。还请各位看官见谅 二叉树是一种典型的树状结构, 二叉树每一个节点最多有两个子树的结构。以下是遍历二叉树的几种方式, 总的来说使用递归的方式, 还是非常…"}, {"id": "6985065262072463367", "title": "LeetCode第104题：树的高度", "desc": "题干 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,"}, {"id": "6935454523255160863", "title": "[LeetCode209题长度最小的子数组] | 刷题打卡", "desc": "[LeetCode1200. 最小绝对差] | 刷题打卡 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度…"}, {"id": "6877765688451137544", "title": "重建二叉树", "desc": "给定一颗二叉树的前序遍历和中序遍历的数组，且数组中不包含重复的数字，根据给定的两个数组求出这颗二叉树，这就是重建二叉树问题的定义。 本文将详解重建二叉树问题的解题思路以及其代码实现，欢迎各位感兴趣的开发者阅读本文。 乍一看，貌似得不到什么有用的信息，那我们就用一个例子结合题目的…"}, {"id": "6856673818530807821", "title": "学习一下LRU（最近最少使用）缓存机制", "desc": "最近买了一个学算法的小课，讲的非常不错，里面提到了LRU缓存机制。 其实这不是我第一次听说LRU。在我使用next.js的时候，我看过一篇文章，里面提到使用LRU缓存访问过的页面进行优化。 听说Redis里面也用到了LRU缓存机制。 由此，我找了一些资料学习了一下，为了防止再次…"}, {"id": "6935769276779331614", "title": "LeetCode1.两数之和｜刷题打卡", "desc": "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 !!!注意，两层循环很多情况下都意味着 O…"}, {"id": "6947968117649702926", "title": "js 树形结构打印", "desc": "题目：根据给的数据，打印出此结果这道题主要考察：怎么把一段数据，用树的结构体现树的广度优先遍历题目数据：实现代码"}, {"id": "6844903504293675016", "title": "JS中的算法与数据结构——二叉查找树（Binary Sort Tree）", "desc": "主要是针对前端同学，将一些常见的算法和数据结构用 JavaScript 去实现，起到一个抛砖引玉的作用"}, {"id": "6844903665359306759", "title": "[计算机网络] - 从英雄联盟，看数据包何去何从？", "desc": "我们总是在说TCP/IP协议。HTTP头怎么怎么样；TCP头怎么怎么样；IP头怎么怎么样；MAC头怎么怎么样。不过话又说回来，计算机网络的问题，大多都是问这些。深入了解这部分内容，的确是最优解。 不过作为德智体美劳全面发展的新时代码农，多了解一点，多学习一点。总归是没错的。（不…"}, {"id": "6936223446149890085", "title": "由两个栈实现一个队列，支持队列的基本操作 | 刷题打卡", "desc": "一、题目描述💯由两个栈实现一个队列，支持队列的基本操作（add,poll,peek）二、思路分析🤔1.由stackPush压入stackPop时，要将stackPush全部压入2.出队时，如果stac"}, {"id": "6936217375695962120", "title": "一个栈实现另一个栈排序｜算法系列", "desc": "一个栈中元素为整形，现在想将这个栈从栈顶到栈底自大到小排序，允许申请一个栈。除此之外无其他数据结构。允许申请新变量，如何完成排序？ 2.将stack依次弹出，判断弹出的值curt与help的栈顶元素大小关系，如果curt较小，就将help的栈顶元素弹出并压入到stack中，反之…"}, {"id": "6972367280252387342", "title": "leetcode top100挑战, 每天不鸽一道题之 有效的括号(3/100)", "desc": "题目描述 寻找两个正序数组的中位数 标签 栈 解题分析 1. 栈 这道题可以用栈的思路来解决，需要注意的以下几点： 传入的字符串中，左括号必须要有右括号闭合。 如果这个字符串是右括号，而没有左括号，那"}, {"id": "6924308102892224520", "title": "算法刷题——链表", "desc": "给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 用三个指针分别指向前一个，要交换的第一个，要交换的第二个，进行相应交换之后继续向后遍历，如果是偶数个节点first会先到Null,如果是奇数个节点seco…"}, {"id": "6935665904986357796", "title": "[LeetCode236题二叉树的最近公共祖先] | 刷题打卡", "desc": "[LeetCode1200. 最小绝对差] | 刷题打卡 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点…"}, {"id": "6939165915137179655", "title": "[LeetCode874. 模拟行走机器人] | 刷题打卡", "desc": "机器人在一个无限大小的 XY 网格平面上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令 commands ： 在网格上有一些格子被视为障碍物 obstacles 。第 i 个障碍物位于网格点 obstacles[i] = (xi, yi) 。…"}, {"id": "6986912802958999559", "title": "LeetCode 26 Remove Duplicates from Sorted Array (Tag:Array Difficulty:Easy)", "desc": "题目描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额"}, {"id": "6844903597067468807", "title": "JavaScript之内存泄漏【四】", "desc": "对以上简单的总结就是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。下面就让我们一起看看垃圾收集器是如何回收内存的： 在JavaScript中，标记清除是最常用的方式. 例如：在函数中声明一个变量，就将这个变量定义为“进入环境”。从逻辑上讲 进入环境的变…"}, {"id": "6844903906292711437", "title": "初识加密算法", "desc": "本文中使用到的代码可至https://github.com/FantasyGao/FantasyGao.github.io获取。1.加密算法的意义 很简单，加密算法的出现正是为了解决万物互联下数据隐私与安全的问题，在畅游于网络之中时候，那便是数据在不停的交换和流动的时候，如果没…"}, {"id": "6971683032981831716", "title": "LeetCode第605题：种花问题", "desc": "题干 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成"}, {"id": "6844903816526036999", "title": "有道算法题之矩阵的Z字型遍历", "desc": "前言对矩阵型数据的一些操作是面试中的入门级题目，其实主要是一个脱离细节接收宏观的思想，本文一共提出三点：矩阵的Z字形输出矩阵的旋转矩阵的回形打印其实都很简单，只是个人感觉第一个更具有代表性，所以主推第"}, {"id": "6868102072835768328", "title": "【算法】BFS、DFS、递归", "desc": "剑指 Offer 10- I. 斐波那契数列 定义： 深度优先搜索算法（DFS）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深的搜索树的分支。 剑指 Offer 12. 矩阵中的路径 定义： 广度优先算法（Breadth-First-Search），简称BFS，是一种图形…"}, {"id": "6844903955705643021", "title": "丰富图例讲解十大经典排序算法 | 面试必备", "desc": "... 平方阶 (O(n**2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 原地排序：特指空间复杂度是 O(1) 的排序算法。 稳定性…"}, {"id": "6986657202362646559", "title": "前端算法入门之路（九）(Algorithm算法杂谈）--开课吧门徒计划历程", "desc": "计数排序 统计每一项出现的次数 根据统计的次数循环输出对应的值 应用于值域有限的排序场景中 基数排序 统计低16位每个数字出现的次数，求其前缀和后在temp里排序 统计高16位每个数字出现的次数，求其"}, {"id": "6844904116632715278", "title": "前端工程师的 LeetCode 之旅 - 夜喵 23", "desc": "给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。 请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。 解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是…"}, {"id": "6916874684176957454", "title": "javascript 算法之 树    必出精品 （二）", "desc": "1、leetcode104二叉树最大深度道理我们都懂来我们开始操作一下吧步骤也很清楚上面是思路部分走喝杯卡布奇诺时间复杂度O(n)空间复杂度递归嵌套形成堆栈最好的情况O(logn)最坏情况O(n)不分"}, {"id": "6939102058645553189", "title": "[LeetCode：Letter Combinations of a Phone Number] | 刷题打卡", "desc": "我觉得这道题可以改一改：你是一位有志之士，组织派你破解敌方的信号，你在他们手机上安装了一个能窃听哪个键被按下的装置，你需要通过被按下的按键来确定敌方所有可能输入的信息，最后将敌方一举拿下。算了，不扯了... 回溯算法主要操作两个变量：一是待选数组，二是当前已选择的内容，每次递归…"}, {"id": "6978071306877009956", "title": "JSMS25-输出单链表倒数第N个节点的值-剑指offer15", "desc": "分析，这道题目可以采用遍历两遍然后得到长度，然后输出。当然也可以遍历一遍就可以得到结果，具体就是通过一个指针p1在前面遍历，p2指针和p1之间的长度差为N个，这样p1遍历结束之后，p2所指向的就是倒数"}, {"id": "6938768328328642573", "title": "[LeetCode：Missing Number] | 刷题打卡", "desc": "一种想法是先把数字排序，有序的数组找丢失的数会方便很多，但是排序的平均时间复杂度都是 O(nlogn)，不能接受。 第二种想法是：申请一个长度等于 nums 的数组 arr，由于 nums 中的数字都是自然数，刚好和数组的下标对应，遍历到 nums[k] 的时候，在 arr[n…"}, {"id": "6886785189008932877", "title": "前端仔的“数据结构与算法”之路——队列", "desc": "队列的概念相对栈来说更好理解，就像我们去排队买奶茶，先来的先喝，后来的依次排队。典型的先进先出、后进后出的数据结构。 它和栈一样，是一种操作受限的数据结构。只支持两个基本操作“入队列”、“出队列”。 入队列，从队列尾部插入元素。 出队列，从队列头部删除元素。 用数组实现的队列，…"}, {"id": "6844903941696651271", "title": "时间复杂度", "desc": "时间复杂度定义: n称为问题的规模,当n不断变化时，时间频度T(n),也就是算法中的语句执行次数也会不断变化,若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(…"}, {"id": "6844904073360211975", "title": "前端工程师的 LeetCode 之旅 -- 173周赛", "desc": "给你一个字符串 s，它仅由字符 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文子序列。 返回删除给定字符串所有字符（字符串为空）的最小删除次数。 【子序列】定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的…"}, {"id": "6937919883216683039", "title": "[LeetCode387.字符串中的第一个唯一字符] | 刷题打卡", "desc": "给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 提示：你可以假定该字符串只包含小写字母。 最最最容易想到的就是双层循环，但是算法追求的是最优解法，即较低的空间和时间复杂度，所以我们这里不对这种解法做举例。 遍历这个字符串，建立一个key为…"}, {"id": "6920154727103774734", "title": "初学者应该了解的数据结构：Array、HashMap 与 List", "desc": "当开发程序时，我们（通常）需要在内存中存储数据。根据操作数据方式的不同，可能会选择不同的数据结构。有很多常用的数据结构，如：Array、Map、Set、List、Tree、Graph 等等。（然而）为程序选取合适的数据结构可能并不容易。因此，希望这篇文章能帮助你了解（不同数据结…"}, {"id": "6844903612859023367", "title": "Promise异步控制流模式", "desc": "现在的 Node.js 核心实用工具库util里面已经支持(err, value) => ...回调函数是最后一个参数的函数, 返回一个返回值是一个promise版本的函数。 在看异步控制流模式之前，先开始分析顺序执行流。按顺序执行一组任务意味着一次运行一个任务，一个接一个地运…"}, {"id": "6844903612871606279", "title": "对于JavaScript实现排序算法的一些其他测试", "desc": "在我的上一篇文章中，总结了六种排序算法的JavaScript实现，以及每种算法的思想，掘金上的许多盆友提出了一些好的想法或者优化的方法，这里针对这些方法做一些新的测试，以验证盆友们的说法。此外，非常感谢大家仔细阅读我的文章，你们的意见让我进步很大，同时意识到自身的许多不足，我还…"}, {"id": "6844903513726648334", "title": "HTTPS 高性能传输优化详解", "desc": "HTTPS 高性能传输优化详解"}, {"id": "6844903665292017672", "title": "React专题：可变状态", "desc": "React使用一个特殊的对象this.state来管理组件内部的状态。 然后开发者就可以通过描述状态来控制UI的表达。 一般我们会在constructor生命周期钩子初始化状态。 也可以直接用属性初始化器的写法，看起来更加简洁。 然后通过this.setState()来改变状态…"}, {"id": "6844903826361679886", "title": "Vue源码分析系列四：Virtual DOM", "desc": "当我们操作Dom其实是一件非常耗性能的事，每个元素都涵盖了许多的属性，因为浏览器的标准就把 DOM 设计的非常复杂。而Virtual Dom就是用一个原生的JS对象去描述一个DOM节点，即VNode，所以它比创建一个真实的Dom元素所产生代价要小得多。而我们主流的框架React…"}, {"id": "6935969854868422669", "title": "LeetCode 141 环形链表｜刷题打卡", "desc": "给定一个链表，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不…"}, {"id": "6989614062631911455", "title": "数据结构与算法之狄克斯特拉算法", "desc": "求有向加权非负最短路线就可以用狄克斯特拉算法 前提条件就是，不能加负权，有向 原理： (1) 找出最小权的节点。 (2) 检查该节点的接下来的所有未处理过的节点，将它们的权分别计算相加，比较得出当前权"}, {"id": "6844903987961462792", "title": "【Leetcode 做题学算法周刊】第二期", "desc": "本文记录刷题过程中的整个思考过程，以供参考。主要内容涵盖： 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 这道题从题面来看，仍…"}, {"id": "6965657384295333896", "title": "算法打卡-leetcode-20210524", "desc": "1. 路径总和 III 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子"}, {"id": "6844903711462916103", "title": " Javascript设计模式（四）策略模式", "desc": "通过使用策略模式重构代码，消除来原程序中分支语句。所有计算奖金有关的逻辑分布在策略对象中，每个策略对象的算法已被各自封装在对象内部，当我们对这些策略对象发出“计算奖金”的请求时，它们会返回各自的计算结果，这不仅是多态性的体现，也是“自由交换”的目的。 从定义上看，策略模式就是用…"}, {"id": "6938382633571188773", "title": "机器人在矩阵中的活动范围能有多大？｜刷题打卡", "desc": "原题链接：剑指 Offer 13. 机器人的运动范围 地上有一个m行n列的方格，从坐标 $$[0,0]$$ 到坐标 $$[m-1,n-1] $$。一个机器人从坐标 $$[0, 0]$$ 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列…"}, {"id": "6935451212082839560", "title": "leetcode 42.接雨水-双指针 ｜刷题打卡", "desc": "给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 经过前两次的题解，发现总是总是会遍历多次，就像有没有方法可以一次遍历解决。很明显双指针就可以对其优化。 前一次使用动态规划的思路是从左至右缓存下每个位置之前的最高的柱子，以及从右…"}, {"id": "6844903597436567559", "title": "优雅的理解 call 和 apply 的使用方法 ", "desc": "每次看到别人用 apply 和 call 其实从以前的懵懵懂懂到现在的明白，但是自己从来未下手去用过，最近比较闲。开始打一下 JavaScript 的算法基础，刷一下简单的算法题目。然后从自己拙劣的解题思路和方法比较大牛的优雅的JavaScript的方法后有所感想。 上面的理解…"}, {"id": "6844903565052362765", "title": "使用动态规划 实现字符级Diff & Patch", "desc": "文章开头先上demo，只需键入任意内容的两个字符串，页面上就能自动计算并呈现字符串之间的差分。 动态规划(dynamic programming)是大家在算法学习中都会遇到的话题之一。我个人对于它的理解是： 最长公共序列问题(longest common sequence pr…"}, {"id": "6938352338591547405", "title": "「算法」455.分发饼干 (漫画版)| 刷题打卡", "desc": "假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩…"}, {"id": "6937537534394122276", "title": "刷leetcode-用两个栈实现队列 | 刷题打卡", "desc": "用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 若出栈没元素的话，将进栈的的元素一个个扔进来，然后在扔…"}, {"id": "6844903541304197127", "title": "面向前端工程师的机器学习引导课", "desc": "智能行为和现象，有不同的来源。有的来自生物，有的来自机器。 我们可以把那些来生物的智能，称之为自然智能。它们是通过自然选择逐步演化而来的智能。 而另外一些由人类设计的机器所表现的智能，就是人工智能，简称 AI。 人工智能的两大分类 按照解决问题的能力，我们可以把人工智能，分成两…"}, {"id": "6844903926467133447", "title": "「leetcode」 349.两个数组的交集；350.两个数组的交集 II", "desc": "349题和350题思路类似，都是利用Hash，所以放在了一起解析。 给定两个数组，编写一个函数来计算它们的交集。 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 我们首先循环nums1数组，使用nums1数组中的每一个子项，作为key，value设置为tru…"}, {"id": "6937639546888667173", "title": "LeetCode450. 删除二叉搜索树中的节点｜刷题打卡", "desc": "给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 这样操作完之后仍能维持二叉…"}, {"id": "6947841980122529822", "title": "前端刷题路-Day8｜刷题打卡", "desc": "给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 这题说实话，自己想了半天也没想出来，只想到了最暴力的一种解法，更好的答…"}, {"id": "6996683934285168654", "title": "「前端刷题」14. 罗马数字转整数", "desc": "解题思路 解法一：逐个比较 解题思路： 从前往后一次比较字符串，获取公共前缀 画图帮助理解一下： 代码实现： 时间复杂度：O(s)，"}, {"id": "6975426241348239367", "title": "leetcode top100挑战, 每天不鸽一道题之 合并两个有序链表10/100)", "desc": "合并两个有序链表：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。"}, {"id": "6912313125161140237", "title": "BFC 普解对称二叉树 | 创作者训练营", "desc": "为啥是普解，学会 BFC 这个题目真的 10 分钟轻轻松松拿下，没有悬念。如果你还不了解 BFC，可以看这篇文章 有迹可循的 BFS 问题 BFS 解法，使用一个队列缓存当前层的所有节点，拿到节点后比较正序和 reverse 之后的是否相等。如果中间不相等，直接返回。然后一直遍…"}, {"id": "6844903616612925448", "title": "【可能是个假前端】扫雷之平铺算法", "desc": "If you want authentic front-end knowledge, get out and turn left, see Lao Wang. 言归正传，这个 Topic 系列的文章我会尽量多说一些可能与前端知识关系不太大但非常有意思的东西，是希望将自己实践中遇…"}, {"id": "6844903502536261646", "title": "漫画：如何破解MD5算法？", "desc": "在之前的漫画中，我们介绍了MD5算法的基本概念和底层原理，没看过的小伙伴们可以点击下面的链接：漫画：什么是MD5算法？这一次，我们来讲解如何破解MD5算法。设MD5的哈希函数是H（X），那么：H(A)"}, {"id": "6844903636292599822", "title": "分支预测：为什么有序数组比无序数组快?", "desc": "最近几天在搜集一些关于 JavaScript 函数式编程的性能测试用例，还有内存占用情况分析。 我在一年前(2017年1月) 曾写过一篇文章《JavaScript 函数式编程存在性能问题么？》，在文中我对数组高阶函数以及 for-loop 进行了基准测试，得到的结果是 map`…"}, {"id": "6936467516206088223", "title": "[LeetCode 合并两个有序数组] | 刷题打卡", "desc": "在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。 1.如果matrix[i][j]等于0，那么就不用看了，直接等于0。 2.如果matrix[i…"}, {"id": "6951706160315498509", "title": "「算法」大数阶乘 | 刷题打卡", "desc": "一、题目描述：此题在leetcode上没找到完全一样的，可以参考这道类似的题目：剑指 Offer 66. 构建乘积数组示例 1:注意:所有元素乘积之和不会溢出 32 位整数a.length <= 10"}, {"id": "6935774194076483614", "title": "LeetCode88. 合并两个有序数组｜刷题打卡", "desc": "给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自…"}, {"id": "6880540114989088775", "title": "前端仔的“数据结构与算法”之路——栈", "desc": "可以想象成一堆叠好的衣服，我们新叠好一件衣服，是放在最上层，去取衣服时为了不弄乱衣服，也是从最上层取，一件一件的放一边，直到找到我们需要的那一件。 栈是一种先进后出、后进先出的结构。 从操作上看，它是一种操作受限的结构，入栈只能放最上层，出栈也只能从最上层出。 对于前端来说，我…"}, {"id": "6844903670912548871", "title": "js实现数据结构及算法之排序算法", "desc": "它会首先比较较远的元素而非相邻的元素，让元素尽快回到正确的位置。 通过定义一个间隔序列来表示在排序过程中进行的元素间隔。"}, {"id": "6905724097657831432", "title": "数据结构和算法简单的总结以及基础数据结构的实现", "desc": "Time complexity refers to the total count of operations an algorithm will perform given a set of items. Space complexity refers to the tota…"}, {"id": "6935768237623738398", "title": "剑指 Offer 12. 矩阵中的路径 JavaScript版本", "desc": "theme: 剑指 Offer 12. 矩阵中的路径 JavaScript版本 剑指 Offer 12. 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一…"}, {"id": "6886820835772858376", "title": "前端学数据结构与算法（九）：常见五种排序算法的实现及其优缺点", "desc": "数据结构章节暂时告一段落，从这一章节开始算法之旅。首先从排序开始，排序作为最基础的算法，一点也不简单，写一个快排、堆排、归并排序在大厂面试中并不罕见，或者某些题目就需要使用某些排序的思想来解决，这也就是为什么要学习排序。当然最重要的是学习它的思想，例如快排的partition操…"}, {"id": "6844904206055243790", "title": "LeetCode  27. 移除元素：JavaScript 遍历和双指针两种解法", "desc": "主要思路是遍历数组 nums，每次取出的数组元素为 num，设置初始下标为 ans。 在遍历过程中，如果 num 与需要移除的值不同，则进行拷贝覆盖 nums[ans] = num，ans 自增 1。 如果相同，则跳过该数字不进行拷贝覆盖，最后 ans 即为新的数组长度。 这种…"}, {"id": "6945771148663586823", "title": "处理链表的本质，是处理链表结点之间的指针关系", "desc": "可以想象成每个节点都是扣子，新链表的指针像线一样，将扣子穿起来。 虽然看着两层循环，但其实，每个节点只遍历一次，所以时间复杂度是 O(n)，空间复杂度是 O(1). 这里，重复的节点本身也会删除。"}, {"id": "6918267087886483464", "title": "前端小算法之二叉树的纵向遍历", "desc": "树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。 二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。 所谓的纵向遍历二叉树，通常指的是前序遍历、中序遍历、后序遍历。 下面会介绍这…"}, {"id": "6920027129543393293", "title": "算法进阶—[leetcode] 189.旋转数组", "desc": "给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 最简单的方法是旋转k次,每次将数组旋转1个元素。 时间复杂度 O(n*k) 每个元素都被移…"}, {"id": "6986636298698588191", "title": "Leet code(盛水的最大面积) 前端刷题解法记录与思考", "desc": "先看要求 给你一个数组,数组里面的每一项代表水池的高度,求出两个高度之间盛水最高的面积 思路 1.循环数组,将每一种面积情况都求出来 选出面积最大的哪一项 (但性能很差) 2.双指针解法从左边和右边同"}, {"id": "6981077558410510349", "title": "JSMS36-希尔排序算法实现", "desc": "希尔排序，相对于冒泡排序来说时间复杂度要低一点，同时要稳定得多。 解析，希尔排序是比较简单的也就是增加一个shell增量，下面代码中的d，d的初始值为5，之后分别为2,1，如果a[5]<a[0],则直"}, {"id": "6947856821990195208", "title": "一文搞懂动态规划", "desc": "递归的实质是能够把一个大问题分解成比它小点的问题，然后我们拿到了小问题的解，就可以用小问题的解去构造大问题的解。 但缺点就是随着 n 值的增大，递归树 Recursion Tree 变的越来越深，相应需要计算的节点也越来越多。 指数级别的时间复杂度对超算来说都是噩梦... 上一…"}, {"id": "6883287394675032077", "title": "Git 看这一篇就够了", "desc": "上一篇讲Git的文章发出来没想到效果特别好，很多读者都要求继续深入的写。那今天齐姐简单讲下Git的实现原理，知其所以然才能知其然；并且梳理了日常最常用的12个命令，分为三大类分享给你。本文的结构如下："}, {"id": "6952065114929365022", "title": "[打卡12：leetcode4. 寻找两个正序数组的中位数]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第12题。题目描述题目链接：寻找两个"}, {"id": "6956049138370740261", "title": "端到端加密通道方案研究", "desc": "一、加密通信 加密通信：在发送信息的时候把信息加密成密文，然后在接收方把密文解密成信息的通信过程。 ​ 加密通信的主流技术包括对称加密和非对称加密两种。 对称加密：加、解密使用的同是一串密钥。 **常"}, {"id": "6951191039143051278", "title": "[打卡8：leetcode26. 删除有序数组中的重复项]  ｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情前言第一次参加掘金打卡活动，别的不说 主要是奔着奖励来的。4.12开始为了达到14题小目标 冲冲冲！！！这是第8题。题目描述题目链接：删除有序数"}, {"id": "6988015327716048904", "title": "二分查找", "desc": "定义 当我们要从一个序列中查找一个元素的时候，二分查找是一种非常快速的查找算法，二分查找又叫折半查找。它对要查找的序列有两个要求，一是该序列必须是有序的。 代码实现 应用 在排序数组中查找元素的第一个"}, {"id": "6939149594064322574", "title": "[LeetCode1550题存在连续三个奇数的数组] | 刷题打卡", "desc": "题目地址：1550. 存在连续三个奇数的数组 给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。 题目给定一个整数数组arr，判断数组中是否有连续三个元素都是奇数。 这道题的思路很简单，我们就是判…"}, {"id": "6844903504654368781", "title": "JavaScript专题之解读 v8 排序源码", "desc": "v8 是 Chrome 的 JavaScript 引擎，其中关于数组的排序完全采用了 JavaScript 实现。 排序采用的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。(当然了，这种说法并不严谨)。 我们先来看看插入排序…"}, {"id": "6977019027906363429", "title": "算法学习笔记——二分查找", "desc": "在计算机科学中，二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在有序..."}, {"id": "6844903655406059533", "title": "从Chrome源码看audio/video流媒体实现二", "desc": "第一篇主要介绍了Chrome加载音视频的缓冲控制机制和编解码基础，本篇将比较深入地介绍解码播放的过程。以Chromium 69版本做研究。 由于Chromium默认不能播放Mp4，所以需要需要改一下源码重新编译一下。 1. 编译一个能播放mp4的Chromium 说是在demu…"}, {"id": "6844904109808549901", "title": "瀑布流背后的算法问题", "desc": "B：我写过等宽瀑布流。实现是当用户拉到底部的一定高度的时候，向后端请求一定数量的图片，然后再插入到页面中。 B：这个需要后端发来的数据里面有图片的高度，然后我就可以看当前高度最小的是哪里列，将新图片插入那一列，然后再看看新的高度最小的是哪一列。 B：（想了一段时间）对不起，这个…"}, {"id": "6950794383385952270", "title": "前端刷题路-Day16｜刷题打卡", "desc": "掘金团队号上线，助你 Offer 临门！ 点击 查看详情x 的平方根（题号69）题目实现int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只"}, {"id": "6844903839607291912", "title": "神奇补0解决链表相加：LeeCode002两数相加", "desc": "该解法使用数字相加的方法进行计算，但该解法有一个致命的问题是整数溢出。所以，严格意义上说，这种方式是错误的。代码如下： 该解法使用一个变量表示进位值。如下图，temp表示进位。将两个list长度改为一致，通过补0操作。 关于没到题目的解法我都发布在我的博客：https://ri…"}, {"id": "6844903607402250253", "title": "JavaScript 模块相关", "desc": "在编写稍大些的项目的时候，模块化和组件化是当前 JS 的最佳解决方案。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。 Node.js是通过模块的形式进行组织与调用的，在编写每个模块时，都有require、exports、m…"}, {"id": "6974343102983045128", "title": "LeetCode第62题：不同路径", "desc": "题干 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。"}, {"id": "6844903834272137224", "title": "你能找到心仪的妹子吗？- 时间复杂度进阶", "desc": "这个五一是个不平凡的五一，苍老师成功诞下了双胞胎。 假如有一天，有这样一个机会降临到你的头上。 你的面前是一条很长很长的路，这条路上齐刷刷的站满了妹纸，没错，就是妹子，一双双大白腿闪闪发光。 但是呢，有一个条件，你只能从路的这头走到那头，只要你选择了一个妹子，就要离开这里，这个…"}, {"id": "6923216558269399054", "title": "算法刷题——双指针", "desc": "给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内 画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 这道题实际上就是求Max…"}, {"id": "6844903882305306637", "title": "【问答】算法数据结构里面有没有什么有趣的内容？", "desc": "有很多。 我记得《算法导论》里就有一些很有意思的例子，惊喜在本文末尾。 前提条件基本是这样，然后就是分析了。 由于有多少人你就要面试多少次，所以小费用这一部分没法节省。 问题的关键就在于如何尽量减少大费用的支出了。 最坏的情况就是 n 个应聘者的质量逐天递增，你每次都发现你每天…"}, {"id": "6936921843701907469", "title": "介于简单和困难之间的薛定谔算法题？？｜刷题打卡", "desc": "今天的算法可以说很有意思了，当你用暴力法破解的时候他就是一道简单的题目，而当暴力法一旦被判超时，那难度蹭蹭蹭就上来了，就跟薛定谔的脑血压一样。 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动…"}, {"id": "6915763611415789576", "title": "前端就该用 JS 刷算法9", "desc": "这道题其实就是让你了解一下，为啥我们做树题的时候，明明在做树题（或者链表）这些题目的时候，控制台的例子都是数组，而不是一个可视化的树结构的数据，之前我一直很难理解，直到了解到序列化和反序列化之后。 个人理解这是为了兼容不同语言内置数据结构的不同而做出来的优化策略，比方说 JS …"}, {"id": "6844903958989783048", "title": "每天一道前端算法题--回溯算法--N皇后问题", "desc": "先来了解一下什么时回溯算法。回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），…"}, {"id": "6935733149385097230", "title": "一颗红心多种解法！响应掘金号召3.3.2｜刷题打卡", "desc": "可以使用一个栈存储点，每次出栈一个点，如果其向右向左的点存在，就入栈，每次遍历到 (m - 1. n - 1)这个点是ret++，最后return ret 可以使用一个队列存储点，每次出队一个点，如果其向右向左的点存在，就入队，每次遍历到 (m - 1. n - 1)这个点是r…"}, {"id": "6935480135290191908", "title": "83. 删除排序链表中的重复元素｜刷题打卡", "desc": "83. 删除排序链表中的重复元素｜刷题打卡 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 这是一道简单题，不过对我们这些算法小白来说是个认识链表这一数据结构的不错选择。 那什么是链表呢？我觉得小灰算法讲的不错。没找到电子版，直接拍的照哈。 对于链表的遍历来说，…"}, {"id": "6912732328599470088", "title": "每日算法-最长公共前缀(分治-简单）", "desc": "编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 这个题容易让人理解错误，这里要找的是公共前缀。 分治定义将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为…"}, {"id": "6844903937506541582", "title": "「动态规划」「leetcode」 213.打家劫舍 II", "desc": "你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数…"}, {"id": "6938695050427629599", "title": "[ 力扣1431 ] 拥有最多糖果的孩子 | 刷题打卡", "desc": "给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时…"}, {"id": "6914803869528784904", "title": "Divide and conquer algorithm: 分而治之, 逐个击破", "desc": "将手头的问题分成较小的子问题，然后分别解决每个子问题。如果子问题没办法解决，将子问题划分为更小的子问题时，到达无法划分的阶段时得出结果。最后合并所有子问题的解决方案，以获得原始问题的解决方案。 分割，将问题分割为较小的子问题，通常采用递归的形式，直到没有子问题可以进一步分割为止…"}, {"id": "6844903647260868622", "title": "React从零实现-组件渲染和setState", "desc": "在react中组件大体分为两种，一种是一个纯函数，没有生命周期的。另一个通过继承自React.Component的类来实现。 我们先来写一个Component类。 我们完成了一个Component类，同时该类的实例有一个setState函数，用来更新该组件。updateComp…"}, {"id": "6844903607880548365", "title": "JS策略模式《JavaScript设计模式与开发实践》阅读笔记", "desc": "策略模式可以避免代码中的多重判断条件。 策略模式很好的体现了开放-封闭原则，将一个个算法（解决方案）封装在一个个策略类中。便于切换，理解，扩展。 策略中的各种算法可以重复利用在系统的各个地方，避免复制粘贴。 策略模式在程序中或多或少的增加了策略类。但比堆砌在业务逻辑中要清晰明了…"}, {"id": "6938398208347340831", "title": "又回到最初的起点，来回顾一下两数之和怎么计算｜刷题打卡", "desc": "这次，我决定回顾一下我在leetcode上做的第一题，看了下提交记录，没想到已经是两年前了。 原题链接：1. 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对…"}, {"id": "6844903925888319495", "title": "「leetcode」649.Dota2 参议院", "desc": "Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项： 参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。 如果参议员发现有权利投票的参…"}, {"id": "6844904102972014599", "title": "这次的红黑树应该够简单易懂了", "desc": "自从上次写了这篇简单易懂的红黑树原理及实现(js)之后，总觉得光是图片展示还是不太够，最好是有一个动画能够展示出来，然后突然想起了之前后端小伙伴给我看的一个页面实现的数据结构的展示动画（具体地址不记得了），突发奇想，为什么不自己实现一版红黑树的呢？于是，开始搞起了这个。"}, {"id": "6844903576037228551", "title": "从拥挤的兔子到伪随机数算法", "desc": "不过兔子怎么可能“永不死去”呢！那我们现在开始考虑兔子的出生率和死亡率。先从容易的来：每对兔子父母每年生四只小兔，然后死去。如果一开始有两只兔子（第0年），那么第1年会有四只兔子，第二年会有8只兔子……每年兔子的数量会翻一番。记第 t 年的兔子数量为 ，那么： ，即 。很显然，…"}, {"id": "6844903506927681549", "title": "【译】JS 中的内存管理 && 常见的 4 种内存泄露处理方式", "desc": "JS 中的内存管理 常见的 4 种内存泄露处理方式"}, {"id": "6914616793345179662", "title": "矩阵中的最长递增路径", "desc": "我们可以把矩阵每个单元格看作一个点，而若一个点的值小于相邻点的值，那么就看作这两个点之间有一条有向边，由小的点指向大的点。这样，求最长递增路径的问题，就变成了求有向无环图最长路径的问题。我们可以用深度优先搜索来解决。 那么问题又来了，如果直接使用深度优先搜索，那么将会大量重复计…"}, {"id": "6844903648397361160", "title": "带你一起撸一遍 nodejs 常用核心模块（三）", "desc": "zlib 可以用来实现对 HTTP 中定义的 gzip 和 deflate 内容编码机制的支持。 HTTP 的 Accept-Encoding 头字段用来标记客户端接受的压缩编码。 使用 zlib 编码成本会很高, 结果应该被缓存。（下面的演示代码只演示压缩） crypto 模…"}, {"id": "6938236806026493989", "title": "[ 力扣 01.02 ] 判定是否互为字符重排（三种思路解决） | 刷题打卡", "desc": "给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 数组的sort方法如果参数不传，则使用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。 本…"}, {"id": "6900508138505273351", "title": "给定一个 n × n 的二维矩阵表示一个图像 ，使用几何方法将图像顺时针旋转90度", "desc": "第一次刷leetcode，正好在重新学习矩阵的几何解释，发现用几何知识来求解，可以非常直观的理解矩阵旋转。虽然题目要求不能用另外一个矩阵来旋转图像，但实际应用中，元素之间并不会有规律可循，所以几何方法是最直观的，代码也最容易理解和阅读 先作图，画一个3*3的图像，并标出坐标。实…"}, {"id": "6900506769814978568", "title": "二叉树经典算法套路分析与总结(JavaScript版)", "desc": "二叉树在前端的工程日常中不常见，但是多叉树组件——树形控件却经常使用到。所以掌握好二叉树的经典算法，其实多叉树也很容易举一反三，不仅有利于面试，对我们前端的日常开发也可以提供很多优化的思路。 二叉树看似复杂，其实其中蕴含了很多规律，只要掌握了二叉树的特点和规律，理解其中的套路，…"}, {"id": "6844903728420487175", "title": "【一起学习排序算法】4 插入排序", "desc": "本系列的文章列表和相关说明，请查看序言。具体列表如下： 本篇为此系列第四篇。 把列表分为两个部分，一部分是已经排好序，一部分待排序。（这一点和选择排序类似） 初始将第一个元素作为有序子列为，然后每次迭代从有序序列中移除；然后将它插入到有序序列中的相应位置。 重复以上步骤，直到到…"}, {"id": "6844904000786022407", "title": "LeetCode 简单算法-计数二进制子串", "desc": "题目：给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。重复出现的子串要计算它们出现的次数。 寻找规律: 通过图示法发现规律所在，从上图可以看出每次匹配到的结果都是向后移一位的，所以这里可以考虑使用递归或…"}, {"id": "6899023659382341639", "title": "【动态规划】LeetCode 115 不同的子序列-Hard", "desc": "定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\"ACE\" 是 \"ABCDE\" 的一个子序列，而 \"AEC\" 不是） 题目数据保证答案符…"}, {"id": "6937185422401339405", "title": "[LeetCode14.最长公共前缀] | 刷题打卡", "desc": "题目描述：编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串\"\"。并且我们假设：所有输入只包含小写字母a-z。需考虑数组为空的情况。示例：方法分析：在分析此类问题，我们的思"}, {"id": "6844903507523272711", "title": "react fiber", "desc": "In order to do any of this, we first need a way to break work down into units. In one sense, that's what a fiber is. A fiber represents a u…"}, {"id": "6844903655540293639", "title": "　　详细解析DES系列加密技术(二)  　", "desc": "我们在上一篇《详细解析DES系列加密技术(一)》中提到说DES在1999年1月被破解,并且有分析报告提出DES算法在理论上存在的一些漏洞,另外,2001年,DES作为一个标准已经被取代了.一旦一种加密技术被破解,那么,被取代也就是必然的事情了,对于DES来说,取代他的又是谁呢?…"}, {"id": "6936317141062778888", "title": "[LeetCode7.整数反转] | 刷题打卡", "desc": "题目描述给你一个32位的有符号整数x，返回x中每位上的数字反转后的结果。 如果反转后整数超过32位的有符号整数的范围[−231,231−1]，就返回0。 假设环境不允许存储64位整数（有符号或无符号）"}, {"id": "6935729566145052703", "title": "刷 整数反转 | 刷题打卡", "desc": "给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 你的算法应该具有线性时间复杂度。 你可以不使用额外…"}, {"id": "6844903793897766920", "title": "【算法】二分查找和大O表示法", "desc": "这里用大 O 表示法讨论运行时间，都是讨论的最糟糕的临界值，比如简单查找 100 个元素，就是要看每一个元素。二分查找也是查看最远的，那么就只用查看 log100 个元素约为 7 大 O 表示法指出了算法有多快。例如，假设列表包含 n 个元素，简单查找需要检查每个元素，因此需要…"}, {"id": "6844904114975932429", "title": "【详细笔记】JavaScript数字类型详解", "desc": "这是一篇偏综合性的总结，根据笔者的 routine 整理好的，并对代码进行了改进。以下内容出处均已在 参考资料 中列出，如有侵权，联系笔者删除。 计算机是二进制的，无法直接表示正负数，另外在计算机内部直接实现减法，也会影响计算机效率，所以人们希望要找到一种既能使用二进制表示10…"}, {"id": "6844903575999479815", "title": "Minimax 和 Alpha-beta 剪枝算法简介，及以此实现的井字棋游戏（Tic-tac-toe）", "desc": "前段时间用 React 写了个2048 游戏来练练手，准备用来回顾下 React 相关的各种技术，以及试验一下新技术。在写这个2048的过程中，我考虑是否可以在其中加入一个 AI 算法来自动进行游戏，于是我找到了这篇文章：2048-AI程序算法分析，文中介绍了 minimax …"}, {"id": "6934680308121862175", "title": "Leetcode303 区域和检索 | 刷题打卡", "desc": "题目出自Leetcode 303. 区域和检索 - 数组不可变 给定一个整数数组nums ，求出数组从索引 i 到 j（i ≤ j） 范围内元素的总和，包含 i、j 两点。 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i…"}, {"id": "6844903697281974285", "title": "Node 案发现场揭秘 —— 如何利用 GC 日志不修改代码调优应用性能", "desc": "GC 的全称是 garbage collection，它其实是一种自动内存管理机制，一般会由对应语言实现的垃圾回收器，在某些触发条件下对当前程序不再使用的对象内存进行回收处理。 GC 日志目前是文本格式输出的形式，需要大家获取到以后进行对应的按行解析处理，也可以使用 v8-gc…"}, {"id": "6992029581498646564", "title": "3周攻克数据结构[数组篇-2] ｜8月更文挑战", "desc": "DAY3 1. 两个数组的交集 II 方法1：哈希表查询 方法2：双指针 2. 买卖股票的最佳时机 方法1：贪心算法 方法2：动态规划 科普篇 贪心算法：（Greedy Algorithm） 贪心算法"}, {"id": "6992901828400660517", "title": "LeetCode最长回文子串 | 算法练习系列", "desc": "这是我参与8月更文挑战的第5天，活动详情查看：8月更文挑战 前言 最长回文子串是非常经典的一道算法习题，难度还是有的，做之前一定充分考虑各种情况，要不然就会不断踩坑，特别是字符串有中心点和没中心点的情"}, {"id": "6978425025799913479", "title": "JSMS28-判断二叉树b是否为二叉树a的子树-剑指offer18*", "desc": "就是判断二叉树b是否为a的子树 分析：这道题有点点难度，但也不是很难，主要就是对二叉树的遍历熟练掌握之后就可以下手。这道题代码没有调通，过段时间重新调通"}, {"id": "6844903865553256461", "title": "《前端算法系列》如何让前端代码速度提高60倍", "desc": "今天的问题从排序算法入手，来讲解如何根据业务需求，结合金典的算法，来实现js高性能开发。 老板让小明给公司的20000+条数据排个序，但是由于排序的操作会频繁发生，如果操作执行的时间很慢，则会严重降低用户体验，听到这条噩耗后小明开始了代码。 运行该测试函数后，耗时760ms，小…"}, {"id": "6977532481944125447", "title": "前端刷题路-Day61：在排序数组中查找元素的第一个和最后一个位置（题号34）", "desc": "给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合..."}, {"id": "6982235753115811876", "title": "排序算法", "desc": "排序作为前端面试的经典考题，常常让我等厂工无奈。但是跑又跑不掉，逃又逃不了，索性勇敢面对，一口气将所谓的排序算法一口气吃个透。"}, {"id": "6998853165659455501", "title": " 【温故知新】`18. 四数之和` 由2Sum 3Sum 递归演化为 nSum： n数之和", "desc": "两数之和 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答"}, {"id": "6987583322239008776", "title": "LeetCode刷题，面试题 03.04. 化栈为队", "desc": "化栈为队，使用两个栈(s1,s2)进行模拟队列，入队时使用s2保存，出队时把s2栈，进行依次出栈。 出栈的元素依次进行入栈到s1，然后s1出栈就是正确的队列模式下应该出队的元素首位"}, {"id": "6982936906023567390", "title": "Day 2 | 合并两个有序数组", "desc": "「本文已参与好文召集令活动，点击查看：后端、大前端双赛道投稿，2万元奖池等你挑战！」 题目描述： LeetCode 地址 标签：数组 难度：简单 描述： 给你两个有序整数数组 nums1 和 nums"}, {"id": "6844903604038402056", "title": "LeetCode 算法题刷题心得（JavaScript）", "desc": "花了十几天，把《算法》看了一遍。然后重新 AC 了一遍 LeetCode 的题并记录下心得。"}, {"id": "6972461310839635982", "title": "数据结构与算法系列——二叉树系列题目（1）", "desc": "这是我参与更文挑战的第3天，活动详情查看： 更文挑战 前言 身为前端开发人员，平时项目中写代码用的最多的就是 数组、集合、对象。这3种数据结构，但是作为程序员这肯定时不够的。但是在我们看博客、源码解读"}, {"id": "6994230406132269070", "title": "前端刷题路-Day75：子集（题号78）", "desc": "给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集..."}, {"id": "6989955773115662343", "title": "数据结构之“树”", "desc": "树简介 树是什么？ 一种分层数据的抽象模型 前端工作中常见的树包括：DOM树、级联选择，树形控件... JS中没有树，但可以用Object和Array构建树。 树的常用操作：深度/广度优先遍历、先中后"}, {"id": "6993203891449888782", "title": "前端刷题路-Day72：搜索插入位置（题号35）", "desc": "给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置..."}, {"id": "6844903496232206349", "title": "VirtualDOM与diff(Vue实现)", "desc": "因为对Vue.js很感兴趣，而且平时工作的技术栈也是Vue.js，这几个月花了些时间研究学习了一下Vue.js源码，并做了总结与输出。 文章的原地址：https://github.com/answershuto/learnVue。 在学习过程中，为Vue加上了中文的注释http…"}, {"id": "6996266494006919205", "title": "LeetCode有效的括号 | 算法练习系列", "desc": "这是我参与8月更文挑战的第14天，活动详情查看：8月更文挑战 前言 作为一个开发人员，我们日常开发的过程中应该都用过格式校验工具，比如我就是用的ESLint,它可以帮我们校验书写的格式是不是正确，比如"}, {"id": "6994273924322164766", "title": "LeetCode刷题，二叉树的前序遍历（144）", "desc": "二叉树的前序遍历 给你二叉树的根节点root，返回节点值的前序遍历 解题代码 思路：递归，直接依次遍历左右子树，传入节点值即可。"}, {"id": "6993715456141951013", "title": " LeetCode算法学习之--Stack--柱状图中的最大矩形", "desc": "大家好今天给大家分享下一道 LeetCode 困难难度 的题目[柱状图中最大的矩形] 题目 分析 解法一：stack+array 思维借鉴https://leetcode-cn.com/problem"}, {"id": "6986242041617317901", "title": "LeetCode算法学习之--数组--区间和的个数", "desc": "大家好今天给大家分享下一道 LeetCode 困难难度 的题目区间和的个数 题目 分析 解法一： 归并排序 解法二：二分查找 总结 这道题 比较难，需要的前置知识比较多， “前缀和” “二分查找” “"}, {"id": "6994986407626276901", "title": "前端刷题路-Day77：不同的二叉搜索树（题号96）", "desc": "给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数..."}]