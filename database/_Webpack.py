[{"id": "6844903545490128903", "title": "深入理解 webpack 文件打包机制", "desc": "希望通过这篇文章，能够帮助读者你理解：webpack 单文件如何进行打包，webpack 多文件如何进行代码切割，webpack1 和 webpack2 在文件打包上有什么区别，webpack2 如何做到 tree shaking，如何做到 scope hoisting。"}, {"id": "6844904037083512839", "title": "Webpack实战（一）：Webpack打包工具安装及参数配置", "desc": "在每个script标签中，顶层作用域即全局作用域，如果没有任何处理而直接在代码中进行变量或函数声明，就会造成全局作用域的污染，也会造成命名冲突。 模块化很容易就避免这些问题，避免冲突，合并资源减少网络开销，通过导入和导出语句我们可以清晰地看到模块间的依赖关系。 模块打包工具（m…"}, {"id": "6946469221693915144", "title": "Webpack编译流程详解", "desc": "1. webpack 运行流程图 2. 研究 webpack 源码的好处 3. webpack 插件 4. webpack 入口 5. compile 6. compilation 这里使用 SingleEntryPlugin 作为例子，配置单入口时会使用此插件，插件往 mak…"}, {"id": "6844903568240017415", "title": "快速入门vue-cli配置", "desc": "Vue-cli有两个文件——build和config：build文件包含了脚手架在开发环境和生产环境下webpack该如何配置。config文件则包含了build文件下webpack具体配置的值。换句话说，build下的webpack配置的值要引入config后才能获取到。 w…"}, {"id": "6905261629064085512", "title": "编写一个 webapck plugins", "desc": "一个 JavaScript 命名函数。 在插件函数的 prototype 上定义一个 apply 方法。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 Compiler 对象代表了完整…"}, {"id": "6991052651878154247", "title": "HR-10-webpack打包上线", "desc": "打包上线 配置路由模式 路由模式的介绍 hash模式 ：使用 URL 的 hash 来模拟一个完整的 URL, 其显示的网路路径中会有 “#” 号。 http://localhost:8080/#/h"}, {"id": "6945829206106308621", "title": "【教程】webpack从零搭建TS版React开发环境", "desc": "本文初衷：平时的项目大多用create-react-app开发，从开发到打包都只是在敲命令而见不到webpack.config.js配置文件，简直是面向黑箱编程，遇到问题之后即使解决了也不知道怎么回事，这种感觉非常不好。 学习 webpack 的重要性不言而喻，即使市面上已经有…"}, {"id": "6844904066057764871", "title": "开发一个基于react & typescript 的npm ui组件包", "desc": "代码仓库地址npm注册登录前置条件:切到对应的npm源npmlogoutnpmlogin依次输入账号、密码、邮箱npmpublish（会提示去npm官网验证邮箱地址）npm发布时可能遇到的问题源出错包"}, {"id": "6844903813917179918", "title": "使用webpack4一步步搭建react项目（二）", "desc": "前面已经实现了一个简单webpack配置，接下来需要在前面的基础上对webpack.config.js进行拆分。 项目开发时，我们需要用webpack-dev-server启动开发服务器，当我们修改文件时，它能自动重新打包项目并刷新页面。 项目打包上线时，我们希望webpack…"}, {"id": "6844903877951619080", "title": "Webpack：代码分割", "desc": "在当前的前端项目中，常常使用 gulp、webpack、Browserify 等将多个文件压缩合并成一个。这个过程称为打包。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。接着在页面上引入该 bundle，整个应用即可一次性加载。 打包是个非常…"}, {"id": "6844904004439244808", "title": "webpack入门笔记", "desc": "当我全局引入a.scss文件时，就会使得全局的title类名的元素文字颜色都变为红色。 使用webpack-dev-server 时。你会发现，现在没有dist目录了 ，这是因为webpack-dev-server将打包后后的文件放在了电脑的缓存中 浏览器会重新刷新，之前的所有…"}, {"id": "6844904069841027079", "title": "干货！撸一个webpack插件(内含tapable详解+webpack流程)", "desc": "Webpack可以将其理解是一种基于事件流的编程范例，一个插件合集。 而将这些插件控制在webapck事件流上的运行的就是webpack自己写的基础类Tapable。 Tapable暴露出挂载plugin的方法，使我们能 将plugin控制在webapack事件流上运行（如下图…"}, {"id": "6945660600106090532", "title": "webpack打包优化", "desc": "index 和 other 分别作为两个入口文件，且都引用了a，b两个模块。我们可以使用webpack的optimization配置抽离a，b到单独的模块，index 和 other 只需要引入抽离的公共模块即可，不需要再单独引入a，b。配置如下： 此刻，如果我们还引用了第三方…"}, {"id": "6844903553035665416", "title": "webpack打包第三方类库的正确姿势", "desc": "webpack 的使用越来越广泛，但其中不乏很多鲜为人知的细节设置，甚至很多人会认为这是 webpack 的 bug。这次，我们就来聊一聊 webpack.optimize.CommonsChunkPlugin。"}, {"id": "6949776544340393992", "title": "webpack：提高开发者效率的工具", "desc": "webpack的基本配置，重点介绍了loaderh和plugins.在讲解了下目前可以提高开发者开发效率的webpack属性。"}, {"id": "6844903816328904711", "title": "webpack打包,生成js，提供给node和浏览器使用", "desc": "目标项目搭建1：项目初始化2：文件列表3：webpack配置webpack.config.js配置如下：此处需要进行设置，这样就能够使用在node和浏览器中libraryTarget:\"umd\"glo"}, {"id": "6844903736490328072", "title": "webpack入门学习手记（一）", "desc": "之前用过gulp、grunt，但是一直没有学习过webpack。这两天刚好有时间，学习了下webpack。webpack要想深入研究，配置的东西比较多，网上的资源也有很多。我这里学习的主要途径是webpack官方给出的指南，和webpack中文网的翻译版本。因为我觉得第一手资料…"}, {"id": "6844903944985001991", "title": "webpack配置--基础篇", "desc": "webpack是一个模块打包工具,能够递归构建一个js模块的依赖关系,将模块最终打包成一个或多个文件. 进行打包. 将所有的css放在head标签中,如果内容过多,导致页面加载阻塞,根据需要将css抽离到单独的文件中. 此时,通过import $ from 'jquery'时,…"}, {"id": "6844903853398163463", "title": "demo11 webpack处理css", "desc": "在 webpack 中，所有类型的文件都是模块，比如 js、css、图片、字体、json（可以说是万物皆模块）。 但是，在普通的 js 代码中，我们直接 import (或require) 一张图片或css是会报错的。 传统引用 css 代码的方式是在 html 通过 <sty…"}, {"id": "6913034398476533768", "title": "webpack4教程【万字长文】", "desc": "​ 本质上，webpack是一个现代JavaScript应用程序的静态模块打包器。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 ​ context是webpack编译时的基础目录，…"}, {"id": "6977260323556294692", "title": "使用add-asset-html-webpack-plugin解决webpack4 dll文件在不同环境生成hash不一致的问题", "desc": "问题描述： 同一份代码，利用dll使用缓存时发现每次生成的hash值不一定总是相同，所以干脆每次打包都生成一遍，多浪费了几秒，但是解决了类似jenkins部署时不同机器环境可能生成不一致的问题。 先来"}, {"id": "6844903828794376206", "title": "理解webpack原理，手写一个100行的webpack", "desc": "什么是webpack他是一个模块打包器，也可以引用官网的一幅图解释，我们可以看到webpack，可以分析各个模块的依赖关系，最终打包成我们常见的静态文件，.js、.css、.jpg、.png。今天我们"}, {"id": "6946495106262401060", "title": "webpack打包图片资源", "desc": "webpack只能处理js模块，在js中加载图片模块时需要借助file-loader。如 url-loader可以把较小的图片转化成base64数据，从而减少对图片资源的http请求。同时打包文件也会变大； 当图片大小超过设置的限制（limit）时，默认采用file-loade…"}, {"id": "6844904012651692040", "title": "渐进式配置webpack4单页面和多页面(三)", "desc": "新建module文件，约定module目录里面每个文件目录必须有个html文件，还有一个与其名字相同的js文件作为入口文件。 引入了lodash、dropzone、xlsx、axios这4个包。 引入了dropzone、xlsx、echarts这3个包。 引入了react、re…"}, {"id": "6844903853381386254", "title": "demo05 webpack + typescript", "desc": "typescript（简称 ts ）是 javascript 的超集，具有类型系统，是可编译的。可以想象得到，在代码运行之前能够进行代码类型检查和编译是多么重要的事儿（就像 Java 等强类型语言一样）。 ts 默认根据 tsconfig.json 配置文件（很强大）来对 ts…"}, {"id": "6844903853389774856", "title": "demo09 使用 SplitChunksPlugin 分离第三方依赖包以及异步包", "desc": "在单页面或多页面应用中，通过代码分离的方式，能够优化性能。 比如把异步加载的代码分离成一个单独的chunk，等到需要调用的时候再按需加载（比如click时），这样可以减少首屏的代码体积，从而提高首屏的加载速度。 （比如 max-age ），实现对相关资源包的长缓存，从而优化性能…"}, {"id": "6943940758546153502", "title": "webpack的生产模式与开发模式详情", "desc": "在webpack看来，前端的所有资源文件（js、css、img、json..）都会作为模块处理。然后会根据模块的依赖关系进行静态分析，打包生成对应的静态资源。 口指示webpack以哪个文件为入口起点开始打包，分析构建内部的依赖图。 让webpack去处理非JavaScript…"}, {"id": "6844903550527471623", "title": "模块化开发神器 - webpack-dev-server", "desc": "webpack-dev-server就是一个基于Node.js和webpack的一个简易服务器。它在服务器端使用webpack-dev-middleware进行webpack构建打包；并在客户端注入一份runtime，用于接受服务器端的构建打包后信息。"}, {"id": "6894513545011003399", "title": "webpack实现前端代码打包(上)", "desc": "本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个…"}, {"id": "6844903599525330957", "title": "模块化的一些小研究", "desc": "我们知道最常见的模块化方案有CommonJS、AMD、CMD、ES6，AMD规范一般用于浏览器，异步的，因为模块加载是异步的，js解释是同步的，所以有时候导致依赖还没加载完毕，同步的代码运行结束；CommonJS规范一般用于服务端，同步的，因为在服务器端所有文件都存储在本地的硬…"}, {"id": "6844903811190882311", "title": "webpack4.29.6搭建常用功能的环境", "desc": "因项目需要，用webpack搭建一个常用功能的环境。 其他的文件可以先空着,图片先不导入也没关系。 确保局部依赖和全局依赖版本都如下图是最新的（看清楚了，webpack是4.29.6的，如果你因为网络问题装成3.几的，后面将全部报错。这步很关键，不然你会有无穷尽的麻烦,如果实在…"}, {"id": "6910175031238606861", "title": "webpack学习记录(0)-核心功能简述", "desc": "webpack 默认配置⽂文件：webpack.config.js，可通过webpack --config来指定配置文件。 在webpack.config.js中，除了我们常用的导出对象的方式，还有多种配置类型。 该函数会传入两个参数。一个是环境对象(environment)，…"}, {"id": "6844903636565229576", "title": "Webpack 构建策略 module 和 nomodule", "desc": "前端性能优化已经过了刀耕火种的年代，现在更多的优化是从代码层面，其中重中之重的当然是 JS 的优化"}, {"id": "6844904046499741709", "title": "Webpack之Javascript的编译", "desc": "Target是preset的核心配置，告诉preset编译的具体目标。"}, {"id": "6844904102095224846", "title": "纯手撸简单实用的webpack-html-include-loader（附开发详解）", "desc": "在单页应用盛行的今天，很多人似乎已经把简单的切图不当做一种技术活了。对于切页面，写静态网站都快要嗤之以鼻了。其实并非如此，写静态页面是前端入门的基本工作，是基本功扎实的体现。而且在工作中，我们也少不了要开发一些静态的官网类网站。我们要做的是想一想如何更好的开发静态页面。 歪马最…"}, {"id": "6950160617978200095", "title": "AST 抽象语法树", "desc": "前言：Q1：AST是什么？如何得到AST?Q2：AST用处是什么？Q1:AST是什么？如何得到AST?在程序中，一段代码在被执行之前，都会经历三个阶段：1.扫描--词法分析这个过程会将由字符组成的字符"}, {"id": "6844903847521959950", "title": "复习webpack4之DevServer实现请求转发与单页面路由", "desc": "这次学习webpack4不仅仅要会配置，记住核心API，最好还要理解一下webpack更深层次的知识，比如打包原理等等，所以可能会省略一些比较基础的内容，但是希望我可以通过此次学习掌握webpack，更好地应对以后的工作。 我们正常在开发过程中，肯定会去请求接口，在先进的项目中…"}, {"id": "6844904022940319757", "title": "如何使用webpack打包一个库library", "desc": "经过以上步骤后会生成一个library文件夹，里面包含一个package.json文件。然后简单修改为如下所示： 在根目录下新建src文件夹，新建一个math.js和string.js。相关文件内容如下： 之后会在根目录下生成一个dist文件夹，里面包含一个library.js…"}, {"id": "6865876510981488647", "title": "webpack4.x结合babel的简单实践", "desc": "1. 生成package.json 2. 安装依赖，最新的4.x webpack 3. 新建一个文件夹src，里面新建个index.js，添加es6语法 4. 新建一个webpack.config.js，这个是webpack的配置文件 5. 在 package.json 加上 …"}, {"id": "6936832346041614349", "title": "使用typescript与webpack搭建开发环境（二）", "desc": "上一章中已经搭建好开发环境，下面开始逐渐丰富项目的内容，本章是静态资源的引入。 webpack默认是只认识JavaScript的，只知道该怎么处理它，如果项目中出现了其他类型的文件，并且也希望webpack对它进行打包的时候，就要安装对应的loader了。"}, {"id": "6844903508462796808", "title": "webpack的sourcemap", "desc": "jssourcemap原理如何开启sourcemap？在打包后的代码尾部追加一行：soucemap的格式value作用eval每个模块都用eval封装进行运算，并且在末尾追加注释//@sourceUR"}, {"id": "6923753617635672072", "title": "使用 webpack 代码分割和魔术注释提升应用性能", "desc": "1. Web 应用性能优化的关键 关于 Web 应用性能优化，有一点是毫无疑问的：「页面加载越久，用户体验就越差」。我们几乎可以说 Web 应用性能优化的关键之处就在于：减少页面初载时，所需加载资源的「数量」和「体积」。 或许你会觉得这个标准有点过于苛刻了，是有一点点，但为了创…"}, {"id": "6969717147371372580", "title": "web前端开发之webpack打包", "desc": "前端工程化 一、模块化 1.1 服务器端模块化规范 CommonJS 模块分为单文件模块与包 模块成员导出：module.exports和exports 模块成员导入：require ('模块标识符'"}, {"id": "6844903998193926152", "title": "node 自动化webpack多页面打包原理", "desc": "1. 目标 学会node 的基本fs,path模块的操作。 学会自动生成webpack多页面入口文件。即对应插件。 2. 已知前提 webpacck 手动多页面打包不能，就是在entry中增加多个js入口，然后在html-web-plugin 中增加对应的多个插件就行了。如下：…"}, {"id": "6969504185498730503", "title": "《Webpack原理与实践》课程之如何使用Webpack实现模块化打包", "desc": "Webpack 作为一个模块化打包工具，除了能实现模块化打包的问题，还能在打包过程中通过 Loader 机制编译代码解决兼容性问题以及不同类型的文件（如 css 图片 html等）的打包编译"}, {"id": "6844903840601505806", "title": "webpack4-03-生成html、css3前缀、babel配置等..", "desc": "而 display: flex... 并没有添加前缀 上面的问题，主要原因是需要配置指定浏览器的范围内添加CSS前缀才能给 display: flex等，添加前缀。 现在有四种配置方法可以解决上面的问题。 在跟目录新增 .browserslistrc 配置文件。 选择此方法的目…"}, {"id": "6975521148675031047", "title": "webpack 性能优化", "desc": "1、开发环境性能优化 打包构建速度 HMR 模块热更新 （hot module replacement）~ 一个模块变化，只重新打包一个模块，极大的提高构建速度 style-loader0 内置了热更"}, {"id": "6902762475083530254", "title": "重学webpack(生产环境的配置)", "desc": "在webpack开发环境下我们往往不会让源目录中css文件在打包后单独生成一个css文件，但是这往往会使得打包后包含这些css文件内容的js文件体积臃肿，甚至可能出现闪屏现象，因为因为它的工作原理时是先加载js文件再去加载css文件。 之前通过'css-loader'和'sty…"}, {"id": "6844903513571459085", "title": "关于webpack热更新出现`Nothing hot updated`的解决方案", "desc": "今天同事反馈为什么我们的项目突然之间不能热更新了？于是我试了一下，咦，果然不能热更新了。然后试了好几个版本，发现原来热更新已经好久都不能使用了。现在是不能回滚到很老的版本的了(之前webpack做过一个很大的配置优化)，那么只能在这个新版本下找到问题的根源所在。好在所有的代码都…"}, {"id": "6909468081655906312", "title": "webpack | loader二三事 | loader类别", "desc": "前言我们都知道，loader的本质其实就是个函数；然后，额，就不知道了；“但求精，而非浮于表面”，这是我上次和面试官面面相觑了三分钟之后的最大心理感受，也是我那次面试最大的收获，本文来自于此；话不多说"}, {"id": "6844904047221145608", "title": "webpack 4 源码主流程分析（二）：配置初始化", "desc": "通过在 cli 执行命令 webpack 开始，以 development 模式为例，暂时忽略支线剧情（错误响应，缓存等等），只分析探索 webpack 的打包主流程。 根据 npm 的规则，cli 执行 webpack 后，就会去执行 node_modules/.bin/we…"}, {"id": "6844904047233744910", "title": "webpack 4 源码主流程分析（十）：资源的构建", "desc": "这一步用于生成 module 资源。 在 createModuleAssets 里获取每个 module.buildInfo.assets，然后触发 this.emitAsset 生成资源。buildInfo.assets 相关数据可以在 loader 里调用 api: thi…"}, {"id": "6844904158634475528", "title": "利用http-proxy实现本地化前端项目dist目录预览", "desc": "前后端分离项目，前端发布基本是在服务器放置一个目录，然后通过 nginx 代理方式，通过监听 / 跳转到前端dist目录存放的路径下的index.html。 如果想在本地配置一套类似服务器端的环境。 先通过fs.exists 查看文件是否存在，如果不存在，就返回404. 后续的…"}, {"id": "6844904163172696071", "title": "剖析 webpack 4 模块解析", "desc": "webpack tapable「看看git仓库的README基本就差不多了」. 简单会用webpack. webpack使用的是enhanced-resolve这个模块在进行解析，解析的原理可以简单理解成是一个管道「pipeline」 进行解析，从最初的地方传入要解析的路径，并…"}, {"id": "6975080902720897061", "title": "webpack重学— 面试汇总", "desc": "这是我参与更文挑战的第18天，活动详情查看: 更文挑战 1, webpack 核心配置 2, 有哪些常见的Plugin？他们是解决什么问题的？ 3, 为什么需要loader? 有哪些常见的Loader"}, {"id": "6918017282887122958", "title": "webpack进阶1", "desc": "文件监听是在发现源码发生变化时，自动重新构建出新的输出文件。不用手动重新构建和刷新浏览器。 在配置webpack.config.js 中设置watch: true。 轮询判断文件的最后编辑时间是否变化。 某个文件发生了了变化，并不会立刻告诉监听者，⽽而是先缓存起来，等aggre…"}, {"id": "6844903519971966990", "title": "ES6和Babel你不知道的事儿", "desc": "因babel的版本从5升级到6有很多改动，比如babel本身不再提供任何transform的工作，都需要借助插件来完成，本文的所有讨论都是建立在babel 6之上的。如果只想看结论，直接跳到文章最后。 ---写在前面 ES6即ECMAScript 6，是前端开发的JS最新规范，…"}, {"id": "6855129007320236045", "title": "搞懂搞透 webpack 的灵魂 tapable", "desc": "这段时间没更新文章，把时间全耗在了 tabable 核心原理分析上，现在终于把 tabable 搞懂了，通过本文分享给大家。最后我发现了一个非常容易掌握 tabable 的方法。 经过这几天的学习，我把 tapable 总结成一句话「通过一种机制，监听特定的事件」。拿最经典的一…"}, {"id": "6844903893445378056", "title": "【深度好文】我在做前端构建过程中的思考", "desc": "编者按：本文作者曾负责过内部某产品（以下简称 X）的「构建」流程的重构工作，在重构过程中深挖了许多知识点（为这种刨根问底的精神点赞👍），尽数浓缩在这篇五千字长文中，通篇读完绝对能带给你满满的干货！P.S.: 我们假定你已经了解 Webpack 以及前端构建相关概念。以下为正文…"}, {"id": "6912237607950745613", "title": "Webpack4.0各个击破（7）plugin篇", "desc": "一. plugin概述 plugin机制是webpack中另一个核心概念，它基于事件流框架tapable，你可以参考浏览器环境中的*【DOM事件模型】，【SPA模型中的生命周期钩子】或是node环境中的【EventEmitter模块】*来理解其作用。plugin系统提供给开发者…"}, {"id": "6844903970499117069", "title": "webpack从零基础到企业实战", "desc": "webpack是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bu…"}, {"id": "6844903551609602062", "title": "Webpack Loader源码导读之less-loader", "desc": "本篇是Webpack Loader源码导读系列中关于less-loader的解读，主要阐述loader的工作，less编译部份的内容未来将单独讲解。 @import \"~bootstrap/less/bootstrap\";，默认的模块解析将和webpack一致，但如果loade…"}, {"id": "6968746709660745741", "title": "webpack 优化措施", "desc": "介绍几点项目中webpack的优化措施 resolve配置 DLL，预打包 缓存的使用 css cache缓存 plugins 模块缓存 并发处理 js的并发处理loader，webpack之前hap"}, {"id": "6901273838291304462", "title": "webpack构建流程", "desc": "主要为了接下来进行编译做准备。 2. 编译阶段 1. 第一步： 根据入口文件进行生成一个chunk id：唯一编号，开发环境和name相同，生成环境是一个数字，从0开始。 记录检查：编译阶段一开始会有个表格，最开始这个表格是空的，表格用来存储记录的模块。 2. 读取文件内容 3…"}, {"id": "6920880832471105549", "title": "webpack系列学习-热更新和压缩", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 本篇文章讲述下热更新，文件指纹，压缩知识。 1.启动webpack命令，带上--watch参数。 2.在配置webpack.config.js中配置watch:…"}, {"id": "6844903768031690760", "title": "搭建webpack简易脚手架", "desc": "本文是为下一篇《3分钟搞定 Vue + TypeScript开发》文章做的知识铺垫，文章结尾提供完整的github示例代码库。 已经掌握vue开发的情况下，想体验一下TypeScript开发vue，可以通过以下过程配置一个脚手架。 这是一个使webpack能工作的最小配置。 当…"}, {"id": "6862251953179754504", "title": "webpack的基本概念及简单打包一个项目", "desc": "本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个…"}, {"id": "6954238345178415141", "title": "output里面的publicPath和devServer中的publicPath的区别", "desc": "在研究webpack打包的时候，一直对于publicPath有比较大的迷惑。今天就来记录一下我解惑的过程。 首先，webpack-dev-server也可以打包，它用于在开发环境中打包文件，并将打包后"}, {"id": "6844903504876683278", "title": "基于Vue-cli和Vux的webpack配置", "desc": "安装postcss和scss还有less，不是我神经病，是引用插件和个人习惯。 转换vux的px为PX，因为weUI没有使用rem，使用的是em和px，但是又不能把它的px给转换成rem，而且vux还有一个1px.less，也不能把它的px转换成大写。但是浏览器不管px是大小写…"}, {"id": "6844903970327134215", "title": "【webpack优化篇】如何让你的项目打包更快呢？", "desc": "在上一篇文章中，我们从零搭建了一个react的基础项目，其核心是webpack的配置，但是我们的webpack只是进行了基础的配置，保证了打包成功和项目的运行。如果我们想要打包更快呢？ 基于上一篇文章中的webpack，这一篇文章就教你如何优化webpack的配置。 我们在打包…"}, {"id": "6844903593313566728", "title": "Webpack基本架构浅析", "desc": "随着掌握的前端基础知识越来越多，对技术的要求逐渐不满足于实现即可，技术到了瓶颈期，自己也曾尝试写过一些开源库，不过很少有满意的作品，通常没迭代几个版本就没有耐心继续维护了。通常是面临的情形是前期设计思路太过简单导致后期扩展的时候需要重构大量的代码（GG吧~），就好比一坨屎，再怎…"}, {"id": "6844903840089800712", "title": "Webpack 知识梳理", "desc": "1. Webpack 简介及相关知识 Webpack —— JavaScript应用模块打包工具。 Node.js 是 javascript的服务器版本，Webpack 在执行打包压缩时是依赖 Node.js 的。 初始化项目，并安装 Webpack 依赖，安装 webpack…"}, {"id": "6844904081576689678", "title": "Webpack源码分析 - 初识Js解析器", "desc": "Js解析器Parser是Webpack中最重要的工具之一，不同类型的文件在经过loader处理后，将会被转换输出成为一串js字符串。紧接着Parser会将其转换为AST语法树，有了语法树就可以对代码为所欲为了，其中最重要的功能就是分析出这段代码依赖了哪些模块。Webpack将会…"}, {"id": "6844903602360680461", "title": "前端干货系列----入门webpack这一篇文章就够了", "desc": "博主学习webpack，并不是因为项目需要，而是因为webpack现在比较流行，所以想学习一下，顺便看看对现在的项目是否有用。最后经过思考感觉对当前项目的作用并不大，不过总结了一下webpack适合使用的几个场景 1.前后端分离的项目，像vue,angular,react都采用…"}, {"id": "6844903922147000333", "title": "记一次webpack打包导致的事故", "desc": "上个星期十二点半同事反馈说我们有个页面出了问题，那天我很早睡了，然后后来是我的leader在一点半被电话call醒，帮我把当天下午的版本回滚了。。。 然后第二天醒来，看到那些记录。。唉，心情复杂。 这个bug真的还是比较隐蔽，查了一上午，发现是和一个vendor有关，从vend…"}, {"id": "6844903517853843464", "title": "开发更好用的 JavaScript 模块", "desc": "不少人都曾经在 npm 上发布过自己开发的 JavaScript 模块，而在使用一些模块的过程中，我经常产生“这个模块很有用，但如果能 xxx 就更好了”的想法。所以，本文将站在模块使用者的角度总结一下，如何能让模块变得更好用。 webpack 和 rollup 都支持对 ES…"}, {"id": "6879386150193070088", "title": "Webpack的核心概念-devServer、HMR与Babel", "desc": "1. devServer 他就会监听打包源代码的变化，一旦源代码有变化他就会重新打包。从而更新dist目录下面的文件。 这是第一种解决方法。不会帮我们起服务器，没办法做ajax调试，必须手动刷新浏览器。 上述方法只能完成自动打包，但是你想要自动打开文件，并且模拟一些服务器的特性…"}, {"id": "6844903768283332616", "title": "webpack4+babel7入门到精通(一、环境的搭建)", "desc": "对于一般的新手都有一个疑惑我是全局安装还是本项目中安装(局部安装),个人建议,现在前端发展那么快,我们使用局部安装的方式更好(使用最新的技术栈)。 我们知道javascript是弱语言,有局部变量和全局变量,其实全局安装与局部安装的性质与函数的全局变量与局部变量有点类似。 6、…"}, {"id": "6844903609923026957", "title": "Web Bundler CheatSheet, 选择合适的构建打包工具", "desc": "题注：Web Bundler CheatSheet 属于 Awesome-CheatSheet 系列，盘点数个常用的开发打包工具清单。欢迎加入阿里南京前端团队，欢迎关注阿里南京技术专刊了解更多讯息。 工欲善其事，必先利其器，当我们准备开始某个 Web 相关的项目时，合适的脚手架…"}, {"id": "6844904195397550093", "title": "webpack构建过程的进度条实现原理", "desc": "我们在使用webpack的时候经常会用到webpackbar或者progress-bar-webpack-plugin之类的webpack插件通过进度条等方式来展示webpack的构建进度，以提升构建过程中的反馈体验。对于不同的插件来说，它们只是进度条的UI展示形式不同而已，但…"}, {"id": "6844903586942451726", "title": "webpack的编译&构建", "desc": "上一篇文章webpack详解中介绍了webpack基于事件流编程，是个高度的插件集合，整体介绍了webpack 的编译流程。本文将单独聊一聊最核心的部分，编译&构建。 webpack的构建中总会经历如下几个事件节点。 其中make是整个构建中最核心的部分编译，通过模块工厂函数创…"}, {"id": "6844903587718365197", "title": "基于Webpack和ES6构建NPM包", "desc": "1. 创建repository并clone到本地 2. 添加.editorconfig 3. 创建目录 4. 创建package.json 5. ESLint 初始化 6. 创建webpack和babel的配置文件 7. 添加npm命令 1. 安装AVA 和 nyc 2. 添加…"}, {"id": "6925594176071565320", "title": "从 Bundleless 看前端构建", "desc": "Bundle or Bundleless？自 2015 年 ESM 标准发布后，路线之争就开始逐步升温。转眼间，时间已来到 2021 年。如果白酒的车你错过了，那么不妨看看 Bundleless，或许它就是前端圈的下一位「茅台」。 不得不说，曾经把自己定位为「打包器」的 Web…"}, {"id": "6844903962198409230", "title": "webpack基础（三）--多页面打包", "desc": "多页应用MPA：每一次页面跳转，服务器都会返回一个新的html文档，这种类型的网站就是多页网站，也叫多页应用。 缺点：每次新增或删除页面都需要修改webpack配置,页面过多时，会写非常多的html-webpack-plugin配置，造成webpack配置文件冗长，不利于维护。…"}, {"id": "6844903735970414599", "title": "JavaScript模块化原理浅析", "desc": "模块化简单来说就是是指把一个复杂的系统分解到多个模块以方便编码。JS模块化的大致流程为：CommonJS（服务端） -> AMD（浏览器端）-> UMD（兼容了CommonJS和AMD） -> ES Module（ES6标准）。本文将从它们的用法进行介绍，简单实现其原理。并简易…"}, {"id": "6854573216108085261", "title": "HTML Webpack Plugin（翻译）", "desc": "这是一个webpack插件，它简化了HTML文件的创建，为您的webpack包提供服务。这对于在文件名中包含哈希值的webpack包包特别有用，它会在每次编译更改。你可以让插件为你生成一个HTML文件，使用lodash模板提供你自己的模板，或者使用你自己的加载程序。 html-…"}, {"id": "6844904018053955591", "title": "contenthash才是缓存的重要hash - webpack hash contenthash chunkhash你真的懂了吗?", "desc": "webpack在实例化的时候会在全局创建一个Tapable子类Compiler, 该实例掌握了初始化配置信息，运行编译入口函数，注册和调用插件等等。 但是, 每个chunk都是有css与js组成, 也就是说当其中一个文件发生变化，这个chunk都会重新编译，此时contenth…"}, {"id": "6844903581678567437", "title": "为vue项目添加骨架屏 - xiaOp的博客", "desc": "前段时间阅读了饿了么的 PWA 升级实践一文，受益匪浅。其中构建时使用 Vue 预渲染骨架屏一节，为开发者提供了减少白屏时间，提升用户感知体验的新思路。本文将借鉴这一思路，尝试为 Vue 项目添加骨架屏。 著作权归作者所有。 商业转载请联系作者获得授权,非商业转载请注明出处。"}, {"id": "6844903968536018957", "title": "浅谈webpack，实现从零到一", "desc": "webpack是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bu…"}, {"id": "6844903607439982599", "title": "深入理解webpack如何解析代码路径", "desc": "直接引入模块名，会查找当前文件目录，父级目录直至根目录下的 node_modules(默认) 文件夹，看是否有对应名称的模块。 了解上述的路径形式和最终的解析规则后，根据我的一些标识，大致上也能够看出webpack路径配置的发挥空间了。 接下来将着重对resolve中alias…"}, {"id": "6844903715250389006", "title": "Webpack之模块化优化", "desc": "当然，相信了解过前端模块化发展历史的童鞋，都应该听过IIFE、AMD、CommonJS等等，它们都是能够实现模块化的规范，直到ES2015出来后，才正式把模块化纳入其标准中。在谈到今天主题前，我们先简单讲解一下上面几种模块化方式的实现以及区别，对于后面将要讲到的webpack模…"}, {"id": "6969597381184585742", "title": "webpack 之 Loading chunk x failed", "desc": "闲话几句，看书看到 webpack 打包抽取vendor 并进行客户端缓存加快整体渲染速度，联想到之前在开发后进入测试环节时，明明我本地是没有问题的，但相同的代码在生产环境下打包部署到测试环境时，"}, {"id": "6854573212202696717", "title": "webpack常用配置", "desc": "1. 模块热替换 启用此功能需要更新 webpack-dev-server 的配置，和使用 webpack 内置的 HMR 插件。 CSS 的模块热更新，借助于 style-loader 。 2. Tree shaking 「副作用」的定义是，在导入时会执行特殊行为的代码，而不…"}, {"id": "6844903736746180616", "title": "可能是全网最全最新最细的 webpack-tapable-2.0 的源码分析", "desc": "但是 tapable 2.0.0-beta 版本的重构，犹如艺术品一般，让人惊艳。源码内部采用 getter 惰性加载与缓存的方式，以及利用 new Function 去消除递归调用。 消除递归调用的方式就是在第一次调用 call 的时候，通过字符串拼接可执行的字符串代码（源码…"}, {"id": "6969588654134001677", "title": "玩转 webpack5（下）", "desc": "前言 这是接玩转 webpack（上） 的续集。 本篇长文是学习程柳峰老师开设的《玩转 webpack》专栏的实践笔记，和专栏不一样的是，我的实战源码是基于 webpack5，它的配置和源码实现上与 "}, {"id": "6844903861430255630", "title": "构建工具篇 - react 的 yarn eject 构建命令都做了什么", "desc": "前段时间，一直在研究 react 技术栈，对于项目的构建方面，又有一定的特殊需求，通过 npx create-react-app [filename] 安装以后，发现没有 webpack 相关的配置的目录，在读了 react 官方文档后，发现通过 yarn eject 可以弹出…"}, {"id": "6844903808678510600", "title": "Webpack 模块打包机制浅析", "desc": "在官方定义中，Webpack 是一个现代 JavaScript 应用静态模块打包器。它统一了 JavaScript 在发展过程中出现的各种模块化方案，我们可以认为 Webpack 是 JavaScript 模块化的统一解决方案。 如果有对 JavaScript 各种模块化方案还…"}, {"id": "6988083824462659598", "title": "Webpack配置工程师如何玩转Plugin？", "desc": "了解 Webpack Plugin 的作用和原理，能够独立开发需要的 Webpack Plugin。"}, {"id": "6962122030002995207", "title": "如何用Webpack打包组件库", "desc": "如何用webpack打包组件库，有多个entry，能按需引入，打包文件不冗余。 网上webpack打包组件库的案例不多，快来看看吧"}, {"id": "6844904130620702734", "title": "基于webpack从0配置vue开发", "desc": "vue 官方为了让开发者快速进行开发，为了很大的精力，提供了vue-cli脚手架，只需简单几步，就能开始vue的开发了。 然而，对项目里的webpack封装和配置了解的不清楚，就容易导致出问题不知如何解决，甚至不会通过webpack去扩展新功能，对webpack+vue项目究竟…"}, {"id": "6992835694846541860", "title": "webpack为啥这么难搞明白", "desc": "网上在介绍webpack的时候，一般都是照本宣科，但是对于初学者来说，其他会还是不太懂怎么回事。下面我还是要根据自己的理解跟大家简单介绍一下。webpack工程化的部分，现在用一张图搞清楚到底怎么回事"}, {"id": "6844903694035582989", "title": "vue + webpack 前端性能优化", "desc": "对于程序开发者而言，开发一个项目不仅仅注重效率和功能，前端的性能问题也是非常重要的。这直接影响用户的体验，从而间接的也反应该项目质量的好坏。 影响项目性能的原因有很多，如：资源文件的大小，业务的繁杂程度等，所以前端优化的方式也很多。这些东西很零碎，容易被人遗忘。所以这篇文章中对…"}, {"id": "6844904057593659400", "title": "基于webpack的热重载live reload和热更新HMR", "desc": "热更新HMR： 热重载live reload并不能够保存应用的状态（states），当刷新页面后，应用之前状态丢失。举个列子：页面中点击按钮出现弹窗，当浏览器刷新后，弹窗也随即消失，要恢复到之前状态，还需再次点击按钮。而webapck热更新HMR则不会刷新浏览器，而是运行时对模…"}, {"id": "6981334547711393800", "title": "webpack5 编译打包优化", "desc": "webpack5 的版本为优化手段 引入 webpack5 持久缓存，在开发环境和生产环境下，提高编译打包速度。"}, {"id": "6866747701908733966", "title": "深入 Webpack 的 Tree Shaking", "desc": "书接上回，JS SDK 构建实现 Webpack VS Rollup 中 Webpack 和 Rollup 的代码打包体积拉开了一倍差距，很大原因是因为各自的 Tree Shaking 算法不一样， 所以本文先深入 Webpack Tree Shaking 源码一探究竟。 tr…"}, {"id": "6871239792558866440", "title": "实现一个 webpack loader 和 webpack plugin", "desc": "例如 babel-loader 可以将 ES6 代码转换为 ES5 代码；sass-loader 将 sass 代码转换为 css 代码。 rules 数组包含了一个个匹配规则和具体的 loader 文件。 上述代码中的 test: /\\.js$/ 就是匹配规则，表示对 js …"}, {"id": "6861445973114585095", "title": "webpack编译体积优化——CDN", "desc": "对于一个应用来说，如果资源体积过大，那么势必会影响到性能。所以我们会绞尽脑汁想着去提升应用的性能，而CDN就是一种手段。对于一些提供了CDN的第三方库，我们完全可以不用通过npm的形式安装到项目里，而是以CDN方式引入。这样做无疑可以减少资源打包体积，而且应用响应速度更快。 C…"}, {"id": "6844903683826810887", "title": "Javascript 模块化管理的来世今生", "desc": "直接回想起来的就是 cmd amd commonJS 这三大模块管理的印象。但是大家清楚 cmd amd commonJS 为什么会出现么？接下来，我们就一起来瞅瞅这具体是啥情况。 通过立即执行函数，让外部根本没有时间从外部去修改内部的属性，从而达到一定的防御作用。 以上就是我…"}, {"id": "6993649086117183495", "title": "webapck核心依赖库--Tapable", "desc": "Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable"}, {"id": "6844903558597312520", "title": "从零开始做Vue前端架构（1）", "desc": "想想也已经做过不少架构的项目了，有基于vue，基于react，基于thinkPHP，基于laravel的。 做多了，也就对现有的架构有各种想法，有好的，有坏的，总之，用起来还是不爽。vue-cli虽然可以很快地构建并使用，尤其是vue-cli v3.0，把webpack都封进@…"}, {"id": "6996598190719893535", "title": "babel的安装和使用到webpack中使用babel", "desc": "babel的安装和使用 babel简介 babel一词来自于希伯来语，直译为巴别塔 巴别塔象征的统一的国度、统一的语言 而今天的JS世界缺少一座巴别塔，不同版本的浏览器能识别的ES标准并不相同，就导致"}, {"id": "6959721156350296095", "title": "谈谈gulp和webpack？✔️", "desc": "☀️对于刚毕业踏入社会的小白前端，在习惯了Vue脚手架完成业务功能后自带的webpack打包后对于打包的印象基本上就只有一个:npm run build 但是往往我们看招聘信息上面都有这么一行..."}, {"id": "6988896034520825869", "title": "Webpack5学习 --- 资源模块类型和常见的plugins", "desc": "模块资源类型是webpack5中新增的，用以直接对引入的资源进行打包，而不用再使用loader进行解析。loader的功能主要是模块解析，如果需要对webpack进行扩展，需要使用对应的plugin。"}, {"id": "6844903545011961869", "title": "NODE_ENV和webpack", "desc": "很显然，NODE_ENV 属性并不在 process.env 对象上，但通过字面意思（node environment）可以知道，这意为 node.js 环境。 express.js 中首次使用该变量，然后推广、普及至整个前端社区。 它的主要用途是：在使用 node.js 环境…"}, {"id": "6844903625139961863", "title": "Webpack下多环境配置的思路", "desc": "由于前后端分离的前端应用脱离了后端的支持，在单独开发前端应用时，页面调试时使用固定的开发环境地址还好，如果出现在本地开发时需要调试不同环境的远端API，或者需要将应用部署到不同环境的服务器上时，如果不将这些环境对应的服务器地址、环境专属变量等单独配置，也许每次切换环境都需要修改…"}, {"id": "6844904001792655373", "title": "webpack优化之玩转代码分割和公共代码提取", "desc": "开发多页应用的时候，如果不对webpack打包进行优化，当某个模块被多个入口模块引用时，它就会被打包多次（在最终打包出来的某几个文件里，它们都会有一份相同的代码）。当项目业务越来越复杂，打包出来的代码会非常冗余，文件体积会非常庞大。大体积文件会增加编译时间，影响开发效率；如果直…"}, {"id": "6844903587491889165", "title": "Webpack4优化之路", "desc": "Webpack4 那点儿东西 基于webpack4总结了一些webpack的常见配置，但是webpack 各种强大的配置有时候让你不堪重负，会打包很多的文件，遍历解析很多文件。。。。。总之，这些操作会让webpack打包过程变得很慢，所以开发过程中我们不得不去优化一些配置，让w…"}, {"id": "6894122794578083847", "title": "重学webpack4之构建速度提升和体积优化", "desc": "没用过... 经过一周的时间，重新对这几年使用webpack4的感悟进行整理，是时候和 webpack4 说再见了，希望以后不要再见了... webpack5 向我们招手，读了webpack5源码，得出一个结论：v5之前所有的webpack技巧和插件、loader...，全被遗…"}, {"id": "6989948999130152973", "title": "了解Webpack Source Map配置与实践", "desc": "Source Map是浏览器对于混淆压缩代码与源码之间做转换的技术，方便开发者调试的。浏览器默认是不加载的Source Map文件的，只有在浏览器弹出调试控制台的时候才会加载。所以线上要使用单独的.m"}, {"id": "6898966751787417614", "title": "手写一个轻量级的 js 打包工具", "desc": "当我们用 node 去运行 index.js 的时候，会得到这样的结果 hello, water! I'm 28 years old.。但是当我们直接在 html 中引入该 index.js 文件，控制台是会报错的，就像下面这样（相信大家都应该见过）： 那很显然了，浏览器已经很…"}, {"id": "6887480965455675406", "title": "WebPack基础入门(一)：万物皆可webpack", "desc": "前端技术日新月异的发生着变化，涌现出了很多的框架以UI为主的三大框架(react,vue,angular)，与样式相关的less、sass。语法相关的es6 typescript以及npm上面成千上万的第三方工具包，各种可以提高开发效率的新思路和框架层出不穷，但是他们都有一个共…"}, {"id": "6907481449499197454", "title": "前端工程化概述", "desc": "从广义上来讲，前端工程化其实就是遵循一定的标准和规范，通过工具去提高生产效率，降低开发成本的一种方式。工程化在近些年被广泛的关注和探讨，其主要原因是现代化前端应用功能要求在不断提高，业务逻辑变"}, {"id": "6984742630139625480", "title": "webpack学习笔记（五）：webpack5+express+react+mongoose", "desc": "这是webpack学习笔记系列的第五篇文章，我们将利用第四篇笔记的项目作为基础项目，搭建完整的全栈项目配置模板。"}, {"id": "6844903567606677518", "title": "webpack-4.0更新日志（翻译）", "desc": "不在支持Nodejs 4。源代码已经更新到一个较高的ecmascript版本。 import()永远都会返回一个带命名空间的对象。CommonJS模块会被包成export的default里面。 这个很可能会破坏你的代码，如果你使用import()的方式去导入你的CommonJS…"}, {"id": "6983988494251065375", "title": "webpack打包Vue后生成一个可修改的配置文件", "desc": "问题背景 工作中两个场景都需要将stg和prod环境的前端代码中不同的接口url 以及各种外部引用的url等提取到静态变量中，并且更改静态变量的配置url就可以改变网站的访问接口 场景一：做docke"}, {"id": "6993274785505476645", "title": "webpack 学习系列(一)：module federation", "desc": "使用 module federation，我们可以在一个 javascript 应用中动态加载并运行另一个 javascript 应用的代码，并实现应用之间的依赖共享。"}, {"id": "6975051058955419655", "title": "Webpack实战配置", "desc": "webpackDevServe的作用是什么？ 每一次，我们改变完了我们的代码，如果想正确的能够在浏览器上运行，都需要在npm run build后手动打开dist目录下的html文件，这样办才能实现代"}, {"id": "6924484965073862664", "title": "一文搞懂 webpack 懒加载机制 —— webpack 系列", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器 (module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图 (dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多…"}, {"id": "6977544448313917453", "title": " webpack 依赖管理", "desc": "webpack 依赖管理 webpack 提供的模块加载方式很多，ES2015 的静态加载方式是官方推荐的，但有时需要加载大批量的模块，就可以使用 webpack 模块方法的 require.cont"}, {"id": "6898451631076016141", "title": "带给你幸福感的 auto-inject-async-catch-loader 😍", "desc": "前天（周日），写了一个 webpack-loader，auto-inject-async-catch-loader，晚上 8 点多发的 npm 包。昨天早上，上 npm 官网一看，才十几个小时下载量 282 次（着实有点意外😯）～ 在之前，我写过一篇文章《现场教学，优雅地处理…"}, {"id": "6972844010612195365", "title": "深入剖析webpack", "desc": "说到构建工具，我往往会在前面加「自动化」三个字，因为构建工具就是用来让我们不再做机械重复的事情，解放我们的双手的。"}, {"id": "6966483968279445534", "title": "手写 webpack 模块加载与理解 module federation 原理", "desc": "前言 最近在使用 qiankun 构建子应用的时候，遇到了父子应用使用了相同 lib 的导致打包出来两份 ，增加了代码体积。为了优化这个问题，官方文档目前建议使用 webpack 的 external"}, {"id": "6844903512086675469", "title": "一个干净优雅的 Element UI Admin 模板", "desc": "最近做了很多单页应用，当项目越来越大的时候，才发现刚开始多做一些基础工作，多想想项目合理的结构和一些必要的封装会带来事半功倍的效果。以后再也不要接到需求就干了。 hh~~ 这个是基于Element UI的后台单页应用模板，封装了api,做了一些基础工作，可以自行查看，就只有登陆…"}, {"id": "6844903664297967630", "title": "使用webpack4打造自己的前端工作流", "desc": "webpack4发布已经有一段时间了，我在实践的过程中发现，很多项目配置在webpack3下工作正常，但是升级到webpack4直接就崩了，如果想要webpack4正常工作，很多插件也需要升级到新版。下面是我使用webpack4配置的一个学习案例，包含了日常开发的常用配置项，比…"}, {"id": "6965677810862161950", "title": "Webpack 模块化原理和SourceMap", "desc": "Webpack模块化 Webpack打包的代码，允许我们使用各种各样的模块化，但是最常用的是CommonJS、ES Module。 包括如下原理: CommonJS模块化实现原理; ES Module"}, {"id": "6844904078468710407", "title": "再谈前后端分离开发和部署", "desc": "前后端分离开发已成为业界的共识，但分离的同时也带来了部署的问题。传统web模式下，前端和后端同属一个项目，模板的渲染理所当然由后端渲染。然而随着node的流行，以及webpack的模块化打包方案，让前端在开发阶段完全有能力脱离后端环境：通过本地node启动一个服务器，搭配Moc…"}, {"id": "6844903545846644750", "title": "从搭建vue-脚手架到掌握webpack配置（一.基础配置）", "desc": "接下来我们从初始化到写配置再到添加loader和插件逐步构建一个可用的vue工程化环境，让初学者亲自搭建vue-cli之余还了解到webpack常用的一些配置项。 vue-loader,是用于编译vue项目中组件化文件 *.vue ，把其转换为JavaScript的webpac…"}, {"id": "6844903596970999815", "title": "关于Rollup那些事", "desc": "下一代打包工具，这是rollup对自己的定位。如今的前端领域，构建工具并不缺少，每个前端工程师都用过或者听过webpack。可以看到的是像React、Vue等框架的构建工具使用的都是rollup。既然如此，这些框架为什么会选择rollup？它的特性是什么？面对不同场景，我们要怎…"}, {"id": "6844903540461142029", "title": "跟着Vue-cli来'学'并'改'Webpack之 打包优化", "desc": "首先，我们要知道什么要用webpack来打包，这样打包有那些好处。我们可以简单的列出以下几点： 这篇文章的重点讲的就是webpack打包之优化浏览器缓存管理，vue-cli生成的脚手架的配置中，已经做了很多对于打包，利用缓存的优化处理，本文将来学校其中知识，并且做出改动。 在此…"}, {"id": "6844903686649413645", "title": "【webpack进阶】可视化展示webpack内部插件与钩子关系📈", "desc": "webpack的成功之处，不仅在于强大的打包构建能力，也在于它灵活的插件机制。 也许你了解过webpack的插件与钩子机制；但你或许不知道，webpack内部拥有超过180个钩子，这些钩子与模块（内置插件）之间的「创建」「注册」「调用」关系非常复杂。因此，掌握webpack内部…"}, {"id": "6844904194059550734", "title": "替代 webpack？一文带你了解 snowpack 原理，你还学得动么", "desc": "近期，随着 vue3 的各种曝光，vite 的热度上升，与 vite 类似的 snowpack 的关注度也逐渐增加了。目前（2020.06.18）snowpack 在 Github 上已经有了将近 1w stars。 snowpack 的代码很轻量，本文会从实现原理的角度介绍 …"}, {"id": "6989109194838900767", "title": "webpack配置练习typescript的web项目", "desc": "目前最流行的三大框架，Angular高版本强制依赖ts，后来react和vue也引入对ts的支持。ts除了是js的超集，还很可能是js的未来，花点时间学一下也是有必要的。"}, {"id": "6844903512351080461", "title": "知多一点 webpack 的 CommonsChunkPlugin", "desc": "hello~亲爱的看官老爷们大家好~ 最近一直在学习 webpack 的相关知识。曾几何时我总觉得 webpack 的体系庞大而难以掌握，一直回避不愿去学。然而伟人鲁迅曾说过： 世上太多事会因无法掌握而使你狂躁不安，最好的解决方法就是硬着头皮开始做！ 因而就从比较简单的 Com…"}, {"id": "6965667424146292750", "title": "记一次 webpack 4 升 5 的心路历程", "desc": "前言 由于最近在使用 qiankun 搞微前端，遇到个优化问题即假如基座和子 app 都共用了同一版本的 vue 和 vantUI，那么就导致说基座和主应用都会分别打包一份，导致了用户需要请求的代码体"}, {"id": "6944920055649927176", "title": "谈: webpack的loader与plugin", "desc": "一句话总结,webpack是用来编译打包代码的. 在当下ES6语法在项目中屡见不鲜的情况下,一些浏览器其实对ES6还不是很友好,这时候就需要有个中间介质来做翻译.那webpack就是市面上众多'翻译'中的一员. 在日常开发中,我们除了一些样式/图片元素还会使用很多框架,类库..…"}, {"id": "6977281866902536200", "title": "【开门见山】Webpack从入门到入土", "desc": "一、Webpack 简介 1.1 webpack 是什么 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在webpack 看来, 前端的所有资源文件(j"}, {"id": "6974792801523335175", "title": "Webpack基础配置", "desc": "Entry与Output的基础配置 entry 顾名思义就是打包的入口文件, Output就是打包的出口文件。 上述代码块中的Entry配置的是多文件入口，其中main是指入口文件是src目录下的in"}, {"id": "6969378129563516941", "title": "《Webpack原理与实践》课程之Webpack究竟解决了什么问题", "desc": "要知道 Webpack 解决了什么问题， 先要对他解决的问题进行了解。 先回答我：为什么模块很重要？ 答：因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 但是，这样做有"}, {"id": "6987347279749316639", "title": "TypeScript和webpack问题浅析", "desc": "never 类型是什么？ 它用来描述那些永远无法出现的值。 never类型是所有类型的子类型，可以赋值给任何类型的值 除never类型外，任何类型都不是never的子类型，也不能赋值给never类型的"}, {"id": "6986936374876176397", "title": "Webpack 构建小程序环境", "desc": "小程序开发过程当中发现随着开发的推进包大小越来越大，同时平时开发中适应了SCSS、LESS预处理器的用法，再来写wxss是完全不适应，因此考虑通过webpack构建小程序开发环境，解决上述问题。"}, {"id": "6844903560828682248", "title": "webpack 4.0.0-beta.0 新特性介绍", "desc": "近年来前端技术如雨后春笋般蓬勃发展，我们也在这个潮流下不断地学习、成长。前端技术的不断发展，给我们提供了许多的便利。例如：JSX的出现为我们提供了一个清晰、直观的方式来描述组件树，LESS/SASS的出现提高了我们书写css的能力，AMD/CommonJS/ES6 的出现为我们…"}, {"id": "6999408105352069127", "title": "深入 Webpack5 等构建工具系列二(8) - PostCSS 的介绍和命令行使用", "desc": "这是我参与8月更文挑战的第21天，活动详情查看：8月更文挑战 上一篇文章我们讲了一个非常重要的工具——browserslist，可以说，在当前涉及前端工程化的项目中，都会用到这个工具。而我们在安装 w"}, {"id": "6844903588506894349", "title": "Webpack 4进阶--从前的日色变得慢 ，一下午只够打一次包", "desc": "近期在团队项目里把Webpack升级到4.4.1，过程中发现现存的升级文档十分有限，踩了不少坑，好在升级之后提升还算显著，production场景下第三方依赖打包速度提升76%，development场景下本地服务首次启动提升效果约46%，再次启动提升效果上升至63%。这里将这…"}, {"id": "6930236333369589774", "title": "vite的前世今生及自制md插件", "desc": "Vite使用nativeESmoduleimports实现组件、样式、模板加载以及热更新，这会不会成为后续工具链的发展方向？vite是什么vite——一个由vue作者尤雨溪开发的web开发工具，它具有"}, {"id": "6937920661629173797", "title": "webpack@4.x迁移webpack@5.x记录，减少了1.2%的构建体积", "desc": "如果出错需要更新node版本，当前使用的node版本为v14.0.0。 注意: 测试完后需要清除这部分代码。 这是因为copy-webpack-plugin在版本更新到7.*后，API有所变更导致的，解决方式为: 按新的API进行更新配置项。 如需查看详情，可点击相关链接。 当…"}, {"id": "6903034786407776269", "title": "webpack配置", "desc": "6.在项目下打开命令行窗口，运行npx webpack命令，webpack项目会自动先找到webpack.config配置项，然后根据配置信息进行打包，成功后项目中会多个dist文件，dist就是打包输出的结果。 2.在webpack.config.js中引入html-webp…"}, {"id": "6882283978947035144", "title": "Webpack4打包速度优化", "desc": "chunkhash和hash不一样，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。我们在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以…"}, {"id": "6982578426276216845", "title": "webpack试练01", "desc": "1、项目生成 2、配置 1、entry 文件入口 2、output 输出文件 3、module 模块配置 4、plugin插件 hash 文件指纹 hot 热更新 另一种方法： mode 环境"}, {"id": "6982560275664732190", "title": "从0到1构建 react+ webpack ", "desc": "教你从无到有的构建 react 应用，再到 webpack 的配置优化 如果感觉对你有帮助，请点赞哦~"}, {"id": "6978839148014764062", "title": "webpack | 进阶用法2：代码分割和动态引入的实现方式", "desc": "webpack系列文章连载中... Webpack可以将代码分割为chunks（语块），当代码运行到需要它们的时候再加载。"}, {"id": "6866756948704886791", "title": "使用 webpack-chain 来创建 webpack 配置", "desc": "常用的 webpack.config 结构主要有 entry、output、resolve、module、plugin、optimization 这几项配置。我们来看看在 webpack-chain 中这些都是怎么配置的。 可以看到这个构造函数中有很多属性和原型上的方法,接下来…"}, {"id": "6844904196790026253", "title": "妈妈再也不用担心我的优化｜Webpack系列（二）：SplitChunksPlugin源码讲解", "desc": "上期通过项目优化分享和实例解析：在淘宝优化了一个大型项目，分享一些干货（代码实例，图文结合），把 webpack 打包优化利器 SplitChunksPlugin 系统讲解了一遍。本期进一步深入，分析 SplitChunksPlugin 源码，搞清楚 webpack 是怎么和 …"}, {"id": "6844903650939109384", "title": "Webpack 4 和单页应用入门", "desc": "可以说是我目前看到最详细的 webpack 4 入门文章。 基本看完这个，基本也算一个合格的初级webpack配置工程师了。"}, {"id": "6872354325553741838", "title": "深入了解 webpack 模块加载原理", "desc": "webpack 是一个模块打包器，在它看来，每一个文件都是一个模块。 无论你开发使用的是 CommonJS 规范还是 ES6 模块规范，打包后的文件都统一使用 webpack 自定义的模块规范来管理、加载模块。本文将从一个简单的示例开始，来讲解 webpack 模块加载原理。 …"}, {"id": "6965306376050606094", "title": "80行代码教你写一个Webpack插件并发布到npm", "desc": "最近在学习 Webpack 相关的原理，以前只知道 Webpack 的配置方法，但并不知道其内部流程，经过一轮的学习，感觉获益良多，为了巩固学习的内容，我决定尝试自己动手写一个插件"}, {"id": "6844903560325398541", "title": "react-loadable原理浅析", "desc": "有兴趣的同学可以自行研究。 这样，你就会发现只有路由匹配的时候，组件才被import进来，达到了code splitting的效果，也就是我们常说的按需加载，\b代码分块，而不是一开始就将全部组件加载。 可以观察到，点击不同的路由都会加载一个chunk.js，这就是我们所分的块。…"}, {"id": "6844904122613760007", "title": "Vue项目webpack打包报错：Module not found: Error: Can't resolve './src/todoItem'", "desc": "今天在学习vue单文件组件的打包，在运行 npm run build 打包出现报错。 问题的根源是在导入组件时没有指定文件扩展名。真是惭愧😥，使用脚手架构建项目，组件导入的时候都是不用拓展名的，却又没有深究为什么可以不适用拓展名。因为脚手架生成的配置文件中有对模块文件的扩展名…"}, {"id": "6990612761084428319", "title": "webpack5+react+typescript遇见的坑,总结篇(持续更新)", "desc": "webpack5+react+typescript 热更新失效 路由重定向 使用 import 文件路径别名"}, {"id": "6941321963956600862", "title": "EMP 下一代微前端解决方案 V1.8.0  工程化推进", "desc": "EMP微前端 目前项目遇到的使用问题 以及微前端的一些问题整理和优化，目前订立更具象化的工程化内容如下:1 emp-config.ts 引入 优化EMP配置方案 v1.8.0已完成json expor"}, {"id": "6844903833445859335", "title": "webpack系列之五module生成2", "desc": "在上一篇 module生成1中我们已经分析了 webpack 是如何根据 entry 配置找到对应的文件的，接下来就是将文件转为 module 了。这个长长的过程，可以分成下面几个阶段 create: 准备数据，生成 module 实例。 add: 信息保存到 Compilat…"}, {"id": "6844903903675285511", "title": "Webpack 源码研究", "desc": "将我的研究成果，画一个简要的流程图，如果您有兴趣看完，回头再看看这个流程图。 图片里的方块中文字的序号，就是运行的顺序。 通过我们以往对tapable的了解，知道可以通过钩子来监听Tapable类相应的事件，我们做相应的处理就行了。 写插件关键的问题不是注册钩子，而是compi…"}, {"id": "6870764830450515982", "title": "【我只看到了第三层】重新聊聊webpack", "desc": "针对技术而言，越学越感觉不会的太多。可能是没到达一定的境界。在网上冲浪学习的时候，看到有些大佬文笔从容，思路清晰。对某个技术点的深度刨析。真产生了一种发自内心的尊重和佩服和尊重和佩服。有些时候，一段文字就能点醒你，原来是这样！！！有时候感觉到这东西被嚼碎了往你嘴里塞你都嚼不动的…"}, {"id": "6916315177411411981", "title": "「webpack 核心特性」loader", "desc": "webpack 是一个现代 JavaScript 应用的静态模块打包器。那么 webpack 是怎样实现不同种类资源模块加载的呢？ 没错就是通过 loader。loader 用于对模块的源代码进行转换。loader 可以使你在 import 或加载模块时预处理文件。 webpa…"}, {"id": "6992559832733581320", "title": "webpack基础 | 8月更文挑战", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 简介 官网：https://nodejs.org/en/ Webpack是一个JavaScript应用程序的静态模块打包器（module b"}, {"id": "6872559510746529799", "title": "webpack原理与实践（一）为什么选用webpack", "desc": "在写Node入门系列的时候，我在文中就预告过，会再出一个webpack系列，因为webpack的打包构建离不开Node.js的支持，二者紧密联系，如果仅仅只学webpack，一定会碰到Node.js的相关知识。截止本文发稿，Node.js系列已经写到第五篇，我已经为你准备好了所…"}, {"id": "6844904149406973960", "title": "通过这6个很棒的Webpack插件提高您的生产力", "desc": "webpack插件用于执行更广泛的任务，例如包优化，资产管理和环境变量注入。 webpack本身建立在与webpack配置相同的插件系统上。根据你使用Webpack的方式，有多种使用插件的方法。 事不宜迟，这里有六个很棒的webpack插件。 通过交互式的、可缩放的树状图来可视…"}, {"id": "6844904131157557256", "title": "常见loader源码简析，以及动手实现一个md2html-loader", "desc": "本文会带你简单的认识一下webpack的loader，动手实现一个利用md转成抽象语法树，再转成html字符串的loader。顺便简单的了解一下几个style-loader，vue-loader，babel-loader的源码以及工作流程。 webpack允许我们使用loade…"}, {"id": "6969092196003741704", "title": "webpack学习笔记（三）：环境配置", "desc": "在这篇博客中，主要介绍三个内容：开发环境，生产环境，环境变量。在学完这些东西之后，基本上就可以搭建一个简单的webpack工程模板了。"}, {"id": "6844903768014716942", "title": "一个合格的Webpack4配置工程师素养：第一部分", "desc": "总结Webpack4常见的配置, 含DEMO, 一步步肥肠详细，略长, 后续结束时候我们给出源码文件。 然后通过npx执行webpack进行打包。 或者配成一个script命令也可以。 在浏览器打开index.html就会发现代码执行成功了。 假设我们现在需要在index.js…"}, {"id": "6844903780408901639", "title": "曲线救国：webpack打包优化黑科技", "desc": "随着我们项目越来越复杂，我们在用webpack打包的时候，会发现打包的速度越来越慢，最后慢到打包一次要几分钟甚至更多的时间，缓慢的打包速度严重影响效率，那么如何提高打包速度就成为了我们的痛点，一般大家都是用HappyPack、Dellplugin和UglifyJsPlugin(…"}, {"id": "6844903921354276871", "title": "React学习笔记-webpack基本配置", "desc": "首先要确保你的电脑安装了node.js；安装完成后打开命令行窗口运行命令 node -v 可以查看版本号证明安装成功。 这时说明Nodejs下的包管理器 npm 也安装成功。由于使用npm安装模块是从国外服务器下载，受网络影响较大，可能下载较慢或者出现丢包等情况，推荐使用淘宝镜…"}, {"id": "6844903600917856263", "title": "基于React+Webpack+Mobx+Less项目搭建指南", "desc": "Webpack 支持零配置，如果 entry 不配置，默认值为 ./src ；如果 output 不写，默认值为 ./dist。 Webpack 在 4.X 版本废弃了 CommonsChunkPlugin，需要使用 optimize.splitChunks 来替换。 extr…"}, {"id": "6901213619606781966", "title": "前端项目搭建部署全流程（二）：webpack配置", "desc": "assetNameRegExp: 正则表达式，用于匹配需要优化或者压缩的资源名。默认值是 /\\.css$/g"}, {"id": "6844903566914633742", "title": "Webpack 4 发布，不再支持 Node.js 4", "desc": "可以直接处理 JSON，必须在生产和开发模式中选择一种模式。"}, {"id": "6844903695201599502", "title": "minipack 源码简析", "desc": "背景：其实“打包”对于前端来说再熟悉不过了，但是深入其中的原理，却不是人人都熟悉。由于webpack功能的强大和盛行，我们大部分都是所谓的“配置工程师”。借此，特地简单分析了一官方文档中提到的一个minipack项目的源码，以此深入了解下什么是打包？以及打包的原理是什么？ 读取…"}, {"id": "6844904106285334541", "title": "【webpack 系列】基础篇", "desc": "Webpack 是一个现代 JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 Loader: 加载器，Webpack 原生只能解析…"}, {"id": "6844903497993814029", "title": "我如何将 Webpack 包大小缩减一半", "desc": "很实用"}, {"id": "6844903844640456711", "title": "复习webpack4之Library打包", "desc": "这次学习webpack4不仅仅要会配置，记住核心API，最好还要理解一下webpack更深层次的知识，比如打包原理等等，所以可能会省略一些比较基础的内容，但是希望我可以通过此次学习掌握webpack，更好地应对以后的工作。 现在我们就模拟开发一个库，首先npm init -y，…"}, {"id": "6844904181866692621", "title": "学习Webpack", "desc": "现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 ... 这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又…"}, {"id": "6844903506009128974", "title": "create-react-app不用eject的定制方案", "desc": "Tweak the create-react-app webpack config(s) without using 'eject' and without creating a fork of the react-scripts. All the benefits of cr…"}, {"id": "6844904032209731591", "title": "前端多语言编译处理解决方案, 支持Vue, React, Angular, TypeScript", "desc": "项目打包后根据配置的多语言数量生成多分具有单一语言的文件. 例如使用zh-cn, en则最后输出将会有"}, {"id": "6844904084214906888", "title": "快速删除node_modules目录的方法", "desc": "/s 是代表删除所有子目录跟其中的档案。"}, {"id": "6919039278253080589", "title": "webpack 学习笔记", "desc": "入口文件，指示 webpack 应该使用哪些模块来作为其构建内部依赖图的开始。 默认是 ./src/index.js，可以通过配置 webpack.config.js 进行设置。 用来告诉 webpack 如何将编译后的文件输出到磁盘。 webpack 开箱即用只支持 JS、J…"}, {"id": "6844903829176057863", "title": "一步步使用 webpack 第二篇：使用 webpack 编译 PostCSS 代码", "desc": "在 上一篇文章 中，完成 webpack 的基础配置就可以完成 es6 的编译，本篇文章介绍如何使用 webpack 完成 PostCSS 的编译。 想要了解 PostCSS 常用插件与语法介绍，点击这里查看。 接下来我们添加代码测试配置是否成功。 打开 index.html …"}, {"id": "6844903809160855559", "title": "Tapable v1.1文档翻译+简单解释", "desc": "tapable提供很多钩子类（Hook classes），他们可以被用来为插件创造钩子。 所有的钩子类的构造器都接受一个可选参数，它是一个 这个钩子所接受参数的参数名数组。 为了定位你的插件，一个合适的名字（上面WarningLampPlugin）是必须的。 对于同步的钩子，t…"}, {"id": "6856304871315488775", "title": "从基础到实战 手把手带你掌握新版webpack4.0", "desc": "1、webpack是1个模块打包工具，module bundler. 2、npx 可以在当前文件夹中使用。 3、webpack-cli使得我们在命令行中可以使用webpack命令。（cli:command-line interface命令行界面） 4、chunks指的是每个文件…"}, {"id": "6844904005236162567", "title": "webpack核心模块解析", "desc": "webpack的运行分很多阶段，每个阶段都有一个钩子，我们可以在钩子上注册我们自定义的插件。 注册后，我们自定义的插件会在钩子运行阶段执行。 插件目的在于解决 loader 无法实现的其他事。 插件是 webpack 的 支柱 功能。 webpack 自身也是构建于插件系统之上…"}, {"id": "6918341901095534605", "title": "基于vue2.x的webpack升级/项目搭建指南", "desc": "firstthingfitrst：绝不标题党、面试没帮助、新手不友好有人看最好不过的背景：　　十月初对公司产品的前端构建做了一些优化，但还遗留了一些问题：　　1.热重载过慢：单文件改动，热重载的十次平"}, {"id": "6950964669523705870", "title": "webpack深入浅出（四）| 小册免费学", "desc": "缩小文件搜索范围随着时间和业务量的累积，代码变得越来越臃肿，打包时间变得越来越长，这无疑是一件很头疼的事情（虽然现在大部分都是CI/CD构建），缩小搜索范围也可以减少构建时间使用loader编译文件是"}, {"id": "6950964366556528671", "title": "webpack深入浅出（三）| 小册免费学", "desc": "之前我们了解了webpack中的配置方式，下面我们来说一下实际生产中经常使用的loader以及plugin以下说到的所有依赖都将省略安装过程，除非特别指明，否则都是直接npm安装依赖名babel虽然目"}, {"id": "6847902222072676360", "title": "手把手教你webpack配置，读完马上掌握webpack!", "desc": "一. 什么是webpack？ ... 3）然后，你突然发现这些问题webpack都轻松搞定了。如图所示 通过上边的一堆文字，此时你的心中应该明白了webpack是干什么的，它有什么用。 世上任何概念的定义，都是从其性质，适用范围，作用来下的。 2. 核心组成 特意将整段代码贴上…"}, {"id": "6998365504654032903", "title": "深入 Webpack5 等构建工具系列二(5) - webpack 的 style-loader 的使用和编写顺序", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 上一篇文章的最后，我们运行 npm run build 命令对项目中的相关文件进行了打包，其中，css 文件实际上也已经被打包了，或者也可"}, {"id": "6910764120698519560", "title": "Webpack5 新功能 Module Federation 用法", "desc": "Module Federation 模块共享整体是通过ModuleFederationPlugin这个插件串联起来的。"}, {"id": "6847902218570432520", "title": "Webpack5 内置缓存方案探索", "desc": "随着Babel、TypeScript、VueLoader、Terser等编译、转译技术的大规模使用，Webpack的编译时间正不断膨胀。为了优化编译速度，社区主要有两种方案： 这些方案在一定程度上解决了编译速度慢的问题，但随之而来的是成堆的配置，严重影响了Webpack的使用体…"}, {"id": "6844903641527091207", "title": "【翻译】如何在React中使用async/await (componentDidMount Async)", "desc": "create-react-app 构建的项目支持开箱即用。 但是如果你想在自己搭建的webpack配置的项目中使用，你可能会遇到 regeneratorRuntime is not defined 的异常错误。 如果你遇到了这个错误还想在React中使用async/await,…"}, {"id": "6844903971325214734", "title": "🔥🔥🔥由浅至深了解webpack异步加载背后的原理", "desc": "先来一波名词解释。先上网上一张图解释： 1、module：我们源码目录中的每一个文件，在 webpack 中当作module来处理（webpack 原生不支持的文件类型，则通过 loader 来实现）。module组成了chunk。 2、chunk。webpack打包过程中的产…"}, {"id": "6973199677122412558", "title": "webpack 简析", "desc": "webpack可以做的事： 处理各种资源，css、js、html、图片等 代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布 1. 基本使用 1.安装 这里使用webpack4版本 "}, {"id": "6973855807876104229", "title": "记录前端xx国部署，如何去掉源代码内的所有中文？", "desc": "记录前端xx国部署，如何去掉源代码内的所有中文？ 背景：由于政治问题，需要去xx国国内部署内部已有的平台（10+个） 要求点： 源代码内不能有跟国内本公司有关的所有关键字和图片，所有域名也要替换成xx"}, {"id": "6992546061713670158", "title": "3.一步步了解 Webpack Loader 开发", "desc": "这是我参与8月更文挑战的第3天，活动详情查看：8月更文挑战 Webpack Loader 配置 单个 loader，你可以简单通过在 rule 对象设置 path.resolve 指向这个本地文件 多"}, {"id": "6844903541509718030", "title": "用 webpack 写一个简单的 JS SDK", "desc": "1. 加载引用 2. 暴露一个公共变量 最简单的做法是在 index.js 里加一句 window.SDK = ... 3. 提供两个版本 4. 提供定制版本 5. 内部实现通过模块引用"}, {"id": "6844904167060799502", "title": "大声对webpack4.0说声你好之loader基础篇资源打包讲解(二)", "desc": "哈哈哈，它踏着轻快的步伐来啦。 大声对webpack4.0说声你好之webpack的基本使用(一)》,建议您先大致浏览，因为我会接着上一节的代码继续记笔记。 本篇你将会对loader有个初步认识，还会对一些常用的静态资源打包，例如图片、样式、字体等，如果你想学习更多关于load…"}, {"id": "6922965817638256653", "title": "「webpack 核心特性」插件(plugin)", "desc": "上一篇 「webpack 核心特性」loader 说到 webpack 的 loader 机制，本文主要聊一聊另外一个核心特性：插件(plugin)。 插件机制就是为了完成项目中除了资源模块打包以外的其他自动化工作，解决上述的问题。 plugin 是用来扩展 webpack 功…"}, {"id": "6850418110983241741", "title": "了不起的 Webpack Scope Hoisting 学习指南", "desc": "Scope Hoisting 是 webpack3 的新功能，直译为 \"「作用域提升」\"，它可以让 webpack 打包出来的「代码文件更小」，「运行更快」。 在 JavaScript 中，还有“变量提升”和“函数提升”，JavaScript 会将变量和函数的声明提升到当前作用…"}, {"id": "6844903605070200846", "title": "从零开始搭建React应用（一）——基础搭建", "desc": "webpack4的cli(command line interface)已经移动到webpack-cli了，如果要使用CLI,你需要安装webpack-cli，具体使用可以查看webpack-cli的文档。 由于Babel默认只转换新的JavaScript句法（syntax），…"}, {"id": "6844903683000385543", "title": "记录一次打包优化", "desc": "webpack本地开发时，经常会出现开发着然后打包速度很慢的情况。 可以看见每个chunk都很大 有些快达到了1M。 可以看出lodash被打包了很多次，导致加载lodash的chunk很大。 重新打包时间达到了2.592s，其中起始文件index.0a8ac.js达到了841…"}, {"id": "6844903661093519368", "title": "企业级React项目的个人构建总结", "desc": "距离上篇文章已经好长一段时间了，这两个星期公司派驻到京东方这边出差负责入驻项目团队的前端工作。这段时间从零搭建一下前端项目，这次给的时间比较充裕，思考的也比较多。以前也常有搭过前端项目，但是给的时间都比较紧，因此很多问题都忽略掉了。这次正好对以前的进行一次优化，并总结了一些经验…"}, {"id": "6844903684829085709", "title": "搭建Typescript+React项目模板(1) --- 项目初始化", "desc": "8 . 配置tsconfig 9 . 项目启动"}, {"id": "6930519573196177422", "title": "webpack配置环境变量", "desc": "在实际项目开发中，需要基于多种环境去设置不同的环境变量以便于在构建阶段或是运行阶段去使用，例如常见的通过process.env.NODE_ENV在构建时去判断当前的构建环境是development还是production，例如需要在开发环境、测试环境和生产环境去访问不同的接口服…"}, {"id": "6898889812741210125", "title": "如何找到webpack对应的loader版本", "desc": "困扰了好一会，记录一下学习过程。 如果有不正确的地方麻烦耐心指出。（菜鸡的自我修养） webpack是前端常见的模块打包工具，但是webpack只能用来处理js代码及其间的依赖。 而前端除了js外还有很多文件，包括css、图片等等，这些文件的打包需要webpack的扩展来实现，…"}, {"id": "6982903286005235725", "title": "零基础学习Webpack—02(Webpack打包CSS/Less样式资源)", "desc": "1. 初始化npm 2. 全局安装webpack和webpack-cli 3. 将webpack添加到package.js的开发依赖 4. 创建src文件夹，并建立入口文件index.js index"}, {"id": "6981077224103346183", "title": "webpack-node-externals中文文档", "desc": "webpack-node-externals中文文档 当为后端捆绑 Webpack 时 - 您通常不想捆绑其node_modules依赖项。该库创建了一个外部函数，node_modules在 Webp"}, {"id": "6844903780769595405", "title": "webpack系列之四loader详解1", "desc": "2 种不同的配置形式，在 webpack 内部有着不同的解析方式。此外，不同的配置方式也决定了最终在实际加载 module 过程中不同 loader 之间相互的执行顺序等。 在讲 loader 的匹配过程之前，首先从整体上了解下 loader 在整个 webpack 的 wor…"}, {"id": "6932334291430932487", "title": "Webpack 记录 - webpack 5 变更记录", "desc": "2020年10月，webpack 发布了 webpack 5.0.0。作为前端工程化的核心能力，webpack团队考虑到开发者的学习成本，并没有做成重大的 API 升级(ღ( ´･ᴗ･)ღ), 对比了一下 webpack4，对一些核心的升级点做下记录并分享 webpack 5 …"}, {"id": "6996528887442178061", "title": "深入 Webpack5 等构建工具系列一 - webpack 初体验", "desc": "这是我参与8月更文挑战的第13天，活动详情查看：8月更文挑战 写在前面 本系列文章核心内容： webpack 核心配置深入解析； webpack 常用 Loaders 和 Plugins 深入学习； "}, {"id": "6970678129845239839", "title": "webpack5 的使用（五）：babel 转译 js 代码", "desc": "这是我参与更文挑战的第6天，活动详情查看： 更文挑战 前言 在前面的文章里，我们已经可以通过 js 进行 import 各种资源。现在还有个问题，就是需要将 es6+ 代码需要转换为 es5 和添加 "}, {"id": "6925321865410019341", "title": "从Webpack打包后的文件分析导入的原理", "desc": "主流框架中，不论是React还是Vue，都是使用Webpack进行资源的打包，这篇文章我们试着分析打包后的bundle文件来了解下其是如何进行静态和动态导入的。 modules​：缓存 ​module​ 代码块，每个 ​module​ 有一个 ​id​，开发环境默认以 ​mod…"}, {"id": "6844904054393405453", "title": "看完这篇webpack-loader，不再怕面试官问了", "desc": "比如有一个txt文件，我们想通过raw-loader来获取整个txt文件里面的字符串内容。除了使用统一webpack config配置的方式之外，我们还可以在引入的时候，用这样的语法来引入： 其实使用webpack.config文件统一配置loader后，最终也是会转成这种方式…"}, {"id": "6989172752141942797", "title": "《乘风破浪学webpack》", "desc": "目标一：用webpack编译JS 首先下载webpack 然后由于是本地安装，所以需要指定在哪里去找webpack的执行程序 还有一种简易的方法，就是 npx 会自动帮我们找webpack在本地的哪个"}, {"id": "6925624472074469390", "title": "Webpack 初探（二）", "desc": "有一段时间没有做积累和学习了，近期学习的内容会陆陆续续更新进来。 Webpack 应该会写一个系列吧，从 初探 => 深入 => 实战。 前面的内容只是使用 Webpack 提供的打包构建能力，实现打包构建的需求，但是在开发的过程中可能不仅仅需要打包构建的能力，同时还需要开发调…"}, {"id": "6992946133253226510", "title": "webpack性能优化 | 8月更文挑战", "desc": "这是我参与8月更文挑战的第5天，活动详情查看：8月更文挑战 首先说明优化目的： 1、加速打包时间 2、减少打包后的体积 一、加速打包时间 要加速打包时间，就需要先缩⼩⽂件搜索范围，一般影响整体打包的时"}, {"id": "6858505844397768718", "title": "深入源码理解webpack是如何保证plugins的执行顺序的", "desc": "最近突然想到一个问题，在webpack中我们添加plugin是以数组的形式添加的，那么如何保证这些插件的执行顺序呢，比如一个插件依赖需要等另一个插件改完，比如一个插件和另一个插件是可以并行的，于是从源码从去探析出了结果。 插件是webpack的支柱，webpack实际自身也是基…"}, {"id": "6975898319780315173", "title": "Code Splitting以及SplitChunksPlugin配置参数详解", "desc": "什么是Code Splitting？ 场景 现在我们在入口文件index.js中引入了一个第三方库lodash假设它是1mb，以及编写了几万行的业务代码也1mb，此时我运行npm run build打"}, {"id": "6973821532292251685", "title": "多入口 Webpack 热更新失效？", "desc": "前言 Webpack 对于现代前端开发者，想必是相当熟悉了，在很多项目中，应用非常广泛，而 webpack-dev-server，相信大家应该也都接触过。最近，作者在配置多入口，热更新在单入口是好使的"}, {"id": "6844903686569721869", "title": "webpack4.0 入门篇 - 构建前端开发的基本环境", "desc": "自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 入口(entry point): 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的…"}, {"id": "6990319247436021796", "title": "webpack热模块替换", "desc": "热模块替换概念： 热模块替换只用于开发阶段，用于在运行之中，模块修改只会局部刷新，而不是整个页面进行刷新 js模块替换 index.js: print.js: webpack.config.js中开启"}, {"id": "6976493897027420196", "title": "webpack项目打包或git提交更新版本号，检测项目版本更新实现。", "desc": "本次项目地址：https://github.com/ht-sauce/vue3-pc-template 1、pre-com"}, {"id": "6964950713935855624", "title": "webpack -- tree shaking 介绍：", "desc": "tree shaking 的作用： 在我们使用webpack进行打包的时候，我们现在有一个有一个模块A.js;我们在index.js中引入A模块的部分代码；tree shaking会帮我们吧我们不需要"}, {"id": "6844903941793120264", "title": "基于webpack4 构建多页(mpa)应用", "desc": "本教程 github地址 如果对你有帮助欢迎点赞。 虽然当前大前端时代，web应用大多已经做成单页应用(spa),但是在某些场景下，我们的项目还是可以做成多页应用(mpa)。在继续往下看之前，你需要对webpack、nodejs、npm基础概念有一定的了解，如果还不熟悉，请移步…"}, {"id": "6884954719798689800", "title": "webpack5上手初体验！", "desc": "10月10号，刚刚过完中秋国庆，webpack官方就不懂声色的说webpack5上线了...It's released,本篇文章主要从webpack4和webpack5对比的角度入手，看一看webpack5到底有哪些改变，让我们来动手实践一下吧。 webpack5运行时间132…"}, {"id": "6844903728764452878", "title": "骚年，Koa和Webpack了解一下？", "desc": "有必要声明下，很多人在没看完这篇文章之后，就评论一些和文章主题不相符的内容。 这篇文章主要讲述的是如何在本地开发环境下通过启动node服务器之后，无缝启动webpack，从而达到前后端配置一体化。 适合做node全栈项目、node中间层，配合前端项目、等等。 实现继承,采用的是…"}, {"id": "6988726767007744013", "title": "webpack5学习 --- 基本配置和样式打包", "desc": "webpack本身只能处理js模块，如果需要处理其它类型资源的模块，就需要配置对应的解释器进行处理，这些解释器就被称之为loader。"}, {"id": "6906319173064851470", "title": "@vue/cli Vue2 模版迁移到微前端 EMP", "desc": "删除node_modules目录在package.json删除以下依赖yarnadd-D@efox/emp-cli@efox/emp-vue2yarn在项目根目录创建emp-config.js修改pu"}, {"id": "6980913108366098462", "title": "记录一次webpack5升级过程和常见问题总结", "desc": "前言 本文将记录一次webpack4（后面称w4）升级为webpack5（后面称w5）的全流程。一方面是作为知识的记录，也希望可以给看到的人提供一点点帮助。"}, {"id": "6959056141531906061", "title": "从分析打包内容入手，实现一个简易webpack", "desc": "本文将手把手教你，分析webpack的打包内容，并逐步带你自己手动实现webpack的核心打包功能。"}, {"id": "6844903687496663048", "title": "Nginx，Charles与Webpack配置前端API代理教程(超详细)", "desc": "大家都知道，浏览器是存在跨域限制的，处于安全性考虑，服务器ABC不可能设置为允许任何请求都可以访问，So, 我们配置前端API的代理的目的其实就是为了解决跨域问题，前端按照既定的规则配置好代理之后，就能保证开发阶段和线上部署服务的一致。 本文以配置Dva项目的代理为示例，因为D…"}, {"id": "6844903864592760845", "title": "webpack系列之六chunk图生成", "desc": "这篇文章主要是通过源码去探索下 webpack 是如何通过在编译环节创建的 module graph 来生成对应的 chunk graph。 我们都知道 webpack 打包构建时会根据你的具体业务代码和 webpack 相关配置来决定输出的最终文件，具体的文件的名和文件数量也…"}, {"id": "6985097762714943501", "title": "webpack improt 引入css报错【求解】", "desc": "求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,求解,"}, {"id": "6991797650634833933", "title": "webpack5--Module Federation摸索", "desc": "概念 模块联邦 ：Module Federation Module Federation的动机 是为了不同开发小组共同开发一个或者多个应用 应用将被划分为更小的应用块，一个应用块，可以是比如头部导航，"}, {"id": "6984809074084806686", "title": "webpack试练03", "desc": "1、tree shaking 提到tree shaking就要说到mode 当mode为develoment|none时，未使用到的模块也会被被打包进来 当mode为production时，未使用到的"}, {"id": "6917069979913289736", "title": "对比webpack，你更应该先掌握gulp【10分钟教你彻底掌握gulp】", "desc": "可能很多人对于gulp都相对陌生，特别是vue，react出现以后，渐渐淡出了做业务前端人员的视野，14到16年的时候应该是它最巅峰的时候，真正的是出道即巅峰，取代了当时最火的grunt成为了前端构建的主流工具，就连某度都忍不住来瓜分一下流量，出了个fis（不过按照烂尾的惯例来…"}, {"id": "6844904191840747533", "title": "利用 webpack 理解 CommonJS 和 ES Modules 的差异", "desc": "CommonJS 导出的是值的拷贝；ES Modules 导出的是值的“引用”。 我相信很多人已经把这个答案背得滚瓜烂熟，好，那继续提问。 对于以上两个问题，我也是感到一脸懵逼，好在有 webpack 的帮助，作为一个打包工具，它让 ES Modules 和 CommonJS …"}, {"id": "6955878306981871623", "title": "十分钟精进 Webpack：module.issuer 属性详解", "desc": "全文 1000 字，阅读时长约 10 min，讲解 webpack 的 module.issuer 属性，内容涵盖该属性的作用、运行原理、应用场景。"}, {"id": "6844903640444960781", "title": "优雅配置vue项目，webpack 4.x + Vue模仿vue-cli配置 (一)", "desc": "url-loader对未设置或者小于limit设置的图片进行转换，以base64的格式被img的src所使用；而对于大于limit byte的图片用file-loader进行解析。 minify 使用minify会对生成的html文件进行压缩。默认是false cache 默认…"}, {"id": "6877354359940874254", "title": "Webpack项目优化之CDN加速、Gzip压缩和SplitChunks拆分", "desc": "这里以vue项目为例，配置包括但不限于vue项目。其他项目按类似逻辑配置基本一样。 分析：通过把类似 echart、element-ui、lodash 等第三方依赖库单独提取出，从而减小打包的体积大小，关键属性 externals 配置后的依赖插件不会被打包进 chunk 。而…"}, {"id": "6844903774645911566", "title": "webpack插件机制之Tapable", "desc": "对于Webpack有一句话Everything is a plugin，Webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable。Tapable有点类似nodejs的events库，核心原理也是依赖与发布订阅模式。webp…"}, {"id": "6844903942384517127", "title": "从源码看webpack的hash策略", "desc": "所以只要某一个文件被修改，所有输出文件的hash都会跟着变化；因此它有一个弊端，一旦修改了某一个文件，整个项目的文件缓存都会失效。 webpack的三种hash生成策略都是根据源码内容来生成，只是该源码已经被webpack封装成能在webpack环境中运行的代码了，包含每一个源…"}, {"id": "6844903645637509127", "title": "Vue的使用总结和技巧", "desc": "当然是尤大的官网入手了,许多刚学框架的新手都喜欢从网上找视频教程，例如慕课网这种，本人不建议这种学习方法，因为视频的作者会让你跟着他的思维去写一套他的风格的代码，这是一个细思极恐的事情。 其实vuejs官网的东西是非常丰富的，并且我认为需要加入浏览器书签，是需要不间断的重复看的…"}, {"id": "6885188280963317774", "title": "【前端工程化】篇三 席卷八荒-Webpack（基础）", "desc": "声明：本篇文章基于webpack v4.43.0，如按照文中代码执行报错，请先检查依赖版本是否和示例代码仓库中一致。 自Web2.0以来，前端技术日益蓬勃发展，前端仔们不再满足于切切页面、写写动画，而是能够做更多\"高大上\"的事情了。但随着项目规模和复杂度的提升，代码的依赖维护、…"}, {"id": "6977300086695051277", "title": "实现一个简单的webpack的plugin插件", "desc": "简介 本次分享如何实现一个简单的plugin插件 创建自定义plugin步骤 声明一个js函数或class类（大驼峰命名） 定义一个原型方法apply，apply方法接收一个compiler对象，我们"}, {"id": "6844903606420766734", "title": "在webpack-dev-server内添加mock server", "desc": "前端页面已经编排好了，但是后台接口还没准备好，或者是突然出现Bug，这样没办法进行对接测试。 我们希望服务器返回特定类型的数据，以测试某页面在特定条件下是否存在问题，但作为前端我们一般不会接触到后端代码和数据库，每次都找后端添加模拟数据又很麻烦。 为解决这两个问题，最简单的解决…"}, {"id": "6844903792819847175", "title": "即刻起，加速您的前端构建", "desc": "如果你的项目也在使用发布系统或者是CI工具，而且项目比较大，发布经常需要耗费十几分分钟，那么以下的工具可能会对你起作用。 影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。"}, {"id": "6844903946415243272", "title": "Webpack按需加载打包chunk命名", "desc": "大家都知道Webpack是现在流行的前端打包编译工具，通过模块之间的依赖关系，将代码打包组织到一起。Webpack目前已经到v4.x，不同版本版支持按需加载的方式不同，主要有两种： webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将[模块b…"}, {"id": "6844903630978433038", "title": "从0开始发布一个无依赖、高质量的npm", "desc": "没有发布过npm包的同学，可能会对NPM对开发有一种蜜汁敬畏，觉得这是一个很高大上的东西。甚至有次面试，面试官问我有没有发过npm包，当时只用过还没写过，我想应该挺难的，就小声说了没有，然后就让我回去了o(╯□╰)o。 其实，在现在的我看来，npm包就是一个我们平时经常写的一个…"}, {"id": "6844903625420963853", "title": "Webpack的Code Splitting实现按需加载", "desc": "一. 什么是Code Splitting? 在最开始使用Webpack的时候, 都是将所有的js文件全部打包到一个build.js文件中(文件名取决与在webpack.config.js文件中output.filename), 但是在大型项目中, build.js可能过大, 导…"}, {"id": "6844904197138153486", "title": "webpack构建过程的进度条实现原理", "desc": "我们在使用webpack的时候经常会用到webpackbar或者progress-bar-webpack-plugin之类的webpack插件通过进度条等方式来展示webpack的构建进度，以提升构建过程中的反馈体验。对于不同的插件来说，它们只是进度条的UI展示形式不同而已，但…"}, {"id": "6980284324943757319", "title": "vue3.0 搭载webpack5", "desc": "webpack5搭载vue3上路。感受从0到1的至尊奢华，高贵不失优雅的配置。你值得拥有。葬爱家族用了都说好。v3w5艾玛真香🍚"}, {"id": "6844903620765286407", "title": "打包工具的配置教程见的多了，但它们的运行原理你知道吗？", "desc": "前端模块化成为了主流的今天，离不开各种打包工具的贡献。为了避免成为一位“配置工程师”，我们需要来了解一下打包工具的运行原理，只有把核心原理搞明白了，在工具的使用上才能更加得心应手。"}, {"id": "6844904165701845006", "title": "避免在单页应用程序中使用CORS，如何以及为什么？", "desc": "了解如何通过使用前端开发服务器中的代理配置来避免CORS。 在过去的十年中，单页应用程序已成为构建Web应用程序的标准技术。如今，诸如Angular，Vue之类的框架以及诸如React之类的库主导着前端开发，为这些应用程序提供了基础平台。好消息是，它可以从一个域中为前台和后台A…"}, {"id": "6983331178543579149", "title": "Webpack", "desc": "一. Webpack 1. 模块打包工具的由来 ES Module 存在环境兼容问题 模块文件过多，网络请求频繁 所有的前端资源都需要模块化 2. 模块打包工具概要 主流的模块打包工具 Webpack"}, {"id": "6844903568420388872", "title": "公司vue组件库开发心得", "desc": "公司移动端产品主要以微应用的形式发布，所以微应用总数是很大的，而且开发频率也相当高（技术栈为vue）。这就导致一个问题，在高的产品开发频率下，必然会导致许多无用功现象的发生，列如最常见的loading、message组件每次都要重新再新的项目里面复制粘贴，偶尔文件地址放错了还会…"}, {"id": "6994825510916358174", "title": "webpack手动构建15步 ｜ 8月更文挑战", "desc": "1, webpack手动搭建15步 1，安装 2, 打包编译HTML文件 3, 热更新 4，babel编译 5, CSS 处理 6, 启用模块热替换 7, 环境变量 8, 开发环境配置查看源码 9, "}, {"id": "6901444936260911112", "title": "webpack DLL 动态链接库", "desc": "许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即 DLL 文件，放置于系统中。当我们执行某一个程序时，相应的 DLL 文件就会被调用。一个应用程序可使用多个 DLL 文件，一个 DLL 文件也可能被不同的应用程序使用，这样的 DLL 文件被称为共…"}, {"id": "6844903760188145672", "title": "Webpack 将代码打包成什么样子？", "desc": "可能你学会了如何使用 Webpack ，也大致知道其工作原理，可是你想过 Webpack 输出的 bundle.js 是什么样子的吗？ 为什么原来一个个的模块文件被合并成了一个单独的文件？为什么 bundle.js 能直接运行在浏览器中？ 下面通过 Webpack 构建一个采用…"}, {"id": "6844904134697549832", "title": "文件监听和热更新原理分析", "desc": "文件监听是在发现源码发生变化时，自动重新构建出新的输出文件。 轮训去判断文件的最后编辑时间是否发生变化。当某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等待一定时间段 aggregateTimeout，在这个时间段内，如果有其他的文件也发生了变化，那么他最终会把这些…"}, {"id": "6956502563080372232", "title": "webpack优化学习笔记", "desc": "1. 打包结果优化 2. 构建过程优化 3. Tree-Shaking是一个优化思想 配置缓存，这样可以不用重复解析。 比如fast-sass-loader就比sass-loader块，因为fast-sass-loader是并行编译处理sass文件的。 HMR：热更新，实现浏览…"}, {"id": "6879748260848730120", "title": "如何实现一个 Webpack 的 Bundler 打包机制 ？| 掘金技术征文-双节特别篇", "desc": "我想这两年，应该是「Webpack」受冲击最明显的时间段。前有「Snowpack」基于浏览器原生ES Module 提出，后有「Vite」站在「Vue3」肩膀上的迅猛发展，真的是后浪推前浪，前浪.... 并且，「Vite」主推的实现技术「不是一点点新」，典型的一点使用「esbu…"}, {"id": "6844904137994272775", "title": "Webpack实用的优化方案", "desc": "Webpack是当下最热门的前端资源模块强大打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生成环境部署的前端资源；还可以将按需加载的模块进行代码分割，等到实际需要再异步加载。在使用webpack时，如果不注意性能优化，非常大的可能产生性能问题。性能问题主要分为开发时构…"}, {"id": "6844903701342060557", "title": "React 16.x折腾记 - (5) 记录用React开发项目过程遇到的问题(Webpack4/React16/antd等)", "desc": "闲话不多说,直入主题,有兴趣的可以瞧瞧,没兴趣的止步,节约您的时间. 翻了一些Stack Overflow上的问答和文档,发现还是有的. 因为用了mobx,实在不想用高阶函数的写法(一堆括号)。 我是直接配置babelrc的. 跟随最新babel 7,装上这个依赖即可支持 看到…"}, {"id": "6844903761756815368", "title": "【工程化】从 0 搭建 VueJS 移动端组件库开发框架", "desc": "之前发表过一篇《Vue-Donut——专用于构建Vue的UI组件库的开发框架》，仅仅是对框架一个粗略的介绍，并没有针对里面的实现方式进行详细说明。 最近参与维护公司内部的一个针对移动端的UI组件库，该组件库缺乏文档和严格的文件组织结构。Vue-Donut的功能比较简单，并不能方…"}, {"id": "6844903871907643399", "title": "Webpack如何引入CDN链接来优化编译后的体积", "desc": "在 Vue 项目中，引入到工程中的所有 js 文件，编译时都会被打包进 vendor.js，也就导致了 vendor.js 文件体积变得相当臃肿，一定程度上影响着页面的渲染。为了减少编译后的体积，提高页面渲染速度，我们可以通过引入 CDN 链接把库分离，多线程异步 js 库，从…"}, {"id": "6844903805666983944", "title": "Webpack 之常见见招拆招", "desc": "前端的发展，大致的发展路线可以看黄玄的JavaScript 模块化七日谈。从最初的全局污染式的注入到ES6模块化，打包工具的不断迭代替换。主要的原因都是因为前端发展越来越复杂庞大所导致。 本篇文章主要是来谈谈 webpack 在我们平时的开发工作中起到什么作用，以及我们该如何灵…"}, {"id": "6968350990957281316", "title": "老工程打包提速折腾记（下）- roadhog 1.x 到 webpack 4.x", "desc": "框架搭建于2017年，roadhog + dva + antd，在当时也算是很时髦的了。然而后续忙于迭代，忽略了几个关键库的升级，导致现在变得老旧，升级成本极高，只能在原来基础上修修补补，但毕竟提升有"}, {"id": "6927881426205573134", "title": "webpack用法及原理", "desc": "前文我们介绍了打包器的基本情况，今天对于webpack进行详细的介绍。 执行webpack打包我们第一个文件，如果没有配置文件默认entry是src/index，输出的bundle文件是dist/main.js，具体为在命令行调用npx webpack或者在package.js…"}, {"id": "6915659007894126599", "title": "webpack搭建React项目（5）", "desc": "经常让人摸不着头脑的是 chunk 和 bundle 这两个概念。chunk，翻译过来就是大块，也就是代码块；而 bundle 则是束，包的意思。从 webpack 给出的术语表中是这么解释的： webpack 文档的解释很模糊，chunk 其实是 code splitting…"}, {"id": "6844903557661982734", "title": "CommonsChunkPlugin学习小结", "desc": "如果你还有兴趣，那就一起来看看吧。 首先弄明白chunk是什么东西：webpack将多个模块打包之后的代码集合称为chunk。 entry chunk: 含有webpack runtime代码的模块代码集合。 normal chunk：不含runtime代码的模块集合。 ini…"}, {"id": "6844903540528267278", "title": "Webpack实战-构建离线应用", "desc": "你的网页性能优化的再好，如果网络不好那也会导致网页的体验差。 离线应用是指通过离线缓存技术，让资源在第一次被加载后缓存在本地，下次访问它时就直接返回本地的文件，就算没有网络连接。 在没有网络的情况下也能打开网页。 由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速…"}, {"id": "6844903877666406408", "title": "@pika/web", "desc": "现在前端开发已经离不开webpack. 虽然webpack带来很多好处,但是它繁琐的配置以及较高的学习成本成为了开发人员的负担.vue-cli为我们做了一些基础配置,但是会带来另外一个问题.我们可能只是写一个小demo,但是需要安装一大堆没用的第三方依赖. @pika/web在…"}, {"id": "6992551833436684318", "title": "webpack的环境变量设置", "desc": "process是什么？ process是node中的一个全局变量，它有一个env属性，任意创建一个js文件，打印process变量，就可以看到process的内容 process.env.NODE_E"}, {"id": "6879694164159758343", "title": "深入理解webpack原理 （下）", "desc": "上一篇文章《深入理解webpack原理（上）》中，我主要是从理论层面上介绍了webpack的一些基本原理。而本文将会从代码层面上带大家一起来认识webpack。 由于webpack的打包过程实际上是利用了AST语法树来实现的，因为在具体讲解webpack打包原理之前，我们一起来…"}, {"id": "6844903602239045645", "title": "让你的 webpack sass 和 css 处理性能 10 倍提升", "desc": "看名字就知道, 它们相比官方版本的 loader 要更快, 那到底有多快? 下面给个性能对比. 看到这里, 你大概会问为啥这两个 loader 要比官方快? 其实得问官方版本的 loader 慢在哪里. 对于 sass-loader 而言, 最大的问题是没有去重, 导致 sas…"}, {"id": "6844903891180453901", "title": "手撸loader和plugin全解析", "desc": "我们在使用webpack配置项目时会使用过各种各样的loader和plugin,例如less-loader、file-loader、html-webpack-plugin、clean-webpack-plugin等等。但是我们是否想过这些loader或plugin是如何编写的呢…"}, {"id": "6844904127139414023", "title": "记一次webpack+typescript+react的优化过程", "desc": "为什么想要弃用 awesome-typescript-loader呢？是因为每当文件改动时，该loader都会重新去转译和类型检查，项目慢慢大了，特别影响开发速度，并且会有类型检查遗漏的情况发生。 @babel/preset-typescript方案，直接移除了TypeScri…"}, {"id": "6844904133850300430", "title": "从零开始学webpack：基础配置", "desc": "webpack是什么webpack是一个非常实用的静态模块打包工具，它通过递归的方式构建一个包含应用程序需要的所有模块的依赖图，然后将这些文件打包成一个或多个bundle输出为什么要使用webpack"}, {"id": "6897894030294646791", "title": "140行实现一个乞丐版webpack", "desc": "看他的注释就可以知道什么意思，__webpack_require__模拟的是commonjs的require方法，里面暴露的对象module.exports、exports跟commonjs的一致，所以我们才只需要处理require这个关键字，这个方法帮我们减少不少工作。 至此…"}, {"id": "6871183366029312014", "title": "用Vue CLI打造属于自己的项目脚手架工具", "desc": "脚手架：命令行工具作用：减少重复性工作，不再需要复制其他项目再删除step1初始化1、新建项目vue-demo-cli2、npm-yinit初始化package.json3、配置package.jso"}, {"id": "6928560087912939534", "title": "前端增长（webpack）（源码篇）", "desc": "其实就是通过webpack打包后，如果commonJs代码，就直接返回，如果是esm代码，则需要加工，返回带module.export或module.a等形式。"}, {"id": "6913429075767853069", "title": "Webpack从手把手配置到原理浅析(四)：构建速度优化", "desc": "在开发过程中，源文件经常要被修改，免不了要重新构建打包，才能看到修改后的效果。这时候构建速度就显得尤为重要，构建速度的优化能极大地提高开发效率和体验。 本文介绍一些常见的Webpack优化构建速度的方法。 babel-loader的作用是将ES6及以上的语法转译为浏览器能识别的…"}, {"id": "6903910160184868878", "title": "Webpack学习笔记三：js的兼容性处理", "desc": "上一节中我们简单实现了webpack的打包功能，并且对webpack的一些基本配置、打包命令以及不同模式下打包的区别做了一个简单的了解，也了解了下控制台输出信息的含义。接下来的几节我们一起来了解下，针对于不同类型的资源，webpack是如何进行编译打包的，在打包期间又需要做一些…"}, {"id": "6986896605420978189", "title": "1. webpack初识", "desc": "一直以来，对webpack的了解都处于初级阶段，复杂的配置没配过，没有实际项目经验。面试问到只能回到用的脚手架。。。 前段时间找到了一个课程，这个相当于是课程的一个笔记吧"}, {"id": "6924294294803234830", "title": "偷懒必备，按需加载省掉注册路由的麻烦", "desc": "项目中常常需要一些专题或者系列的页面场景，初期的时候一两个在路由表里面注册也不算什么，如果子项目越来越多了，一个个去注册也麻烦，也不方便后期查找或修改。 假定我们有一个游戏专题，以如下目录结构呈现，有多个项目，每个项目又可能有子项目，这时候如果一个个注册会使得路由表非常冗长且繁…"}, {"id": "7001443156537376799", "title": "面试基础复习--webpack面试题(一)", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 建议先观看webpack官方文档，了解基础概念，然后看这些整理的面试真题，加深对概念的理解。每天量不多，后续会持续更新，，， 概念题"}, {"id": "6844903669100445710", "title": "体积减少80%！释放webpack tree-shaking的真正潜力", "desc": "在上周末广州举办的feday中，webpack的核心开发者Sean在介绍webpack插件系统原理时，隆重介绍了一个中国学生于Google夏令营，在导师Tobias带领下写的一个webpack插件，webpack-deep-scope-analysis-plugin，这个插件能…"}, {"id": "6850037264962027534", "title": "体验webpack5个人总结", "desc": "经过上手使用，webpack5打包体积大小，持续编译速度都有很不错的提升，对webpack4兼容也很平缓，Module Federation也对项目中如何使用微型前端应用提供一种解决方案。如果升级过程中有遇不兼容的情况，可以去webpack5变更日志上查阅。 在webpack5…"}, {"id": "6986479307329634340", "title": "webpack 源码解析-运行", "desc": "webpack 源码解析之运行 运行环境webpack 版本 新建一个文件夹 执行 命令 yarn add webpack webpack-cli -D 在node_modules/webpack/b"}, {"id": "6882268573315072008", "title": "号外号外，Webpack5正式发布！", "desc": "webpack作为最使用最广泛的前端打包工具，已经成为前端工程化基础设施的一部分。而Webpack上一个大版本更新已经是18年的时候了，两年时间过去了让我们看看Webpack5都带来了哪些新特性，对我们的应用又有哪些帮助。 不得不说，这个官方声明稍微简略了一点，只提到了持久化缓…"}, {"id": "6844903673403801607", "title": "前端性能优化—js代码打包", "desc": "现在的 web 应用，内容一般都很丰富，站点需要加载的资源也特别多，尤其要加载很多 js 文件。js 文件从服务端获取，体积大小决定了传输的快慢；浏览器端拿到 js 文件之后，还需要经过解压缩、解析、编译、执行操作，所以，控制 js 代码的体积以及按需加载对前端性能以及用户体验…"}, {"id": "6950092728919130126", "title": "✏️ loader知识分享", "desc": "loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。loader 本质上是导出为函数的 JavaScript 模块。"}, {"id": "6988781437990207502", "title": "Markdown转HTML的plugin插件【记录Plan】", "desc": "平常经常写markdow，那么markdow如何生成html显示出来呢。本文主要是完成一个简单的md转html的plugin功能，一起来学习吧"}, {"id": "6954179005134143524", "title": "浅入webpack4 高效简单的配置", "desc": "前言 在vue-cli3中已经将webpack等详细配置（config）去除，我们配置webpack只能在vue.config.js里进行配置，这里我个人总结了一套webpack的优化方案模板并且附有"}, {"id": "6994757371817885727", "title": "Webpack配置-模块化原理", "desc": "准备工作 两个文件，分别使用 CommonJS和ES Module导出方法如下图： 初识mode 应为说到模块化原理需要用到 mode属性所以这里简单认识一下 mode 三者之间的区别： 默认情况下是"}, {"id": "6844903561910812685", "title": "babel之配置文件.babelrc入门详解", "desc": "官方解释,是下一代JavaScript 语法的编译器。 既然是下一代Javascript的标准，浏览器因版本的不同对此会有兼容性问题，JavaScript的新的方法都不能使用，但是目前我们在项目开发一直提倡使用最新的语法糖编写，不但能减少代码量，而且async,await等新特…"}, {"id": "6844903606122971144", "title": "浅入浅出webpack", "desc": "准备了挺久，一直想要好好深入了解一下Webpack，之前一直嫌弃Webpack麻烦，偏向于Parcel这种零配置的模块打包工具一些，但是实际上还是Webpack比较靠谱，并且Webpack功能更加强大。由于上一次学习Webpack的时候并没有了解过Node.js，所以很多时候真…"}, {"id": "7001305934341341215", "title": "深入 Webpack5 等构建工具系列三(2) - file-loader 文件名和文件路径设置", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 上一篇文章我们讲了 file-loader 的使用，我们配置了相关规则，使得当遇到 png 或 jpeg 或 jpg 或 gif 或 sv"}, {"id": "6844904202926309384", "title": "webpack4 搭建企业级脚手架", "desc": "eval模式，构建速度很快，可以得到错误在源代码中的行列，但是无法查看具体的行列信息， 因为它无法查看源代码，只能查看转换后的代码。 cheap-module-eval-source-map 和 cheap-eval-source-map 类似，但是是loader转换之前的源文…"}, {"id": "6991399125367390222", "title": "webpack学习笔记｜8月更文挑战", "desc": "webpack简介 webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。"}, {"id": "6994251135540264996", "title": "webpack5学习 --- 环境分离和代码分割", "desc": "目前所有的webpack配置信息都是放到一个配置文件中，当配置越来越多时，这个文件会变得越来越不容易维护。所以，我们最好对配置进行拆分。同样为了提升加载效率，打包后的文件也需要进行拆分操作。"}, {"id": "6930877602840182791", "title": "手写一个webpack，看看AST怎么用｜牛气冲天新年征文", "desc": "本文开始我会围绕webpack和babel写一系列的工程化文章，这两个工具我虽然天天用，但是对他们的原理理解的其实不是很深入，写这些文章的过程其实也是我深入学习的过程。由于webpack和babel的体系太大，知识点众多，不可能一篇文章囊括所有知识点，目前我的计划是从简单入手，…"}, {"id": "6844903889393680392", "title": "Webpack 理解 Chunk", "desc": "希望读过本篇文章，你在看Webpack配置的时候，能在脑中形成Chunk的生成过程。 Chunk不同于entry、 output、module这样的概念，它们对应着Webpack配置对象中的一个字段，Chunk没有单独的配置字段，但是这个词出现在CommonsChunkPlug…"}, {"id": "6985452935547191310", "title": "webpack进阶（二）", "desc": "1. CSS前缀自动补全 为什么需要前缀自动补全呢？这是因为市场上浏览器内核不一样，为了对css3的兼容就需要补全相应的前缀。 1.1 安装插件 1.2 使用postcss-loader 1. 配置p"}, {"id": "6992496125995384862", "title": "一篇搞懂webpack", "desc": "概述 本文主要介绍webpack的诞生的原因，webpack解决了什么问题。 webpack中的loader、plugin是什么？如何工作的？能否自己构建loader或plugin webpack怎么"}, {"id": "6844903539962036238", "title": "Webpack实战-管理多个单页应用", "desc": "上一节3-9为单页应用生成HTML中只生成了一个 HTML 文件，但在实际应用中一个完整的系统不会把所有的功能都做到一个网页中，因为这会导致这个网页性能不佳。 实际的做法是按照功能模块划分成多个单页应用，每个单页应用生成一个 HTML 文件。并且随着业务的发展更多的单页应用可能…"}, {"id": "6844903587722575879", "title": "webpack中的热刷新与热加载", "desc": "相信大部分的vue开发者都是从vue-cli开始的，很多初学者欢快的跑着vue项目却不敢改随意改变vue-cli的配置（毕竟webpack确实很复杂，vue-cli也做了很多工作来优化初学者的体验）。 相比之下react没有提供一个比较健壮的脚手架了(至少没有明显地被我找到，望…"}, {"id": "6844903570874056717", "title": "webpack从入门到放弃", "desc": "注册所有配置的插件，让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 …"}, {"id": "6844904047233728526", "title": "webpack 4 源码主流程分析（八）：生成 chunk", "desc": "执行 compilation.finish，触发 compilation.hooks：finishModules，执行插件 FlagDependencyExportsPlugin 注册的事件，作用是遍历所有 module 将 export 出来的变量以数组的形式，单独存储到 m…"}, {"id": "6844903721042870286", "title": "webpack性能优化(上)", "desc": "通常我们的项目会有开发环境和生产环境，而开发环境我们配置的目标是构建更快，模块热替换，能从chrome控制台报错信息对应的源码的错误处(source map)等。生产环境我们更加关注chunk分离，缓存，安全，tree shaking等优化点。 当然对于开发和生产环境的配置文件…"}, {"id": "6844903614301880328", "title": "定制化vue-cli Template/webpack", "desc": "以前的项目要不是前人搭建的，要不就是从 vue-cli 搭建，然后将一些旧项目公用的代码搬过来，这些操作下来一个小时估计是跑不了的了，所以搭建属于自己的 template 是一件省时省力的事情。 本文章不会讲到 vue-cli 的原理和实现，有兴趣的同学可以阅读 从vue-cl…"}, {"id": "6933212664445272077", "title": "tapable简单分析", "desc": "实例化了一个Hook类，然后赋予tapAsync，tapPromise，compile函数。因为是同步钩子，所以tapAsync和tapPromise方法都只是抛出了一个错误。这里看不到call、tap方法，显然在Hook类里面。Hook代码如下： 说实话不知道有什么用，省去查…"}, {"id": "6844903550464557063", "title": "Parcel-VUE零配置前端构建（iview实践）", "desc": "在我的上一篇文章才刚刚阐述了vue-cli的webpack模板工程构建优化方案和步骤，以及在结尾时对未来前端构建的思考和展望。结果这个时候 【Parcel】 就横空出世了，目前关于Parcel的文档很少，而且Parcel本身也处于高速迭代发展的实验阶段，但它的确是前端构建的最终…"}, {"id": "6844904081861902349", "title": "从构建进程间缓存设计 谈 Webpack5 优化和工作原理", "desc": "翻看日历，发现今天是 2020 庚子年第一个节气——立春。上古以“斗柄指向”法，用北斗星斗柄指向寅位时为立春。干支纪元，以立春为岁首，意味着新的一个轮回已开启，万物起始、一切更生。尽管我们今天仍然面临险峻疫情的挑战，但今日就代表了温暖、生长，我也愿意在在此刻梳理计划本年度的技术…"}, {"id": "6844904163709550605", "title": "webpack3如何升级为webpack4？", "desc": "但是随着时间的推移，这种优化产生的效果越来越弱化，手上的项目体积越来越大，对本地开发热更新速度和生产打包发布速度都有了很大的影响。 webpack3升级到webpack4迫在眉睫，这篇博文将记录一些我在升级过程中遇到的坑。 当你遇到这些坑时，通过搜索引擎找到我这篇文章，如果能够…"}, {"id": "6844903713165803527", "title": "rollup打包js的注意点-haorooms博客分享", "desc": "rollup比较适合打包js的sdk或者封装的框架等，例如，vue源码就是rollup打包的。webpack比较适合打包一些应用，例如SPA或者同构项目等等。最近我们对rollup小试牛刀了一下。简单分享一些注意事项吧。 rollup基础知识及插件的一些使用，网上有不少资料，可…"}, {"id": "6844903619863511047", "title": "webpack4.0让编译速度飙升", "desc": "前端开发一个crm项目的时候，因为项目内容比较庞大，导致webpack编译和打包都巨慢，实在是影响开发效率，所以着手升级webpack。 webpack4-es6-react是一个全新的基于webpack4、react16、es6、antd-mobile的前端架构实现方案，默认…"}, {"id": "6844903801292324872", "title": "webpack4.0 CheatSheet", "desc": "还在为webpack的配置而烦恼吗？这里有一份webpack从简易到高级版本的配置。还附赠配置地址，你想要吗？不，你不想。老老实实自己配置去吧。 压箱底的笔记而已，大家看看乐乐就好了，这是笔者为了练习webpack而尝试了不同的配置方式，参考了create-react-app的…"}, {"id": "6844903951133851661", "title": "学习webpack一个案例就够了", "desc": "这两个属性中保存的都是当前包所有的依赖信息。 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错,报错内容为:'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序或批处理文件。 由于使用--contentBase指…"}, {"id": "6954393463408295967", "title": "Webpack——【入门篇-上篇】", "desc": "本系列为Webpack——入门篇，跟着此文档，可轻松入门webpack，分为上篇、中篇、下篇；此篇为上篇"}, {"id": "6844903774180343815", "title": "一个为了让console.log写起来更偷懒的webpack-plugin", "desc": "最开始，无论我们在控制台输入webpack指令还是使用Node.js的API，都是调用了webpack函数（源码）,并传入了webpack的配置选项，创建了一个 compiler 实例。 compiler 是什么？—— 明显发现compiler保存了完整的webpack的配置参…"}, {"id": "6919416114602573831", "title": "webpack 之 loader 和 plugin", "desc": "Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。…"}, {"id": "6844903905944403976", "title": "webpack-dev-server + nginx + node调试https微信授权网页", "desc": "一般情况下，在使用webpack-dev-server热更新的时候，使用的域名都是localhost/127.0.0.1之类的，都是基于http协议的。 热更新成功后，浏览器会以当前域名+端口发送一个用于热更新的请求。该请求默认域名是webpack入口配置中webpack-de…"}, {"id": "6844903693419053064", "title": "React SSR重构踩坑记录(持续更新)", "desc": "场景：第一次在node中直接使用import Story from '../js/containers/story';就会报这个错误。 错误说明：node本身使用的是commonjs的语法，支持的模块引入和导出方式为require以及module.export，然而es6定义的…"}, {"id": "6924563005115990024", "title": "Webpack介绍与基础配置", "desc": "WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 构建就是把源代码转换成发布到线上的可执行 JavaScrip、…"}, {"id": "6901580077998276622", "title": "简析webpack中的tree-shaking", "desc": "这是 webpack4 文档中 tree-shaking 部分的介绍：https://v4.webpack.js.org/guides/tree-shaking/，你可以先快速过一遍来了解一下什么是 tree-shaking。 tree-shaking 是一个术语，通常指在 J…"}, {"id": "6844903860893384718", "title": "12个常见的实战场景 - [webpack 第二篇]", "desc": "以上是一个最基础的配置，我们接下来一步一步的加入更多的功能. 首先，我们通过第一节，可以知道了怎么将一个入口main.js打包成bundle.js了，那么入口文件肯定是要引用在html中啊，那么，怎么创建html文件？怎么创建build以后的html文件，以及html文件如何引…"}, {"id": "6844903955638517773", "title": "解决 vue cli 使用 typescript 后打包巨慢的问题", "desc": "最近新开了一个项目，虽然用的是 vue 技术栈，但是为了项目的健壮性，还是强上了 typescript, 于是引出了下面的问题。 之前使用过 ts-loader 打包 react 项目，给我的感觉就是巨慢，开发环境下，每次保存后，需要等10秒钟左右才能构建完成，当时为了解决这个…"}, {"id": "6915298839112974350", "title": "webpack ——自定义Loader，将i18n英文单词首字母转大写", "desc": "在客户要求下要将项目中中英文切换，英文要以英文单词首字母大写为准。可是前期开发人员并没有规范。 多以这种： 存在，可是emmmmm...一个一个修改，必si。 去看了vue-i18n 官网，找到formatter可实现。 使用loader。 测试。"}, {"id": "6947874638185627655", "title": "webpack", "desc": "webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bund…"}, {"id": "6883414561194508295", "title": " webpack 萌新研究入门全过程（1）", "desc": "npx webpack 后报错 找不到对应loader。 由此可知不管有没有使用样式，通过入口文件引入的module/文件 都需要有loader进行处理。webpack默认只能处理js Access to XMLHttpRequest at 'xxx' from origin …"}, {"id": "6992597748960722975", "title": " 利用webpack拆分css ", "desc": "利用webpack拆分css {ignore} 要拆分css，就必须把css当成像js那样的模块；要把css当成模块，就必须有一个构建工具（webpack），它具备合并代码的能力 而webpack本身"}, {"id": "6844903585160019975", "title": "webpack4.0优化那些事儿", "desc": "You can also speed up babel-loader by as much as 2x by using the cacheDirectory option. This will cache transformations to the filesystem. …"}, {"id": "6868157642666147848", "title": "Webpack--Webpack的配置和局部安装", "desc": "上文我们打包的时候，打包命令是 webpack main.js ../dist/bundle.js，我们每次都要设置打包的入口和出口，就很麻烦。有什么设置能设置出口和入口，免得我每次都要设置嘛？当然可以有，在项目中添加这个文件，这个文件的文件名是固定的：webpack.conf…"}, {"id": "6955488876030853151", "title": "从零开始的webpack5+react+typescript", "desc": "Webpack配置 简述 说明：从0开始配置一套 react + typescript 的 webpack 配置"}, {"id": "6873277767165837325", "title": "webpack构建流程解析", "desc": "1. 什么是webpack webpack是一个模块化打包工具，它将一切文件都视为模块，通过loader编译转换文件，通过plugin注入钩子，最后将输出的资源模块组合成文件。 2. 构建流程 第二步：利用初始化的参数创建complier对象，complier可以视为一个web…"}, {"id": "6844903743587090440", "title": "【译】关于Webpack中一些让人困惑的地方的解答", "desc": "Webpack是React和Redux项目的主要模块加载器。我认为使用Angular2和其他的框架的人在如今也大量使用Webpack进行开发。 当我第一次查看Webpack的配置文件时，我是懵逼的。在使用过一段时间以后，我觉得这是因为Webpack有着独一无二的语法和标新立异的…"}, {"id": "6844903605086978062", "title": "TypeScript+Webpack+React组件库开发采坑实记", "desc": "本文为配置TypeScript+Webpack+React，开发UI组件库时遇到的坑以及相对应的解决方案记录，适合相关同学进行查阅解决问题。 此三类配置和选择会同时导致某一类问题，因此这三类不作为分类标准，仅作为读者思考的方向，我们下面会根据具体的问题和错误以及对应的解决方案来…"}, {"id": "6844903510379610120", "title": "基于 webpack 的持久化缓存方案", "desc": "基于 webpack 的持久化缓存方案"}, {"id": "6844904114359386125", "title": "使用Webpack配置React和Vue开发环境【超实用】", "desc": "当下前端最火的两个框架就是了 React 和 Vue 了，Facebook 官方推出的 create-react-app ，Vue 也有自己的 CLI 工具Vue-CLI，两个工具都已经非常好用，但在实际项目中，我们仍然需要做一些修改才可以满足实际项目上线的需求，同时我们仍希望…"}, {"id": "6844903766857089031", "title": "【译】十五分钟，学习 Webpack", "desc": "由于 JavaScript 应用程序的复杂性不断增加，构建工具已成为 web 开发中不可或缺的一部分。Bundlers 允许我们去打包、编译和管理现代 web 项目需要的众多资源文件和依赖库。 在本教程中，我们将了解 webpack，一个强大的开源打包和预处理器，可以处理大量复…"}, {"id": "6946440886586703886", "title": "逐行分析webpack源码入口都能学到啥", "desc": "经历了蛮荒，小作坊，故事发生在前端工程化时代，传说有这么一个江湖，江湖中有一条有名的街道，名曰\"打包街\"，街上的铺子依稀能看到几个大大的Logo：Grunt，Gulp，FIS，Webpack，Rollup，Snowpack，Vite... 其中以Webpack最为热闹，只见牌匾…"}, {"id": "6975161386045440014", "title": "从零开始学webpack(v5.0)", "desc": "webpack静态模型快打包工具 https://webpack.docschina.org/ 还有几个打包工具：grunt、gulp、fis、webpack、snowpack、vite..."}, {"id": "6844903599923806222", "title": "webpack实战（一）：真实项目中一个完整的webpack配置", "desc": "前段时间，使用webpack查阅资料时发现要么是入门级文章，要么是如何优化打包速度或如何使用某个plugin、loader的文章。找不到一个在真实项目中的使用webpack的完整方案用以参考，所以花了许多精力去整合资料、查看代码和踩坑。 因此我将自己摸索的一个配置方案，分享出来…"}, {"id": "6850418122005217293", "title": "自己实现一个inline-manifest-webpack-plugin", "desc": "项目里有用到inline-manifest-webpack-plugin，当把html-webpack-plugin升级到v4时，插件就报错了。原本想等插件适配，结果发现不维护了。所以自己动手实现一个吧！ 将我们选择的chunk文件直接插入到html中，减少请求次数，方便做缓存…"}, {"id": "6878594632628830216", "title": "用typescript 写一个webpack多页应用架构", "desc": "虽然网上有很多webpack多页面相关的内容，但是大部分都很老旧了，用typescript写webpack配置的很基本没有。这里主要是给喜欢typescript的同学提供一点参考。 以上就是所有的webpack配置，没有用到Babel，也没有polyfill，如果还需要其他功能…"}, {"id": "6900955685178048519", "title": "webpack入门必备（一）：基础配置", "desc": "开始编译前的准备：实例化Compiler，加载所有plugin，执行对象的run方法并开始编译。接着根据配置中的entry找到所有入口文件 编译模块：从入口文件出发，调用所有loader对模块进行编译，再找到模块依赖，重复上述步骤知道所有入口文件都经过处理。在loader处理完…"}, {"id": "6844903581196222478", "title": "一个vue-cli创建项目webpack相关都配置合简介", "desc": "使用vue-cli 脚手架创建，其实很简单的，主要是和后台合作，项目整合在一起。开发者了解webpack的相关配置非常有利于项目构建。如果搞不懂的话，自己可以去尝试修改配置查看效果。"}, {"id": "6942381974547857416", "title": "webpack常用的一些优化", "desc": "1.开发环境优化1.1 resolve.modules告诉webpack在那个文件夹下面去找第三方模块，避免了层层的查找1.2 resolve.alias对一些第三方比较打的库，指定其文件夹位置，避免"}, {"id": "6844904102841827336", "title": "webpack自己用的配置", "desc": "webpack.config.common.js主要是开发环境和生成环境都可用到的文件。 rule加载是从右到左，从下到上，注意配置。 同样这里会去找.eslintrc.js中的配置这里可以去自己找下Airbnb的配置，有需要的话可以在纸上进行改动。还可以新建.eslintig…"}, {"id": "6844903543644618760", "title": "webpack优化不完全指南", "desc": "实现思路(参考vue-cil)，通用配置可以设置一个base文件然后exports，在其他的配置文件中require进来。 上面这个配置中new webpack.optimize.UglifyJsPlugin()就可以放入webpack.prod.conf.js中，因为代码压缩…"}, {"id": "6844903544982618120", "title": "webpack对样式的处理", "desc": "这时我们便需要引入相应的webpack loader来帮助我们解析这段代码。 在上面的代码里，解析顺序是从右到左解析，先使用css-loader解析出css文件之后，再使用style-loader嵌入到js代码里。 如果你使用less来写样式的话，则需要先用less-loade…"}, {"id": "6844904154821836807", "title": "记一次多页面开发 - 模板复用与数据注入", "desc": "我司目前大多数项目都以Vue或React进行开发。就在上个月来了一个多页面的官网页开发需求，最后输出页面多达20+，但大多数页面可以用同一个模板输出，只是其中部分数据有所不同。例如产品下有数个不同产品，每个产品都要有一个单独的页面，其中的布局都相同，只有文案与图片需要进行替换。…"}, {"id": "6844903842765602823", "title": "渐进式配置webpack4单页面和多页面（一）", "desc": "终端输入完成后会自动创建一个package.json的文件。 运行命令，引入webpack和webpack-cli，安装webpack-cli是为了在项目里面运行webpack命令。 手动创建webpack.config.js。 在终端里面通过npx运行webpack命令无法进…"}, {"id": "6946237073258971167", "title": "webpack 学习（系统掌握重点知识）", "desc": "文章主要用通俗易懂的语言来解释概念和一些重点知识，方便复习，不会太详细说明细节操作。 一个打包器，识别import和export，根据依赖关系把引入的js按顺序打包，最后只输出一个js文件。 在远古时代原始时代开发的时候我们把所有js代码写在script标签里面。 于是诞生了新…"}, {"id": "6844903507070287880", "title": "如何不用构建工具开发Vue全家桶项目", "desc": "Vue是目前最流行的前端开发框架之一，与Vue-router和Vuex组成俗称的Vue全家桶，更是开发前端富交互应用的利器。配合webpack等构建工具，开发大型应用也可以得心应手。随着Vue的普及，可能一些老旧项目也希望能“渐进式”的使用Vue，或者有的项目想用Vue来做但不…"}, {"id": "6844903510971006989", "title": "[译]Rollup - 下一代 ES6 模块化打包工具 - 对 Rich Harris 的采访", "desc": "鉴于浏览器目前尚不能按照“原样”解析 JavaScript 源码，所以打包这一步必不可少。将源代码编译成浏览器可以理解的形式，这是打包工具（例如 Browserify，Rollup 或者 webpack）存在的原因。 为了深入探讨这个话题，我们正在采访 Rollup 的作者 R…"}, {"id": "6844904039893712909", "title": "一个 vue-cli chrome extension 开发模板，支持同步刷新与 支持 crx 打包", "desc": "一个 Vue-cli chrome 扩展开发模板，支持同步刷新与 crx 格式打包。 使用： vue init kinglisky/vtemp-chrome-extension my-project cd my-project npm install npm run dev 最…"}, {"id": "6863774127833448456", "title": "Webpack配置篇后续", "desc": "sourceMap是一个信息文件，里面储存着位置信息。如果出现错误，通过他可以反向定位到源代码的位置，方便我们调试。开发环境默认开启，如果需要关闭，可以在配置文件里更改。安全起见，线上不推荐开启，会暴露源代码。 webpackDevServer是一个基于express的小型服务…"}, {"id": "6844903613387505671", "title": "动态构建的多页面vue-cli模版", "desc": "vue官方提供了几个vue cli的模版，但都单页面模版，然而在真实的业务场景下还是有多页面模版的需求，百度和google上都能搜索到不少单页面模版改多页面模版的文章，但是没有现成的模版可以直接用，而且多页面模版页面多了之后，首次构建的速度真的很慢，无法忍受。这里我fork了官…"}, {"id": "6844903648913440776", "title": "简单易懂的现代魔法-递归", "desc": "平时在前端开发中，好像也没啥用到递归的地方。不过这并不代表递归不重要，如果你看过一些框架的源码，就会经常见到它的影子：比如渲染虚拟DOM的render函数，webpack中require依赖分析，Koa2洋葱式的中间件模型，其实都运用到了递归算法。 代码在运行过程中，会有一个叫…"}, {"id": "6844903641149603854", "title": "webpack 4.0 Tapable 类中的常用钩子函数源码分析", "desc": "Tapable 是webpack中的基础类，类似于node中的EventEmitter，都是注册监听，然后收发事件，监听函数执行的过程，自身可以被继承或混入到其它模块中。 webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapa…"}, {"id": "6844904035351265288", "title": "从0到1，手写webpack的开发之路。", "desc": "这几年一路走来略有心得，从了编程，也不能荒废了爱写作的手艺，所以平时有空会写点文章，关于自己的职场、人生经验之谈。 若不是生活所迫，谁会把自己弄的一身才华。[ 手动滑稽 ] webpack是一个工具，是一个致力于做前端构建的工具。简单的理解：webpack就是一个模块打包机器，…"}, {"id": "6844904047233728519", "title": "webpack 4 源码主流程分析（九）：优化 chunk", "desc": "在 chunk 生成后，开始进行 chunk 优化之类的处理。 根据 module.id 给 module，chunk，reasons 等排序。 这一步主要用于设置 chunk.id，算法与 this.applyModuleIds 一致。 根据 chunk.id 给 modul…"}, {"id": "6921145769688825864", "title": "webpack系列学习-多页面打包", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 在src目录下创建各自的文件夹，如search文件夹，在search文件夹中，创建index.html和index.js。其他一样。 开发环境开启，线上环境关闭…"}, {"id": "6983973646670757919", "title": "新手必看的Webpack 基础", "desc": "webpack 是什么呢？有什么用呢？ 1.是前端资源模块化管理和打包工具。 2.可以使前端开发更加模块化。详细来讲就是：将松散的模块按依赖、规则打包成符合当前环境部署的前端资源；按需（异步）加载；通"}, {"id": "6844903661454229518", "title": "【webpack进阶】使用babel避免webpack编译运行时模块依赖", "desc": "babel是一个非常强大的工具，作用远不止我们平时的ES6 -> ES5语法转换这么单一。在前端进阶的道路上，了解与学习babel及其灵活的插件模式将会为前端赋予更多的可能性。 本文就是运用babel，通过编写babel插件解决了一个实际项目中的问题。 1. 遇到的问题 最近在…"}, {"id": "6983915985472323614", "title": "devServer里 contentBase和publicPath", "desc": "我的理解 contentBase是静态资源所在的路径，比如我们的模板index.html所在的路径，默认为项目根目录。 publicPath，webpack的打包输出目录，打包结果会在资源路径添加这个"}, {"id": "6859302827395825671", "title": "自定义 webpack 配置1：基础配置", "desc": "3. package.json 添加 build 脚本 4. 拆分 webpack.config.js 都可以生成dist/main.js文件，区别就是dev为 develpotment 模式代码未压缩。 5. 使用 html 模板 9. 添加 React 支持 10. 自动编…"}, {"id": "6904843864608079885", "title": "webpack5+babel7爬坑记", "desc": "webpack5正式版已发布2个月，相信大家已经想迫不及待升级，体验一下\"真香\"功能，我们团队主要构建工具目前已经升级到最新webpack5.x+babel7.x，历经一个月，踩了许多坑。经过上手使用，webpack5打包体积大小，持续编译速度都有很不错的提升，对webpack…"}, {"id": "6844904146659721223", "title": "从0到1搭建webpack4.0+react全家桶（下）", "desc": "把这个loader放在其他loader前面，放置在这个loader之后的loader就会在一个单独的worker池中运行，尽量只在耗时的loader上面使用，如果项目体积较小打包时间可能还会延长。 可以通过预热worker池将制定的loader模块载入node模块缓存里防止启动…"}, {"id": "6927192258831712263", "title": "webpack5新特性体验", "desc": "通过持久缓存提高构建性能. 使用更好的算法和默认值来改善长期缓存. 通过更好的树摇和代码生成来改善捆绑包大小. 清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改. 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5. 早期，web…"}, {"id": "6844903610048839694", "title": "CSS-Next : CSS预处理器简单写法的替代者, 想了解下么?", "desc": "颜色计算,一般定制主题或者 UI 规范的会考虑.. 把手头项目 vue-cli 初始化的项目.升级到了 webpack4.8.3 , 引入了一堆移动端相关东东。 webpack 4.8.3的不如期待那般美好，只能说有所提升。"}, {"id": "6844903678718001166", "title": "多页应用增量更新静态资源Webpack打包方案", "desc": "自从vue、react或者angular这类框架流行后，单页应用的数量也越来越多。但是限制于单页应用的一些缺点，比如：seo、首屏时间等因素，很多应用的结构还是保持了多页面结构。此篇讲述的是如何在多页面应用结构的基础上，利用webpack生成带hashcode文件名的方式实现静…"}, {"id": "6844904047225339918", "title": "webpack 4 源码主流程分析（四）：reslove 前的准备", "desc": "在方法中先触发 compiler.hooks: beforeRun，执行之前注册的 NodeEnvironmentPlugin（该插件此时判断 inputFileSystem 是否被配置，如未配置则执行 purge 清理方法），然后在回调里触发 compiler.hooks: …"}, {"id": "6844903556584046599", "title": "webpack之代码拆分 ", "desc": "作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。 要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。 …"}, {"id": "6844903814588268552", "title": "webpack4生产环境和开发环境的对比", "desc": "近期一直在看webpack4的文档，于是给自己做了这个总结，对比一下生产环境和开发环境的区别。 在项目开发过程中，我们关注的是能否追溯到代码的错误来源，能够及时刷新页面让我们看到代码的实际效果，因此webpack针对开发特点提供了几个插件。 source-map有多种使用方式，…"}, {"id": "6844903582588731405", "title": "从零开始搭建webpack应用", "desc": "最近研究webpack配置神烦，打包工具指不定哪天又要被取代。要想自己手动搭一个复杂应用的webpack脚手架不是一件容易的事, 看看vue-cli的webpack配置文件就有8+个，使用的插件有14+个，代码800行＋。还没开始写代码就要搞懂这么多“规则”，还不如多花点时间研…"}, {"id": "6880442159036629006", "title": "Webpack的进阶概念-TreeShaking与buildMode", "desc": "1. TreeShaking tree shaking 是一个术语,通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性,例如 import 和export 接着我们build打包一下，发现打包后端…"}, {"id": "6844904127202377735", "title": "webpack--基于vue-cli搭建一个多项目使用的工程", "desc": "不懂webpack推荐看这个浅入浅出webpack(很短的，不多内容，但是可以有基本的了解)，看完了再继续看下面的。 到这里的话开发环境就搭建好了。 npm run admin-dev就可以运行起来了。（如果没有意外的话）。 然后所有项目都可以引入啦。 如果怕麻烦，也可以npm…"}, {"id": "6923963977496002574", "title": "解析tapable并实现一个自己的tapable", "desc": "|SyncLoopHook|同步循环|返回值不是undefined，循环。多个taps时返回不是undefined，从第一个tap重新循环| |AsyncSeriesLoopHook|异步循环|返回值不是undefined，循环。多个taps时返回不是undefined，从第一…"}, {"id": "6844903602947883021", "title": "值得了解的webpack高级技能", "desc": "在只要这几步，webpack速成不是事儿一文中, 笔者简单介绍了webpack的常见用法。能满足最基本的开发需求。在这篇文章中，再来谈谈一些较高级的应用。 1. 配置不同环境的构建脚本 之前构建都是通过 npx webpack ... 这样的方式执行构建命令。可能你会觉得这样的…"}, {"id": "6844903504872472583", "title": "如何开发webpack plugin", "desc": "继上回介绍了如何开发webpack loader 之后。趁热打铁，来继续看下webpack另一个核心组成：plugin。 下面也和loader一样，让我们一起从基本的官方文档着手看起。 loader : 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack…"}, {"id": "6844903748251336717", "title": "快速配置 webpack 多入口脚手架", "desc": "要改多入口，首先改造一下webpack.base.conf.js中的context和entry。 context：基础目录，绝对路径，用于从配置中解析入口起点(entry point)和 loader。 entry：起点或是应用程序的起点入口。从这个起点开始，应用程序启动执行。…"}, {"id": "6844904096688783367", "title": "从基础到实战 手把手带你掌握新版Webpack4.0", "desc": "上面的步骤，只是做了语法上的翻译(如: let/const/箭头函数/... 都会被转换)，但一些新的变量和方法并没有被翻译(如: promise/.map()/...)，这时就要使用 @babel/polyfill 来处理 webpack-chart：webpack stat…"}, {"id": "6844904142402502669", "title": "prefetch 和 preload 及 webpack 的相关处理", "desc": "使用预取和预加载是网站性能和用户体验提升的一个很好的途径，本文介绍了使用prefetch和prefetch进行预取和预加载的方法，并使用webpack进行实现Link的链接类型<link>标签的rel"}, {"id": "6983659602696994829", "title": "package.json中库的版本号详解(^和~区别)", "desc": "一般package.json依赖配置如下 其中依赖名前会加上，例如 ~ ^ >= < + * 这些符号 patch：修复bug，兼容老版本 minor：新增功能，兼容老版本 major：新的架构调整，"}, {"id": "6953926446108639268", "title": "webpack npm打包配置(react版本)", "desc": "这篇文章是以打包react插件的形式，介绍webpack的一些配置信息。如果写简单插件的话还是推荐使用rollup，但是可以用写插件的形式去学习一下webpack的一些东西。（适用于初中级webpac"}, {"id": "6967230083773759519", "title": "webpack学习笔记（二）：基本属性管理", "desc": "前一篇博客介绍了webpack的基本概念和从零开始搭建webpack工程的方法。在这一篇博客中，我想讲的是webpack的基本属性管理，主要有两个：资源管理、输出管理。"}, {"id": "6844904137662955527", "title": "从零开始的 webpack4 + React 构建", "desc": "5. 执行打包命令 在浏览器中打开 dist 下的 index.html，如果一切访问都正常，你应该能看到以下文本：'Hello webpack'。 1. 添加 webpack.config.js 配置文件 2. 添加 NPM 脚本 1. 下载 react 和 react-do…"}, {"id": "6977383955267846158", "title": "前端通用组件封装的尝试", "desc": "Muti Repo情况下怎么去抽离通用组件单独维护呢, 独立发布到 npm 吗? 我可不可以使用 git submodule 这种方式呢?"}, {"id": "6909470845442195470", "title": "webpack | loader二三事 | loader是如何执行的", "desc": "核心：在webpack中，对于loader的处理是基于一个第三方库loader-runner的，其模块内部导出了一个函数runLoaders，webpack将loader地址及处理完成后回调传递给它，它则将经过loader处理过后的结果返回给webpack（即回调参数）。 传参…"}, {"id": "6930505520738467848", "title": "webpakc性能优化", "desc": "1. babel缓存 2. 文件资源缓存 chunkhash：根据chunk生成的hash值。如果打包来源同一个chunk，那么hash值就一样 contenthash：根据文件的内容生成hash值。不同的文件hash值一定不一样 前提：1、使用ES6模块化。2、必须在prod…"}, {"id": "6844903546115063821", "title": "react异步加载组件实现解析", "desc": "react+webpack对于react开发，相信已经是一个大众套餐了，至于其他的parcel或者rollup或者其他一些构建框架我也没仔细用过，也不太熟，听说parcel上github短时间内已经上万颗星了，很流弊的样纸，不过这都不是我们本文重点，呵呵。本文重点是模块的异步加…"}, {"id": "6968853878762635271", "title": "react开发环境搭建", "desc": "==@babel/preset-env== 把es6,es7语法转换成es5。bebel7以上的版本只用这一个预设包就可以实现语法的转换，已经废弃了preset-stage-0，preset-stage-1，preset-stage-2等这些包。但是这个包还不能转换es6，es…"}, {"id": "6930416843760861191", "title": "(webpack篇)2.webpack中loader", "desc": "在webpack.config.js中配置在css-loader之前必须先使用下面的postcss-loader&#x26;sass-loader。PS:不然会出现问题，我们写的sass代码会直接用css-loader导致报错。 说明：通过在css-loader下的option…"}, {"id": "6844904025754697735", "title": "通过bundler学习webpack模块依赖分析", "desc": "在bundler中创建src文件夹，在src文件夹新建index.js,message.js,word.js。文件内容如下： 如果想直接在浏览器中运行index.js的话，当然是不能的，浏览器无法识别es6的语法，以前我们都是通过类似webpack的打包工具将es6代码转换成e…"}, {"id": "6929876680999698445", "title": "Webpack打包优化", "desc": "Webapck 4 之后默认为我们做了很多配置项，内部开启了很多优化功能。对于开发人员，这种开箱即用的体验显然是很好的，但是同时也会导致我们忽略了很多需要学习的东西，一旦出现什么问题的时候，我们就无从下手了，下面我们就来看一下主要的优化配置项。 DefinePlugin 是用来…"}, {"id": "6844903923220742158", "title": "Webpack 4 构建大型项目实践 / 微前端", "desc": "本文所讲述的微前端区别于广泛认知的微前端定义，它不兼容不同技术栈（微前端的简单实现），为了区分我称之为同构微前端。相比之下，同构微前端降低复杂度的同时，又避免了多个框架、组件库导致的依赖臃肿问题，是我十分推崇的架构设计。 通过上一节的优化，我们已经有了从零构建中小型单页项目的能…"}, {"id": "6907122376468529160", "title": "使用dllPlugin优化webpack打包速度", "desc": "由于多人开发项目，引入的第三方库特别多，导致项目过于臃肿，而第三方库不经常变更，所以需要dllPlugin生成dll文件保证在运行时，不需要反复打包建议使用speed-measure-webpack-"}, {"id": "6844904195074572295", "title": "Module Federation in Webpack5(上)", "desc": "Module Federation的起源项目为webpack-external-import，现已经并入 Webpack5, v2.2.4为最后独立发布的版本。 原文为PPT，章节为本人划分。 部分图片转换为文字翻译插入文章中。 个人添加的内容标记为\"注\"。 Module Fe…"}, {"id": "6945777605723455502", "title": "webpack5搭建vue3（三）根据环境拆分webpack配置", "desc": "然后我们写一下webpack.dev.config.js的配置， 用于开发时使用。 根据这三篇文章， 差不多就可以自己手搭公司的项目进行开发了， 其他的可以添加dllPlugin啊，cache-loader啊等，这些优化项根据需要添加就好了,代码开发规范 eslint 自行配置…"}, {"id": "6943167927327653895", "title": "从零配置webpack 5 + React脚手架（二）", "desc": "执行 npm start 看看能否给我们第一个 div 加上颜色呐。不出意外的话你的页面应该是什么都没有展示。浏览器中的 console 也应该是报了错与此同时运行 npm start 的终端也报了 error。 来吧，让我们处理报错。 以上配置完成后，通过 import \".…"}, {"id": "6844903504457252877", "title": "JavaScript 性能优化", "desc": "前端工程师不但要保证完成界面的规划与开发，并且同时需要保证代码的质量，其中Javscript的运行速度则变得非常重要，此篇文章从工程师的角度入手，结合了开发者工具进行分析, 总结了一些常用的优化手段和法则.... - 小亦俊"}, {"id": "6938397834320297991", "title": "Webpack生产、开发环境的拆分与合并", "desc": "缺点：需手动切换环境。"}, {"id": "6844903866677329928", "title": "webpack:sass-loader, scss中使用url加载图片报NotFound的三个解决方法", "desc": "那这是为什么呢？虽然这是sass-loader的一个已知的问题，还是要把解决过程记录下来，丰富自己也造福后来人。 1. 一开始走错了方向，总是觉得自己的路径写的有问题；是因为我己对webpack怎么处理静态资源不清楚，见参考1； 2. 由于我在Home.vue中，直接在img …"}, {"id": "6844903550204510216", "title": "Vue尝鲜快速、零配置的打包工具---parcel~", "desc": "Parcel 将 资源 树转换成 包(bundles) 树。许多其它的打包工具基本上是基于 JavaScript 资源，还有附加在其上的其它格式的资源。例如，在 JS 文件中内联成字符串。 Parcel是对文件类型无感知的，它能按你所期待的方式那样与任意类型的资源工作，且毋须配…"}, {"id": "6994451065634553869", "title": "webpack插件学习", "desc": "webpack插件有什么用 webpack的插件用来处理loader所不能完成的功能的，loader是用于模块源代码的转换，而插件可以通过webpack编译时的提供的钩子，访问编译的每个环节，实现对w"}, {"id": "6994443602982092836", "title": "webpack自定义loader", "desc": "1.定义loader loader就是一个函数 ，不可以是箭头函数,需要用到this做操作 必须有返回值 配置设置 loader高级应用 this.query 接受参数 loader 的 api 都挂"}, {"id": "6844903684833280014", "title": "搭建Typescript+React项目模板(2) --- 提升开发体验", "desc": "sass是一款css预处理语言，支持变量，嵌套，mixin和导入等功能，可以极大地方便和简化css写法。 css module是针对css类名作用域做出限定的一种规范，用以解决css类名冲突的问题，此外还能避免一些爬虫进行数据爬取(当然厉害的爬虫除外)，同等的还有BEM规范。 …"}, {"id": "6844903670656565261", "title": "读 VuePress（二）：使用 Webpack-chain 链式生成 webpack 配置", "desc": "vuepress 有三套 webpack 配置：基础配置、dev 配置、build 配置，看似和普通的一个前端项目也没什么差别，但它使用 webpack-chain 生成配置而不是传统的写死配置。 在引入详细的示例之前，先让我们介绍一下 webpack-chain 中内置的两种…"}, {"id": "6963198688965427213", "title": "webpack进阶（一）", "desc": "介绍webpack项目常用插件及静态资源内联方案。在之前的两篇文章中，我们每次打包后想要查看打包代码运行效果需要手动在dist文件夹下新增一个index.html文件，并且在文件中手动引入打出的js包"}, {"id": "6906340668247900174", "title": "webpack4、5打包后代码对比分析", "desc": "前端日新月异，我们要不断学习新的知识文化才能跟上时代的步伐。 webpack现在是前端打包常用的工具。 今天分别使用 webpack.4x 和 webpack.5x 进行打包代码，对比看一下 webpack4、5 产出代码的区别。(以下简称 webpack4 、webpack5…"}, {"id": "6844904072001093645", "title": "记一次vue-cli3 webpack简单性能优化", "desc": "配置完成后，执行npm run analyz命令。 属性名是引入的模块名，值是需要替换的变量，这个值必须和 cdn 中提供的一样，其作用是不打包使用外部引入的扩展，也就是 build 的时候不打包这也模块。详见 webpack 外部扩展。 script 元素中设置了 cross…"}, {"id": "6844904081190830087", "title": "手摸手：webpack 3秒打包一个three.js项目（有物证）", "desc": "要打包的项目是这个样子的。 关于 three.js 的安装和使用部分都省略。 首先是最基础的。我们需要安装 当然，需要把 dev 或 prod 中的配置和 base 的配置合并起来，安装个webpack-merge 吧。 然后配置一下最熟悉的脚本运行环节吧。通过--config…"}, {"id": "6910860597747777550", "title": "Webpack从手把手配置到原理浅析(二)：高级配置", "desc": "上一篇文章介绍了最基本的Webpack配置，可以满足一个前端项目最基本的构建和打包需求。 本文在基本配置上，增加更高级的配置，包括多入口处理、压缩CSS、公共代码和第三方库打包优化和懒加载。 上一节介绍的配置都是单一入口文件，最终打包产出单一HTML文件。 如果想要最终产出多个…"}, {"id": "6844904146655510536", "title": "webpack 性能优化分析篇", "desc": "生成的文件在通过官网的 说明 可以对打包结果的性能进行分析， 除此外 webpack 官网提供了在线分析的 分析工具, 通过上传生成的 stats.json 文件，可以更直观的分析打包模块. 除了上述的方式外，使用第三方工具 webpack-bundle-analyzer 可以…"}, {"id": "6854573212085764109", "title": "超详细！webpack 4 编译后代码解读", "desc": "dvetool: \"inline-source-map\"。 一个简单的实例，后面会逐行进行解读，a是入口文件，依赖b和c模块。 1.声明一个module缓存变量，对已加载的模块不会重复执行。 2. 声明一个加载模块的方法 __webpack_require__。核心方法，整个执…"}, {"id": "6844904167262142477", "title": "webpack4.0  把自己总结'吐'的一篇文章", "desc": "上大学的时候老师讲一门语言，上来的第一节课就是配置各种环境，而通常看到那些脑袋都是一种快要炸的状态🤯。随着后来对Linux的学习之后发现，并没有那么头疼配置的东西（对于命令这么复杂的东西都可以接受，那么配置是不是也不显得那么枯燥了😂）。 本章是结合自己项目中的应该以及查看了…"}, {"id": "6844903842346172430", "title": "webpack4-06-开发、生产环境、动态CDN配置", "desc": "在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)、热模块替换(hot module replacement)能力的 source map(方便开发者调试代码) 和 localhost server（本地服务器）。 在生产环境中，我们的目标则转向…"}, {"id": "6844904101159895047", "title": "对比Webpack，使用Babel+Node实现一个100行的小型打包工具", "desc": "Webpack很强大，作为前端开发人员我们必须熟练掌握。但它的原理其实并不难理解，甚至很简单。毕竟所有复杂的事物都是由简单的事物组合形成的。不光是Webpack，像Vue，React这样成熟的前端框架亦是如此。 Webpack打包本质还是使用fs模块读写文件，加以组合。 Bab…"}, {"id": "6844903788881379336", "title": "基于webpack4.x项目实战1-简单使用", "desc": "webpack4支持0配置，默认./src/index.js为入口文件，webpack运行时，会根据mode的值采取不同的默认配置,mode两个可选值：production 和 development。没有传mode，会有一个警告 development和production的…"}, {"id": "6844903615216222215", "title": "babel-polyfill使用与性能优化", "desc": "本文主要内容包括：什么是babel-polyfill，如何使用，如何通过按需加载进行性能优化。 本文所有例子可以在 笔者的github 找到。"}, {"id": "6844903774192926728", "title": "Tree Shaking in Webpack", "desc": "webpack 2.0 开始引入 tree shaking 技术。在介绍技术之前，先介绍几个相关概念： AST 对 JS 代码进行语法分析后得出的语法树 (Abstract Syntax Tree)。AST语法树可以把一段 JS 代码的每一个语句都转化为树中的一个节点。 DCE…"}, {"id": "6844903878069075981", "title": "Webpack入门（1）- 图解\"webpack是什么\"", "desc": "毫无疑问，Webpack在前端中有着独特的重要性，是你必须要熟悉的一个技能点。因为你在投简历浏览一些大公司的前端岗位时，Webpack毫无疑问是写明了至少要是熟悉Webpack。我在学Webpack期间，常常被它的配置，环境给绕晕了,现在重新开始学一遍，希望我可以掌握它。本着分…"}, {"id": "6999810322592710670", "title": "Webpack 配置", "desc": "1. webpack 介绍 Webpack是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 2. 预备知识 2.1 toStringT"}, {"id": "6844903588586586126", "title": "聊聊 cube-ui 的技术内幕", "desc": "cube-ui 是滴滴去年底开源的一款基于 Vue.js 2.0 的移动端组件库，主要核心目标是做到体验极致、灵活性强、易扩展以及提供良好的周边生态—后编译。 自 17 年 11 月开源至今已有 5 个月，在这个过程中 cube-ui 受到了不少的关注，同时从社区中也收到了很多…"}, {"id": "6844903817331343374", "title": "24 个实例入门并掌握「Webpack4」(二)", "desc": "字面意思是摇树，项目中没有使用的代码会在打包的时候丢掉。JS 的 Tree Shaking 依赖的是 ES6 的模块系统（比如：import 和 export） 命令行运行 webpack 打包后，打开打包后生成的 /dist/app.bundle.js 文件。查找我们 a()…"}, {"id": "6974214620345008159", "title": "Webpack - 面试题汇总", "desc": "哈喽大家好，我是一名大三在校学生，近期打算提前给自己找份实习工作，大家有好的实习岗位面试资料可以与我分享，谢谢！以下是有关Webpack的面试题 前端面试题汇总 Webpack webpack与gru"}, {"id": "6975428591546793991", "title": "Webpack从入门到入土的晋级之路", "desc": "webpack你学会了吗，从入门到入土的webpack学习，当中一定会遇到很多版本迭代出现的问题，这里都有很好的解决办法噢~"}, {"id": "6966422095274180639", "title": "[探索]Webpack DevServer和HMR原理", "desc": "Webpack-Dev-Server 目前开发的代码，为了运行需要有两个操作 npm run build编译 通过live-server或者直接通过浏览器打开html文件，查看效果 为了完成自动编译，"}, {"id": "7001679327880282143", "title": "深入 Webpack5 等构建工具系列三(3) - url-loader 加载图片资源", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 接上篇文章，本文讲解 url-loader。 url-loader 和 file-loader 的工作方式是相似的，但是可以将较小的文件转"}, {"id": "6844903864097832967", "title": "小程序工程化实践（上篇）-- 手把手教你撸一个小程序 webpack 插件，一个例子带你熟悉 webpack 工作流程", "desc": "小程序开发者工具不好用，官方对 npm 的支持有限，缺少对 webpack, babel 等前端常用工具链的支持。 多端框架(Mpvue, Taro)崛起，但限制了原生小程序的能力。 我司在使用一段时间多端开发框架后，决定回退到原生方案，除了多端框架对原生能力有所限制外，最重要…"}, {"id": "6942787730476630029", "title": "webpack包教不包会（二）性能优化最佳实践", "desc": "小即是快！如果你装的包有问题，可能是版本不兼容，真的坑... 速度分析（webpack5到目前还不支持），使用smp.wrap包裹。 2、利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server …"}, {"id": "6955679716766400526", "title": "Webpack  VS  Gulp", "desc": "前言 前端项目日益复杂，构建工具已经成为开发过程中不可或缺的一个部分。构建工具，说白了就是帮助我们通过配置或者编写约定好的代码，来自动完成上面的这些功能的一个工具。对于需要反复重复的任务，例如压缩、编"}, {"id": "6844903970406694925", "title": "从WebPack 4.X 到 Vue-Cli  3.X  自己留着用", "desc": "5 监视文件改动，热部署。 1. 安装webpack： npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装。 2. webpack 自定义配置 3. 自定义配置文件名 4. webpack-dev-server: 是一个…"}, {"id": "6844903939289120782", "title": "手摸手 Webpack 多入口配置实践", "desc": "最近在做项目的时候遇到了一个场景：一个项目有多个入口，不同的入口，路由、组件、资源等有重叠部分，也有各自不同的部分。由于不同入口下的路由页面有一些是重复的，因此我考虑使用 Webpack 多入口配置来解决这个需求。 1. 目标分析 2. 准备工作 首先我们 vue init w…"}, {"id": "6922265673074737165", "title": "webpack5都来了，还不学习配置一下webpack5+Vue3的配置嘛", "desc": "如果你使用的是 webpack v5 或以上版本，你不需要安装这个插件。webpack v5 自带最新的 terser-webpack-plugin"}, {"id": "6935217623487643656", "title": "为女朋友解梦之——webpack编译原理", "desc": "小伙伴们中午好鸭，昨晚做了一个梦，梦见未来女朋友问我啥是webpack编译原理？我一愣，webpack编译原理是个啥啊？突然我变成一道光回到现实，才有了这篇文章，小伙伴们要是有任何疑问，可以在评论里畅所欲言，今晚10点，我将带着你们的留言入梦复命... webpack 的作用是…"}, {"id": "6903404018945654791", "title": "重学webpack(性能优化的配置)", "desc": "问题：我们会发现每次修改源目录文件的内容时整体页面都会被刷新，页面会被重新加载，如果我们的页面含有之前填写过的表单信息，然后我们又去改动了源目录某个文件的内容，按下CTRL+S保存后我们会发现之前填写过的表单数据因为整体页面的reload被清空了，这种情况往往不是我们想要的效果…"}, {"id": "6952702774644015141", "title": "实现一个自动上传资源到CDN的Webpack插件", "desc": "日常开发中我们通常会把前端的静态资源上传到CDN，以提高访问速度。本文将会带领大家开发一个Webpack插件，实现把资源打包成zip，然后上传到COS自动解压的功能。"}, {"id": "6908565593562202125", "title": "67行代码掌握webpack核心原理，你也能手撸一个”小webpack“~", "desc": "在我刚学会配置webpack的时候，用webpack打包出来的文件也曾想去读一读看一看，但是自己内心误以为会很难懂，所以直接放弃了，如今在回过头，其实并不难。用我的一句话总结就是：使用nodejs的fs模块来读取文件内容并创造出一个‘路径-代码块’的map，然后写进一个js文件…"}, {"id": "6844903825480876040", "title": "【实战】webpack4 + ejs + express 带你撸一个多页应用项目架构", "desc": "最近接了一个公司官网的项目，需要 SEO 友好，所以不能使用前端框架，前端框架自带的脚手架工具自然也帮不上啥忙。只好自己使用 webpack4 + ejs + express ，从头搭建一个多页应用的项目架构。搭建过程中，遇到许多坑，然而网上的相关参考也是非常少，所以写个博客记…"}, {"id": "6844903619158867982", "title": "Webpack打包优化", "desc": "前端的打包工具从之前的browserify、grunt、gulp到现如今的rollup、webpack，涌现出了很多优秀的打包工具，而目前最火的无疑是webpack，无论是当前热门的框架还是工具库很多都选择了它作为打包工具，因此在开发中webpack作为打包工具是一个很好的选择…"}, {"id": "6998136126158897160", "title": "webpack5源码解析", "desc": "本文阐述了webpack5的在构建过程中关键流程。包括插件的调用，loader的调用以及如何生成chunks的整个流程。最后还附了一张总结的全流程思维导图，想看源码的同学可参考～"}, {"id": "6991784184809259045", "title": "webpack5从0到1搭建一个react项目的实现步骤| 8月更文挑战", "desc": "这篇文章主要介绍了使用webpack5从0到1搭建一个react项目的实现步骤，文中通过示例代码介绍的非常详细，希望通过这篇文章，你也可以从0到1 构建项目"}, {"id": "6925622767794520071", "title": "Webpack 初探（一）", "desc": "有一段时间没有做积累和学习了，近期学习的内容会陆陆续续更新进来。 Webpack 应该会写一个系列吧，从 初探 => 深入 => 实战。 这里使用 lerna 创建一个 Monorepo，不了解 Monorepo 和 lerna 的同学可以看一下这篇文章：大型前端项目管理 - …"}, {"id": "6844903877771264013", "title": "webpack的面试题总结", "desc": "随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如react的jsx代码必须编译后才能在浏览器中使用；又如sass和less的代码浏览器也是不支持的。 而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack脱颖而出成…"}, {"id": "6978477363881312269", "title": "使用vite构建现有webpack项目", "desc": "将现有项目迁移到vite 最近准备重构一个老项目。原先这个项目是用webpack4打包的，为了尝尝鲜，准备在项目中加入vite构建的功能。 vite官网 由于现有的是一个webpack项目，说以首先得"}, {"id": "6844903700943601671", "title": "webpack4.x最详细入门讲解", "desc": "本文主要从webpack4.x入手，会对平时常用的Webpack配置一一讲解，各个功能点都有对应的详细例子，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也不过如此。 简单来说，它其实就是一个模块打包器。 如果像以前开发时一个html文件…"}, {"id": "6886598372124278791", "title": "[ 干货篇 · 第四期] 让webpack5再飞一会儿，夯实webpack4吧（基础篇）", "desc": "海阔凭鱼跃，天高任鸟飞。Hey 你好！我是秦爱德。😄 我是秦爱德，一名web前端划水员。提起webpack基本上是面试必问，工作必用的技术。多年来，随着技术的不断发展与变更，前端越来越注重模块化、组件化、工程化。这也迫使了webpack正在变得越来越重要！ 我本身是学java…"}, {"id": "7003737785727189005", "title": "5、使用webpack打包样式", "desc": "css-loader 分析出css文件之间的关系，并合并成一个css文件。style-loader 会把css-loader生成的css内容挂在到页面的head部分。"}, {"id": "6994016226259238943", "title": "从今天学习webpack-搞一个webpack脚手架（1）", "desc": "webpack 极简版脚手架，使用webpack、webpack-dev-server 、webpack-cli、html-webpack-plugin、clean-webpack-plugin"}, {"id": "6998672343836917797", "title": "深入 Webpack5 等构建工具系列二(6) - webpack 处理 less 文件 - less-loader", "desc": "这是我参与8月更文挑战的第19天，活动详情查看：8月更文挑战 在开发中，我们可能会使用 less、sass、stylus 等预处理器来编写 css 样式，以提高效率。那么，如何可以让我们的环境支持这些"}, {"id": "6844903549290151949", "title": "你的Tree-Shaking并没什么卵用", "desc": "Tree-Shaking这个名词，很多前端coder已经耳熟能详了，它代表的大意就是删除没用到的代码。这样的功能对于构建大型应用时是非常好的，因为日常开发经常需要引用各种库。但大多时候仅仅使用了这些库的某些部分，并非需要全部，此时Tree-Shaking如果能帮助我们删除掉没有…"}, {"id": "6991780011246092296", "title": "Webpack配置-其他资源加载以及处理（图片、字体、文件等）", "desc": "在 webpack5之前加载资源文件一般会是用 file-loader、url-loader、raw-loader等，但是在webpack5之后可以直接使用资源模块类型（asset module ty"}, {"id": "6844904182525198344", "title": "webpack打包首页优化及路由懒加载", "desc": "平常当中经常这么写，只不过你可能不知道这就是路由懒加载。官网，官网上提到这是由于异步组件和weback的代码分割code-splitting功能，每个异步路由会打包成不同的块，实现按需加载。除了上面的ES2015模块的写法，它还有 然后去看了下vue-cli的具体配置，路由已经…"}, {"id": "6844903670300016648", "title": "Vue-cli@3.0 插件系统简析", "desc": "Vue-cli@3.0 是一个全新的 Vue 项目脚手架。不同于 1.x/2.x 基于模板的脚手架，Vue-cli@3.0 采用了一套基于插件的架构，它将部分核心功能收敛至 CLI 内部，同时对开发者暴露可拓展的 API 以供开发者对 CLI 的功能进行灵活的拓展和配置。接下来…"}, {"id": "6999073565072949261", "title": "深入 Webpack5 等构建工具系列二(7) - 浏览器兼容性和 browserslist", "desc": "这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 为了引出一个叫 postcss-loader 的 loader，下面我们先来讲一些必要的前端知识。 1. 浏览器的兼容性 我们来思考一个问"}, {"id": "6969018138591494158", "title": "[打包优化]Webpack体积压缩", "desc": "HTTP压缩 HTTP压缩是一种内置在 服务器 和 客户端 之间的，以改进传输速度和带宽利用率的方式; HTTP压缩的流程什么呢? 第一步:HTTP数据在服务器发送前就已经被压缩了;(可以在webpa"}, {"id": "6895324456668495880", "title": "Module Federation原理剖析", "desc": "最近webpack5正式发布，其中推出了一个非常令人激动的新功能，即今日的主角——Module Federation（以下简称为mf），下面将通过三个方面（what，how，where）来跟大家一起探索这个功能的奥秘。 一. 是什么 结合以上，不难看出，mf实际想要做的事，便是…"}, {"id": "6992156510201577508", "title": "2.webpack 插件机制", "desc": "这是我参与8月更文挑战的第2天，活动详情查看：8月更文挑战 webpack 插件机制 特点 先来瞅瞅 webpack 插件在项目中的运用 那么符合什么样的条件能作为 webpack 插件呢？一般来说，"}, {"id": "6996947024335601671", "title": "webpack打包原理", "desc": "webpack是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。并不是什么commonjs或者amd之类的模块化规范。webpack就是识别你的 入口文件,识别你的模块依赖，来打包"}, {"id": "6969480065025310727", "title": "webpack5 的使用（二）：多个环境配置", "desc": "这是我参与更文挑战的第3天，活动详情查看： 更文挑战 多个环境配置 有时候在一个项目里，我们的环境并不是只有一个，可能会分为多个环境，比如：开发环境、生产环境。这个时候如果把开发环境的配置和生产环境的"}, {"id": "6977183266986000414", "title": "webpack或esbuild。为什么不同时进行呢？", "desc": "使用esbuild等工具可以使构建速度更快。然而，如果你已经投资了webpack，但仍然想利用更快的构建，有一个方法。 在本教程中，我们将向你展示如何使用esbuild和webpack以及esbuil"}, {"id": "6844903767247159303", "title": "那些花儿，从零构建Vue工程(webpack4 Eslint git hooks...)", "desc": "webpack默认只能识别JavaScript文件，不能解析.vue文件（vue单文件组件 是Vue独有的），于是作者提供了vue-loader。 提供了一个解析器，它能够将 CSS 解析成抽象语法树（AST）。 \b\b开发环境下一般不开启css提取\b，要不然每次代码改动重新编译…"}, {"id": "6958434052588339207", "title": "【学习笔记📒】webpack|手写loader — 模板编译 tpl-loader", "desc": "Webpack 基础知识点 Webpack 三大件 核心概念 mode entry output loader plugin devServer Loader 什么是Loader loader 用于对"}, {"id": "6953084680422260743", "title": "【Webpack源码分析】Webpack如何编译打包", "desc": "Webpack源码分析 本文篇幅会比较长，建议收藏。 概念 从 v4.0.0开始，webpack 开箱即用，可以无需使用任何配置文件。然而，webpack 会假定项目的入口起点为 src/index，"}, {"id": "6844904105031237645", "title": "聊一聊 webpack 的打包优化实践", "desc": "去年接触了公司内一个开发运行了两年多的项目，整体应用是基于 React 技术栈的，多个单页应用有构成了多页应用。可以理解为比较独立的子业务之间是 MPA 形式跳转，而子业务内部则是 SPA 形式。 本地开发环境下，代码改动后的热更新（增量编译）需要大概 10～20s 的时间，使…"}, {"id": "6939547615134482440", "title": "Webpack上传腾讯云｜项目复盘", "desc": "Webpack上传腾讯云是我个人之前为了解决遇见的问题所写的一个NPM插件，主要就是在Webpack打包完成之后可以将项目包上传到指定的腾讯云对象存储，实现CDN加速功能，提升项目的打开和访问速度。 Webpack上传腾讯云我在去年的时候发过一篇介绍的文章，我们公司是一个线上线…"}, {"id": "6844903592915107847", "title": "Webpack 4 和单页应用入门", "desc": "是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。 官网新的 webpack 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。 可能…"}, {"id": "6895255081415868429", "title": "简单讲讲Webpack", "desc": "众所周知，Webpack是一个静态模块打包工具，主要用于将多个JS文件进行打包成一个，这个是webpack最早的作用。随之时间的推移发展，webpack添加了许多新的功能，并且也增加了强大的定制能力，因此，Webpack也变得复杂了起来。 Webpack的Loader和Plug…"}, {"id": "6850418115189309447", "title": "使用 webpack4.0 从零搭建 React + TypeScript 应用", "desc": "刚接触 react 的时候，大家都是通过 create-react-app 等脚手架来快速创建应用。当基本配置满足不了我们的特殊需求时（比如使用 sass），我们会修改 eject 出来的 webpack 配置文件。 面对各种配置项一脸懵逼，不知道怎么快速修改。其实，学习项目搭…"}, {"id": "6854573218112487432", "title": "前端工程化 - 聊聊  Webpack v3 到 Webpack v5 的核心架构变迁", "desc": "Webpack 诞生之初的口号是一切皆可打包, 正如官网首页上的那张图所显示的那样, 可以说从 Webpack 开始, 前端工程才有真正意义上的 bundle, 过去的 grant, gulp 解决了流程问题, 但始终没有解决如何将资源打成一个包, 这个最朴素的问题, Webp…"}, {"id": "6956482714866286628", "title": "在 uni-app 中自定义 webpack loader 处理图片路径", "desc": "如何在 uni-app 中, 使用特定前缀的方式引用图片路径 例如: 在代码中使用自定义前缀处理图片路径"}, {"id": "6924503113223110669", "title": "从Webpack打包后的文件分析导入的原理", "desc": "主流框架中，不论是React还是Vue，都是使用Webpack进行资源的打包，这篇文章我们试着分析打包后的bundle文件来了解下其是如何进行静态和动态导入的。 modules​：缓存 ​module​ 代码块，每个 ​module​ 有一个 ​id​，开发环境默认以 ​mod…"}, {"id": "6844903877477662734", "title": "一文速览Webpack", "desc": "1. 核心概念 模块，在Webpack里一切皆模块，一个模块对应一个文件。Webpack会从配置的entry开始递归找出所有依赖的模块； 总结： Webpack在启动后会从Entry里配置的Module开始，递归解析Entry依赖的所有Module。每找到一个Module，就会…"}, {"id": "6844903895999709198", "title": "深入理解webpack的require.context", "desc": "require.context 其实是一个非常实用的 api。但是 3-4 年过去了，却依旧还有很多人不知道如何使用。 而这个 api 主要为我们做什么样的事情？它可以帮助我们动态加载我们想要的文件，非常灵活和强大(可递归目录)。 可以做 import 做不到的事情。今天就带大…"}, {"id": "6901936131835723790", "title": "【webpack系列】webpack小老弟接了个简单活", "desc": "大家好，我是一个专门做打包的打工仔，我的英文名叫webpack。今天npm老大哥找我帮忙，打包下他刚创建的webpack-test项目。本来今天挺忙的，但既然npm老大哥叫我来就还是来了，毕竟很多生意都是老大哥给我介绍的。唉，打工人没有尊严。😩 我进来webpack-test…"}, {"id": "6844903645700423693", "title": "前端工程化——构建工具选型：grunt、gulp、webpack", "desc": "前端工程化是依据业务特点，将前端开发的规范、流程、技术、工具、经验等形成规范并建立成一种标准的体系。 实现前端工程化的目的简单来说就是通过流程规范、自动化工具来提升前端的开发效率、性能、质量、多人协作能力以及开发…"}, {"id": "6844903501890322440", "title": "手把手教你如何使用webpack 生成css sprites", "desc": "我们在开发网站的时候，通常会把常用的图标合并成css sprite(雪碧图)，可以有效的减少站点的http请求数量，从而提高网站性能。 下面让我们一起来学习一下如何使用webpack合并sprite图。 好了，以上就是webpack生成css sprite的办法了，是不是觉着很…"}, {"id": "6979450550911762468", "title": "前端第十二步：模块化开发及规范化标准", "desc": "[TOC] 模块化 模块化只是思想 不模块化问题： 污染全局作用域 命名冲突 无法科学管理文件 解决方法： 模块化规范 + 模块加载器 模块规范 CommonJS 一个文件就是一个模块 每个模块都有单"}, {"id": "6899240081224450056", "title": "关于将codepen迁移到本地的一次思考", "desc": "用过codepen的都知道，codepen 是一个很好用的，网页demo快速编写工具。你只需要在左边编写你的网页，然后就可以在右边实时预览他的效果。例如下图： 并且他提供了许多HTML、CSS、HTML预处理工具。例如HTML有pug，ejs等等；CSS有scss，sass，l…"}, {"id": "6844903831306928142", "title": "一行一行手敲webpack4配置", "desc": "webpack4可以零配置打包，webpack4会默认对src目录下的index.js文件打包。 现在运行npx webapck，可以在demo1目录下看到dist目录，dist目录下有一个main.js文件，这就是打包后的文件，打开查找可以看到 console.log(dem…"}, {"id": "6844903669721219079", "title": "webpack loader—自己写一个按需加载插件", "desc": "在开发的工程中，线上环境需要引入一些统计和打印日志的js文件。但是对于开发环境，加速打包速度减少页面渲染时间很关键。我于是想根据开发环境，写一个简单的loader,按需加载一些资源。 为了完成按需加载的功能。打算使用自定义的loader。 拿到传入的参数并根据环境判断是否加载。…"}, {"id": "6958992396965117966", "title": "Webpack的基本配置和打包与介绍（一）⚡️", "desc": "Webpack是什么❓ 可能有很多的小伙伴对于这个Webpack既熟悉又陌生，有一些刚开始接触vue的小伙伴在对项目进行打包的时候经常会使用到npm run build来进行打包，但"}, {"id": "6844904084781154318", "title": "探索webpack构建速度提升方法和优化策略", "desc": "配置好之后，运行命令，就会在根目录生成一个stats.json文件，可以查看分析结果。这种方式只是初级分析，颗粒度较大。 配置好之后，运行打包命令的时候就可以看到每个loader 和插件执行耗时。 构建完成后，会在http://127.0.0.1:8888展示相关文件大小。按照…"}, {"id": "6988472813434699806", "title": "面向未来的前端构建工具 - Vite（分享文档总结）", "desc": "前言 关注前端社区的同学可能知道Vue.js他爹尤雨溪这两年推出Vite这个构建工具，初衷就是大佬觉得基于webpack，在开发时候，每保存一次代码就要等webpack重新去构建打包代码，这个过程太漫"}, {"id": "6967164397127270436", "title": "[打包优化]Webpack DLL", "desc": "认识DLL库 什么是DLL DLL全称是动态链接库(Dynamic Link Library)，是为软件在Windows中实现共享函数库的一种实现方式; 那么webpack中也有内置DLL的功能，它指"}, {"id": "6986512470932193294", "title": "webpack 学习记录", "desc": "webpack-前端资源构建工具，静态资源打包器（moudle bundler）学习记录，主要组成，插件和loader以及优化"}, {"id": "6844904021321318413", "title": "webpack5 + webpack-chain 构建一个大型应用系列 2（附 vscode 跟 prettier 配置）", "desc": "继上一篇 一步步从零开始用 webpack 搭建一个大型项目 之后的第二篇。本文使用了 webpack5 将项目进行了重构，并全程使用的 webpack-chain 来配置 webpack，每个功能也都是独立文件，可单独使用。因此该项目的配置可以在任何项目中被使用。此项目可实战…"}, {"id": "6899640414446780430", "title": "webpack | 动态导入语法import", "desc": "对于随着功能而使用的代码，可以先拆分出来打包到一个单独的js文件中（代码分割），然后在使用时动态创建script标签进行引入。"}, {"id": "6844903677958815752", "title": "【译】Google - 使用 webpack 进行 web 性能优化（一）：减小前端资源大小", "desc": "现代 web 应用经常使用打包工具来创建生产环境的“打包”文件（脚本、样式等等），这些文件经过优化和压缩之后能够极快的被用户下载。在使用 webpack 进行 web 性能优化系列文章中，我们将介绍如何使用 webpack 高效的优化站点资源。这将会帮助用户更快的加载网站以及交…"}, {"id": "6844903635474710541", "title": "[翻译]阮一峰webpack教程（Demo集合）", "desc": "Webpack用于构建Javascript模块脚本来给浏览器使用的前端工具。 Webpack允许多个入口文件存在，在多页面的app中很有用，每个页面有不同的入口文件。 加载器(Loaders)是一些预处理器，用于在Webpack的构建过程前，将你app里的一些资源文件进行转换。…"}, {"id": "6992905287761920037", "title": "Tree shaking（摇树）你必须要知道的事情", "desc": "本文章主要介绍Tree shaking以及涉及到的相关知识点，项目开发中、个人包管理要注意的技能点。"}, {"id": "6844903606743744526", "title": "基于Webpack搭建React开发环境", "desc": "在任意目录下，新建一个文件夹作为你的项目文件夹，命名随意。随后使用命令行工具，切换到该文件夹，键入npm init进行初始化（遇到的问题一直回车就好了），初始化完成之后可以看到生成了一个package.json文件。 随后在该项目文件夹下新建两个文件夹：/dist和/src，其…"}, {"id": "6844903640533041159", "title": "Webpack 中的 sideEffects 到底该怎么用？", "desc": "webpack v4 开始新增了一个 sideEffects 特性，通过给 package.json 加入 sideEffects: false 声明该包模块是否包含 sideEffects(副作用)，从而可以为 tree-shaking 提供更大的优化空间。 基于我们对 fp…"}, {"id": "6844904137033793543", "title": "霖呆呆向你发起了多人学习webpack-构建方式篇(2)", "desc": "你盼世界，我盼望你无bug。Hello 大家好！我是霖呆呆！ 什么？！你还想要\"呆妹\"出来给你讲webpack？！小伙子，你的想法很危险❌啊。 不可能的，下次想要见到\"她\"可能要等到呆呆5000粉的时候吧😒。在这之前我绝不可能再女装👚了 😊。 另外关于「霖呆呆的webpa…"}, {"id": "6844904040128577549", "title": "你值得拥有的几款实用webpack4性能分析插件【测评与推荐】", "desc": "在webpack打包的过程中有没有想过这其中的打包过程是怎么样的呢？有没有什么办法能反映出这个打包的过程和结果呢？webpack打包太慢需要优化怎么办呢？或许以下这几款插件能帮助到你，记得点个赞哈哈。 这款插件能把打包的进度以进度条的形式显示出来，同时也可以自定义显示百分比的格…"}, {"id": "6844903541962702855", "title": "webpack 搭建 vue 项目", "desc": "由于在使用vue时会用到很多es6的语法，但是现在很多浏览器对es6的支持不是很好，所以在编译时需要将这些语法转换es5的语法，此时我们使用babel来进行编译。 babel的使用请阅读官网文档http://babeljs.cn/。 此时一个基于webpack的vue 项目就搭…"}, {"id": "6966125434052280328", "title": "Webpack打包css中引用font、img等资源文件的路径问题", "desc": "Webpack打包css中引用font、img的路径问题 问题探究 Css中引入的各种资源，在开发环境下可以正常获取，但是打包之后在生产环境经常会出现资源路径错误的问题 分析 这个问题一般都是生产环境"}, {"id": "6965025783861477412", "title": "Webpack 核心总结", "desc": "前言 笔者最近重新复习了一遍 Webpack 核心功能，果然是温故而知新！这篇文章结合高级进阶之 Webpack 篇阅读效果更佳！ 常见优化手段 构建速度优化 思路：缩写搜索范围，减少不必要的模块打包"}, {"id": "6965401141156773924", "title": "webpack学习记录(6)-体积优化策略", "desc": "在之前的webpack学习内容中，介绍了使用webpage打包项目的基础构建，其中讲解了对js、css文件的压缩。这其实可以视为项目体积优化的一部分，下面针对体积优化进行进一步的学习。"}, {"id": "6997009154351038494", "title": "Webpack5 系列（三）：开发环境的设置", "desc": "上一篇讲到如何处理静态资源，本篇将更进一步，介绍如何打造一个基础而不失效率的开发环境。HtmlWebpackPlugin、Source Map、WDS、HMR。"}, {"id": "6844904126699044872", "title": "vue-cli设置publicPath小记", "desc": "几种设置publicPath后，再对比打包后的index.html文件测试背景：每次打包build完后，都单独生成一个/dist文件夹，且dist中每次都只有相同文件目录部署的时候，是部署在服务器的一"}, {"id": "6850418117898993671", "title": "Webpack4多页应用打包方案", "desc": "学习了webpack之后，将自己的博客的前端进行重构，由于自己的博客是多页应用，所以研究了下多页应用的打包方案。在这里把最后配置的成果分享下，不足之处，请指正。（文字不多，全是代码，不是配置教程，所以没有特别详细的写，只是一个参考） 多页应用的打包思路是每个页面对应一个entr…"}, {"id": "6929880861433167879", "title": "(webpack篇)1.webpack初识", "desc": "PS：注意webpack-cli版本，不然会报错。"}, {"id": "6914540064982859783", "title": "Webpack：从入门到配置、懒加载", "desc": "Webpack 用于编译JS模块，即俗称的“项目工程化”工具。 详见英文文档和中文文档。 如果你使用脚手架（vue-cli）等快速搭建工具，一般都集成了Webpack和一些基本配置。 首先通过 npm 查看 Webpack 的版本信息。 我们使用默认的最新版本 webpack4…"}, {"id": "6953447260059336718", "title": "webpack核心模块-tapable", "desc": "简介 在看L7源码时，看到我们使用了webpack的核心模块tapable，这个模块是连接webpack各个plugin的关键纽带，简单的说，如果不了解tapable，那肯定看不懂webpack的源码"}, {"id": "6931231392382582792", "title": "webpack快速入门", "desc": "webpack是一个静态模块打包工具，基于node.js开发。在开启webpack coding之前，我们先了解一些核心概念。 一. 核心概念 在webpack中，万物皆模块。它本身只能理解 json和js文件。loader 让 webpack 能够去处理其他类型的文件，并将它…"}, {"id": "6954168457713680415", "title": "webpack-loader分析", "desc": "webpack-loader浅析，结合实际案例style-loader和css-loader实现分析"}, {"id": "6844903504922837006", "title": "深入认识vue-cli：能做的不仅仅是初始化vue工程", "desc": "在讨论区有许多类似的问题： “vue-cli当中如何配置sass？” “vue-cli中如何修改devServer的端口？” “vue-cli中发现项目跑不起来” …… vue-cli说：“这锅我不背。”"}, {"id": "6950211315277234213", "title": "深入浅出webpack-webpack源码解析", "desc": "在深入浅出webpack-Tapable源码解析中,我们了解到webpack是基于Tapable来实现打包的任务调度,本文基于webpack的源码梳理打包的实现流程.在源码分析中会主要关注以下几点:w"}, {"id": "6934890884030791687", "title": "记录一个webpack插件的书写过程", "desc": "最近在做一个公共ui组件库的开发工作，针对公共库，有一定的规范，比如需要一个压缩版本，一个未压缩版本，一个索引文件。一般生成后的目录如下： 生成压缩和未压缩版本，我们可以配置两个entry，然后使用terser-webpack-plugin，指定文件压缩。webpack的大概配…"}, {"id": "6844904129974763533", "title": "认识 webpack-chain、以及 loader、plugin 的简单实现", "desc": "搭建可插拔的开发环境跟生产环境，灵活配置项目，完善定制化解决方案。 当你安装了 webpack-chain， 你就可以开始创建一个webpack的配置。下面的代码示例来自于官方示例。基本配置 webpack.config.js 共享配置也很简单。仅仅导出配置 和 在传递给web…"}, {"id": "6844903874046722056", "title": "透视前端工程化之 Webpack 基本介绍【文末有彩蛋～】", "desc": "Webpack 是一款强大的打包工具。在 Webpack 中一切皆模块。Webpack 官网的 Banner 图完美地诠释了这一理念。Webpack 从一个入口文件开始递归地分析模块的依赖关系，根据依赖关系将这些模块打包成一个或多个文件。 目前几乎所有的前端构建和开发都是采用 …"}, {"id": "6922004478958764040", "title": "webpack 暴露配置、快捷路径配置", "desc": "1. 引言 2. npm run eject eject为不可恢复操作，输入y，即可进行eject。 eject后，会在目录下发现几个新增的目录config，script。 webpack.config有两个，一个是dev（开发）环境下的配置文件，一个为prod（生产环境下，即…"}, {"id": "6844903573189312526", "title": "Promise入门", "desc": "这就是所谓的回调地狱，代码层层嵌套，环环相扣，很明显，逻辑稍微复杂一些，这样的程序就会变得难以维护。 对于这种情况，程序员们想了很多解决方案（比如将代码模块化），但流程控制上，还是没有掏出})的大量嵌套。但去年ES2015的标准里，Promise的标准化，一定程度上解决了Jav…"}, {"id": "6844903678726389768", "title": "mpvue 分包方案", "desc": "json文件。拷贝图片目录到dist下。 css和js文件从之前分别打包到单独的css和js目录，改为pages单文件目录下。vendor.js和manifest.js则一起打包到common目录下。 开发环境和生产环境打包生成的路径从原来的static下改为单文件目录下。 对…"}, {"id": "6844903701719711757", "title": "基于weex的有赞无线开发框架", "desc": "出于对开发效率和动态化的要求，无线端的开发框架也一直在更新，从 Hybrid、结构化 Native View、React Native、Weex，再到现在正在大受关注的 Flutter。什么样的框架才是适合自己的团队？不仅要有技术追求，而且要考虑实际业务需要。最近，有赞移动选择…"}, {"id": "6844903567191441416", "title": "Webpack 4正式发布，实现零配置启动", "desc": "Webpack 4 正式发布，代号为 Legato，包括多项重要更新，特别是增加了 0 配置特性，可以视为对前阵子大火的 Parcel 的有力回击。"}, {"id": "6844904154696155144", "title": "配置Loader (CSS-Loader & Style-Loader 的关系)", "desc": "Webpack可以以指定入口的一系列相互依赖的模块打包成一个文件，模块可以是js，也可以是其他类型的文件，但其他类型的文件需要对应的Loader转义配置Loader的方式在webpack.config"}, {"id": "6844903879247659015", "title": "深入 webpack 打包后的 js 世界", "desc": "在现代主流的前端项目开发中，几乎总能找到 webpack 的影子，它似乎已经成了现今前端开发中不可或缺的一部分。 下图是 webpack 官网首页，它生动形象的展现了 webpack 的核心功能：将一堆依赖关系复杂的模块打包成整齐有序的静态资源。 webpack 的出现加上现成…"}, {"id": "6844903872150913038", "title": "记开发一个webpack插件的心路历程", "desc": "作为一名前端菜🐔，日常工作就是写各种业务代码， 看着大佬们写的小工具、插件啥的，羡慕不已。 偶然想到要不也写个插件试试？试试就试试，抱着试试看的态度，开始了。 一、插件介绍。 良辰：在左边test文件中写export语句时， 会自动在右边的index文件中导出。 橘子：这样省…"}, {"id": "6844903504578871304", "title": "使用 webpack 优化资源", "desc": "在前端应用的优化中，对加载资源的大小控制极其的重要，大多数时候我们能做的是在打包编译的过程对资源进行大小控制、拆分与复用。 本片文章中主要是基于 webpack 打包，以 React、vue 等生态开发的单页面应用来举例说明如何从 webpack 打包的层面去处理资源以及缓存，…"}, {"id": "6844903692987023373", "title": "基于 Webpack4 搭建 Vue 开发环境", "desc": "自从工作之后，就已经很久没有写过博客了。时间被分割得比较碎，积累了一段时间的学习成果，才写下了这篇博客。 之前有写过 Webpack4 的文章，但是都比较偏入门，唯一的一篇实战篇 —— 基于Webpack搭建React开发环境，也是比较简单的，没有涉及到 CSS 抽取，第三方库…"}, {"id": "6976890920872607752", "title": "深入 webpack 打包后的 js 世界", "desc": "前言 在现代主流的前端项目开发中，几乎总能找到 webpack 的影子，它似乎已经成了现今前端开发中不可或缺的一部分。 下图是 webpack 官网首页，它生动形象的展现了 webpack 的核心功能"}, {"id": "6985104820298317854", "title": "Vue的webpack2.0升级到webpack4.0解决方案（utils篇）", "desc": "Vue的webpack2.0升级wepback4.0解决方案 由于项目最开始使用了vuecli脚手架搭建项目，webpack版本为2.0。后续由于项目引入插件需要支持webpack4.0。所以有了这次"}, {"id": "6992208596591181860", "title": "记录一次两年前的Vue项目升级", "desc": "记录一次两年前的Vue项目升级。 包括vue配置、webpack配置、babel配置、eslint及husky配置"}, {"id": "6962822550850109476", "title": "[建议收藏] Webpack 4+ 优秀学习资料合集", "desc": "推荐一波质量很高，值得一看的学习资料，内容涵盖 Webpack 应用、示例、原理、工具，希望对你有用"}, {"id": "6847009773305462791", "title": "前端工程化===Webpack？No，我来告诉你什么是前端工程化！", "desc": "由于现在开发中，前端可以负责的范围越来越大，早已不是仅限制于网页。像 App、小程序、甚至桌面应用，都可以使用前端技术来开发。 所以原来通过前端写 Demo，后端套数据的模式早就无法支持现代多元化前端开发。 前端工程化就是在这个背景下成为了受人重视的技术，并且是目前前端开发必备…"}, {"id": "6844903825216651271", "title": "webpack-bundle-analyzer插件快速入门", "desc": "首先，这是一个webpack的插件，需要配合webpack和webpack-cli一起使用。这个插件的功能是生成代码分析报告，帮助提升代码质量和网站性能。 3、在命令行工具中输入npm run dev，按回车。 此时会打开浏览器，你将看到项目的分析图，大概长这样。 缺点： 每次…"}, {"id": "6844903853708541959", "title": "html-webpack-plugin 使用总结", "desc": "html-webpack-plugin 的作用是：当使用 webpack打包时，创建一个 html 文件，并把 webpack 打包后的静态文件自动插入到这个 html 文件当中。 html-webpack-plugin 默认将会在 output.path 的目录下创建一个 i…"}, {"id": "6844903781377785863", "title": "重构之路：webpack打包体积优化（超详细）", "desc": "这一章讲打包体积优化，这个也算是最重要的一章了，我之前可是花了很多时间去查资料怎么优化打包体积的，不同版本的webpack之间还有一些区别，所以也算踩了很多的坑，所以这一章会比较长。 可以清晰的看到antd和react-dom就占了一半多，下面来优化。 1. 修改mode 2.…"}, {"id": "6901210575162834958", "title": "你必须知道的webpack插件原理分析", "desc": "在 webpack 中，专注于处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。它和 loader 有以下区别： loader 是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。webpac…"}, {"id": "6844904164904943623", "title": "这可能是最通俗易懂的 webpack 知识全景图", "desc": "Entry（入口）：Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module（模块）：在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk（代码块）：一个 Chun…"}, {"id": "6988059325784653838", "title": "webpack构建流程", "desc": "Webpack的构建流程主要有哪些环节？如果可以请尽可能详尽的描述 Webpack 打包的整个过程。 回答以上问题首先要了解webpack什么？ 了解webpack最基础的概念之后，我们再来跟进一步了"}, {"id": "6844903895697735687", "title": "webpack优化", "desc": "准备一份将VUE打包成DLL的webpack配置文件。 在build目录下新建一个文件webpack.vue.js，专门用于打包vue的DLL的。"}, {"id": "6844903725975240711", "title": "《从零构建前后分离的web项目》：前端1.0 终 - 前端性能优化 (多图预警)", "desc": "我们通常在本地开发，本地环境和线上也并非完全一样，很多项目第一次上线几乎都会遇到本地开发无法复现的问题，可能是字体、样式的问题，也可能是webpack 编译的问题、甚至可能是本地的奇葩环境。所以 本地完美运行 ≠ 线上完美运行，我们需要 build 项目，模拟线上测试一下，看看…"}, {"id": "6906392940675874830", "title": "使用webpack5从0到1搭建一个react项目", "desc": "在这之前，每开始一个新项目我都是使用现有的脚手架，这非常便于快速地启动一个新项目，而且通用的脚手架通常考虑地更加全面，也有利于项目的稳定开发；不过对于一个小项目，根据需求自己搭建可能会更好，一方面小项目不需要脚手架那么丰富的功能，另一方面可以提高对项目的掌控度以方便后期的扩展。…"}, {"id": "6844904193136787470", "title": "了不起的 Webpack HMR 学习指南（含源码分析）", "desc": "Hot Module Replacement（以下简称：HMR 模块热替换）是 Webpack 提供的一个非常有用的功能，它允许在 JavaScript 运行时更新各种模块，而无需完全刷新。 当我们修改代码并保存后，Webpack 将对代码重新打包，HMR 会在应用程序运行过程…"}, {"id": "6844903795512573966", "title": "使用 webpack 的各种插件提升你的开发效率", "desc": "近几个月，接手了一个老项目的重构规划，有多老呢？就是前端青铜时代的项目，一个前后端都在同一个锅里的项目、完全没有使用任何的打包工具。 前端 html、css、js三剑客 加上 jQuery 复制粘贴就是干。 前端不够后端来凑。如果前端有一些需求不是很复杂的话，后端人员有时候也会…"}, {"id": "6892379956543029261", "title": "EMP for Vue&React 互相远程调用", "desc": "做好前端开发不是件容易的事情，而比这更难的是扩展前端开发规模以便于多个团队可以同时开发和维护一个大型且复杂的产品。为解决这个难题，前端领域逐渐出现一种趋势，可以将大型的前端项目分解成许多个小而易于管理的独立部署的应用，并实现应用级别的资源（UI组件/工具函数/业务模块）分享，就…"}, {"id": "6844904070868631560", "title": "🔥Webpack 插件开发如此简单！", "desc": "做自己的轮子，让别人用去吧。 本文灵感源自业务中的经验总结，不怕神一样的产品，只怕一根筋的开发。 在项目打包遇到问题：“当项目托管到 CDN 平台，希望实现项目中的 index.js 不被缓存”。因为我们需要修改 index.js 中的内容，不想用户被缓存。 打包时动态创建 s…"}, {"id": "7000003965446422565", "title": "初识webpack|webpack是做什么的？", "desc": "写在前面 在现在的前端工程中，一定少不了webpack的身影，那么我们的项目中为什么需要用到webpack呢？下面我看来一起了解一下。"}, {"id": "6844903981479624711", "title": "月下三兄贵！Webpack和它的小伙伴vue&&react脚手架基配", "desc": "简单来说 Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 webpack是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 webpack 处理应用程序时，它会递…"}, {"id": "6856042330810646541", "title": "大白话讲webpack热更新", "desc": "webpack热更新，也称热替换，英文缩写「HMR」(Hot Module Replacement)。ok，介绍完定义，那么HMR的「作用」是什么呢？答案是让web项目可以在开发环境下，每次更改文件后无需重刷浏览器，即可看见更改的效果。嗯，了解完这些后，让我来抛出以下问题： 相…"}, {"id": "6844904116150337543", "title": "[Webpack] 核心概念、基础配置、常用loader和常用插件", "desc": "入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./…"}, {"id": "6844903513470795789", "title": "【填坑】vue+webpack 升级后在原有项目上的适配问题", "desc": "1. loaderUtils.parseQuery() ...... 2. vue - scope 3. 番外篇：vue-loader 的报错"}, {"id": "6844903853788233742", "title": "复习webpack4之提升Webpack打包速度的方法", "desc": "这次学习webpack4不仅仅要会配置，记住核心API，最好还要理解一下webpack更深层次的知识，比如打包原理等等，所以可能会省略一些比较基础的内容，但是希望我可以通过此次学习掌握webpack，更好地应对以后的工作。 如果Node进行了版本更新，性能方面有所提升，webp…"}, {"id": "6844904061829922824", "title": "大前端之路 -webpack 速成（二）", "desc": "另外 tree shaking 只支持 es module ，import模块的引入。 不支持 common js 的引入。 那么这个tree shaking 默认就是打开的。 假设你引入了一个css 文件，却没有明确使用它，默认情况下就把css 文件也去除掉。这可能并不是我们…"}, {"id": "6844903559503282184", "title": "前端开发--如何快速定位错误", "desc": "写代码时，通常要耗费大量的时间去排查bug产生的原因，如何快速的定位bug，在很大程度上决定了你的开发效率。下面是我的一些经验分享。 在一个项目足够简单时，往往不会意识到编码规范和代码质量的重要性。当项目大到需要多人协作或是接收别人的代码时，你就会意识到，编码规范的统一、项目结…"}, {"id": "6882671598743060493", "title": "Webpack 优化", "desc": "在项目庞大时构建耗时可能会变的很长，每次等待构建的耗时加起来也会是个大数目。 isomorphic-fetch 在不同的运行环境下使用不同的代码是因为 fetch API 的实现机制不一样，在浏览器中通过原生的 fetch 或者 XMLHttpRequest 实现，在 Node…"}, {"id": "6844903577857556493", "title": "webpack总结", "desc": "插件，用于在文件头部输出一些注释信息。"}, {"id": "6914078753861664775", "title": "webpack系列学习-初体验", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 第四步：打包后就能看到dist/bundle.js了。 下篇文章：介绍下webpack基本用法。"}, {"id": "6904300563500892174", "title": "Webpack学习笔记四：eslint语法检查", "desc": "在上一节文章末尾，我们提出了一个问题，我们要如何控制代码风格的统一，避免一些低级错误。这一节我们就来介绍下解决这两个问题的方法：eslint语法检查。 在日常开发过程中，项目一般都是多人合作。为了保证代码的统一和规范，我们需要借助eslint去完成。在此过程中，我们需要使用到e…"}, {"id": "6844903918766391304", "title": "掌握Webpack4（实战篇二）", "desc": "字面意思是摇树，项目中没有使用的代码会在打包的时候丢掉。JS 的 Tree Shaking 依赖的是 ES6 的模块系统（比如：import 和 export） 命令行运行 webpack 打包后，打开打包后生成的 /dist/app.bundle.js 文件。查找我们 a()…"}, {"id": "6844903838751670286", "title": "webpack4插件及工作流程", "desc": "webpack4重写了Tapable, 是webpack的插件组织的核心。它提供给各个插件钩子，在事件触发时执行这些挂载的方法。webapck的插件里必须有apply()方法，当其被调用的时候webpack将钩子上的方法挂载到各个事件下面有点像nodejs里EventEmitt…"}, {"id": "6908899942048202765", "title": "项目中常用的webpack插件", "desc": "不同项目，使用webpack版本不同，对应的插件也不同。 -- chunkFilename: chunk是webpack进行模块依赖分析时，代码分割出来的代码块。用于配置没有入口起点的代码块输出的文件名 -- loader在module.rules中配置，如使用vue-load…"}, {"id": "6872641206212362254", "title": "webpack plugin 探索 (内含详细 tapable 讲解)", "desc": "上面是官网给出的解释，听起来十分的酷炫。那么要怎么去使用并写出心仪的plugin呢？随之在官网找到了下面的demo。看完后陷入了大大的疑惑apply什么时候调用的？compiler是啥？传入的comp"}, {"id": "6844904166767198222", "title": "webpack4配置总结(三)", "desc": "上一篇整理了webpack配置的四大配置概念。这篇来整理loader的使用。 因为我的项目是基于Vue全家桶及sass的，所以loader部分会有偏向这方面的介绍，使用TS，React全家桶及less的可以找一下相应的loader。 webpack打包模块时，会把模块拿到mod…"}, {"id": "6949435305288007688", "title": "tapable 学习笔记", "desc": "代码地址：try-tapable同步钩子SyncHook: 同步钩子SyncBailHook: 执行过程中注册的回调返回非 undefined 时就停止不再执行SyncWaterfallHook: 瀑"}, {"id": "6986472674918678535", "title": "webpack4自定义loader", "desc": "如何自定义webpack-loader，loader是什么，手把手实现一个简单的webpack-loder"}, {"id": "6847902223028977678", "title": "写了这么多webpack配置，不想做一个自己的打包工具吗", "desc": "总所周知，现代前端，基本都离不开前端工程化，多多少少都要用上打包工具进行处理，例如webpack、rollup。不过写得再多，也只是针对webpack/rollup的配置工程师，具体打包过程，对我们来说却是个黑盒。 在构建之前我们要梳理一下打包的流程。 因为第一个分析的模块一定…"}, {"id": "6958013132568526855", "title": "webpack构建流程", "desc": "本文也来自拉勾教育的课程学习笔记，旨在了解webpack打包流，根据老师实现的简易版webpack走了一遍流程"}, {"id": "6968740371988348935", "title": "浅析Webpack", "desc": "本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，"}, {"id": "6890535054360739848", "title": "webpack tapable 简单了解", "desc": "Tapable 承包了 webpack 最重要的事件工作机制，包括 webapck 源码中高频的两大对象（compiler , compilation）都是继承自 Tabable 类的对象。这些对象都有 Tapable 的注册调用插件的功能，并向外暴露出各自的执行顺序以及 ho…"}, {"id": "6844903960814469127", "title": "webpack", "desc": "webpack基于Node.js静态资源的模块打包器当打包时会从一个七点开始查找各模块的依赖关系，并且按照依赖关系将文件打包成一个或多个包使用webpack打包的优点模块化通过模块化管理这些依赖自动编"}, {"id": "6915654869449703437", "title": "webpack搭建React项目（4）", "desc": "webpack 通过loader来支持多种语言和预处理器语法编写的模块，这样就可以处理各种非 JS 内容。 之前的配置是直接在 webpack 的打包输出目录下创建一个 html 页面，并手动引入 webpack 输出的 JS 文件。尽管引入了 WDS，可以自动打开并刷新页面，…"}, {"id": "6844903573826830349", "title": "Vue + Webpack 灰度发布控制", "desc": "实现前端项目多个版本共存。如果只存在一份资源，\b会导致每次修改都会影响到所有的用户，\b对于持续更新的Web项目来说，需要保证每次的修改只会影响到小部分用户，而不是所有的，控制范围，减少\b损失。 原直接以master分支\b作为production，功能修改完善合并到master上…"}, {"id": "6923792435512508430", "title": "tapable源码浅读", "desc": "The Hook will compile a method with the most efficient way of running your plugins. hook 实例会自行判断执行注册的 plugin 消费者的最有效率的方法。 每一个 hook 可以注册（被 t…"}, {"id": "6948198120937226254", "title": "怎么调试Webpack+React项目，报错basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\")怎么办", "desc": "今天在WebStorm上Windows上准备调试一个React项目，就出现了这样的报错。 Node Parameters里面写的是webpack-dev-server的执行文件.\\node_modules\\.bin\\webpack-dev-server.cmd，用的是相对当前工…"}, {"id": "6994412302585823240", "title": "03. Webpack高阶内容", "desc": "Dev Server 较为理想的开发环境 首先，它必须能够使用 HTTP 服务运行而不是文件形式预览。这样的话，一来更接近生产环境状态，二来我们的项目可能需要使用 AJAX 之类的 API，以文件形式"}, {"id": "6973104030658592804", "title": "webpack5 的使用（零）：概念", "desc": "这是我参与更文挑战的第13天，活动详情查看： 更文挑战 前言 在学习 webpack 的过程中，难免会遇到一些 webpack 专用的概念（术语），webpack 官方还专门在写了个 “术语表” 文档"}, {"id": "6844903542629613582", "title": "前端构建工具之争——Webpack vs Gulp 谁会被拍死在沙滩上", "desc": "gulp 和 webpack 是时下前端领域最火的两款工具，一个是年少成名，地位稳固，一个是后起之秀，来势汹汹。二者之间扑朔迷离的关系长期弥漫在前端圈，这俩货之间到底有什么恩怨情仇？不属于一类，没有可比性？还是另有玄机？"}, {"id": "6844903502464942093", "title": "webpack 应用编译优化之路", "desc": "目前大家使用最多也是最广泛的应用打包工具就是 webpack 了，除去 webpack 本身已经提供的优化能力（例如，Tree Shaking、Code Splitting 等）之外，我们还能做哪些事情呢，本篇主要就为大家介绍下滴滴 WebApp 团队在这条路上的一些探索。 现…"}, {"id": "6902748872792080391", "title": "【webpack系列】webpack小老弟打包大项目", "desc": "话音刚落 ~ npm老大哥又来电话了【有大工程】。 webpack小老弟在接到npm老大哥的介绍后，立马动身参与到大项目中。准备狠狠地大展身手~~~ webpack哼着小曲：“画画的baby，画画的baby...”；过了半个小时车程后，终于见到了大工程负责人：茂狸【校园商铺公众…"}, {"id": "6932029776173465607", "title": "浅析webpack源码之NodeEnvironmentPlugin（一）", "desc": "NodeEnvironmentPlugin由四个基本的文件系统组成，分别是inputFileSystem与outputFileSystem处理文件i/o，watchFileSystem监听文件改动，intermediateFileSystem则处理所有不被看做是输入或输出文件系…"}, {"id": "6844903583670861831", "title": "如何开发一个可爱的CLI（二）", "desc": "在系列的上一篇《如何开发一个可爱的CLI（一）》中，我给大家讲述了如何开发一个生成、渲染、转换样板文件（Boilerplate）的简单脚手架工具。本文，将是愉快的进阶环节 —— 如何基于webpack写一个 “零配置” 的命令行工具（暂且命名为lovely-cli.），实现以下…"}, {"id": "6844903588745986055", "title": "进击的模块化+webpack的简单实现", "desc": "本文的初衷是来实现一个我们工作中最常用的构建工具，webpack，当然我们所实现的构建工具和真正的webpack差距甚远。这里只是简单一个实现罢了，感兴趣的同学可以继续看下去。 AMD也是一种JavaScript模块化规范，与CommonJS最大的不同在于它采用异步的方式去加载…"}, {"id": "6844903950395654157", "title": "【前端】webpack loader配置全流程详解", "desc": "1.主要目的为稍微梳理从配置到loader的流程。另外详解当然要加点源码提升格调(本人菜鸟，有错还请友善指正) 2.被webpack打包的文件，都被转化为一个module，比如import './xxx/x.jpg'或require('./xxx/x.js')。至于具体实际怎么…"}, {"id": "6919863979607080967", "title": "预热面试季-webpack基础篇", "desc": "因为零配置是很弱的，特定的需求，总是需要自己进行配置。 在webpack有一个默认的配置文件，我们可以新建webpack.config.js，对这个文件进行修改，个性化配置。 模块解析，模块转换器，用于把模块原内容按照需求转换成新内容，可以理解为翻译官的意思。webpack是模…"}, {"id": "6867881388364791815", "title": "webpack 教程「三.生产环境配置」", "desc": "背景 开发环境 - 能让代码本地调试运行的环境 - 自动化操作（打开、刷新、关闭等）凑字凑字凑字凑字"}, {"id": "6954593750593044487", "title": "理解Webpack4用分块策略(common chunk strategy) webpack4 splitchunks", "desc": "理解Webpack4用分块策略(common chunk strategy) webpack4 splitchunks 最初，chunks（以及内部导入的模块）是通过内部 webpack 图谱中的父子"}, {"id": "6844903509574287374", "title": "让vue-cli初始化后的项目支持服务端渲染，SSR 实战", "desc": "当前 SPA 架构流行的趋势如日中天，但在 SEO 方面好像一直是个痛点，所以众多流行的 mv* 等框架也为此痛点提出了解决方案。 vue 官方提供了快速构建项目的工具 vue-cli，其方便快捷性众所周知。本文章来分享一下使用vue cli构建项目后如何集成 SSR(serv…"}, {"id": "6844903853419134984", "title": "demo19 webpack 开发模式和生产模式", "desc": "开发环境和生产环境的构建目标是有很大的不同的。 在开发环境中，为了便于代码调试以及实现浏览器实时更新,我们需要开启 source map 和 localhost server。 而在生成环境中,为了实现缓存优化以及改善加载时间,我们的目标转向于打包成更小的 bundle 或 c…"}, {"id": "6844903503962308615", "title": "Vue + TypeScript 尝鲜体验", "desc": "适用 Vue.version &lt; 2.5 &amp;&amp; Vue.version &gt;= 2.2其实我个人一开始很讨厌 TypeScript 这个东西，就是因为讨厌 Java 的啰里巴嗦，突然在我眼前出现了 JavaScript，便爱上了这门语言。但现在的我稍稍…"}, {"id": "6974794145102004254", "title": "webpack优化", "desc": "webpack的优化，主要是一些webpack自身配置和plugins的优化，还有就是代码分割的一些应用"}, {"id": "6906492869365334024", "title": "browserslist", "desc": ", or or: 表示‘或’，and: 表示‘且’。 鉴于上面出现的BUG，我全局安装browserslist，然后可以在控制台手动得到相应结果，而且不会出现bug."}, {"id": "6947495997702406151", "title": "使用webpack搭建react脚手架", "desc": "create-react-app是个优秀的脚手架工具，然而作为前端开发者，不能不会自己搭建脚手架工具。所以，开始了学习webpack之路。 打包就是将文件打包为另一个文件的能力。webpack将打包过程视为输入、输出两部分，其中这个过程还包括入口、模块、chunk、chunk组…"}, {"id": "6844904069870387208", "title": "libraryTarget的几种选择我们来好好分析", "desc": "这一切的起因都是因为那只pm，整个一个奇奇怪怪的需求，然后发现需要写库了，就在我流利的初始化项目时，突然脑抽风的发现，library配置貌似不太对，libraryTarget配置貌似也不太对，所以还是停下来吧，好好分析回顾一下，阿西吧。 先来回顾一下，library是指定义一个…"}, {"id": "6877011936421740558", "title": "Webpack 创始人 Tobias Koppers 教你手把手打包 （webpack4.0）", "desc": "为了更好地理解模块打包工具背后的理念，以及在底层它们是如何运作的，在观看 Tobias Koppers 放在油管的视频后整理本文，后续将录制视频帮助理解，demo地址将在底部放出。 视频[1]从开头介绍了整个项目的大体内容，位于 src 文件中：项目以 React 作为示范，引…"}, {"id": "6948666766541193230", "title": "webpack 核心知识点总结", "desc": "新特性打包编译： ESM有环境兼容问题，需要打包工具将开发阶段的一些文件在生产阶段直接编译成兼容绝大多数环境的代码。 模块化JS打包： 将模块文件打包到bundle.js文件中，解决了浏览器中频繁对模块文件发出请求的问题。 安装完成之后，对应的webpack和webpack-c…"}, {"id": "6844904061880238094", "title": "Webpack源码分析 - loader及优化", "desc": "loader解析文件是Webpack中重要的一环，之所以能一切皆模块就是因为有许多强大的loader提供的支持。了解它的工作原理可以让我们从容地为项目选择合适的配置，还可以更有目的性的针对性能瓶颈分析优化，更好地做一个合格地Webpack配置工程师。 issure: 匹配引用这…"}, {"id": "6844903608610193421", "title": "vue-loader解析", "desc": "最近在做一个玩具，其中用到了vue结构。 本文主要简单介绍下Webpack的loader具体做了些什么，然后简单解析一下vue-loader。 首先先介绍一下Webpack的loader究竟是什么，按照官网的说法，简单来说loader是让其他类型的文件转换成webpack能理解…"}, {"id": "6915667028527284232", "title": "webpack优化构建速度", "desc": "在使用 loader 的时候通过include或者exclude属性传入必要的路径和文件，避免全局匹配，可以提升 webpack 构建的速度。 resolve.modules指定 webpack 解析模块时应该搜索的目录，默认是['node_modules']，也就是 webp…"}, {"id": "6844903817641721864", "title": "svg图标的webpack优化", "desc": "最近在做项目的优化升级，因为折腾了一下午的图标管理，所以就把自己的经验分享出来，希望可以帮助大家更快的解决自己的需求。 我现在的项目，都是引入iconfont的图标库，真是的好用又方便。现在有三种模式，使用方法可以在官网的 使用说明 页查看。我们今天主要讨论的主要是第三种，也就…"}, {"id": "6969756995364585503", "title": "解决webpack-dev-server热更新异常情况", "desc": "解决webpack-dev-server热更新异常情况 如果是高效的热更新，页面就不会刷新。并且只会加载对应的更新资源。 开发中碰到的异常情况： 热更新是页面刷新reload的情况 危害：所有的资源都"}, {"id": "6844903519959400462", "title": "Webpack飞行手册", "desc": "在学习 Webpack 之前，我们需要了解一个概念：模块。 比如：我想在 C# 中进行数据库操作，我只需要在代码头部加上 下面这两段代码即可。 这两段代码可以看成 两个与数据库操作相关的模块。 当我们需求是数据库，或者是读取 IO 等其他操作，我们便加载其他不同的模块。 很明显…"}, {"id": "6856296259901194253", "title": "webpack从入门到进阶(一)", "desc": "现代浏览器已经支持了，es6的ES Module的模块引入方式，可以在 &#x3C;script> 标签中加入 type=\"module\" 属性 ，并且将项目运行在服务器上即可。 得益于 css3 中的 @font-face ，使得我们可以在网页中使用我们喜欢的任何字体。还有一…"}, {"id": "6844903641543868424", "title": "Vuex 原理浅析笔记", "desc": "不能直接改变store，改变store唯一途径就是显示地提交mutations。这样使得我们可以方便跟踪每一个状态的变化，从而让我们实现一些工具帮助我们更好的了解我们的应用 mapActions 辅助函数将组件的methods映射为store。dispatch调用 Vuex 运…"}, {"id": "6901470332201205767", "title": "Webpack 5 release版 官方文档全文翻译", "desc": "webpack 4在2018年二月份发行。在那以后我们封装了一些列特性，但是并没有引入破坏性的变化。我们知道大家不喜欢有破环新变化（breaking changes）的变更。特别是针对webpack这类工具，人们一年只会接触这种应用的机会很有限，其余时候把它丢在一边，只要它能正…"}, {"id": "6844903969337131022", "title": "webpack — 入门详解", "desc": "webpack 是一个前端资源加载/打包的工具。 其将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源 。。。 一. webpack初始化项目： 二. 配置文件出入口 三. loader-常用loader： 四. Plugin-常用插件： Plug…"}, {"id": "6844904015419949063", "title": "【原创】webpack如何优化vue项目", "desc": "日常开发中，Vue框架通常都会使用Webpack进行构建，随着项目不断迭代，项目逐渐变得庞大，然而项目的构建速度随之变得缓慢，于是对Webpack构建进行优化变得刻不容缓。通过适当的方法优化后，项目的构建速度提高了50%。现将相关优化方法进行总结分享。 由于Loader对文件的…"}, {"id": "6844903527882457096", "title": "优化webpack构建时间的小技巧", "desc": "在之前工作的地方，我们一直使用webpck去构建。但是，经过长达四年的更新迭代，每个人都在同一个项目中做了不同的操作和更新，这导致我们生产构建时间达到了惊人的一分半，watch模式的rebuild也达到了14秒之久。 这导致你每次保存代码都需要等待漫长的14秒之久。 有几个小技…"}, {"id": "6844903506839601166", "title": "搭建一个多页面的无依赖的工程化项目", "desc": "最近金拱门比较火，我们先戳开它的官网看看。 用vue/react吧，单页应用满足不了seo，而且IE兼容性不好。上node中间层做服务端渲染又把事情搞麻烦了。只能用JQuery干，但是又该怎么做工程化呢？好像也不是很容易。因为目前大家的工程化方案多是一整套单页应用全家桶，如vu…"}, {"id": "6844903599999303694", "title": "前端构建工具发展及其比较", "desc": "好文解决了我之前对前端构建工具的不清晰认识"}, {"id": "6882370334671142925", "title": "Webpack 5 released，中文（部分）尝鲜版介绍", "desc": "就在昨天，webpack 5 released ，我也火急火燎地去看了一下更新文档介绍。确实，如文档开头所说这次做了重大改变，以便于未来可以很好地应用新的功能。因此，整个发布内容的介绍非常多，大概 1 万多字。并且兴趣使然，我也开始了火急火燎的翻译，但出于个人时间和信息的时效性…"}, {"id": "6844903638431694862", "title": "Web Worker 初探", "desc": "以前我们总说，JS是单线程没有多线程，当JS在页面中运行长耗时同步任务的时候就会导致页面假死影响用户体验，从而需要设置把任务放在任务队列中；执行任务队列中的任务也并非多线程进行的，然而现在HTML5提供了我们前端开发这样的能力 - Web Workers API，我们一起来看一…"}, {"id": "6864546220124143629", "title": "大声对webpack4.0说声你好之webpack的实战配置与优化(五)", "desc": "学习了四节之后，我们对webpack可以说是已经有了深刻的认识，相信你也可以根据自己学到的内容对自己的网站等进行一系列的打包。 如果你是从第一节就跟着我走到这里的，那你就算我的webpack老战友了。这节当然你也会学到很多比较有趣的知识，例如： 因为github已经提交了前四节…"}, {"id": "6964931589868519437", "title": "Webpack核心Tapable从应用到源码之三(源码)", "desc": "Tapable 包是 Webpack 插件机制的核心，它暴露出很多 Hook 供插件使用......"}, {"id": "6844903667779239949", "title": "如何使用webpack构建Ueditor", "desc": "由于种种原因，我们选择了Ueditor作为我们的富文本编辑器选型。 Ueditor不支持模块化，所以无法在代码中使用import去引入。一开始我们在项目中是将Ueditor的js文件直接通过script标签引入，在React的代码里直接使用window.UE去使用编辑器。但是这…"}, {"id": "6895229827747020807", "title": "新手的 webpack 多页面多环境配置实战", "desc": "花了几天详细地学习了 webpack 的用法，基本上常用配置和一些主要的 loader 和 plugin 的用法和配置已经都学了个七七八八，不过真的要自己从头配置又有点无从下手的感觉。学习就是这样，看是一回事，做又是另一回事，只有在不断的练习中犯错，修正，不断的重复才能真正掌握…"}, {"id": "6844903829536784391", "title": "webpack 打包后文件分析", "desc": "webpack 用于编译 javascript 模块， 可以把文件格式编译成我们想要的静态文件格式， 但是处理的过程并不是全部由 webpack 本身完成， webpack 只是提供了一个打包机制， 对于各类文件的打包处理需要使用相对应的 预处理模块 loader 来处理， 作…"}, {"id": "6844903646480580615", "title": "webpack怎么能只是会用呢,核心中的核心tapable了解下?", "desc": "1. tapable 同样的，在使用tap*注册监听时，传递的第一个参数，也只是一个标识，并不会在程序运行中产生任何影响。而第二个参数则是回调函数 3. Sync*类型的钩子 串行同步执行,第一个注册的回调函数会接收call传进来的所有参数,之后的每个回调函数只接收到一个参数,…"}, {"id": "6911191910795198471", "title": "webpack4.0各个击破（4）—— Javascript & splitChunk", "desc": "一. Js模块化开发 javascript之所以需要打包合并，是因为模块化开发的存在。开发阶段我们需要将js文件分开写在很多零碎的文件中，方便调试和修改，但如果就这样上线，那首页的http请求数量将直接爆炸。同一个项目，别人2-3个请求就拿到了需要的文件，而你的可能需要20-3…"}, {"id": "6927407999312986120", "title": "前端开发工具集（五）：模块打包器（browserify、parcel、rollup、webpack）", "desc": "本文是开发工具集系列文章之一，其他请点击这里。 模块打包器(module bundler)，顾名思义就是将各个模块（module）打包到一个或几个文件中，然后在html文件中引入。 在es module中，module是对应script的一个概念，即可以理解为应用中使用到的非全…"}, {"id": "6844903585738653709", "title": "漫谈Vue组件库开发", "desc": "聊聊基于webpack脚手架开发一个Vue移动端UI组件库的经验与思考"}, {"id": "6844903776713867277", "title": "【填坑指南】webpack图片路径与打包问题", "desc": "因为在webpack中，除了js类型的文件是能够直接被识别并打包，其他类型文件（css、图片等）则需要通过特定的loader来进行加载打包，而图片则需要用到file-loader或url-loader。 在JavaScript中引入图片路径时，webpack并不知道它是一张图片…"}, {"id": "6932647857048682503", "title": "基于Vue-Cli4构建项目的优化配置", "desc": "​ 从Vue-Cli3开始，Vue-Cli为我们提供了一个一键式的快速构建工具，在大部分简单项目中，它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样我们可以专注在撰写应用上，而不必花好几天去纠结配置的问题。但编写合适的配置文件确是可以让我们的项目锦上添花，拥有更好的…"}, {"id": "6844903733290074120", "title": "如何优雅的使用Mock Server", "desc": "前几个月，上了YApi的车。 因为rap2升级就改库，无力维护，且没有支持ldap。但不可否认它支撑了1年多的业务开发。 很赞的。 YApi用起来也很爽，对测试也更友好。我用的手工方式部署的，docker部署起来很爽，但是云上MongoDB贵啊，只能装个本地的，每天自动备份，避…"}, {"id": "6844903593305178125", "title": "撩测试MM神器cypress使用入门", "desc": "据说某家公司有两位前端，天天撸bug，为啥嘞？只怪测试MM倾人国，轻语哥哥有bug。✧(๑•̀ㅂ•́)و✧ 可是最近两位有点犯愁 Σ(っ °Д °;)っ。测试MM有几次提了紧急bug，都在旁边鼓励他们改bug了，可是线上bug重现排查比较麻烦，而且改了后还发现没改好，惹得测试M…"}, {"id": "6995165342347558920", "title": "通过webpack删除项目中的废弃文件", "desc": "现在的项目文件很多，找起来很不方便，而且刚接手不熟悉逻辑的时候，上来一搜很多重复代码，向上查找引用发现根本没有用到这个文件。所以就打算做个一键删除废弃文件的功能"}, {"id": "6901699945619783693", "title": "自动生成骨架屏", "desc": "预渲染: 启动一个浏览器，生成html，加载这个页面的时候先显示再进行替换。 缺陷：如果数据非常实时，比如新闻列表，替换页面之前数据可能还是昨天的。比较适合静态页面 由于服务器端渲染只是个字符串，它不知道DOM什么时候放到页面上。就导致一些浏览器的api无法正常使用了，比如操作…"}, {"id": "6910393218244804616", "title": "从零搭建基于 Webpack5.x 的 Vue 项目", "desc": "webpack5.x 发布至今已经将近两个月了, v5 版本内置了一些常用的插件, 较 v4 版本有很大的变化. 本文基于 webpack5.x 以及 vue2.x, 从零搭建一个基础模板:"}, {"id": "6964561075287097351", "title": "Webpack Loader知识分享", "desc": "Loader可以用于对模块的源代码进行转换；在加载这个模块时，webpack其实并不知道如何对其进行加载，我们必须定制对应的loader来完成这个功能。"}, {"id": "6847902220298649607", "title": "webpack 5 联邦模块介绍", "desc": "本文主要介绍webpack 5 的新特性之一 \"module federation\"(联邦模块)，涉及联邦模块特性、使用方法、适用范围。 webpack 5引入联邦模式是为了更好的共享代码。 在此之前，我们共享代码一般用npm发包来解决。 npm发包需要经历构建，发布，引用三阶…"}, {"id": "6844903516771729416", "title": "钩子函数的运行机理", "desc": "为什么还要提到面向切面，我第一次听到这个词还是在写 java 的时候，它是 spring 的核心思想之一（不得不说，前端从石器时代发展到今天的工业时代，大量借鉴了后台的编程思想，所谓触类旁通，那个道理就是这么讲来着）。发挥想象力，所谓的钩子，是不是在框架工具的某个阶段，切一刀，…"}, {"id": "6844903651413065736", "title": "使用 webpack 构建小程序项目", "desc": "相信开发过插件的同学，都看过 Writing a Plugin 或类似的文章，因为 mini-program-webpack-loader 这个工具开发时正好 webpack 4 发布了，所以就阅读了这篇文章，顺便看了以下几篇文档。 每个插件必须要有 apply 方法，用于 w…"}, {"id": "6914084919245275149", "title": "微前端 Emp 的 2020 | 掘金年度征文", "desc": "本文将以微前端 Emp 框架（后面称 Emp）项目成员的角度总结在过去 2020 中探索微前端框架的过程。 综上所述，引入Single-spa 会增加部署、维护、改造的成本。所以转向研究 Module Federation 。 研究结论：基于 Module Federation…"}, {"id": "6943758280581709855", "title": "webpack 中比较难懂的几个变量名称", "desc": "webpack中有几个比较难懂的变量名称，主要是做一个总结性的概括。 webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。 一般来说一个 chunk 对应一个 bun…"}, {"id": "6844903596992135182", "title": "webpack 换肤功能多主题/配色样式打包解决方案", "desc": "本文主要详细介绍了，如何使用 webpack打包多套不同主题的解决方案以及实践中所遇到的问题。"}, {"id": "6844904074421207047", "title": "webpack多页面打包实践", "desc": "前不久从零开始写了一个webpack多页面打包boilerplate(webpack4-boilerplate)，方便以后工作可以开箱即用，特此记录下开发过程中的要点。 然而现实是骨感的，很多场景下，单页应用的开发模式并不适用。比如公司经常开发一些活动页: 上述三个页面是完全不…"}, {"id": "6907428440329158663", "title": "Webpack入门 - 从0开始搭建项目配置", "desc": "webpack 作为前端最知名的打包工具，能够把散落的模块打包成一个完整的应用，大多数的知名框架 cli 都是基于 webpack 来编写。这些 cli 为使用者预设好各种处理配置，使用多了就会觉得理所当然，也就不在意是内部是如何配置。如果脱离 cli 开发，可能就无从下手了。…"}, {"id": "6844903833584271367", "title": "使用模块化工具打包自己开发的JS库(webpack/rollup)对比总结", "desc": "小程序的模块化采用了Commonjs规范。也就是说，我需要提供一个monitor.js文件，并且该文件需要支持Commonjs，从而可以在小程序的入口文件app.js中导入： 但是考虑到代码量，为了降低耦合度，我还是倾向于把代码拆分成不同模块，最后把所有JS文件打包成一个mon…"}, {"id": "6909662452187660302", "title": "手写一个简单的 webpack 编译代码", "desc": "最外层是一个立即执行函数，入参是所有的 modules（模块） list。传入的 modules 参数是一个对象。 对象的格式是，文件名: 方法。 key 是 index.js 文件的相对路径，value 是一个匿名函数，函数体里面就是咱们写在 index.js 里的代码。（这…"}, {"id": "6901480608531218445", "title": "从无到有，实现一个webpack插件", "desc": "webpack已经成为开发web应用不可或缺的工程化工具，而作为webpack支柱功能的插件系统，是我们深入学习webpack绕不过的一道坎。站在插件开发的视角，你可以更细粒度地控制webpack的工作，实现那些通过修改配置文件做不到的事情。 最近公司团队使用webpack来给…"}, {"id": "6844903891922862093", "title": "Webpack SplitChunksPlugin插件研究", "desc": "自Webpack4以后，代码拆分的插件由CommonsChunkPlugin变成了SplitChunksPlugin，并且不必单独引用，集成到了Webpack之中，通过配置下的optimization.splitChunks和optimization.runtimeChunk就…"}, {"id": "6844904196739710983", "title": "webpack4主流程源码阅读以及实现一个简单的webpack", "desc": "P.S. 以下的源码流程分析都基于 webpack4 这里有个小逻辑区分是否是 watch，如果是非 watch，则会正常执行一次 compiler.run()。 如果是监听文件（如：--watch）的模式，则会传递监听的 watchOptions，生成 Watching 实例…"}, {"id": "6966506054800801823", "title": "webpack5（一）安装和初体验", "desc": "安装 使用 默认入口 src/index.js 输出 dist/main.js 使用全局依赖打包 webpack 本地依赖打包 npx webpack ./node_modules/.bin/webp"}, {"id": "6844903614264115213", "title": "前端配置工程师", "desc": "create-react-app中webpack配置学习"}, {"id": "6844903747508781069", "title": "Webpack 是怎样运行的？(一)", "desc": "Webpack 是时下最流行的前端打包工具，它打包开发代码，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。 你可能已经知道，这种便捷是由 Webpack 的插件系统带来的，但我们今天先把这些概念放在一边，从简单的实践开始，探索 Webpack 打包出的代码是如何在浏…"}, {"id": "6844904030137761800", "title": "webpack自动化架构入门", "desc": "第一次打算学习自动化的时候是参照的一个老哥的文章，没想到现在版本更新太快，那篇文章已经跑不起来了，所以我在这重新写一篇最新版的搭建文章，怀念一下我老哥。 第一句： -D 是 --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependen…"}, {"id": "6894191135896535053", "title": "Webpack4 性能优化实践", "desc": "在使用 Webpack 时，如果不注意性能优化，可能会产生性能问题，会导致在开发体验上不是非常丝滑，性能问题主要是编译速度慢，打包体积过大，因此性能优化也主要从这些方面来分析。本文主要是自己平时的工作积累和参考别人的文章，而进行总结，基于 Webpack4 版本。 对 Webp…"}, {"id": "6844903605841952781", "title": "『转』vue-cli脚手架中webpack配置基础文件详解 | 切图妞", "desc": "vue-cli是构建vue单页应用的脚手架，输入一串指定的命令行从而自动生成vue.js+wepack的项目模板。这其中webpack发挥了很大的作用，它使得我们的代码模块化… 作者：切图妞 原文：https://segmentfault.com/a/1190000014804"}, {"id": "6896304543567953928", "title": "webpack中的各种性能优化", "desc": "webpack中的各种性能优化1.删除无用的csspurgecss-webpack-plugin：删除无用的css插件glob：功能是查找匹配的文件先下载这两个包，再去webpack.config.j"}, {"id": "6844904080150626318", "title": "从零开始实现类 antd 分页器（一）：搭建项目架构", "desc": "这一节我们先来讲一下，项目基本架构的搭建，我们使用 Webpack 来作为我们的项目构建工具，接下来我们就详细看一下项目的初始目录和详细的依赖安装。 安装相应的 webpack 的 plugins，下面的 plugins 的作用我就不细说了。 最后修改 package.json…"}, {"id": "6844903641808109576", "title": "关于webpack优化，你需要知道的事（上篇）", "desc": "webpack 是一个优秀的打包工具，其本身为我们做了大量优化，同时也为我们提供了大量的配置项让我们可以自定义，从而有优化空间。 下面我先讲讲vue脚手架为我们做的一些优化，不喜欢看的请跳过，然后会讲如何在优化的基础上升华一下，内容从浅到深，但是所有的方法都经过楼主考证，内容较…"}, {"id": "6844903615979585550", "title": "webpack动态创建入口方法", "desc": "create-react-app创建的应用默认是SPA的架子入口只有index.html。但是有些情况下我们确实需要在同一个工程下开发多个SPA项目，一个是2C的H5项目，一个是后台的管理项目。网上多页面的配置已经很多了，这里只是想扩展记录一些方法。 项目的架子是下面这样的。 …"}, {"id": "6844903840597147662", "title": "webpack4-02-配置文件、资源加载器（sass、file）- loader", "desc": "上一节中讲了零配置也可以跑起打包js的操作，但是在实际项目中，不只是那么简单的打包，需要自定义配置打包的入口、输出的出口文件。 上面配置中，mode选项就是我们的打包模式，上一节讲过的。 entry 就是打包的入口文件，值是一个路径。 path 是输出到什么目录下，使用Node…"}, {"id": "6844903813917196296", "title": "使用webpack4一步步搭建react项目（三）", "desc": "第二章的配置基本已能达到正常的开发需求了。但是还有很多地方可以进行改善。 React开发中难免要用到ES最新语法。例如常用的Decorators还在Stage 2阶段，Dynamic import还在Stage 3阶段。这些新的语法并没被@babel/preset-env涵盖。…"}, {"id": "6976570710294528031", "title": "webpack简单笔记", "desc": "出入口配置 1：入口和出口，一般单页面应用，就只有一个程序启动入口entry和出口output： 2: 但是需要搭建多页面应用的话，entry和output配置如下： 3:使用CDN和资源hash配置"}, {"id": "6844903805130113038", "title": "webpack4搭建的一次尝试", "desc": "Plugins：Loaders将各类型的文件处理成webpack能够处理的模块，plugins有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。比如对js文件进行压缩优化的UglifyJsPlugin插件 Chunk：coding…"}, {"id": "6844903605330247688", "title": "自建最轻量的react+webpack+es6架构", "desc": "1. react和react-dom是react项目的基础 2. webpack4.x后版本在配置上有些改变如: rules, use 3. 注意样式的loader顺序, use: ['style-loader', 'css-loader'], 反过来的话会报错"}, {"id": "6904126731473387527", "title": "CRA 黑盒如何实现", "desc": "前两篇黑盒内容：“CRA为什么要做成黑盒”和“如何在黑盒中争取主动权” 今天这篇文章我们继续谈谈CRA黑盒的实现。不管是@vue/cli还是create-react-app，它们内部都暗藏着黑盒的机制"}, {"id": "6844904049020502029", "title": "Webpack实战（四）：教教你如何轻松搞定-预处理器（loader）", "desc": "在一个项目中，我们要面临着各种各样的资源，如何让Webpack很好的处理这些资源呢？这个时候我们需要借助于预处理器（loader），loader的字面意思是装载器，在Webpack中它的实际功能则更像是预处理器。Webpack本身只认识JavaScript，对于其他类型的资源必…"}, {"id": "6844903502519468039", "title": "代码分割结合 Prefetch 完美优化单页应用加载性能", "desc": "单页应用性能的最大痛点就是 bundle 体积大导致首屏时间过长。使用 webpack 的 code splitting（代码分割）功能可以将 bundle 分片，加速首屏，但之后的交互势必会受到影响。预加载分片 thunk 是必需的，本文探讨最理想的预加载手段。"}, {"id": "6968642506212769822", "title": "webpack5（五）模块化原理", "desc": "通过查看源码了解webpack中是怎么实现最常用的ES Module、CommonJs和互相引用的 查看源码前先设置mode和soucre map，让生成的源码容易阅读 CommonJs模块化原理 m"}, {"id": "6922362094713045005", "title": "webpack 4 学习随记 二  webpack核心概念", "desc": "模块(Module)：在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 可以通过在 webpack 配置中配置 Entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。 file…"}, {"id": "6904538360249843719", "title": "webpack基本使用", "desc": "webpack是一个现代javascript应用程序的静态模块打包器（modulebundler），当webpack处理应用程序时，它会递归地构建一个依赖关系图(dependencygraph)，其中"}, {"id": "6844903550674272263", "title": "Webpack Loader源码导读之babel-loader", "desc": "webpack应该是当下最主流的前端构建工具之一，但是由于webpack本身糟糕的文档，使得使用者多是会用但不知其所以然，出现问题时难以入手；为此，我想根据自身的理解，详细讲解一些常用loader、plugin源码，深入各个loader及其配置所带来的影响；本系列将以babel…"}, {"id": "6844904040556396551", "title": "前端工程化之推开webpack世界的大门", "desc": "在前端开发领域独立负责项目已有不少，从刚开始的angular1.x到vuejs再到react，前端常用的三大框架都有接触。用过的人都知道这三个框架的使用都离不开webpack，从本地开发到线上部署，webpack给我们带来了很大的方便，所以说精通webpack是现如今前端的必备…"}, {"id": "6844904145166548999", "title": "从 script 标签说到 webpack：javascript 模块化历史", "desc": "最近有个需求要用到 dynamic import ，发现 require 也可以实现同样的效果，但是 webpack 不推荐用多种 module method。后来就尝试去了解关于 static import / dynamic import / require 之间的区别。再…"}, {"id": "6844903509024866318", "title": "前端每周清单第 38 期: Node 9 发布，Kotlin 与 React，Netflix 架构解密", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID：frontshow），及时获取前端每周清单。 Node.js 8 宣布进入 LTS，No…"}, {"id": "6897794046745149448", "title": "配置webpack", "desc": "Plugins：插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等 Loader 本身也是运行在 node.js 环境中的 JavaScript 模块，它本身是一个函数，接受源文件作为参数，返回转换的结果。 如：字体图标..."}, {"id": "6900934461660069902", "title": "webpack打包多页面，怎么按需分chunk", "desc": "前几天，同事在群里问了这么一个问题：一个 vue-cli 启动的项目，使用多页面打包方式，打包出两个应用a和b。a应用引入vant库ipunt组件，b引入vant库list组件。如果把vant打成一个单独的包，里面会既有input也有list，所以a应用加载了它并不需要的lis…"}, {"id": "6895969773260619790", "title": "手把手带你青铜上钻石之——webpack", "desc": "倔强青铜——初识webpack 初始化项目 创建项目文件夹，执行以下命令，生成package.json文件，初始化项目。 package.json文件如下，它包含项目的一些基本信息。 安装webpac"}, {"id": "6983128925740367885", "title": "requireModuleExtension 参数配置错引起的问题", "desc": "webpack 中requireModuleExtension 参数配置错引起的问题。 受掘金上的一篇文章启发准备用vue练习写一个小界面，类似于书签管理。"}, {"id": "6970556040106508302", "title": "前端模块打包之Webpack", "desc": "这里总结一下，自己在学习webpack时，比较疑惑的地方 1、什么是webpack? webpack是前端模块化打包工具，它把一切都看成模块"}, {"id": "6987347612613476360", "title": "AntV G6项目如何兼容IE", "desc": "阿里的AntV G6是很强大很好用，但要兼容IE会遇到各种坑。虽然官网给出了解决方案，但因为原因千奇百怪，即使完全照官方的方案操作一遍，仍然有问题。本文如果能帮到同学少踩坑，那就不枉我花二个小时来总结"}, {"id": "6984393830208536583", "title": "一文搞定webpack", "desc": "Webpack是现在最流行的模块打包工具之一。本文涵盖了Webpack的各种日常用法，欢迎交流探讨。"}, {"id": "6926413159645478920", "title": "tapable源码结构初识", "desc": "本文是tapable项目源码阅读的第一篇，文章的目的是大致梳理一下tapable源码的结构，为接下来深入细节铺平道理，打好基础。 项目的结构非常简单，可以看到tapable支持的所有hook类型以及两个辅助类型都以单文件的形式存在。 入口内容很简单，仅仅是将所有的引入并导出了t…"}, {"id": "6988797451763187742", "title": "require.context，解放你的双手，实现自动引入~", "desc": "require.context 使用场景 当你的项目中有一些组件频繁的被使用到，我们把这类组件称之为基础组件。但是又不想每次使用的时候，都要手动的import一次，而且还需要在components选项"}, {"id": "6987027028276936712", "title": "webpack试练04之疯狂踩坑", "desc": "踩坑一：接上回说到webpack打包发布脚本到npm上，代码根本未变，再次打开vscode诡异的事情发生了，编译后一直报错 回归正题： 1、服务端渲染使用webpack打包 直接上代码 踩坑二：因为对"}, {"id": "6999625608774811685", "title": "webpack的基本使用（一）", "desc": "webpack的学习总是忘记，为了加强印象来记录一下配置的主要基本内容，感兴趣的工友可以看看，不对的地方欢迎指正"}, {"id": "6943866186438443016", "title": "分析 Element 的  Markdown loader : md-loader（1）", "desc": "element 将 vue 语法写入 markdown 文件中，通过 markdown 文件生成了我们看到的文档页。本文将分析 element-ui 是如何做到这一点的。"}, {"id": "6936853506506620964", "title": "2021年的webpack性能优化", "desc": "webpack性能优化如何进行性能数据分析编译时间的优化编译体积的优化如何运行的更快本文起步工程,承接上一篇文章electron主线程和渲染线程的交互总结如何进行性能数据分析安装friendly-er"}, {"id": "6844903586950807560", "title": "入门babel--实现一个es6的class转换器", "desc": "babel是一个转码器，目前开发react、vue项目都要使用到它。它可以把es6+的语法转换为es5，也可以转换JSX等语法等，实际上他能通过自定义插件的方式完成任意转换。 我们在项目中都是通过配置插件和预设(多个插件的集合)来转换特定代码，例如env、stage-0等。那么…"}, {"id": "6988811628678479909", "title": "webpack学习 --- postcss 和 图片资源打包", "desc": "webpack默认只能对于JavaScript资源模块进行打包，如果在项目中需要对css资源模块或图片等文件资源模块进行打包处理操作的时候，就需要在webpack中配置对应的loader来进行解析。"}, {"id": "6982860564851032077", "title": "webpack4升级webpack5", "desc": "webpack4升级webapck5 升级步骤 1、自定义开发环境 对于开发环境，我们更加灵活的自定义配置的方式 2、端口号(可能被占用) 3、ip链接 需求：由于移动端或者pc端，经常会拿ip链接进"}, {"id": "6927972972640600078", "title": "qiankun框架如何支持热更新", "desc": "vue是主工程、react是子工程。一定路由条件下，会在父工程中拉取子工程渲染。且主、子工程都通过weboack-dev-server启动，利用其热更新能力 由于子工程html是主工程通过fetch请求拉取后，再处理塞入主工程html中。因此在当前服务看来，相当于只有一个808…"}, {"id": "6993997283075293221", "title": "webpack5 入门02 缓存", "desc": "其实文档中缓存这个栏目和上一章代码分离太像，因为代码之所以要分离更多是也是因为浏览器性能和缓存，不然都装一个多方便，有些重复的内容。 主要有两个可以说的内容 01 然后外部引用后，直接编译 其实和 w"}, {"id": "6844903593997238285", "title": " Vue SPA项目 + Sentry 实现前端错误监控", "desc": "前端监控是相对于后端监控而言的，以往的后端监控只能记录接口被请求之后所发生的错误，但是现在随着用户复杂度不断提高，很多错误是在后端接口被请求以前就发生的JS错误。对于这种错误，传统的后端错误监控是无能为力的，因此前端监控应运而生。 最近想在公司的项目上部署前端监控，以主动捕捉用…"}, {"id": "6942517516769951752", "title": "webpack包教不包会（一）搭建一个react项目", "desc": "本篇主要目标是配置一个可以使用的react工作环境，支持：代码保存自动刷新、javascript代码自动兼容问题、一键压缩代码，静态资源处理、问题调试定位、支持less样式... entry是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解…"}, {"id": "6884912991859867662", "title": "webPack从零搭建react脚手架", "desc": "1、文件初始化1、安装依赖2、生成package.json文件3、package.json脚本配置5、根目录新建src目录，用于存放源文件，新建/src/index.js，内容任意6、试运行打包2、c"}, {"id": "6937829048332746788", "title": "Webpack 基石 tapable 揭秘", "desc": "Webpack 基于 tapable 构建了其复杂庞大的流程管理系统，基于 tapable 的架构不仅解耦了流程节点和流程的具体实现，还保证了 Webpack 强大的扩展能力；学习掌握tapable，有助于我们深入理解 Webpack。 个人觉得 tapable 是一个基于事件…"}, {"id": "6985340377351847944", "title": "Webpack - Tree Shaking", "desc": "1.什么是tree-shaking呢？ 字面意思 树摇 针对代码的话就是如果代码在我们项目中没有存在的必要 我们就可以通过treeshaking来减少项目体积 简洁度 加载速度更快 tree shak"}, {"id": "6996318573874380830", "title": "webpack性能优化", "desc": "构建速度 优化打包速度 babel-loader IgnorePlugin noParse happyPack parallelUglifyPlugin Dllplugin 自动刷新 热更新 产出代码"}, {"id": "6844904070956711943", "title": "2020年你不能不知道的webpack基本配置", "desc": "需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。 传统的html+css+js开发方式不能不能很好地运用less/scss等css预处理器以及ES6+的高级语法。 代码复用性差，可维护性差。 此时就需要一个处理这些问题的工具，webpac…"}, {"id": "6905364009969844232", "title": "Webpack 5.x 的十个踩坑记录", "desc": "1. webpack-dev-server 无法启动项目 2. 启动项目之后报错 3. devtool 4. 开启 hot: true 但是热更新无效 还需要注意一个问题：如果使用了 mini-css-extract-plugin 插件（将样式以 link 的形式引入而不是 s…"}, {"id": "6979858489451479047", "title": "前端渣渣阿宽带你正确入门学习 Webpack", "desc": "我曾想，该如何学习 Webpack，我上网去搜，很多教程，诸如 Webpack 傻瓜式指南、Webpack 入门体验、Webpack 花式入门教程，我都粗略看了一下，都不错，但没能找到属于自己学习之路"}, {"id": "6844903585948368903", "title": "Webpack4 那点儿东西", "desc": "近几年，构建对于前端开发来说是一个很重要的名词，它给前端开发注入了很大的活力，解放了很多生产力。而webpack在前端项目中起了不可小觑的作用，它可以将我们所用的各种浏览器不认识的代码比如es6，es7,sass,less等转换为浏览器认识的语言，可以对文件进行压缩合并，代码进…"}, {"id": "7000006188968443911", "title": "webpack 入门学习", "desc": "这是我参与8月更文挑战的第23天，活动详情查看：8月更文挑战 原始值： 1. 安装webpack npm install -g webpack npm install -g webpack-cli w"}, {"id": "6877123009555988493", "title": "webpack多页面项目开发按需编译", "desc": "使用 webpack 进行打包已经成为了不少项目的首要选择，在处理单页面的时候，一切都很ok，我们团队的成员只对一个页面负责，那么每次编译这个页面也就是必然的事情了。但是，如果团队正在开发的是多页面项目，那么如果只修改一个页面的话，就编译所有的页面，这就显得不是很合理了。 我们…"}, {"id": "6844903584899792909", "title": " Webpack + Vue，部署时减少包体积的几种方法", "desc": "作为一个做 SPA 起家的框架，Vue 的开发学习曲线较为平缓，相对来说，开发体验属于上乘。但不少初学者会发现，自己的站点，随随便便打包文件就有 10M ！难以置信，其实这跟 Vue 的性能没有太大关系，我们可以通过配置文件来大大改善这一情况。 它的作用是实现延迟加载，避免一次…"}, {"id": "6982859424813563941", "title": "vue cli4 几个常用打包优化技巧", "desc": "vue cli4常用打包技巧通用版。这篇文章主要介绍了，体积分析与剥离，打包文件压缩，打包去注释化，页面去掉预加载等几个常用技巧"}, {"id": "6971220402466979848", "title": "关于 loader 和 plugins ", "desc": "一、loader 1.loader 介绍 loader 是什么 loader 作用 loader 的执行是有顺序的，支持链式的调用。loader的执行顺序是从下到上，从右到左。比如处理样式类的文件，u"}, {"id": "6844903815074807822", "title": "Webpack4+Babel7+ES6兼容IE8", "desc": "前阵子重构了一个挺有意思的项目，是一个基于浏览器环境的数据采集sdk。公司各个产品的前端页面中都嵌入了这个sdk，用于采集用户的行为数据，上传到公司的大数据平台，为后续的运营决策分析提供数据支撑。 笔者接手这个项目的时候，前任开发者已经把功能都写差不多了。唯一需要做的就是做下模…"}, {"id": "6874968805542461453", "title": "webpack从基础配置到性能提升的进阶之路", "desc": "cli工程师，顾名思义就是使用现成的脚手架来实现开发。通过直接拉取现成的脚手架工程固然可以免去项目起始阶段的基础框架配置，便于开发人员快速入手开发，但作为一名合格的前端开发工程师，我们也要具备一定的搭建脚手架的基本能力，所谓知其然也要知其所以然，这也有利于我们日后对于项目进行性…"}, {"id": "6844903604067794958", "title": "Webpack4+ 多入口程序构建", "desc": "其实，说实话这篇文章的由来也是有很多的原因在里面的。在这之前，我也做过不少的项目。有新的项目，也有旧的项目。通过对旧项目的不断研究，改进。再结合自己的理解，将新的构建应用到新的项目中。经过时间的积累，慢慢的就有了一套感觉上还比较适合的webpack前端构建规范。 那这里来说说，…"}, {"id": "6844903933157048333", "title": "搞懂webpack热更新原理", "desc": "HMR即Hot Module Replacement是指当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。接下来将从使用到实现一版简易功能带领大家深入浅出HMR。 如上…"}, {"id": "6983188937283993607", "title": "浅析webpack基础篇", "desc": "为什么需要构建⼯具？ 转换 ES6 语法 转换 JSX 压缩混淆 图⽚压缩 为什么选择学习webpack？ 社区⽣态丰富 配置灵活和插件化扩展 官⽅更新迭代速度快"}, {"id": "6990531821662371871", "title": "DayNote(Webpack)", "desc": "-------------------个人学习笔记-----------------------------"}, {"id": "6882616889907150855", "title": "webpack5开箱体验", "desc": "如果您正在打包前端代码，很可能使用一个工具来实现。这个工具极有可能是Webpack。目前Webpack5已经处于beta阶段。 之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。 此次更新在第一次构建时会找到输出文件看是否有变化，从而决…"}, {"id": "6978656664929075208", "title": "Webpack 原理系列八：产物转译打包逻辑", "desc": "Webpack 构建流程最终站 —— 模块转译与打包逻辑，结合前文，一起学习 Webpack 核心原理。"}, {"id": "6844903830451126286", "title": "如何学习配置webpack(一） ", "desc": "自己配置过webpack的人应该都知道，webpack真的好复杂，一开始做项目都是拿别人现成的做做小修改，但是别人的终究没有自己配的舒服。所以我打算写这篇文章，从我的配置中带大家了解webpack配置，简化读webpack官方页面的复杂度。 在上面的示例中，我们通过 outpu…"}, {"id": "6844904047225339911", "title": "webpack 4 源码主流程分析（三）：编译前的准备", "desc": "该类主要对文件系统做了一些封装，包括输入，输出，缓存，监听等等，这些扩展后的方法全部挂载在 compiler 对象下。 在这里，会把 compiler 实例传进去供 plugin 使用，compiler 包含整个构建流程的全部钩子，通过它可以把控整个 webpack 构建周期。…"}, {"id": "6891649726656020493", "title": "webpack 中如何自定义loader", "desc": "webpack是一个打包模块化JavaScript的工具，它会从入口模块出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中。什么是loader"}, {"id": "6844904048206823431", "title": "如何在 vue2.0 中从 0 - 1 配置 webpack4.0", "desc": "最近掘金上关于webpack的文章像是开了挂一般，疯狂的产出量着实让人望洋兴叹。这不，我这麽懒的人也都来凑个热闹，嘿嘿（黑人头像）！ 先大概说下下来到底干神马。本文默认你已经看过webpack官方文档或者一些上手的文章资料，说实话这方面的优质文章太多了，作为一个前端菜鸟的我就不…"}, {"id": "6844903874889793549", "title": "Webpack 4 构建大型项目实践 / 处理图片、样式和字体", "desc": "上文使用 HtmlWebpackPlugin 生成了一个 index.html 文件，并且插件自动把打包后的资源添加到 index.html 文件中，使我们可以打开 index.html 在浏览器看到 js 的执行效果。本节我们将用 Webpack Loaders 来处理工作中…"}, {"id": "6974954058213752868", "title": "webpack —— 指纹策略", "desc": "从零开始了解webpack的指纹策略，来优化你的项目。 阅读了本文你可以学习到： 指纹策略有几种 指纹策略的使用场景、使用方法 什么时候要选用何种指纹策略更合适 构建项目 关于搭建一个webpack的"}, {"id": "6916440148892876807", "title": " webpack中img标签的src使用相对路径的方法", "desc": "webpack目前已经是大部分前端项目打包工具的首选，但是在使用的过程中还是存在一些问题。我们下面要讲到的就是常见的关于图片路径的问题。 在webpack项目中，如果要直接使用 img 的 src 属性来引用图片，由于webpack对html中图片的相对路径的处理方式的问题发现…"}, {"id": "6964785066354409508", "title": "Webpack核心Tapable从应用到源码之一(应用)", "desc": "Tapable 包是 Webpack 插件机制的核心，它暴露出很多 Hook 供插件使用......"}, {"id": "6924483359271813133", "title": "[webpack学习]梳理一下sourcemap的知识点", "desc": "在生产环境和开发环境下，经过webpack打包的代码在运行发生错误时，控制台报出的错误信息让人很难定位。如下： 则同样的代码以及同样的抛出错误，控制台报出的信息会更详细。如下： 为什么运行的是已经打包压缩后的代码，然而在输出报错时可以精准定位到开发代码。其中是借助sourcem…"}, {"id": "6876710857825484814", "title": "前端不一样的国际化方案", "desc": "关于怎么实现国际化，现在主流的方案有很多，比如基于三大框架的： Vue - Vue-i18n，React - react-intl、react-i18next，Angular - angular-translate。还有像阿里开源的 kiwi 国际化全流程解决方案等......…"}, {"id": "6844903549864787975", "title": "webpack v3 结合 react-router v4 做 dynamic import — 按需加载（懒加载)", "desc": "dynamic import不知道为什么有很多叫法，什么按需加载，懒加载，Code Splitting，代码分页等。 总之，就是在SPA，把JS代码分成N个页面份数的文件，不在用户刚进来就全部引入，而是等用户跳转路由的时候，再加载对应的JS文件。 这样做的好处就是加速首屏显示速…"}, {"id": "6844903834255360007", "title": "从0实现一个webpack loader", "desc": "可以看出loader在webpack打包的过程中起到了至关重要的作用。 由于webpack是基于Node的所以webpack只能识别.js文件，所以针对其他的文件就需要转译，这时候就需要用到我们的loader了。 loader是文件加载器，能够加载资源文件，并对这些文件进行特定…"}, {"id": "6844903647680135182", "title": "开箱即用的多页面webpack脚手架", "desc": "最近接手一个新项目，公司官网，官网为了对爬虫友好，不合适做单页面，更不大适合用react，vue这样的框架。本来觉得几个简单的页面还需要配置webpack挺麻烦，直接ES5，css，html写写就ok，可是一旦下手开始写，离开了前端的各种得心应手的工具，回到了刀耕火种的时代。痛…"}, {"id": "6844904122253377550", "title": "关于Webpack中Loader与Plugin的实践", "desc": "相信大家对webpack也有一定的了解，其实深入浅出webpack这本书也看了很多遍，每一次看都会有一些细节之前没有注意到，我觉得其实可以把它当成是一本工具书来看，之前我也是只看配置都有点让你看不过来，更别说其他的了。 所以今天我就说一下如何编写一个loader与plugin，…"}, {"id": "6978866957160284173", "title": "webpack概念", "desc": "webpack 概念 本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序"}, {"id": "6844903858825609230", "title": "从零实现一个 Webpack Loader", "desc": "Loader 是 Webpack 几大重要的模块之一。当你需要加载资源，就需要设置对应的 Loader，这样就可以对其源代码进行转换。 由于 Webpack 社区的繁荣，使得大部分的业务场景所使用的资源都有对用的 loader，可以参考官网的 available loaders…"}, {"id": "6844903617292402701", "title": "初见React，一步一个坑", "desc": "说在前头：新入职公司，react还不是很熟悉，就开始了官网重构的项目，刚开始开发速度很慢，而且语法也很多不规范的地方，在这里总结一下开发中遇到的坑。 这样就会使NPM包里的文件正常加载了。 原来这些都是打包后的文件！为了使打包后的样式生效，需要使用extract-text-we…"}, {"id": "6915659846335332360", "title": "webpack搭建React项目（8）", "desc": "还有一个需要注意的点是对于 antd 的less，les-loader需要额外配置javascriptEnabled: true这个配置项，如果出现像下面这样的错误，就说明没配置正确。并且less-loader的v5版本和v6+版本以后的配置方式也不一样，v5版本是直接在opt…"}, {"id": "6844903566671347719", "title": "组件库webpack构建速度优化经验总结", "desc": "在公司的主要工作是组件库（基于vue的ui组件库，类似element-ui）的开发，也已经有两个多月，期间一直觉得项目的开发构建太慢，每次开发打开开发环境需要 40s 左右，简直不能忍。前前后后尝试了各种优化手段，但是都不理想。终于在今天，找到了问题所在，构建速度提升了 50%…"}, {"id": "6844903753233989645", "title": "【React v16.6 新特性】使用 React.Suspense 替换 react-loadable", "desc": "当前大部分 React 应用需要使用 code splitting 的时候，都选择使用优秀的 react-loadable 来处理检测代码段是否已加载。然而，随着React v16.6 的发布，我们有一个非常难得的机会 ，可以删除我们的第三方依赖！ React.Suspense"}, {"id": "6844903966912806919", "title": "从零配置webpack 4+react脚手架（四）", "desc": "outputPath是输出到dist目录下的路径，即dist/images/... ； 接下来就是测试下可以不可以用了，在 src 目录下新建一个文件夹： images ，并导入一个图片文件，名为 background.png ，图片文件点我下载。 执行 npm run bui…"}, {"id": "6844903619184033800", "title": "分析vue-cli@2.9.3 搭建的webpack项目工程", "desc": "项目放在笔者的github上，分析vue-cli@2.9.3 搭建的webpack项目工程。方便大家克隆下载，或者在线查看。同时也求个star ^_^，也是对笔者的一种鼓励和支持。 如果对webpack还不是很了解，可以查看webpack官方文档中的概念，虽然是最新版本的，但概…"}, {"id": "6968519671335419935", "title": "手把手带你搭建一个简单的webpack脚手架（二）", "desc": "Plugin插件 在webpack的整个处理流程中，loader让webpack可以处理更多的文件资源。而plugin则存在于webpack整个打包流程中。可以在webpack暴露出的hook触发的时"}, {"id": "6844903520265568263", "title": "Webpack3.0小案例躺坑资源处理、服务器启动和打包优化", "desc": "图片处理 ， 包括file-loader、url-loader、image-webpack-loader的用法，file-loader和url-loader的区别等。 服务端启动webpack-dev-server ，包括手动搭建测试服务端以及运用webpack建立webpac…"}, {"id": "6945812674609414158", "title": "什么才是一个让人舒服的js库", "desc": "封装一个js库其实没有想象中的那么困难，常见时间格式化，发个npm仓库，搞个cdn，引入就能正常使用。 随着诉求的复杂性，往往就不是我们想象的那么简单了，就算代码上面把功能封装得很全面依然会存在真正业务上面不能满足的场景。 例如公司业务上面希望封装通用axios的请求库，同时给…"}, {"id": "6906760333784793102", "title": "webpack源码之旅", "desc": "前言    webpack是目前常用的模块打包构建工具，因为之前对webpack配置优化也比较了解，最近顺着思路debug了一下源码，当然过程很痛苦不过也在看过各个大佬文章也算是对大体一知半解，所以来"}, {"id": "6844903656785969159", "title": "Vue 项目升级到 webpack4.x 小纪【附代码】", "desc": "自 webpack 4.x 发布以来，就独得码农恩宠。我公司的项目是基于 webpack 3.x 版本的 vue 项目， 替换它，于是开始了折磨人的升级过程。 现将自己的升级过程记录如下，希望能给需要升级 vue 项目的朋友一点参考价值。 由于要升级的包很多，一个个操作起来麻烦…"}, {"id": "6884866016565084173", "title": "如何编写一个 Webpack Plugin", "desc": "上次写了 如何编写一个 Webpack Loader，今天来说说如何编写一个 Webpack Plugin。 将命令行参数与 webpack 配置文件 合并、解析得到参数对象。 参数对象传给 webpack 执行得到 Compiler 对象。 执行 Compiler 的 run…"}, {"id": "6844903764512473096", "title": "精读《如何编译前端项目与组件》", "desc": "通过 webpack / parcel / gulp 构建项目。 通过 parcel / gulp / babel 构建组件。 如果你喜欢零配置的 parcel，那么项目和组件都可以拿它来编译。 如果你业务比较复杂，需要使用 webpack 做深度定制，那么常见组合是：项目 -…"}, {"id": "6844903855822471175", "title": "9102了，快来了解webpack4！", "desc": "在当今的前端开发中，我们使用的打包工具可能会有很多种，当然webpack就是其中一种，那么webpack中的配置实际上是很多的，所以今天来整理下常用的配置以及它的作用。 我们就可以使用npm install webpack@4.16.5 -D安装指定版本的webpack了。 那…"}, {"id": "6844904186224590855", "title": "webpack  Code Splitting详解", "desc": "将一个文件分割成多个文件：因为浏览器会缓存你的代码，每当你对某一文件做点改变，访问你站点的人们就要重新下载它，包括依赖。如果你将（这些依赖）分离成单独的文件，访问者就无需多次重复下载它们了。 使用webpack生成一个或多个包含你源代码最终版本的“打包好的文件”（bundles…"}, {"id": "6844903544521228296", "title": "看清楚真正的 Webpack 插件", "desc": "什么是 webpack？ webpack 能干什么？ webpack 怎么用？ 太多的入门教程了，一搜一大把，不再说了，而且 webpack 的官方文档应该是文档届的标杆了，太详细了，由浅入深，从玩具类型的初级 Level，到深度优化的生产环境下产品级别的高级 Level 都讲…"}, {"id": "6920408465387356174", "title": "从零开始搭建一个webpack+react项目", "desc": "执行 npm init 创建一个符合node规范的项目，创建之后会成一个package.json项目。 执行 npm i react react-dom 安装 react 和 react-dom 。 项目中有.tsx文件，所以要安装loader 进行处理：执行 npm inst…"}, {"id": "6844904037624578061", "title": "Webpack 核心库 Tapable 的使用与原理解析", "desc": "前言中的“...都是 Tapable 的实例”改为“...都是 Tapable 的子类”。 修正并行写成串行的错误。 Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 Tapable，Webpack 中最核心的负责编译的 Co…"}, {"id": "6844903519057625102", "title": "Vue 2.0重构G买卖项目经验分享", "desc": "G买卖H5是运行在多端的游戏交易平台。基于产品层面的功能升级以及提高开发效率的需求，前段时间我用Vue和Webpack对项目进行了一次渐进式的重构。所谓渐进式，即每个周期仅对部分页面进行改造，不影响其他业务的开展。这次我改造的是我买到的/我卖出的订单列表以及订单详情。 这次重构…"}, {"id": "6862609111633264653", "title": "webpack 输出打包信息源码分析", "desc": "最近打算写一款webpack压缩图片的插件，但是需要数据对比，原始数据和压缩后的数据以及压缩的比例相关信息，于是想到了webpack打包的时候不就有相关的输出嘛，于是查看了一下webpack是怎么输出信息的。 首先在webpack官网看到所有输出的相关信息全部有stats来管理…"}, {"id": "6844903699639189517", "title": "vue-split-table【表格合并和编辑插件】", "desc": "vue-split-table开源地址,欢迎star,现在已经开源和同步到npm上轻松搞定表格拆分或者合并,编辑,再也不怕被产品怼啦1.核心源码分析里面嵌套实现表格拆分;原生实现复选框的单选和全选功能"}, {"id": "6844904147582631944", "title": "vue项目升级踩坑", "desc": "As of v7.0.0-beta.55, we've removed Babel's Stage presets. for more details. TL;DR is that it's more beneficial in the long run to explicit…"}, {"id": "6844903832980324360", "title": "让prerender-spa-plugin支持cdn域名的几种尝试", "desc": "react、vue等前端spa框架应用到2c网站的问题之一是较长的白屏时间和不支持seo，prerender是解决这些问题的方案之一。在实践中我也比较推荐这种方式，其开发成本和维护难度都比server side render（SSR）低很多，性价比突出。 通常采用的这个webp…"}, {"id": "6844903504755048455", "title": "Vuejs渡劫系列二：最全的vue-cli项目下的配置简析", "desc": "Vuejs渡劫系列的第二篇文章，建立在有扎实的Vuejs和webpack基础知识前提下，通过vue-cli脚手架快速搭建项目，该文章会一一梳理项目下的文件配置和用途。"}, {"id": "6915656442930266119", "title": "webpack搭建React项目（3）", "desc": "上篇文章简单介绍了以下webpack内部WDS的使用，这节讨论一下WDS内部proxy的配置方式。 webpack-devServer，一般简称WDS，是 webpack 内置的用于开发环境的服务器配置。webpack本身提供三种方式用于开发环境修改代码以后自动编译，以提高开发…"}, {"id": "6844904033434468359", "title": "基于webpack的应用治理", "desc": "我们的治理方向，就是围绕前向治理和后向治理。 数据先行，通过speed-measure-webpack-plugin采集性能指标，可以得到webpack在整个编译过程中在loader、plugin上花费的时间，基于该数据可以专项的进行优化和治理。 如果通过SMP分析得知在loa…"}, {"id": "6951344306590318599", "title": "webpack5升级笔记", "desc": "前言webpack5主要更新可以看这里webpack5发布.主要问题在webpack5更新文档中都可以找到相应的解决方案.这里主要记录webpack4升级到webpack5过程中一些插件升级遇到的问题"}, {"id": "6844903504352378894", "title": "如何开发webpack loader", "desc": "作为近段时间风头正盛的打包工具，webpack基本占领了前端圈。相信你都不好意思说不知道webpack。 有兴趣的同学可以参考下我很早之前的webpack简介 . 确实webpack万事万物皆模块的思路真是极大的方便了我们的开发，将css，图片等文件都能打包的功能离不开形形色色…"}, {"id": "6844903828844707848", "title": "Webpack多页应用HMR卡住问题", "desc": "在公司搭建了套webpack多页面应用脚手架，开始用着很爽，解决了既想使用Vue的模块化开发，又想做多页打包上线管理的初衷，但是随着业务项目的增加，我发现npm run dev的时候，每次热加载，webpack的反应都很慢。 准备具体定位一下问题的原因。由于项目基于vue-cl…"}, {"id": "6844903585906425869", "title": "webpack loader的\"套路\"", "desc": "loader是一个函数，用来把文件转换成webpack识别的模块。 this.callback，一个可以同步或者异步调用的可以返回多个结果的函数。 当使用一个loader时，这个loader函数只有一个参数，参数是包含文件内容的字符串。 当配置多个loader时，loader的…"}, {"id": "6844903972050829326", "title": "webpack 4 源码主流程分析（十二）：打包后文件解析", "desc": "以 前言及总流程概览 里的 demo 为例， 前十一张章分析了打包过程，现在来分析它打包后的文件。 @fe_korey/test-loader 是一个测试 loader，该 loader 作用为代码里的字符串 10000 替换为传入的 number。 入口文件，该文件名根据配置…"}, {"id": "6844903609180635143", "title": "从0开始发布一个无依赖、高质量的npm", "desc": "没有发布过npm包的同学，可能会对NPM对开发有一种蜜汁敬畏，觉得这是一个很高大上的东西。甚至有次面试，面试官问我有没有发过npm包，当时只用过还没写过，我想应该挺难的，就小声说了没有，然后就让我回去了o(╯□╰)o。 其实，在现在的我看来，npm包就是一个我们平时经常写的一个…"}, {"id": "6867821334806675464", "title": "【webpack系列】webpack构建速度和体积优化策略", "desc": "1. 初级分析：使用webpack内置的stats 缺点：颗粒度太粗，看不出问题所在。 2. 速度分析：使用speed-measure-webpack-plugin 分析整体打包的总耗时，以及每个loader和插件的执行耗时情况。 3. 体积分析：使用webpack-bundl…"}, {"id": "6844903584836878350", "title": "create-react-app 配置scss,ant-design，装饰器，代理，node支持最新语法，express es6 后端，链接mongodb", "desc": "之后就ok了。你引入一个ant的组件试试就知道了"}, {"id": "6844903637534130183", "title": "【译】使用 Webpack 和 Poi 构建更好的 JavaScript 应用", "desc": "Webpack 是一个将你所有的 JavaScript 文件，图片、字库以及 CSS 等打包到一个依赖关系图的构建工具。这使得你可以在源码中使用 require() 来引用本地文件并且决定在最终的 JavaScript 包中如何处理这些本地文件代码。 Poi 是一个零配置的基于…"}, {"id": "6844903624548548622", "title": "记一次 React 项目的优化（webpack4 插件的使用）", "desc": "这里记录了自己在开发一个 React 项目时使用 Webpack 优化项目的过程，欢迎大家围观点赞或吐槽。 学习 React 时候，写了个个人博客站点。使用 webpack 作为打包工具，在这之前学习 webpack 时候，知道 webpack 有插件可以做资源压缩、抽离，以达…"}, {"id": "6879385830637436935", "title": "Webpack的核心概念-entry、output与sourceMap", "desc": "这样一个场景，打包完的index.html文件会给后端，作为网页入口文件，而那些js文件会上传到CDN中，网页加载的时候再拉下来。 2. sourceMap的配置 sourceMap其实是描述的一种映射关系（基于map文件），当你的代码出错的时候，不打开sourceMap的话出…"}, {"id": "6883777814508601351", "title": "Vue 多入口配置 ——Webpack3.6", "desc": "前段时间业务那边提出要求，要把项目里面的某个模块独立出来（要求有单独的登录入口）。重新建一个新项目显然是不现实的，这个模块用到了很多项目里面的公用组件，就算是搬运也十分繁琐。而且又需要重新做权限控制（菜单和按钮后端分配的）... 最后就想到了。多入口这个解决方案。可以说是完美的…"}, {"id": "6844903700230569992", "title": "显微镜下的webpack4：路径操作", "desc": "对于打包工具来说，最简单也是最复杂的操作莫过于路径的安排了，原本都在src下的资源，想要打包到dist目录下，但是打包出来的文件路径甚不如人意。明明想要分门别类地放置文件文件，然后却像大杂烩一样js,html，css甚至图片都混在了一起。虽然打包之后运行没什么问题，但是这是要逼…"}, {"id": "6844903593200320525", "title": "webpack 知识梳理", "desc": "通俗的讲，webpack 是一个代码加工机器，我们把自己的代码丢给他，它经过加工之后再还给我们。 webpack 还可以为我们提供前端静态服务，极大地方便了我们日常的开发调试。 综上，我们之所以使用 webpack ，主要是为了提高开发效率，优化自身代码。 当我们把自身代码交给…"}, {"id": "6916919296098566157", "title": "Webpack的loader原理和实现", "desc": "上一篇文章中，我们讲到了webpack的执行原理Webpack5的打包分析，这篇文章我们讲解一下webpack是如何处理一些非js文件的内容的。本系列一共分为三篇 url-loader包括file-loader, 图片必须转换成二进制之后才可以进行处理**loader.raw …"}, {"id": "6930133123325755400", "title": "webpack打包源码-打包后文件分析", "desc": "具体功能函数解读下回分解...."}, {"id": "6978730215316914189", "title": "零基础学习Webpack—01(Webpack的五个核心概念)", "desc": "这是我参与更文挑战的第26天，活动详情查看：更文挑战 Webpack是什么？ 举例 引出构建工具 在上面的例子中，很多文件中的语法浏览器并不能识别，需要将这些文件中的语法转换为浏览器能够识别的语法。因"}, {"id": "6844903689904193544", "title": "造一个「轮子」musionUI", "desc": "先放上musionUI的代码仓库：musionUI。现在代码尚未写完，大概只完成了30%，持续更新中... 全部代码完成之后会写简单的说明文档。 尚未完成的：无缝轮播、Dialog、Notification通知、响应式导航条、分页、表单验证、Table、图片上传、Sticky、…"}, {"id": "6844904090632192014", "title": "mina-loader 源码浅析", "desc": "团队最近需要对小程序进行工程化升级，在网上看了《小程序工程化实践》一文收获满满，刚好文章中提到的 mina-webpack 也是我们团队正在使用的工具。mina-webpack 是 tinaJS 配套的工程化工具。（有关 tinaJS源码在我的另一篇文章有讲述）mina-web…"}, {"id": "6844903843109552136", "title": "7中方式来减少webpack bundle体积", "desc": "该方式对于开发者模式是很有必要的。该模式会自动将剔除空格、新的行，还有没有用到的代码。并且该模式下会将一些公共库例如React的调试代码排除在外。 在进行项目打包的时候，针对webpack使用-p的标签同时--mode production。 如果在项目中使用了lodash.j…"}, {"id": "6973901697512914951", "title": "webpack小记(二) — webpack文件资源打包&常用插件", "desc": "文件资源打包 webpack依赖树 当我们使用webpack对资源进行打包时，默认只会将入口文件进行打包 webpack中存在着一个重要的概念：依赖树 依赖树 是指以入口文件为根节点 通过import"}, {"id": "6844903553090191374", "title": "如何使用expose-loader 解决第三方库的插件依赖问题", "desc": "expose 寓意为：暴露，就是为了解决一些插件不支持commonJs引入的问题（如:bootstrap.js，它只允许jQuery暴露为全局变量才可用）"}, {"id": "6844903710888329229", "title": "还在为部署Vue SSR烦恼？Koa-vuessr-middlware 了解一下", "desc": "前言最近在写一个新应用时，想用Koa结合VueSSR，同时写Api接口和页面，于是开始上手写，结果发现需要写的东西很多，参考的大多数例子都用的是十分类似的代码（好像大多都是基于尤大大的hackerne"}, {"id": "6844904054187884557", "title": "前端工程化之webpack核心功能", "desc": "在前端工程化对世界中，掌握webpack配置基本是我们每个前端工程师需要掌握的，在vue/react/angular发展初期，他们但脚手架还不够完善，许多但配置都需要开发者自己来，但随着脚手架工具但完善，项目但整体架构已无需开发人员考虑太多，所以现在许多新入行的前端开发者会觉得…"}, {"id": "6844903570433638414", "title": "JavaScript中使用import 和require打包后实现原理", "desc": "创建文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。接下来我们再创建…"}, {"id": "6973650203035303944", "title": "一分钟快速了解和上手webpack打包工具", "desc": "webpack Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 #安装webpack 需要nodejs环境，node"}, {"id": "6844903633474060296", "title": "如果你也想写个完整的 Vue 组件项目", "desc": "其实上面的除了文档都比较容易做到，除了可能会在构建上踩坑外。那么做到了这些可以上线了吗？是的。不过看一些优秀的库其实还可以做更多的，例如下面的这些： 2.那么，有没有..."}, {"id": "6844903584929169415", "title": "写一个babel插件实现按需打包的功能", "desc": "在Webpack中，提供了mode变量，用于配置运行环境，mode的值可以为development，表示的是开发模式，或者是production，表示的是生产模式。 看到这样打包后的代码，我们发现这种方式引入 打包后的大小是。21.3k 在创建替换逻辑的时候，types上的方法…"}, {"id": "6844903629686571016", "title": "webpack结合reactjs、vuejs项目中图片处理", "desc": "这篇文章主要整理一下自己在使用 webpack 结合 vuejs 或 reactjs 开发过程中图片的处理方法。 项目打包之后（假定输出目录为 dist），除了 index.html，将所有的静态资源上传至 cdn，而并非打包之后所有静态资源都在应用服务器上。 不适合我。 它会…"}, {"id": "6844903839561154568", "title": "【温故】前端工程化思考与实践", "desc": "随着业务不断发展，产品规模不断壮大。越来越多应用建立起立，业务逻辑各有不同且日趋复杂，团队人员越发庞大，代码维护成本越来越高。 不断实践并不断思考，前端开发其实就是要推动前端工程化。 实际开发中却经常遇到第三方包报错，有时候我们可以通过 rm -rf node_modules …"}, {"id": "6844904176925802509", "title": "2020 祝安，缝隙中寻找机遇：面试题第二波：Git&Webpack", "desc": "非常感谢，前同事行长@onlyadaydreamer分享的面经。 先说一下，webpack 5.x 都有了。还要纠结还做个吗？ 不过貌似改动不大，4.x的还是主流"}, {"id": "6844903725077626894", "title": "浅谈 记一次 import 打包 印象误区", "desc": "今天写项目看到一个问题很有意思。先抛出一个问题，哪个写法性能高？ 这个问题对于没有深刻了解过 webpack 打包原理机制的我来说还真的有点迷了。所以决定这段时间去好好研究一波。 在development 模式下 我们看到 第一种 和 第二种 写法 打包出来 完全一样.至于第三…"}, {"id": "6844903557401952263", "title": "浅谈Webpack的AMD插件开发和运行机制", "desc": "在写webpack的插件时，内部必须要实现一个apply方法，传入compiler参数，就可以通过调用plugin方法，在对应的事件钩子订阅事件，然后取出源码进行自定义开发后，return回去即可。 这是因为webpack的内部机制是通过tapable来实现的，通过plugin…"}, {"id": "6844903897744556039", "title": "19-webpack 加载图片优化", "desc": "通过 url-loader 将小文件转换成 base64 URIs 内联到 bundle.js 中，可以减少 HTTP 请求次数。 输出的资源只有一张 51Kib 的图片，22Kib 的图片被转换成 base64 Uris 字符串内联到 bundle.js 中去了。 在Chro…"}, {"id": "6844904006175703048", "title": "浏览器模块化之路（一），了解一下？", "desc": "从amd cmd 到 (commonjs), 再到浏览器支持模块化es6。 让浏览器支持，这几个环境变量。我们来定义这几个变量。 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.ex…"}, {"id": "6844903734703554574", "title": "借助 Webpack 静态分析能力实现代码动态加载", "desc": "对策是要基于原因的，不是基于现象的。 最后从 Webpack 的角度利用静态代码分析的能力来解决问题。 用了 require.ensure 这种方式来异步加载代码，代码执行到这一段的时候才去拉 JS，所以会出现比 ajax 还慢的情况，它是异步的。直接阻塞了后面 new Wor…"}, {"id": "6943489702251429925", "title": "从零配置webpack 5 + React脚手架（三）", "desc": "url-loader 功能类似于 file-loader, 但是在文件大小（单位为字节）低于指定的限制时，可以返回一个 DataURL。 limit: 8192，指定文件的最大体积（以字节为单位）。 如果文件体积等于或大于限制，默认情况下将使用 file-loader 并将所有…"}, {"id": "6844904047237922829", "title": "webpack 4 源码主流程分析（十一）：文件的生成", "desc": "回到 seal。执行： 得到 this.fileDependencies, this.contextDependencies, this.missingDependencies 后，触发了一系列处理资源，优化资源的钩子之后，回到 Compiler.js 的 compile 里的…"}, {"id": "6926132531616022536", "title": "一步步使用Webpack5", "desc": "webpack5几天一版，使用新版的webpack会使你的代码打包更快，更小。下面就介绍一下，webpack5的使用：1.安装初始化package.json安装webpack然后新建public文件夹"}, {"id": "6844903905415921672", "title": "前端webpack构建优化", "desc": "从上面的实验数据可以得出：无论是本地构建还是打包dist，eslint-loader，vue-loader，babel-loader的happypack对编辑速度都是有提升的。 cacheDirectory开启缓存，include去除无需处理文件。 因为默认设置是[node m…"}, {"id": "6953355406139719717", "title": "就自己搬砖经验谈一谈webpack", "desc": "聊webpack之前，先来聊一聊前端模块化这个概念 1.前端模块化 为什么需要前端模块化： 命名空间的问题，由于没有模块化，那么代码中的变量名、方法名在不知情的情况下很容易被使用者给覆盖，容易造成问题"}, {"id": "6844903568370040845", "title": "【译】Google出品 – 利用 Webpack 做 web 性能优化", "desc": "现代 Web 应用经常用到bunding tool来创建生产环境的打包文件（例如脚本、样式等），打包文件是需要优化并压缩最小化，同时能够被让用户更快地下载到。在这篇文章中，我们将会利用webpack来贯穿说明如何优化网站资源。这样可以帮助用户更快地加载你的应用同时获得更好的体验…"}, {"id": "6844903677866541070", "title": "基于webpack4[.3+]构建可预测的持久化缓存方案", "desc": "web缓存的好处不用多说，自从webpack一桶江湖后，如何做Predictable long term caching with Webpack让配置工程师们头疼不已。 webpack4.3前，有相当多的文章介绍如何处理（见参考），这里想做些更到位的探索。 使用HashedM…"}, {"id": "6844903925712158728", "title": "基于webpack4.0构建完整项目", "desc": "执行结果可以看到 把 src 文件夹下的 index.js 文件打包到 dist 文件下的 bundle.js，这时就生成了 bundle.js 供 index.html 文件引用。那么打开index.html就可以看到完整的页面效果了 此时，基本的项目配置已经准备完成，只需要…"}, {"id": "6844903598304788488", "title": "前端构建工具发展及其比较", "desc": "我们一定会感叹前端技术发展之快，各种可以提高开发效率的新思想和框架层出不穷。但是他们都有一个共同特点：源代码无法直接运行，必须通过转换后才能正常运行。 构建工具就是做这件事，将源代码转换成可以执行的JavaScript、CSS、HTML 代码，包括如下内容…"}, {"id": "6844903510165684237", "title": "搭建 vue2 vue-router2 webpack3 多入口工程", "desc": "通过两个具体场景来介绍如何配置多入口工程"}, {"id": "6844904201688989709", "title": "理解webpack中SplitChunksPlugin的作用", "desc": "-- chunk理解为“代码块”，例如node_module下的module，或者你自己import入页面的自定义js。 Originally, chunks (and modules imported inside them) were connected by a pare…"}, {"id": "6844903519703547911", "title": "说说 ParcelJS", "desc": "看到 ParcelJS 还是眼前一亮的。 新建 index.html、index.js 和 index.css，然后 parcel index.html，就能拿到可运行的 html、js 和 css 组合。html 可以作为入口正是我期望的，这让前端开发回归到本来的状态，很舒服…"}, {"id": "6844903533452476429", "title": "原生js系列之无限循环轮播组件", "desc": "在上一篇文章中，我们封装了一个DOM库（qnode），为了让大家直观地感受到其方便友好的自定义工厂模式，于是给大家带来了这篇文章。 没有看过上一篇文章的话，可以在这里找到：原生js系列之DOM工厂模式。 那么这篇文章，我们将基于上述的qnode，从头开始写一个无限循环轮播图的组…"}, {"id": "6844903589425446925", "title": "[WebAssembly 入门] 与 Webpack 联动", "desc": "常规的进行rust代码编写再手动编译为wasm文件是十分缓慢的，目前有几种解决方案，接下来我将基于webpack来提升WebAssembly的编写效率。 如果 buffer的大小超过了 4KB，WebAssembly.Instance 在主线程中不被允许使用。需要使用WebAs…"}, {"id": "6941924227444375589", "title": "Webpack Sourcemap 回顾", "desc": "前几天在优化项目时，发现next.config.js的配置里，development 模式下的 sourcemap 为cheap-module-sourcemap，仔细想了想，记忆中好像有个更推荐常用的开发模式 sourcemap 配置：cheap-module-eval-so…"}, {"id": "6844903954287951879", "title": "带你看懂 HMR 热更新原理", "desc": "在研究 HMR 的过程中，通过 Chrome 的开发者工具，我知道浏览器是通过 websocket 和 webpack-dev-server 进行通信的，但是我在 websocket 中并没有发现任何代码块。那么新的代码块是怎么跑到浏览器的呢？这个 websocket 又有什么…"}, {"id": "6962413106823692318", "title": "【译】使用 Webpack 拆包的 100% 正确的做法", "desc": "使用 Webpack 拆包的 100% 正确的做法。本文翻译自 The 100% correct way to split your chunks with Webpack。"}, {"id": "6844903689912598535", "title": "显微镜下的webpack4入门", "desc": "前端的构建打包工具很多，比如grunt，gulp。相信这两者大家应该是耳熟能详的，上手相对简单，而且所需手敲的代码都是比较简单的。然后webpack的出现，让这两者打包工具都有点失宠了。webpack比起前两者打包工具，对于前端程序员JS编程能力的要求还是挺高的。不过需要兼容i…"}, {"id": "6844903895022436360", "title": "从零认识webpack4.0，带你走进神秘的webpack", "desc": "前言： 作为一个现代javascript 应用程序的静态模块打包器，webpack能将各种资源，如js，css， 图片等作为模块来处理，是当下前端工程化的一个很受欢迎的工具，webpack目前最新的版本是4.0，文章将在4.0 的基础上，从使用者的角度，一步步教你认识并搭建一个…"}, {"id": "6844903877775458312", "title": "Webpack生成文件分析", "desc": "比如使用一个函数，我们需要关注它的输入和输出，就可以很好的使用它。如果想更好的理解这个函数，就需要看看它内部的实现。 同样，使用Webpack，我们也需要关注它的输入和输出。 初学Webpack，我们一般都先了解输入，（源码和配置可以理解成Webpack的输入），但是不太了解输…"}, {"id": "6844903608157208590", "title": "pwa+webpack，初探与踩坑", "desc": "我们都知道pwa是一个新技术.，依靠缓存，离线了还能正常跑，而且秒开。我把以前原生写的小游戏迁移到react，再迁移到webpack+react，最后再升级到pwa。具体介绍不多说，我们开始撸吧。 webpack攻略有很多，不啰嗦了，简单介绍一些重点。记住几个点：入口entry…"}, {"id": "6844903590901841928", "title": "借助webpack对项目进行分析优化", "desc": "由于项目过于庞大，老旧。目前项目包含了打包过慢，冗余文件过多等诸多问题。文章中会一步步介绍我是如何通过webpack进行分析，定位并解决这几点问题的。告别刀耕火种，向坏代码说再见！"}, {"id": "6957994597733629989", "title": "webpack入门", "desc": "开淦! 一、webpack 1.1 webpack的作用 官网中给了解释： 打包所有的样式 打包所有的资源 打包所有的脚本 打包所有的图片 打包所有的样式表 浏览器能解析的是js、css、和一些静态资"}, {"id": "6844903517027565575", "title": "webpack 应用编译优化之路", "desc": "现在越来越多的项目都使用 ES2015+ 开发，并且搭配 webpack + babel 作为工程化基础，并通过 NPM 去加载第三方依赖库。同时为了达到代码复用的目的，我们会把一些自己开发的组件库或者是 JSSDK 抽成独立的仓库维护，并通过 NPM 去加载。"}, {"id": "6879384998139396103", "title": "Webpack的核心概念-loader与plugin", "desc": "1. Webpack的loader Loader就是一种打包方案，对于某一种类型文件他知道如何打包，帮助webpack完成打包工作。 上述其实就是制定了一个规则，告诉webpack遇到以.jpg结尾的文件时候使用file-loader去处理。 这样重新npm run bundl…"}, {"id": "6935709523961184292", "title": "Webpack 常用知识储备及优化", "desc": "1. 防止打包后出现缓存文件？ 2. 怎么配置本地服务和proxy 代理？ 3. 合并配置文件 4. 多入口打包 5. webpack 插件 6. 常用的 loader 7. Loader 和 Plugin 的不同 Loader 是转换器。webpack 只能解析 JS 文件，…"}, {"id": "6844903760096034824", "title": "webpack打包性能优化之路", "desc": "性能优化的路没有穷尽，只有更快。打开页面越快越好，点击响应越快越好。在当今这个以快为主的时代，快才是王道。闲话扯完，说正事！！！ 该优化方案以最近做的一个hybrid webapp为实例演示。 （1）vue-router文件中的router使用懒加载方式。如下图所示 所有现代浏…"}, {"id": "6844904016493674509", "title": "Webpack4那点事", "desc": "在全局创建webpack.config.js或webpackfile.js文件。(本文以webpack.config.js为例) 上文打包之后我们发现现在打包出两个js文件一个html文件中引用了两个js文件，那如果我们想分别引用呢？怎么处理？对的，再new一次html-web…"}, {"id": "6847902224757194765", "title": "教你如何定量分析前端主流的构建工具(Webpack/Rollup/Parcel/Browserify+Gulp)？", "desc": "周日在家看 web.dev 的 2020 三天 live，发现不少有意思的东西，其中有一项是关于 building tool 的，也就是我们常说的前端构建工具，当天的主播是 Jake Archibald（chrome team 成员，个人非常喜欢的技术专家）。 这篇简单的推文引…"}, {"id": "6945274619087552520", "title": "webpack 基础配置指南", "desc": "Entry：指示以哪个入口起点开始打包，分析构建内部依赖图。 Plugins：插件范围更广的任务。打包优化、压缩、重新定义环境中的变量等。 入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) …"}, {"id": "6945096775367655431", "title": "webpack之devServer.publicPath、output.publicPath快速理解 | 小册免费学", "desc": "随着 vue-cli 等脚手架工具对webpack的集成度越来越高，竟然项目都做完了还浑然不知自己对于打包进行了哪些配置和优化。"}, {"id": "6844903598292205576", "title": "[译] 优化 WEBPACK 以更快地构建 REACT", "desc": "如果您的 Webpack 构建缓慢且有大量的库 —— 别担心，有一种方法可以提高增量构建的速度！Webpack 的 DLLPlugin 允许您将所有的依赖项构建到一个文件中。这是一个取代分块的很好选择。该文件稍后将由您的主 Webpack 配置，甚至可以在共享同一组依赖项的其他…"}, {"id": "6844903598099267598", "title": "react内联样式使用webpack将px转rem", "desc": "在开发react项目\b时，很多时候我们把style写在css、less、scss里，经过像postcss这样的配置处理，但有没有这样一种需求呢，像有些样式我们直接写在\bxml标签上style里，然后也能进行处理，\b如px2rem能将px转rem，是否\b在style上写也能实现。"}, {"id": "6844903565207535629", "title": "webpack优化入门详解", "desc": "Scope Hoisting-作用域提升,将模块都放到一个闭包函数中，通过减少闭包函数数量从而加快JS的执行速度。 最终打包可以将css文件直接以内链的形式插入网页中，进而可以减少网页请求。 这显然不是想要的结果，希望改变css文件内容，js文件的hash不会改变，只有相应的c…"}, {"id": "6893868628220280846", "title": "webpack简易打包原理", "desc": "关于最近学习webapck打包原理的一些新的分享 我们都知道webpack是静态模块打包器,他能根据我们的项目入口,找到模块与模块之间的依赖,帮我们构建出我们最终想要的代码,并顺利的在浏览器运行,但是"}, {"id": "6844903853414940685", "title": "demo17 clean-webpack-plugin (清除模式)", "desc": "在之前的 demo 中，webpack 打包后会在根目录下自动创建 dist 目录，并且把生成的文件输出到 dist 下。 当配置的输出包名含有 [hash] 时，hash值会随着文件内容的改变而改变。 因此，我们需要在下一次 webpack 打包输出之前，把 dist 目录清…"}, {"id": "6844903640256233486", "title": "create-react-app集成Prettier", "desc": "进入前端工作也有一些时间了，我们的前端开发也从必须经过千千万万的配置到执行某某一切就可以开始工作了。 我想每个人接触到create-react-app的时候都是惊讶的，原来开始一个应用可以这么简单。 我曾经写过好几页的wiki，上面写满了各种编码规范，甚至常见的情况似乎是通过会…"}, {"id": "6844904160165363725", "title": "SplitChunksPlugin 插件快速入门", "desc": "webpack v4 以前，使用 CommonsChunkPlugin 插件来提取公用的js文件和库，但是这个插件的功能有限，只能把公共文件打包到一个公共文件中，进入页面时加载，只能避免重复加载文件和库，并不能起到优化页面加载速度。 webpack v4版本推出后，官方把代码的…"}, {"id": "6844903950143979528", "title": "Webpack chunk打包时，一定要采用非覆盖式升级", "desc": "最近使用webpack时，遇到了一个问题：版本更新后，如果没有刷新页面就去动态加载某个chunk文件，可能会返回404，即找不到这个文件。 静态资源部署时，采用覆盖的方式。即：将目录下的所有文件都清空，再把最新的静态文件放到目录下 既然chunk文件找不到，那肯定是当前服务器的…"}, {"id": "6918017346121105422", "title": "webpack优化", "desc": "要会优化必须先学会统计分析。 使用 webpack 内置的 stats构建统计信息。 使用 speed-measure-webpack-plugin可以看到每个 loader 和插件执行耗时。 业务里面的组件代码大小。 使用字符串方法替代正则表达式。 会将它及它的依赖分配给 w…"}, {"id": "6844903972055023629", "title": "webpack 4 源码主流程分析（十三）：watch", "desc": "前面分析了 webpack 的普通主流程构建，另外，通过设置 watch 模式，webpack 可以监听文件变化，当它们修改后会重新编译。文档 接下来设置 cli 命令加上 --watch 之后 对 watch 模式下的主流程进行分析（mode = development）。 …"}, {"id": "6844903608169791496", "title": "开箱即用的 Vue Webpack 脚手架模版", "desc": "开箱即用的 Vue Webpack 脚手架模版，对于如何构建中大型 Vue 项目，根据过往的提供脚手架、以及大量的推荐 & 参考性建议。默认引入了 vuex vue-router vue-18n dayjs lodash 等依赖库，以打造高效开发单页面应用 ......"}, {"id": "6987760136416657415", "title": "【从零到一】—— Webpack深入了解", "desc": "前言 作为一门前端程序员,在日常的开发中难免要与各种各样的框架打交道,而框架的使用又需要用到脚手架,比如使用vue时需要用到vue cli。如果在开发过程中我们需要在现有的脚手架的基础上进行功能的增强"}, {"id": "6947174196145291277", "title": "简单实现一个esbuild插件", "desc": "​ esbuild是由Go编写的构建打包工具，对标的是webpack、rollup和parcel等工具，在静态语言的加持下，esbuild的构建速度可以是传统js构建工具的10-100倍，就好像跑车和自行车的区别。相对于webpack等工具，esbuild相对比较纯粹，配置也很…"}, {"id": "6844903997808050190", "title": "vuecli3中webpack配置相关", "desc": "这些环境变量都是在项目根目录下建立的，如果写有变量，那么我们运行相关命令的时候，会根据不同环境载入不同的文件，以至于能正确读到文件里的变量。载入的优先级别是： .env.development 的文件就只会在 development 模式下被载入。 当然，我们是可以通过参数来修…"}, {"id": "6863838861089964045", "title": "我的前端自学笔记 => 模块化开发与规范化标准", "desc": "模块化是一种思想。模块化是主流的代码组织方式，通过把复杂代码按照功能的不同划分为不同的模块，单独进行维护的方式提高开发效率，降低维护成本。 ES Module存在环境兼容问题，通过模块化方式划分的模块较多，网络请求频繁，在前端应用开发中不仅仅需要JavaScript代码需要模块…"}, {"id": "6844904089201934344", "title": "被女友手把手入门webpack", "desc": "前端发展好快的。 越来越多的思想和框架都出来了。 就是为了提高开发的效率。 比如ES6需要通过babel转成ES5才能在浏览器上面运行吧。 ... 这些思想和框架，都是有构建需求的。 webpack是一个模块打包工具，但是只能打包js，所以如果要打包其他的比如css，图片之类的…"}, {"id": "6844903908284825608", "title": "webpack打包原理和基本配置", "desc": "webpack 处理项目时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 通过逐层识别模块依赖。（Commonjs、amd或者es6的import，webpack都会对其进行…"}, {"id": "6844903712058507272", "title": "Webpack原理与实践（一）：打包流程", "desc": "在阅读 webpack4.x 源码的过程中，参考了《深入浅出webpack》一书和众多大神的文章，结合自己的一点体会，总结如下。 webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依…"}, {"id": "6960924869307400200", "title": "Webpack的打包原理", "desc": "Webpack简介 其官网的首页图很形象地展示了Webpack的定义 如下图所示 分析打包后的文件 (webpack版本: 4.41.4) 配置文件: webpack.config.js 入口文件: "}, {"id": "6904930038055960589", "title": "webpack 5 实战 - 01.起步", "desc": "🧳目录webpack5实战01.起步-webpack5构建如果从0到1实现js构建webpack5实战02.特征-基于webpack5新特征实现编译webpack5实战03.拓展-基于现有的体系如何插"}, {"id": "6989812435561480200", "title": "webpack环境配置之process.env", "desc": "process.env process.env就是Nodejs提供的一个API，它返回一个包含用户环境信息的对象。如果我们给Nodejs 设置一个环境变量，并把它挂载在 process.env 返回的"}, {"id": "6977760824626511879", "title": "关于 webpack 的一些笔记", "desc": "太阳无语，却放射出光辉;高山无语，却体现出巍峨。蓝天无语，却显露出高远;大地无语，却展示出广博。鲜花无语，却散发出芬芳;青春无语，却散发出活力。"}, {"id": "6977986139076427789", "title": "webpack | 谈谈webpack的本质", "desc": "webpack系列文章连载中... webpack 是一个现代 JavaScript 应用程序的静态模块打包器"}, {"id": "6844903502720794638", "title": "从React脚手架工具学习React项目的最佳实践（上）：前端基础配置", "desc": "这篇文章不是聊React这门技术本身，而是关于如何维护好一个React项目。 文本可能会涉及一些Webpack的基础知识，如果你还不太了解Webpack的用法的话，可以从我之前的一篇文章《Webpack 速成》入门，深入浅出，童叟无欺。 编程领域中的“脚手架（Scaffoldi…"}, {"id": "6844903726465941518", "title": "webpack - babel 篇", "desc": "基于我的上篇文章，webpack4.0 入门篇 - 构建前端开发的基本环境，补充对babel进行的一次探究。上篇文章讲叙到的 webpack babel 时几乎一笔带过，所以这篇文章将进行补充说明. 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置…"}, {"id": "6844903935812059144", "title": "webpack中的hash、chunkhash、contenthash分别是什么", "desc": "知人者智，自知者明，胜人者有力，自胜者强。——老子 在webpack中有三种hash可以配置，分别是hash、chunkhash、contenthash他们是不对的可以针对不同的配置，首相要搞清楚这三种的hash的区别，什么场景下，适合用哪种。 当有多个chunk，形成多个bu…"}, {"id": "6921360520851243015", "title": "不要再看loader原理了，自己写一个就什么都明白了", "desc": "loader又叫模块转换器。换言之就是将输入到模块到内容按照自己到特性转换输出去（有点像Vue的过滤）。同时，所有的loader的功能都是单一的，他们只会关心自己的输入与输出。同理，loader有链式调用转换的功能（有点像promise then，想要了解这一块的同学，可以看我…"}, {"id": "6896137688781914119", "title": "[译] CommonJS 是如何导致打包后体积增大的？", "desc": "今天的文章，将介绍什么是 CommonJS，以及它为什么会导致我们打包后的文件体积增大。 CommonJS 是 2009 年发布的 JavaScript模块化的一项标准，最初它只打算在浏览器之外的场景使用，主要用于服务器端的应用程序。 你可以使用 CommonJS 来定义模块，…"}, {"id": "6844904175235514375", "title": "Webpack 详解之代码分割（code-splitting）", "desc": "代码分割是 Webpack 最引人注目的特性之一。这个特性允许开发者将代码分割成不同的包，然后可以按需加载或并行加载这些包。它可以用来实现更小的包，并控制资源加载优先级，如果使用正确，将对加载时间产生重大影响。 首先介绍一下 Webpack 默认的代码分割策略。 上面这段话来自…"}, {"id": "6985512182028959758", "title": "Webpack实战：入门、进阶与调优 学习笔记", "desc": "本文来自内容来自对 《Webpack实战：入门、进阶与调优》 学习总结。 一、简介 何为Webpack Webpack是一个开源的JavaScript模块打包工具，其最核心的功能是解决模块之间的依赖，"}, {"id": "6964958004110163976", "title": "新进webpack打包系列一", "desc": "模块打包工具 由来 ES Modules存在环境兼容问题 模块文件过多，网络请求频繁 所有的前端资源都需要模块化 美好设想 编译 开发阶段尽情使用新特性 生产阶段最大程度兼容所有浏览器 打包 将散落的"}, {"id": "6844903833793986567", "title": "两个小优化，webpack打包速度飞起来", "desc": "使用babel7并且使用@babel/preset-typescript代替ts-loader。一方面，babel7拥有着更快的速度，另一方面，ts-loader默认是会读取ts-config的，于是每次构建的时候ts-loader都会去检查全有业务的类型（即使我们只打包a业务…"}, {"id": "6844903661345177614", "title": "记一次element-ui组件开发经历", "desc": "从老东家离职后，闲着没事，想到之前一个后台管理系统的需求，当时需要一个图片预览的组件，但是工程中使用的element-ui并没有这个组件，于是乎自己开始了这个组件的编写。 首先将element-ui库fork到自己的git仓库，clone到本地。 先看看element-ui的主…"}, {"id": "6844903503161196551", "title": "编写自己的Webpack Loader", "desc": "本文将简单介绍webpack loader，以及如何去编写一个loader来满足自身的需求，从而也能提高对webpack的认识与使用，努力进阶为webpack配置工程师。 webpack想必前端圈的人都知道了，大多数人也都或多或少的用过。简单的说就是它能够加载资源文件，并对这些…"}, {"id": "6844903540675051528", "title": "Webpack实战-构建 Electron 应用", "desc": "Electron 可以让你使用开发 Web 的技术去开发跨平台的桌面端应用，由 Github 主导和开源，大家熟悉的 Atom 和 VSCode 编辑器就是使用 Electron 开发的。 Electron 是 Node.js 和 Chromium 浏览器的结合体，用 Chro…"}, {"id": "6844903843365404686", "title": "首屏预渲染方案", "desc": "该方案主要是为了解决，前端 spa (单页面应用)，首屏渲染慢，白屏时间过长问题。 通过 webpack 的 prerender-spa-plugin 编译应用中的静态页面，并将其输出到对应的索引目录。 prerender-spa-plugin 利用了 Puppeteer 的爬…"}, {"id": "6844903549227237384", "title": "分享：一篇webpack配置基础绝好文章", "desc": "Webpack是目前基于React和Redux开发的应用的主要打包工具。我想使用Angular 2或其他框架开发的应用也有很多在使用Webpack。 当我第一次看到Webpack的配置文件时，它看起来非常的陌生，我非常的疑惑。经过一段时间的尝试之后我认为这是因为Webpack只…"}, {"id": "6844903618030616589", "title": "webpack项目轻松混用css module", "desc": "本文讲述css-loader开启css模块功能之后，如何与引用的npm包中样式文件不产生冲突。 比如antd-mobilenpm包的引入。在不做特殊处理的前提下，样式文件将会被转译成css module。 以上代码片段，摘自webpack配置的module.rule。 可以看出…"}, {"id": "6844904095774408711", "title": "Webpack4不求人(5)——编写自定义插件", "desc": "Webpack通过Loader完成模块的转换工作，让“一切皆模块”成为可能。Plugin机制则让其更加灵活，可以在Webpack生命周期中调用钩子完成各种任务，包括修改输出资源、输出目录等等。 今天我们一起来学习如何编写Webpack插件[1]。 在编写插件之前，还需要了解一下…"}, {"id": "6993320027793391647", "title": "Webpack基础概念", "desc": "这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 webpack是什么？有什么作用？ Webpack 是当下最热门的前端资源模块化管理和打包工具。 它可以将许多松散的模块按照依赖和规则打包成"}, {"id": "6916048749634519054", "title": "性能利器，通过Vue3深度解析webpack热更新原理", "desc": "本文就来深度分析一下关于 Webpack 热更新的原理和实现。需要注意的是热更新不是 Webpack 的专利，其他的打包工具也是有的，并且会有一些区别。 本文主要关注 Webpack。 我已经给 Vue3 的 babel-jsx 插件提了PR，有兴趣可以看一下我是如何实现的。 …"}, {"id": "6844903764298579982", "title": "如何利用webpack来提升前端开发效率（二）？", "desc": "通过如何利用webpack来提升前端开发效率（一）的学习，我们已经能够通过webpack的loader和piugin机制来处理各种文件资源。细心的小伙伴们发现了缺少了对字体文件和HTML中<img>标签的资源处理，那让我们先来解决这个问题。 随后在命令行执行npm run bu…"}, {"id": "6844903734007300109", "title": "Webpack升级优化小记：happyPack+dll初体验", "desc": "最近学习了webpack4的使用，并尝试了对项目webpack进行升级和优化，记录一下此次升级的一些实践过程。 项目在2016年引入了webpack作为打包工具，并使用vue-cli搭建build相关的代码，之后再无较大更新。随着项目迭代至今，代码量早已不是当年寥寥的几千行，本…"}, {"id": "6844903581074587661", "title": " vue-cli + es6 多页面项目开发及部署", "desc": "前段时间项目组计划快速开发一个新的App项目，App开发那边提供壳子和部分系统级功能，所有的页面由h5完成，考虑兼容性安卓4.1及ios7.1。全新的项目，没有历史包袱，就尝试了新的开发模式，采用了webpack + vue-cli + vue-router + es6 + a…"}, {"id": "6994270939676426270", "title": "webpack学习笔记-基础用法", "desc": "本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图"}, {"id": "6864385286634225672", "title": "webpack由浅入深系列（一）", "desc": "本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个…"}, {"id": "6844903813220925448", "title": "前端工程（vue）多环境配置方案", "desc": "一个前端工程从开发到上线务必会运行在多种环境中，同时会对环境变量进行相应的配置，如果使用人力去对这些变量进行维护，那么必然会出现错误，所以这个功能交给 webpack 去做最为合适。 其中需要注意的一点是 '\"localhost\"', 如果是定义一个字符串，那么需要双重引号包裹…"}, {"id": "6844903861002436621", "title": "webpack学习之路（四）webpack-hot-middleware实现热更新", "desc": "上一节我学习了webpack-dev-middleware，但是单独使用它并没有实现热更新，所以这节我要学习搭配使用webpack-hot-middleware，来实现热更新功能。 HMR- Hot Module Replacement即热更新，这已经很明白地告诉我们热更新已经…"}, {"id": "6844903503517728775", "title": "《京东E维》基于VUE+Webpack的单页面实践", "desc": "本篇文章和大家聊一聊我们近期的项目——京东E维平台，这是一个专门为运维工程师设计的工单处理系统。它所要肩负的任务是，针对公司内部所有员工在办公时遇到的有关计算机、网络、软件方面等问题，通过E维平台发起问题上报请求。工程师通过该系统可以根据上报工单的紧急程度进行抢单、解决事件单、…"}, {"id": "6844903593741385741", "title": "webpack优化之HappyPack 实战", "desc": "由于运行在 Node.js 之上的 Webpack 是单线程模型的，所以Webpack 需要处理的事情需要一件一件的做，不能多件事一起做。 我们需要Webpack 能同一时间处理多个任务，发挥多核 CPU 电脑的威力，HappyPack 就能让 Webpack 做到这点，它把任…"}, {"id": "6844903696950624264", "title": "vue-cli 3.0新特性解读", "desc": "在9 月 30 日的Vue.js 伦敦大会上， 作者尤雨溪介绍了 Vue 下一个版本将要发布的内容，以及 Vue 3.0 的开发路线，和后面版本的发展情况。虽然，Vue 3.0版本的正式版还没有发布，不过作为vue 项目快速构建工具的vue-cli 早已发布，我们可以通过vue…"}, {"id": "6844903567636070408", "title": "前端开发大杀器hey-cli，全局支持vue react es6开发部署", "desc": "其实，这是一个集成的webpack脚手架。 现今网络上，相信关于webpack的配置，大家也看了不少，基本上比较流行的框架大家都推荐使用webpack来开发部署。 前面有vue-cli的工具，后有ant-design的，大家都基本上帮我们把webpack的那一些配置配置好。 可…"}, {"id": "6844903740734980103", "title": "Webpack 热更新机制", "desc": "想必作为前端大佬的你，工作中应该用过 webpack，并且对热更新的特性也有了解。如果没有，当然也没关系。 下面我要讲的，是我对 Webpack 热更新机制的一些认识和理解，不足之处，欢迎指正。 热更新，是指 Hot Module Replacement，缩写为 HMR。 从名…"}, {"id": "6844903729188044814", "title": "Show me the code，babel 7 最佳实践！", "desc": "大家都知道 babel 是兼容对 ES6 支持不完善的低版本浏览器的转换编译器。 那么废话少说，我们直接点，直接说说常见几个场景下兼容旧版浏览器的方案。 来兼容 Web 应用不支持的 API。 原理大概是 polyfill.io 会读取每个请求的User-Agent标头，并返回…"}, {"id": "6915661058178973710", "title": "webpack分析工具", "desc": "stats是控制 webpack 如何打印出开发环境或者生产环境的打包结果信息。如果是开发环境使用 WDS，还可以在devServer.stats配置。 这些信息可以通过devServer.info - CLI only来禁用，本来这些东西也没啥用，这样再配合一些 webpac…"}, {"id": "6845166890734583816", "title": "webpack之模块联合（翻译）", "desc": "多个单独的构建应该形成一个应用程序。这些独立的构建不应该相互依赖，因此可以单独开发和部署它们。 这通常被称为微前端，但不限于此。 我们区分本地和远程模块。本地模块是正常模块，是当前构建的一部分。远程模块是不属于当前构建的模块，并在运行时从所谓的容器加载。 加载远程模块被认为是异…"}, {"id": "6989444589253820429", "title": "webpack 基础概念教学-3", "desc": "本次大概讲解下DevServer DevServer是启动webpack的功能，里面可以配置端口，host等等，本次简单使用，后续再详细介绍每个 配置项，先简单用起来，感受下 1.首先安装 npm i"}, {"id": "6844903518378147853", "title": "Webapck+Vue多页面商城模板", "desc": "Vue官方提供了Vue-Cli脚手架，集成了Webpack的环境，上手开发和构建非常方便。但Vue-cli适用于单页应用，而平常做的项目中往往都是多页的，网上看了很多Webpack多页面的配置，中间遇到很多坑，自己看文档，对着做出了这个多页面的商城模板。 项目开源在Github…"}, {"id": "6844904015684173832", "title": "webpack5踩坑指南", "desc": "webpack5即将发布，打算趁发布前踩个坑，之前从alpha版本就有关注，本次重点更新在长期缓存，tree shakking和es6打包这块，具体更新日志可以参考官方。 node版本更新为v10。 webpack5默认采用es6代码进行输出，4是es5的(可通过设置outpu…"}, {"id": "6963201773188169764", "title": "webpack-01- webpack常用核心配置详解", "desc": "从零开始，读懂并熟练使用webpack。安装 -> 默认配置 -> 自定义配置 -> 核心配置 ->模式区分打包 -> 其他常用插件"}, {"id": "6968521293796753415", "title": "手把手带你搭建一个简单的webpack脚手架（一）", "desc": "这篇文章主要是从零开始，搭建一个基于webpack的支持react + less + ts的脚手架。主要是面向入门，希望将整个搭建思路讲清楚来，帮助新手搭建一个简单的webpack脚手架。"}, {"id": "6897575210514382862", "title": "Webpack 5中开发loader所遇到的几个问题的解决", "desc": "Webpack中，有两大机制，一个是loader机制，一个是插件机制。虽然社区开源的Webpack loader众多，但是在研发过程中的一些特定场景需求下，我们仍然免不了要自己开发一些loader。本文中，我们就来看看如何实现自定义Webpack loader。 下面我们以实现…"}, {"id": "6891182298701119501", "title": "约定式路由的菜单数据生成方案", "desc": "约定式路由，也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。目前许多开源框架都支持，比如：UmiJS、Nuxt.js、vue-auto-routing等等。 以Nuxt.js的约定式路由规范作为讲解示例。 定义带参数的动态路由，需要创建对…"}, {"id": "6987192913801248804", "title": "webpack5升级踩坑--主要针对报错及处理", "desc": "项目中的webpack的版本还是3，今天就给它升级 这时候面临两个选择，第一，先从3升级到4，再从4升级到5；第二，直接从3升级到5。 好吧，我没那么头铁，还是一步一步来吧"}, {"id": "6969947609662226468", "title": "Webpack 的 tree-shaking 进阶之路（二）", "desc": "webpack 打包 + uglify 实现 tree-shaking 的分析来了！我说过我不会鸽哈哈哈哈... 不会长篇大论讲很多~~细节~~源码，想让我 5 分钟讲明白源码那是不可能的，主要是讲"}, {"id": "6850418120436711432", "title": "webpack的hash、chunkhash、contenthash", "desc": "对于webpack的hash，常用于cdn缓存。我理解的是文件不变的情况下，最后打包出来的hash串也不会变。最近被问到了这是三个hash的区别，就查了一下，发现还很有讲究。 每次构建的生成唯一的一个hash，且所有的文件hash串是一样的。 不用怕，webpack已经提供方案…"}, {"id": "6844903922117820423", "title": "[译]webpack 4: Code Splitting和chunks切分优化", "desc": "当一个chunk有多个父节点的话，我们可以认为当这个chunk被加载的时候，至少有一个父节点已经被加载了.这个信息可以被用来优化，例如，当一个chunk的模块，在所有父节点都可用时，它可以从chunk中被移除，因为它一定已经被成功加载了。 在入口点或异步拆分点处引用chunk列…"}, {"id": "6844903654353436686", "title": "Vue同构(一): 快速上手", "desc": "首先欢迎大家关注我的Github博客，也算是对我的一点鼓励，毕竟写东西没法获得变现，能坚持下去也是靠的是自己的热情和大家的鼓励。 我们可以看到，我们收到服务器的模板中其实并没有我们所期待界面对应的html结构，而仅有一个用于挂载应用的根元素，在客户端浏览器执行加载的JavaSc…"}, {"id": "6921606847359582215", "title": "关于webpack.optimization.splitChunks的心得", "desc": "先过一遍webpack对代码分割功能的实现方式：多入口分割：entry防止重复：使用Entrydependencies或者SplitChunksPlugin去重和分离chunk。动态导入：使用esmo"}, {"id": "6844903957542731790", "title": "webpack4 中如何实现资源内联？", "desc": "首先，我们一起了解下什么是资源内联。 资源内联（inline resource），就是将一个资源以内联的方式嵌入进另一个资源里面，我们通过几个小例子来直观感受一下。 HTML 内联 CSS，这个其实就是我们通常说的 内联 CSS 或者 行内 CSS。我们可以写几行 reset …"}, {"id": "6844903513856671758", "title": "妈妈再也不用担心我不会webpack了2", "desc": "之前写了一篇妈妈再也不用担心我不会webpack了，这次继续对其进行补充。本文依旧是遵循直观易懂的规则进行书写。希望对大家有帮助。如果不太熟悉webpack可以先看看之前的文章妈妈再也不用担心我不会webpack了。下面我们由浅入深来介绍webpack的使用 path其实是no…"}, {"id": "6948951662144782366", "title": "SourceMap详解", "desc": "sourceMap对现在的项目来说也是比较重要的，因为在打包完成之后的代码是经过混淆、压缩的，不能很好的进行定位。如果想看到准确的代码位置，Source Maps（源映射） 通过提供原始代码和转换后代码之间的映射 来解决这个问题。 在2009年google的一篇文章中，在介绍C…"}, {"id": "6844904036710219789", "title": "webpack原理解析（一）实现一个简单的webpack", "desc": "Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。webpack如此强大，其内部机制到底是怎样的，今天我们来一探究竟。 接下来借助@…"}, {"id": "6944668149849522213", "title": "【Webpack进阶】less-loader、css-loader、style-loader实现原理", "desc": "在上一篇文章【Webpack进阶】Loader深入解析中，探索了Loader的原理和运行机制，本文会通过介绍常见样式loader的作用和实现，加深对loader的理解。 下面我们来逐一探讨。 Less是CSS预处理语言，扩展了CSS语言，增加了变量、Mixin、函数等特性，Le…"}, {"id": "6844903935413583880", "title": "为什么 webpack4 默认支持 ES6 语法的压缩？", "desc": "在使用 webpack 的时候，很常见的一个构建优化手段就是缩小构建目标。比如在构建阶段只构建 src 里面的模块代码，对于 node_modules 里面所引入的三方包不进行构建操作。 假设 node_modules 里面存在 ES6 的模板字符串语法，那么在生产环境打包的代…"}, {"id": "6979897227732844551", "title": "webpack", "desc": "入口/出口 npx 打包，使用 npm init -y 进行初始化(也可以使用 yarn)。要使用 webpack，那么必然需要安装 webpack、webpack-cli: loader： 处理不同"}, {"id": "6968020838016614436", "title": "从0到1实现mini-Webpack", "desc": "前言 近日看了直播课里面讲的webpack实现思路，自觉受益匪浅，因此把里面的内容半搬运过来写成博客与大家一起分享，本文适用于对webpack有初步了解的人群"}, {"id": "6844903768564334605", "title": "【手把手带你配 webpack】第二步, 面试官-谈谈你对模块化的理解", "desc": "答: js 的模块化一般来说有 Commonjs AMD(CMD) ESModule 等, Commonjs 使用的同步加载一般用于 node, AMD(CMD) 由于是异步加载所以普遍用在前端. ESModule 旨在实现前后端模块化的统一. 言简意骇, 点到为止. 简直优秀…"}, {"id": "6955125956826628132", "title": "一篇搞懂webpack工作流", "desc": "写在前面 我们每天都在和webpack打交道，都知道他是一个模块和和打包工具，那还有哪些替代工具呢，为什么最终选择webpack？前面也在深入理解ast编译解析原理中讲到webpack是基于ast语法"}, {"id": "6996983908344692773", "title": "深入 Webpack5 等构建工具系列二(1) - webpack 配置文件的使用", "desc": "这是我参与8月更文挑战的第14天，活动详情查看：8月更文挑战 开局一张图： 事先说明一下，上图目录内容是拷贝的上一章结束时的目录内容，当然，这里已经把 node_modules 和 dist 两个目录"}, {"id": "6844903639207657480", "title": "vue-cli中的webpack4一步到位填坑记", "desc": "Webpack也在不断的优化迭代；截至目前，已经更新至 v4.16.0；在Webpack4这个版本，它在原有基础上，做了很多优化，也引入了颇多的新特性。在新的版本中，将获得更多模块类型及对.mjs的支持，更好的默认值、更为简洁的模式设置、更加智能的来分割Chunk，还新增的sp…"}, {"id": "6844903696833183758", "title": "来，用心感受自己的第一个npm包", "desc": "进入到 npm 文件夹，初始化项目。然后会让你填一些项目相关的信息，跟着提示填就是了。没啥说的。注意name不要和现有的其他npm包重名了，不然一会儿发Npm包的时候会失败，可以先去npmjs.com搜一下有没有重名的。 dist代表发布时的目录，src是开发目录。dist里面…"}, {"id": "6844903544760336398", "title": "Tree-Shaking性能优化实践 - 实践篇", "desc": "三. tree-shaking实践 webpack2 发布，宣布支持tree-shaking，webpack 3发布，支持作用域提升，生成的bundle文件更小。 再没有升级webpack之前，增幻想我们的性能又要大幅提升了，对升级充满了期待。实际上事实是这样的 升级完之后，b…"}, {"id": "6844904201311485966", "title": "一文彻底搞懂webpack devtool", "desc": "为什么呢？因为通常我们运行在浏览器中的代码是经过处理的，处理后的代码可能与开发时代码相差很远，这就导致开发调试和线上排错变得困难。这时Source Map就登场了，有了它浏览器就可以从转换后的代码直接定位到转换前的代码。在webpack中，可以通过devtool选项来配置Sou…"}, {"id": "6987586013723901982", "title": "WebPack 模块化原理解析 之 CommonJS原理", "desc": "Webpack 模块化原理解析 Webpack 允许我们使用各种模块化代码 我们最常用的就是 CommonJs 和 ES Module，目前大部分浏览器 还是不支持 模块化的 ES Module 那么"}, {"id": "6881510612761837582", "title": "删繁就简，手写webpack源码", "desc": "这是一份标准的webpack配置文件的组成部分。 执行npx webpack 查看打包后的代码，删除一些无用的代码后。大概是个样子 了解了webpack打包过程，我们可以尝试实现一个简单的webpack打包器。 新建文件夹mypack，新建src/template.js以及in…"}, {"id": "6844903728735059976", "title": "从Webpack源码探究打包流程，萌新也能看懂～", "desc": "上一篇讲述了如何理解tapable这个钩子机制，因为这个是webpack程序的灵魂。虽然钩子机制很灵活，而然却变成了我们读懂webpack道路上的阻碍。每当webpack运行起来的时候，我的心态都是佛系心态，祈祷中间不要出问题，不然找问题都要找半天，还不如不打包。尤其是load…"}, {"id": "6923150535960821768", "title": "深入了解 Loader", "desc": "相关的 Loader，因为像 .png 这样的文件不是一个 JavaScript 模块，你需要配置 webpack 使用 file-loader 或者 url-loader 去合理地处理它们。通过 Vue CLI 创建的项目已经把这些预配置好了。 file-loader 可以指…"}, {"id": "6872590966466576397", "title": "【webpack系列】webpack内部机制", "desc": "webpack本质上可以将其理解为是一种基于事件流的编程范例，一系列的插件运行。 1. webpack启动过程分析 1. 运行webpack 2. 查找webpack入口文件 在运行以上命令后，npm 会让命令行工具进入 node_modules.bin 目录查找是否存在 we…"}, {"id": "6850037279767920653", "title": "Webpack5 新特性尝鲜实战 【第二季】", "desc": "标题我们写上了Webpack 新特性实战尝鲜的第二季，那么肯定就有第一季了( Webpack5.0 新特性尝鲜实战 🦀🦀【第一季】)。距离写上一篇文章已经超过了一年的时间，那时候还是major版，我们先来总结一下吧： 老袁写这篇文章的时候现在的版本是 v5.0.0-beta…"}, {"id": "6995867488449724430", "title": "webpack基础篇", "desc": "一、webpack核心概念 wepack主要有四个核心，entry(入口)、output （出口）、loader、plugin 1、entry entry分为单入口和多入口 单入口 entry是一个字"}, {"id": "6844903935795265549", "title": "webpack中的bundle、module、chunk分别是什么", "desc": "祸兮福之所倚，福兮祸之所伏。——老子 bundle、module、chunk 都是 webpack 中的术语，下面就一个一个介绍他们的定义是什么，怎么产生的。 Bundle是由多个不同的模块生成，bundles 包含了早已经过加载和编译的最终源文件版本。 **Bundle 分离…"}, {"id": "6968275465572188191", "title": "[分享]Webpack打包分析工具", "desc": "Webpack打包分析 打包的时间分析 如果希望看到每一个Loader、每一个Plugin消耗的打包时间，可以借助于一个插件:speed-measure-webpack-plugin 注意:该插件在最"}, {"id": "6959578684386705416", "title": "webpack反编译思路分享", "desc": "本文从思路上解析，如何进行反编译，提取第三方库。 任务说明 接到任务，阅读editor,JsBarcode，两个模块的代码解析、注释工作 为什么要编译？ 因为要进行二次开发，在看不懂的方法上注释或者采"}, {"id": "6844903577064833037", "title": "那些激动人心的React,Webpack,Babel的新特性对于我们开发体验带来哪些提升", "desc": "写在开头: 在怀着激动和忐忑的心情写出团队第一篇文章时,这个兴奋感一方面来自团队组建以来这是我们首次对外部开启一扇窗,另一方面我们也会持续听取意见,维持一个交流的心态。 但是除去这个我们翘首以盼的改变外,也同样有很多我们值得一提的东西。 我们先从编译文件开始我们看看Babel …"}, {"id": "6952139288779685901", "title": "webpack全方位由浅到深讲解，做到简历上真正所谓的“熟悉”(系列二)", "desc": "如果你有梦想，一定要来大城市，这里可以帮您实现你想要的有些梦想，需要借助城市的力量才能实现编写可维护的webpack构建配置构建配置抽离成 npm 包的意义通用性业务开发者无需关注构建配置统一团队构建"}, {"id": "6993522714933723143", "title": "webpack多页面打包配置方案", "desc": "这是我参与8月更文挑战的第7天，活动详情查看：8月更文挑战 多页面应用打包方案   先来说说什么是单页面应用和多页面应用： 单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加"}, {"id": "6896249895108231176", "title": "webpack教程：如何从头开始设置 webpack 5", "desc": "最近开源了一个 Vue 组件，还不够完善，欢迎大家来一起完善它，也希望大家能给个 star 支持一下，谢谢各位了。 如果你们不习惯从头开始设置 webpack 来使用Babel、TypeScript、Sass、React或Vue，或者不知道为什么要使用 webpack，那么这篇…"}, {"id": "6903770216786984973", "title": "手写简单的webpack", "desc": "对这个打包后的结果进行简化分析。抽离出来的核心代码如下 将模块中的所有依赖进行读取，拼接成一个对象，传入自调用函数里面去。 创建一个bin目录，在bin目录下创建yj-pack文件.这个文件的主要目的就是读取webpack.config.js配置目录(暂不支持webpack那种…"}, {"id": "6844904064250019854", "title": "Webpack优化实践，合理分包，降低白屏时间👆", "desc": "webpack打包过程中，经常出现app.js一个文件好几兆的情况，这偏偏又是网页最先加载的文件，由于从上到下的执行顺序，前面的脚本在加载时会阻塞页面渲染，白屏时间由此而来。那么我们如何提高网页渲染速度呢？办法之一就是合理的分包策略。 一个简单的博客项目，项目本身并不大，但透过…"}, {"id": "6844903847668744199", "title": "深入理解 Webpack 打包分块（下）", "desc": "随着前端代码需要处理的业务越来越繁重，我们不得不面临的一个问题是前端的代码体积也变得越来越庞大。这造成无论是在调式还是在上线时都需要花长时间等待编译完成，并且用户也不得不花额外的时间和带宽下载更大体积的脚本文件。 然而仔细想想这完全是可以避免的：在开发时难道一行代码的修改也要重…"}, {"id": "6844903657083797512", "title": "改造vue-cli，让它更好用", "desc": "vue-cli是一个整合了webpack+vue的脚手架，通过这个脚手架，我们可以很方便地创建一个vue项目，甚至引入了vuex和vue-router。webpack的配置对用户来说是透明，用户无需关注webpack的详细配置，从而提高开发效率。 那么vue-cli真的很好用吗…"}, {"id": "6956436157190127652", "title": "如何开发weboack的loader", "desc": "前情回顾 上篇文章简单介绍了一下loader,今天谈一谈自己对loader的理解。 什么是loader loader的定义：一个导出了一个函数的node模块儿。当某些资源或文件需要转换时这个函数被调用"}, {"id": "6844904068456923144", "title": "Webpack原理(1) — Why Webpack", "desc": "如果只是这样用，有什么问题呢？这样引入JavaScript是没办法大量引入的，什么算大量呢？也不用多，加入某个页面我需要20个JavaScript文件，怎么办？好像我只能加20个script标签，然后一个一个去请求。但是这样的话首先会使页面加载变慢，你需要在加载页面后去请求大量…"}, {"id": "6844904048970186760", "title": "webpack原理解析（二）实现一个简单的Loader", "desc": "webpack中 loader 是一个非常重要的概念，loader 可以简单的理解成一个文件处理器，webpack使用 loader 来处理各类文件，比如 .scss转成成 css文件, 小图片转换成base64图片。 本质上讲，loader 只是导出为函数的 JavaScri…"}, {"id": "6844903664931307534", "title": "webpack4搭建现代Hybird-h5工程", "desc": "入口繁杂其实意味着你的前端工程搭建必须是以多入口为起点搭建的，如webpack你可以配置entry，自行写一个脚本在构建时获取每一个页面的js入口，而多入口意味着你必须考虑页面之间共享的模块应该如何抽取以达到一个较优的模块利用率，这点我们在文章下一节详细讲。 其实有做过混合开发…"}, {"id": "6844903655762558983", "title": "重磅！Vue CLI 3.0正式发布，带来多项重大更新", "desc": "近日，Vue 的作者尤雨溪在 Medium 上宣布正式发布 Vue CLI 3.0，它也将为很多开发者带来期待已久的新特性。 丰富的内置功能 尤雨溪表示，Vue CLI 3.0 与其他的版本完全不同，它经历了重构，目的是： 尽可能减少现代前端工具在配置上的烦恼，尤其是在开发者将…"}, {"id": "6844904203026956302", "title": "webpack打包css背景图片路径问题", "desc": "打包后在dist目录的发现没有css文件。这是因为css文件被转化成了js文件。 此时启动项目，背景图片引入正确，能够正常显示。 使用 mini-css-extract-plugin 将css文件单独提取到dist目录下的css目录下。 可以看到此时图片在根目录(dist)目录…"}, {"id": "6927678299044839437", "title": "Webpack打包原理浅析", "desc": "相信大家都学习过webpack的用法，但是它的原理是怎样的呢？面试官问到webpack打包原理的时候，该如何回答呢？我这里借鉴了Dell老师的教程，简单的写一个打包工具，带大家深入了解一下webpac"}, {"id": "6963822022434504734", "title": "Webpack Plugin知识分享", "desc": "认识Plugin Loader是用于特定的模块类型进行转换; Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等; 常用Plugin CleanWebpackPlugin "}, {"id": "6844903717947310093", "title": "WEB 前端模块化都有什么？", "desc": "说到前端模块化，你第一时间能想到的是什么？Webpack？\bES6 Module？还有吗？我们一起来看一下下图。 相信大伙儿对上图的单词都不陌生，可能用过、看过或者是只是听过。那你能不能用一张图梳理清楚上述所有词汇之间的关系呢？我们日常编写代码的时候，又和他们之间的谁谁谁有关系…"}, {"id": "6844903504578871304", "title": "使用 webpack 优化资源", "desc": "在前端应用的优化中，对加载资源的大小控制极其的重要，大多数时候我们能做的是在打包编译的过程对资源进行大小控制、拆分与复用。 本片文章中主要是基于 webpack 打包，以 React、vue 等生态开发的单页面应用来举例说明如何从 webpack 打包的层面去处理资源以及缓存，…"}, {"id": "6844903648422526983", "title": "基于 webpack4 搭建 vue2、vuex 多页应用框架", "desc": "最近在对公司的H5项目做重构，涉及到构建优化，由于一些历史原因，项目原先使用的打包工具是饿了么团队开发的 cooking（基于 webpack 做的封装，目前已停止维护了。）如果继续使用，一是项目目前已经比较复杂，现在的构建方式每次打包耗时较长；二是使用一个已经停止维护的工具本…"}, {"id": "6992767536043393061", "title": "webpack基础知识", "desc": "定义 Webpack是一种前端资源构建工具，一个静态模块打包器(module bundler)。前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。根据模块的依赖关"}, {"id": "6942366092635406349", "title": "webpack实现具有热更新功能的mock接口服务", "desc": "1. 前言 在前端进行开发的时候，一定会遇到和中后台进行接口连调。很多时候，中后台和前端开发是并行的，前端进行静态界面功能开发，后端进行接口业务功能开发，这个时候，中后台是无法提供有用的接口的。这个时候，需要有一个 mock 服务来提供模拟的接口数据，供前端来进行调试，这快加快…"}, {"id": "6844903806711365640", "title": "基于page-skeleton-webpack-plugin分析自动生成骨架屏原理", "desc": "page-skeleton-webpack-plugin是一款由ElemeFE团队开发的webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。 对页面中元素进行删减或增添，对已有元素通…"}, {"id": "6844903969924317198", "title": "webpack的esm", "desc": "关于webpack我心中有很多疑问。。。 这里主要工作就是 遍历模块ast中的一条一条statement, 遇到一些类型做一些处理，并且可能调用预先在evaluate钩子(Parser构造函数中定义的HookMap)上为各种\"表达式\"tap的处理函数，这些表达式为\"Litera…"}, {"id": "6931186451224887309", "title": "polyfill 在babel7时代何去何从", "desc": "babel 的核心功能是转译代码（新语法，如箭头函数，类等）和polyfill能力（新内置对象，api等），本文主要讨论polyfill能力。 babel7.4之后，官方已经废弃@babel/polyfill 。@babel/runtime 在7.0.0后也去除了polyfil…"}, {"id": "6844903956620165133", "title": "在翻译中学习Webpack-SplitChunksPlugin", "desc": "通常，在webpack的内部图谱里面，chunks是以父子关系关联在一起的。CommonsChunkPlugin曾被用来避免他们之间的重复依赖，但是在未来它将起不到优化作用了。 对于大部分用户来说，SplitChunkPlugin是开箱即用的，而且会用的很好。 默认情况下，它只…"}, {"id": "6886735744061145095", "title": "webpack 优化总结", "desc": "babel.config.js 配置如下，自动引入相关组件样式。不要把整个库的Css引入。 不用再像网上其他文章引入uglify,这样会再进行AST解析浪费。 IgnorePlugin的原理是会移除moment的所有本地文件，因为我们很多时候在开发中根本不会使用到。 这个插件的…"}, {"id": "6869707664390094862", "title": "从手写bundler到分析webpack打包结果", "desc": "最近在整理webpack的内容，在此小记一笔。 作为一个菜鸟，以我对webpack浅薄的认识，大概知道webpack的定位是一个bundler，解决的是如何将多个模块打包到一起去的问题。这里的模块定义十分广泛，可以是一个JS文件，可以是一张图片，也可以是一个样式文件……当然，因…"}, {"id": "6923467122613944328", "title": "偷学VueCli和CRA脚手架，入门webpack配置工程师", "desc": "背景目前前端工程化很好，前端工程化在构建方面的核心毫无疑问是webpack，webpack工程师，是每个前端工程师都要有的头衔(狗头保命)，为了学习webpack，笔者看完了webpack中文网又查阅"}, {"id": "6955293673336602631", "title": "webpack——从简易打包实现看webpack原理", "desc": "模块化与webpack 在实现一个简单的webpack之前，我们需要了解为什么需要webpack等打包器存在。在前端刚开始没有模块化工具的时候，会遇到什么问题呢？ 你可能需要把js都依次引入html中"}, {"id": "6979184009616031752", "title": "Webpack | 如何提升构建速度，进行体积优化？", "desc": "webpack系列文章连载中...] 上篇文章，已经说明了进行优化的前期准备，如何查看构建统计信息、速度分析，以及体积分析。"}, {"id": "6844903700247527438", "title": "webpack 打包优化", "desc": "2. router 按需加载 Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。 App部分代码修改后，只需要编译app部分的代码，dll部分，只要包含的库没有增减、升级，就不需要重新打包。这样也大大提…"}, {"id": "6989779080509915144", "title": "webpack基本配置", "desc": "npm 相关知识 版本号 1.2.3 1 大版本号: 代码重构 2 中版本号: 代码加功能 3 小版本号: bug修复 版本号前缀 ^ ~ * 不加前缀符号就装指定版本的依赖 -D -S 的区别 -D"}, {"id": "6844903650037334023", "title": "预渲染插件prerender-spa-plugin使用总结", "desc": "最近两周刚刚接手工程化的工作，领导希望能够集成一个可以预渲染html的插件来解决webpack生成的空白模板问题。 通过调研发现webpack有一个prerender-spa-plugin的插件完全可以满足需求，故将这个插件集成到我们内部的构建流程中。整个过程还是有很多坑的，主…"}, {"id": "6948698645126610975", "title": "BUG！从编写 Loader 到窥探大佬 Debug 全过程", "desc": "首发：https://mp.weixin.qq.com/s/HOGmlICuH3MbLJCb_CjwfQ不同于 web 开发的 html + js + css，在原生小程序开发中，我们使用的是 wxm"}, {"id": "6875512935662551047", "title": "Webpack系列-提取公共资源", "desc": "一、项目是多页应用，有多个入口，多页面之间有共同使用的模块、代码等。这时可以把多个页面的公共部分代码提取出来。 二、我们可以把整个C端项目提取出公共代码，这样用户在打开一个页面的时候，顺便加载缓存了公共文件，后续再打开其他页面的时候，可以直接命中公共文件的缓存，减少资源的下载。…"}, {"id": "6844903875774775309", "title": "webpack 实现 HMR 及其实现原理", "desc": "在这之前我总是容易把热重载和模块热替换混淆成一个概念，在自己动手实现之后才发现两者还是有一些差别的。 保留在完全重新加载页面时丢失的应用程序状态。 然后进行手动判断进行模块热更新，如果你不想做以下判断那么可以使用module.hot.accept()，整个项目做hmr只要有代码…"}, {"id": "6844904048483631111", "title": "揭秘webpack plugin", "desc": "Plugin(插件) 是 webpack 生态的的一个关键部分。它为社区提供了一种强大的方法来扩展 webpack 和开发 webpack 的编译过程。本文将尝试探索 webpack plugin，揭秘它的工作原理，以及如何开发一个 plugin。 通过插件我们可以扩展 web…"}, {"id": "6844903656714665998", "title": "Webpack 4.x搭建react开发环境", "desc": "必要依赖一览(npm install) 安装好。 babel系列是干什么用的呢？是为了支持es6以上的高级语法的编译。但是因为react有jsx这个东西存在，所以单纯的babel是不够的，此外要让babel作用于webpack，需要给webpack添加一个loader（以前版本…"}, {"id": "6954251449769394190", "title": "开发一个自己的 Webpack Loader", "desc": "Webpack loader 一、什么是loader？ ​ loader 是一个文件加载器，能够加载不同的资源，并对这些文件进行操作，如编译，压缩，最终打包到指定的文件。 处理一个文件可以使用多个lo"}, {"id": "6941660854383280164", "title": "【造轮子篇】开发压缩资源为zip包的webpack插件｜项目复盘", "desc": "开发一款可以压缩构建资源为zip包的webpack插件。 开发webpack插件，可以让我们从webpack配置工程师，深入理解webpack工作机制及原理，然后走向webpack开发工程师。那选择开发压缩打包zip的webpack，是因为项目部署经常需要将编译构建的项目打包成…"}, {"id": "6844903698364121101", "title": "Webpack3.X升级到4.X多页面实战和构建优化", "desc": "Webpack4.x出来也有一段时间了，网上已经有很多关于Webpack4.x原理和新特性的介绍，比如零配置等，这边就不重复了。 最近将之前基于Webpack3.x写的一个多页面项目升级到4.x，记录和总结Webpack3.x升级到4.x遇到的问题以及解决方案。 区分3.x和4…"}, {"id": "6844903757533151240", "title": "解决webpack-dev-server代理常切换问题", "desc": "通常我们有一份webpack.dev.config.js使用webpack-dev-server的proxy，代理到开发服务器，来解决本地跨域问题。假如项目变大，可能需要proxy到不同环境，比如docker，或者后端开发人员的电脑上"}, {"id": "6844903605632253966", "title": "使用webpack搭建react开发环境", "desc": "npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies中，主要在开发环境中的依赖包. 如果使用webpack 4+ 版本，还需要安装 CLI。 非全局安装下的打包。 webp…"}, {"id": "6844903920574136327", "title": "webpack 多个入口输出多个文件解决方案   webpack 输出多个css文件", "desc": "1、webpack多个单页面入口，需要重复写多个entry;2、webpackentry不支持glob，不可以使用模糊匹配符号3、webpack会打包所有的css到一个文件，而有需求是分开输出一、解决"}, {"id": "6844903509473640462", "title": "Webpack HMR 原理解析", "desc": "Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对…"}, {"id": "6844903617976107016", "title": "「前端」看懂前端脚手架你需要这篇webpack", "desc": "分割webpack配置文件的多种方法（一）将你的配置信息写到多个分散的文件中去，然后在执行webpack的时候利用--config参数指定要加载的配置文件，配置文件利用moduleimports导出。"}, {"id": "6985885124856381447", "title": "webpack5从入门到精通(一)", "desc": "webpack系列知识分享。webpack5从入门到精通(一)，本节包含介绍、entry、output简单配置。"}, {"id": "6844903998944706574", "title": "Hash vs chunkhash vs ContentHash", "desc": "每次前端静态资源需要更新时，客户端必须重新下载资源。因为从网络中获取资源会很慢，这显然非常低效。这也是为什么浏览器会缓存静态资源的原因。但是有一个缺陷：如果在部署新的版本中不修改文件名，浏览器会认为它没有更新，会继续使用缓存中的旧版本。 文件名加上hash可以保证我们应用发版更…"}, {"id": "6867701871705128974", "title": "webpack4 来啦！", "desc": "安装webpack4## 依赖npminstall--save 上线开发都需要。npmi-D是npminstall--save-dev的简写，是指安装模块并保存到package.json的devDep"}, {"id": "6844904038207586318", "title": "Webpack实战（二）：webpack-dev-server的介绍与用法", "desc": "在开发中，我们都可以发现仅仅使用Webpack以及它的命令行工具来进行开发调试的效率并不高,每次编写好代码之后，我们需要执行npm run build命令更新js文件，然后再刷新页面，才能看到更新效果。webpack-dev-server正好解决了这个问题，是一款便捷的本地开发…"}, {"id": "6844903998726602759", "title": "SplitChunks快速使用手册", "desc": "一些提示默认配置在大多数场景下都有不错的表现webpack的externals更适合把第三方库移到CDN上test匹配规则也可以是一个方法，分组更灵活更多相关的资料webpack4:代码拆分、代码块关"}, {"id": "6844903726495301640", "title": "webpack 打包多页面", "desc": "一开始接触webpack是因为使用Vue的关系，因为Vue的脚手架就是使用webpack构建的。刚开始的时候觉得webpack就是为了打包单页面而生的，后来想想，这么好的打包方案，只在单页面上使用是否太浪费资源了呢？如果能在传统多页面上使用webpack，开始效率是否会事半功倍…"}, {"id": "6844903574506307597", "title": "从简单的例子看 webpack 模块加载机制及思考原理", "desc": "将打包之后的代码简化后非常清晰，就是一个立即调用函数表达式（IIFE：Immediately-Invoked Function Expression）。执行函数 webpackBootstrap 有一个形参 modules，对应的实参是一个数组，数组包含多个函数代码块，每个函数…"}, {"id": "6844904037465210894", "title": "【译】你不得不知道的6个超有用的Webpack插件", "desc": "webpack plugins可以被用来做一些诸如打包代码优化，资源管理，环境变量注入等一系列有用的工作。 本文将会为大家介绍6个超有用的webpack插件。 这个插件会将webpack的输出文件进行可视化展示，展示的树形结构可以进行放大缩小等一系列交互操作。 offline-…"}, {"id": "6844903910189039630", "title": "webpack实战之从roadhog2.x到webpack4.x", "desc": "先说背景，目前主要做的项目其实都是兄弟姐妹系统（是的没错，就是前端圈位于鄙视链底部的TO B系统），基于早期的JSP多页应用使用React进行拆分重构；技术选型采用的是react + antd + dva。我从学校回来接入的时候，项目已经开始一段时间了。当时dva脚手架还是带的…"}, {"id": "6912648957445275655", "title": "移动端组件库构建指北", "desc": "构建组件库的目录结构构建具体步骤使用npmrundev启动开发(site文件夹)构建入口build/dev-server.jsdoc部分：md转化成vue，作为site/doc依赖docs/*.md="}, {"id": "6844903549231431693", "title": "从零开始搭建一个简单的基于webpack的vue开发环境", "desc": "都8102年了，现在还来谈webpack的配置，额，是有点晚了。而且，基于vue-cli或者create-react-app生成的项目，也已经一键为我们配置好了webpack，看起来似乎并不需要我们深入了解。 不过，为了学习和理解webpack解决了前端的哪些痛点，还是有必要从…"}, {"id": "6917641548117049358", "title": "[实践]webpack+vue+ts搭建前端项目", "desc": "webpack是用于javascript应用程序的静态模块打包工具。它可以看作是模块打包机，所做的事情就是分析我们的项目结构，构建一个依赖图，通过依赖图映射项目所需要每个模块，打包成1个或多个bundle（包）供浏览器使用。 具体教程：webpack概念 上讲的很清晰，在进行w…"}, {"id": "6989485075637207070", "title": "webpack 基础概念教学-4", "desc": "接下来教程就开始陆陆续续讲解核心内容的具体配置了 Entry  entry 是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。  entr"}, {"id": "6844903920322510861", "title": "Webpack4配置【高级篇】", "desc": "1. css Tree Shaking 2. js优化 HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack"}, {"id": "6844903876810768398", "title": "webpack3 升级到 webpack4 小记", "desc": "Error: webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead. Error: Plugin could not be…"}, {"id": "6844904134563512334", "title": "了解 webpack5 模块联邦", "desc": "可以解决跨项目的相互依赖，假设目前有两个项目 app1 和 app2，app1 想使用 app2 项目里的某个组件比如 src/components/Button.js。我们可能会将 components 拆成公共的组件库分别在 app1、app2 里引入，但是维护和更新组件库…"}, {"id": "6919512947245088776", "title": "Webpack5模块联邦源码探究", "desc": "虽然webpack5已经发布了一段时间了，但一直都没有研究过，最近正好在做微前端相关的调研，恰好看到了webpack5的模块联邦与微前端的相关方案，便想着探究下模块联邦的相关源码。（ps：关于微前端，稍微说一句，个人觉得在选取微前端方案的时候可有结合现有资源以及形态进行相关取舍…"}, {"id": "6844903607230447629", "title": "webpack (1)——核心概念的理解", "desc": "... 它每一步大体是什么意思。 配合其官网的首页图不难理解其含义：一切文件如：JavaScript 、CSS 、 SASS 、 IMG/PNG等，在 Webpack 眼中都是一个个模块，通过对 Webpack 进行配置，对模块进行组合和打包。经过 Webpack 的处理，最终…"}, {"id": "6844903795638403086", "title": "Webpack DllPlugin 让构建速度柔顺丝滑", "desc": "DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度,将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件中。在之后的构建过程中不会再对这些模块进行编译，而是直接使用 D…"}, {"id": "6942678557076226078", "title": "你真的了解webpack中的loader么？", "desc": "webpack only understands JavaScript and JSON files. Loaders allow webpack to process other types of files and convert them into valid modul…"}, {"id": "6844903728772808717", "title": "实用webpack插件之DefinePlugin", "desc": "通过阅读这篇文章，可以学习到如何使用DefinePlugin插件使得前端项目更加工程化，说清晰点就是如何使用这个插件，在编译阶段根据NODE_ENV自动切换配置文件，提升前端开发效率。 DefinePlugin中的每个键，是一个标识符或者通过.作为多个标识符。 如果value是…"}, {"id": "6844903826592366600", "title": "Webpack模块引用中还有什么坑？", "desc": "最近在引用自己写的一个插件的时候，偶然发现webpack下引用 node_modules下的文件与直接引用文件夹中的文件表现不一致。文件内容都是由webpack打包出的同一个文件 umd.js，从node_modules 引入的可以直接使用，但是从普通文件夹中引入的文件在浏览器…"}, {"id": "6844903604965343239", "title": "从零开始搭建一个mock服务", "desc": "本文完。"}, {"id": "6918195987869761549", "title": "不再为 Node.js 模块引入 Polyfills ", "desc": "2020-10-10 webpack 5.0.0 发布了，其中的一个变化是 Webpack 5 不再为 Node.js 模块引入 Polyfills 了。 在早期，webpack 的目的是为了让大多数的 Node.js 模块运行在浏览器中，但如今模块的格局已经发生了变化，现在许…"}, {"id": "6844903585747042317", "title": "webpack+react+antd脚手架优化", "desc": "1. CSS分离 研究得出结论：webpack升级到v4然而响应的插件没有升级的原故。 在页面上引入第三方资源库，然后使用externals防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(ext…"}, {"id": "6844904196634837000", "title": "了不起的 Webpack 构建流程学习指南", "desc": "Webpack 是前端很火的打包工具，它本质上是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将…"}, {"id": "6931930754288975879", "title": "手写，发布并调试webpack-loader", "desc": "webpack的loader和plugin为我们提供了强大的功能，下面我们就简单的实现一下webpack-loader，顺便发布到npm，以及使用npm link本地调试我们的模块。 此时，我们可以发现node_modules下面我们没有安装bundle-author-load…"}, {"id": "6915749794208022541", "title": "webpack 流程概览", "desc": "Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 的实例。 tapable…"}, {"id": "6844904165915754504", "title": "webpack-dev-server深入理解", "desc": "因为 devops 的项目结构一开始并不是前后端分离的，所以要进行去 local-dev-server 实现前后端分离配置，当然根据前辈清晰的教程自己也成功实现，但是期间对整个webpack启动本地服务过程。以及webpack-dev-server的原理也一知半解，索性就去了解…"}, {"id": "6844903821462732813", "title": "webpack及node.js基础必会--path模块的常见操作", "desc": "在没有相关经验的同学，在学习webpack和使用node时，经常会遇到__dirname path.resolve 等，这时往往会一脸懵逼这些都是什么，干嘛的，为什么这些资料和书都完全不提，难道就我不知道 -。- 其实path模块是很常见很通用的。这里我就简单总结一些在项目中经…"}, {"id": "6844903576318246920", "title": "webpack 4升级指南", "desc": "webpack 4发布也有一段时间了，虽然官方的文档，升级指南都没有完成，部分插件适配webpack 4的开发也还在进行中，但对于一个资深前端配置工程师，大刀早已饥渴难耐，所以就出一份非官方升(cai)级(keng)指南吧。 我没时间看你废话，给我一份配置 webpack 4做…"}, {"id": "6844903910461685767", "title": "基于 Webpack 4 多入口生成模板用于服务端渲染的方案及实战", "desc": "警告：本作品遵循 署名-非商业性使用-禁止演绎3.0 未本地化版本（CC BY-NC-ND 3.0） 协议发布。你应该明白与本文有关的一切行为都应该遵循此协议。 现代化的前端项目中很多都使用了客户端渲染（Client-side Rendering, CSR）的单页面应用（Sin…"}, {"id": "6977693714663604231", "title": "webpack | plugin机制详解", "desc": "webpack系列文章连载中...webpack 插件是一个具有 apply 方法的 JavaScript 对象。"}, {"id": "6968802204371124237", "title": "前端性能优化-webpack", "desc": "1.tree shaking 1.上下文未用到的代码 2.所有代码都必须基于es6 import 和export 3.mode='production‘自动就有tree-shaking 原理 webp"}, {"id": "6844904200292450318", "title": "webpack性能优化面面观", "desc": "webpack在启动后，会根据Entry配置的入口，递归解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置。 1. resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置： res…"}, {"id": "6844904079588605966", "title": "wepack搭建react项目（一）", "desc": "借用官网的解释：本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这…"}, {"id": "6950605587109380110", "title": "Webpack入门", "desc": "1.webpack简介1.1webpack是什么？webpack是一种前端资源构建工具，一个静态模块打包器（module bundler）。在webpack看来，前端多有的资源文件（js/json/c"}, {"id": "6844903872549355534", "title": "教你用webpack4打造优化到极致的活动页面", "desc": "一般待过大公司的同学都知道，一个成熟稳定的公司肯定需要销售产品或推广产品来盈利，推广自己的产品则需要活动页面来引流。下面，我将分享自己在公司的探索经历，教你用webpack4打造优化到极致的活动页面。 安装webpack webpack-cli，配置webpack.config…"}, {"id": "6844903669561835528", "title": "从零开始制造的Webpack4多页面脚手架（通用所有H5多页面应用）", "desc": "工作中大多数需求往往能够用单页面应用的方式来构建，但也少不了多页面的需求场景。这个脚手架往往能够满足你在多页面的场景需求！非常推荐使用！！！"}, {"id": "6844903924764246029", "title": "跨域开发的几种解决方案", "desc": "本地开发过程中，最常遇到的就是出现跨域，无法请求的问题。如何解决在开发中遇到的跨域问题，今天整理了4种解决方法，供大家参考。 跨域出于浏览器的同源策略的限制，浏览器本身会限制跨域请求（严格来说，只是限制跨域的读操作）。那么何为跨域呢?非同源请求均为跨域，即:如果两个请求的协议、…"}, {"id": "6968728833734230047", "title": "1.必备技能 - webpack学习之路", "desc": "接触的东西越多，发现需要学习的内容也就越多，为了以后更好的工作（加薪），下定苦心学习前端神器（webpack）。下面，走起！！！"}, {"id": "6930209852559982600", "title": "热更新简单实现", "desc": "一直对webpack热更新非常好奇，在看了一些资料之后。尝试写一个简单的demo模仿。 第一步要实现一个跟webpack类似的模块处理工具。这里直接用极客时间上的一个课程的demo. 简单介绍一下这几个文件：\u0003 lib：类似webpack。里面的parser.js主要使用bab…"}, {"id": "6844903636577812493", "title": "[译]Webpack 4 — 神秘的SplitChunksc插件", "desc": "这是我的一个粗略尝试，通过一个常见的例子来理解和帮助你使用 SplitChunksPlugin 选项。 作为早期的爱好者，我试图理解代码分割 (Code-Spliting) 背后的魔法。文档说 splitChucnks 接受'initial', 'async', 'all'。我…"}, {"id": "6869385307503591437", "title": "webpack 教程「五.配置详解」", "desc": "接下来这一章节来学习webpack配置的详解。凑字凑字凑字凑字凑字凑字凑字凑字凑字凑字凑字凑字凑字凑字"}, {"id": "6844904072768651278", "title": "webpack中的Code Splitting以及配置参数", "desc": "在最开始的时候，webpack都是将所有的代码打包到一个文件中，但是当项目过大的时候，页面所需要加载的时间就会变长，这个时候我们就需要Code Splitting对文件进行分块，实现代码的按需加载。 当用第一种方式的时候， 我们需要等打包文件加载完成之后，才会去实现文件里面的逻…"}, {"id": "6982369523827474440", "title": "Webpack学习记录", "desc": "学习webpack，俗话说好记性不如烂笔头，光学习不练习，每次还是忘记了，边学习边做笔记，加深自己印象。"}, {"id": "6970952448005537828", "title": "webpack基础入门", "desc": "webpack定义 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 在 webpack 看来, 前端的所有资源文件(js/json/css/img/les"}, {"id": "6944369285816909837", "title": "html-webpack-plugin 又出幺蛾子 | 一次解决bug的过程", "desc": "先说一下这一次出现问题的需求背景，在顺便引出 html-webpack-plugin。最近在做监控，而我需要监控到文件加载错误，并实现上报。熟悉的小伙伴，已经知道，这是一个很容易实现的功能 当我们加载 cutex/xuan.js 这个文件的时候，加载失败，报告404错误。这个时…"}, {"id": "6922722613357707272", "title": "Webpack之Tapable源码解读", "desc": "Tapable对外暴露的Hook可分为同步和异步两种类型, 这两种类型在执行时又可以分为并行和串行两种方式. 具体如下: 具体来说, 使用Tapable Hook使用大致分为三步. 生成的call方法见文章最后部分. 核心代码分布在Hook.js和HookCodeFactory…"}, {"id": "6856709379321200654", "title": "实现element按需加载", "desc": "使用babel-plugin-component实现按需引入、打包。 将webpack配置成多入口，保证最终打包的目录结构符合babel-plugin-component插件的要求，实现按需加载。 实际bable处理时直接删除当前代码，然后在对AST抽象语法树遍历时，将对引用的…"}, {"id": "6844904064673808391", "title": "手把手教你配置 Webpack，并优化", "desc": "在平常的开发过程中，如果没有手动地配置或者优化打包后尺寸，那么用户打开网站时，首屏加载会很慢，几秒后才出现内容，大大增加了用户的等待时间。 为了解决这个问题，我们需要从打包这个环节进行优化。常见的优化打包工具webpack，我们从流行的React和Vue库着手，尝试着优化它们。…"}, {"id": "7000519839378833416", "title": "深入 Webpack5 等构建工具系列二(11) - css-loader 的 importLoaders 属性", "desc": "这是我参与8月更文挑战的第24天，活动详情查看：8月更文挑战 前面三节讲了关于 postcss 的内容，下面我们要讲一个属性。 第二节内容中我们提到可以在 index.css 文件中引入 test.c"}, {"id": "6844904000169607175", "title": "webpack构建流程分析", "desc": "webpack是一个强大的打包工具，拥有灵活、丰富的插件机制，网上关于如何使用webpack及webpack原理分析的技术文档层出不穷。最近自己也在学习webpack的过程中，记录并分享一下，希望对你有点帮助。 本文主要探讨，webpack的一次构建流程中，主要干了哪些事儿。 …"}, {"id": "6990220836644847629", "title": "webpack5-打包样式文件css,less,scss", "desc": "打包样式文件css 参考图 1.目录结构 2.新建目录下初始化项目 操作步骤 webpack.config.js"}, {"id": "6987404440743444487", "title": "webpack试练05之学以致用", "desc": "webpack基础的配置及进阶也学了一个大概了，怎样设计自己的构建配置呢，来简单聊聊 1、目录结构 lib test smoke unit .eslint .gitignore package.jso"}, {"id": "6844903869923737607", "title": "用 webpack 4.0 撸单页/多页脚手架 (jquery, react, vue, typescript)", "desc": "首先来简单介绍一下webpack：现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个会映射项目所需的每个模块 的依赖图(dependency graph)，并生成一个或多个 bundle。webpack4.0出现之后，…"}, {"id": "6844903689442820110", "title": "webpack loader和plugin编写", "desc": "首先我们先回顾一下webpack常见配置，因为后面会用到，所以简单介绍一下。 这里面我们重点关注 module和plugins属性，因为今天的重点是编写loader和plugin，需要配置这两个属性。 通过逐层识别模块依赖。（Commonjs、amd或者es6的import，w…"}, {"id": "6943153110609035277", "title": "webpack 打包后代码及调试全解析", "desc": "平时出于习惯，看到网站就喜欢去打开调试别人的，学习下别人是怎么去写代码的。但是现代的打包工具往往都把代码压缩和优化过了。所以如何调试以 webpack 为代表的这类网站，去看看别人家代码是怎么个逻辑写出来的？以及探索整个网站的逻辑流程，就是我们今天文章讨论的话题。 这篇文章会比…"}, {"id": "6955421936373465118", "title": "Webpack 原理系列二：插件架构原理与应用", "desc": "本文大部分篇幅都 focus 在 Tapable 框架，详细枚举了 Tapable 提供的钩子及各类型钩子的特点、运行逻辑、实现原理，并进一步讨论 Tapable 框架在 webpack 的作用"}, {"id": "7003322090187128868", "title": "webpack基础配置解析", "desc": "Webpack凭借强大的功能，成为最流行和最活跃的打包工具，也是面试时高级程序员必须掌握的“软技能”"}, {"id": "6844904190343381005", "title": "webpack系列之：babel的原理", "desc": "大家好我是林三心，因为之前校招面试被问过babel的原理，那我今天就写篇文章简单讲讲babel的原理吧。"}, {"id": "6844904127596593160", "title": "探索 webpack5 新特性 Module federation 在腾讯文档的应用", "desc": "腾讯文档从功能层面上来说，用户最熟悉的可能就是word、excel、ppt、表单这四个大品类，四个品类彼此独立，可能由不同的团队主要负责开发维护，那从开发者角度来说，四个品类四个仓库各自独立维护，好像事情就很简单，但是现实情况实际上却复杂很多。我们来看一个场景： 对于复杂的权限…"}, {"id": "6844903637450227726", "title": "基于后编译的国际化解决方案", "desc": "在之前做一些前端国际化的项目的时候，因为业务不是很复杂，相关的需求一般都停留在文案的翻译上，即国际化多语言，基本上使用相关的 I18n 插件即可满足开发的需求。但是随着业务的迭代和需求复杂度的增加，这些 I18n 插件不一定能满足相关的需求开发，接下来就和大家具体聊下在做国际化…"}, {"id": "6992943787366416397", "title": "webpack踩坑小结", "desc": "这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 目录： 1、webpack概念 2、入口 默认值、 对象、 字符串、数组、常见场景(实例演示) 3、输出 基本用法、 高级进阶（实例演示） "}, {"id": "6844904017013768205", "title": "【Webpack4】CSS 配置之 MiniCssExtractPlugin", "desc": "在配置 Webpack 时，需要区分用于开发模式还是生产模式。比如我们只需要在生产模式时压缩 CSS；而在开发模式的时候，我们又希望生成 Sourcemap 便于调试，以及样式热更新。那么，怎么在 webpack.config.js 中判断开发、生产模式呢？ webpack.c…"}, {"id": "6859934359638507534", "title": "想知道如何高效读懂 Webpack 源码, 然后吊打面试官? 那就进来吧.", "desc": "在一些书籍中有提到过好的代码应该是自文档的, 什么是自文档 ? 所谓自文档就是代码本身就是设计文档, 通过阅读代码你能够理解程序背后的设计思路. 要做到这点就必须从程序设计入手来构思代码的结构和逻辑, 那什么是一个程序的结构呢? 任何一个程序都有自己的结构, 这种结构一定程度上…"}, {"id": "6999551511688642591", "title": "webpack5 入门07 热替换", "desc": "01. 前言 热替换其实一直都有，我也一直没看，为什么呢???? 其实他本质上就是调试方便，更快的调试，而且还要专门写代码，所以一直不明白为什么需要这样一个功能? 我能想到的优势就是在项目比较大的时候"}, {"id": "6844903693373046792", "title": "基于vue-cli3 SSR 程序实现热更新功能", "desc": "通过上一篇文章 通过vue-cli3构建一个SSR应用程序 我们知道了什么是SSR，以及如何通过vue-cli3构建一个SSR应用程序。但是最后遗留了一些问题没有处理，就是没有添加开发时的热更新功能，难道要每次更新代码都要重新编译打包吗？显然不是很合理。那接下来我们将为该SSR…"}, {"id": "6922351695833858062", "title": "webpack", "desc": "webpack是一个用于现在javascript应用程序的静态模块打包工具。 当webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块，并生成一个或多个bundle。 plugin 目的在于解决 loader 无法实现的其他事，用于执行范围…"}, {"id": "6982869856668352548", "title": "webpack4流程分析7", "desc": "1. createModuleAssets(); 2. createChunkAssets 2.1 MainTemplate 2.2 ChunkTemplate 2.3 JavascriptModul"}, {"id": "6996572755634159629", "title": "webpack之plugin详解", "desc": "基本概念 plugin(插件)是webpack的支柱功能,webpack整体的程序架构也是基于插件系统之上搭建的,plugin的目的在于解决loader无法实现的其他功能. plugin使用方式如下面"}, {"id": "6917537202616401927", "title": "webpack 常用的插件列表-[七日打卡4]", "desc": "本文通过几个例子演示常用的webpack插件的作用以及使用方式，从而加深对webpack的理解。 说明：本文是基于webpack 4.x进行的实验。 webpack是模块打包器，可以把资源打包成javascript资源；webpack-cli是webpack的命令行接口，可以通…"}, {"id": "6844903629581713416", "title": "webpack 快速构建 React 学习环境（1）", "desc": "React 官方有一套脚手架工具，是初学者的最好选择，可以让初学者集中注意力在 React 本身。 本人对脚手架有点儿抵触（可能主要是对未知的恐惧），从开始学习 React 就走了自己搭建开发环境的路线，这里总结下搭建过程，希望能帮助和我一样不愿使用脚手架工具，但又急需一个练习…"}, {"id": "6844903941382078477", "title": "告别webpack，直接运行npm包", "desc": "2019年，距离es6正式发布已经过去了4年多了，es6给我们带来了许多新特性，包括全新的JavaScript模块系统（ESM），它可以直接在浏览器运行。但一般我们开发项目，还是要引入Browserify和Webpack等打包工具进行打包，诚然，这些打包工具可以给项目带来很多好…"}, {"id": "6844903713941749773", "title": "【手把手带你撸一个脚手架】第三步, 获取 github 项目信息", "desc": "ps 由于 github 开放 api 有请求次数限制(未授权每小时 60 次), 所以可能存在下图的情况, 解决方法是在请求中加入认证信息(authToken), 详情参考系列文章下一篇, 本节的临时处理方案为执行命令时候添加自己的 github 账号密码即可. 下集预告: …"}, {"id": "6978427674398031908", "title": "Webpack构建前端项目", "desc": "使用webpack构建前端项目,了解如何使用loader解析不同的文件以及项目中多入口文件的配置方式"}, {"id": "6844903636447789064", "title": "启动本地开发环境更快！webpack 动态入口构建的实现", "desc": "整个酷家乐主站有 100+ 页面，而且所有的页面都在同一个业务 repo 里，并且按照所属业务的不同划分了不同的页面目录，比如户型库、酷家乐大学等等，我们有着统一的 def-cli 命令行工具，它提供了工程开发各个生命周期（dev、build、deploy等）的支持，比如在命令…"}, {"id": "6850418113901985805", "title": "从实现一个简单的webpack中看广度深度算法", "desc": "第二步：生成依赖图谱。"}, {"id": "6953954696570601502", "title": "webpack加载逻辑细分", "desc": "一、分类 当前文件模块类型：esModule / commonJs 加载模块方式：import / import() / require() / require(表达式) 1、基本逻辑 2、当前文件模"}, {"id": "6888650479426469896", "title": "聊聊 webpack 异步加载（二）：webpack 如何处理 import()", "desc": "上篇文章解释了webpack是怎么加载拆包后的代码的，这篇文章解释下webpack如何处理import()。import()包含的代码被webpack当作chunk处理，同样也是通过window[\"w"}, {"id": "6844903933656170510", "title": "项目打包优化之DllPlugin", "desc": "DLLPlugin 和 DLLReferencePlugin 用某种方法实现了拆分 bundles，同时还大大提升了构建的速度。 DllPlugin: 将第三方依赖与项目分离，将所有第三方库代码单独打成dll文件，项目每次打包只需要打包本项目代码。 DllReferencePl…"}, {"id": "6844903680408289287", "title": "【译】Google - 使用 webpack 进行 web 性能优化（三）：监控和分析应用", "desc": "即使你可以通过配置 webpack 使得应用尽可能小，追踪它并且知道它包含什么仍然是很重要的。否则，你可能安装了一个让应用大了两倍的依赖却浑然不觉。 这节就来讲几个可以帮助你深入分析 bundle 的工具。 为了监控你的应用大小，可以在开发过程中使用 webpack-dashb…"}, {"id": "6844904181870886919", "title": "webpack中使用Loader打包静态资源", "desc": "由于webpack只能打包JS文件，当你在文件中引入Css样式，webpack并不知道你要做什么然后出现报错。"}, {"id": "6844903590956367879", "title": "一个简单易用的webpack4多页面脚手架配置加学习", "desc": "前言：以前刚接触webpack的时候还是1，当时大概过了下文档操作了一下当时写的一些注释。后来开发的时候基本写react都是用的create-react-app或者找别人的搭好的脚手架用。所以趁着这段时间的间隙加上webpack4刚出也不算久，重新学习加复习下webpack的一…"}, {"id": "6844903506214649864", "title": "webpack3--loader全解析", "desc": "Loaders are transformations that are applied on the source code of a module. They allow you to pre-process files as you import or “load” th…"}, {"id": "6952063546855260197", "title": "记录npx webpack-dev-server运行报错", "desc": "背景：今天休息无聊想用webpack搭个开发环境随便玩玩。发现报错时项目进度：报错信息如上，开始分析原因：操作和以前一样刚开始最简单的几步，第一反应是依赖包版本变化带来的bug，注意错误信息Canno"}, {"id": "6896712539212775437", "title": "webpack打包后的文件简单分析", "desc": "Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。 1. 新建测试模块"}, {"id": "6844903843029860359", "title": "Webpack打包优化", "desc": "使用 url-loader 优化， 将小图片转化成base64压缩,防止小图片太多请求次数太多。 打包后的bundle.js文件夹较大，所以每次加载的时候，请求比较慢，所以有必要在打包时将第三方包分离出来。使用CommonsChunkPlugin 插件进行配置。 使用 extr…"}, {"id": "6844904029454073864", "title": "JavaScript模块化规范（CommonJs AMD CMD UMD ES6）", "desc": "上面的函数m1、m2就相当于一个模块，使用的时候，直接调用就可以了。 但是这种做法缺点也很明显:由于函数是直接挂载在window(全局)对象下，\"污染\"了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 既然window对象的可命名属性名就那么多，…"}, {"id": "6844903593384869895", "title": "看看webpack都打出了些什么", "desc": "了解webpack打包出来的文件。 了解webpack流程并且自己写loader和plugin。 当然看源码是可以的，但是有点事倍功半并且没有必要，个人觉得完成以上两部分就可以对webpack有不错的了解了。本文主要关于webpack打包出来的文件的内容【希望能够提出不对或者可…"}, {"id": "6844903831973658638", "title": "Vue项目从webpack3.x升级webpack4不完全指南", "desc": "前段时间，泡面将自己的一个Vue-cli构建的前端框架从webpack3.x升级到了4.x版本，现在才拉出来记录一下，已备忘之用，也和大家分享一下，以免大家采坑。 eslint-loader 升级到了1.7.1,这个当时在做启动的时候提示了一些错误,所以索性也就升级了. min…"}, {"id": "7004746789907595278", "title": "webpack基础解析（一）", "desc": "1. webpack/webpack-cli webpack是代码打包工具，可以分析js代码里面各种引入的依赖关系。 webpack-cli是用于运行webpack的命令工具包。 对于一个纯净的项目，"}, {"id": "7005162310322880519", "title": "vue+webpack多个项目共用组件动态打包单个项目", "desc": "项目vue-cli3.0，实现了一个工程多项目共用一些资源，但是打包的时候只打包一个项目，并且每个项目也可以配置多页面"}, {"id": "7005496893551673357", "title": "webpack5构建实现--vue2.x版本", "desc": "构建webpack5版本的vue2.x项目实践。从开发环境、生产环境角度来区分打包。附带eslint代码风格检查"}, {"id": "6999989407264538654", "title": "简单的前端项目配置", "desc": "简单的前端项目配置 在前后端分离的时代，前端也需要开始配置各种环境，在之前的vue项目基本上我一直都是使用`vue cli`直接将环境搭建起来的，所以对于一些配置了解的不多"}, {"id": "6844903685407916039", "title": "Webpack揭秘——走向高阶前端的必经之路", "desc": "随着前端工程化的不断发展，构建工具也在不断完善。作为大前端时代的新宠，webpack渐渐成为新时代前端工程师不可或缺的构建工具，随着webpack4的不断迭代，我们享受着构建效率不断提升带来的快感，配置不断减少的舒适，也一直为重写的构建事件钩子机制煞费苦心，为插件各种不兼容心灰…"}, {"id": "6844904193589772301", "title": "总结18个webpack插件，总会有你想要的！", "desc": "何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。 Plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听…"}, {"id": "6978358599198343204", "title": "Webpack5源码分析一-Webpack5实现CommonJS模块化的原理", "desc": "Webpack 作为前端使用最广泛的打包工具（之一），它支持 CommonJS、AMD 和 ES module 模块化。本文将从源码分析 Webpack5 是如何帮助我们实现代码中支持CommonJS"}, {"id": "6854818576470933512", "title": "Webpack 原理浅析", "desc": "Webpack 迭代到4.x版本后，其源码已经十分庞大，对各种开发场景进行了高度抽象，阅读成本也愈发昂贵。但是为了了解其内部的工作原理，让我们尝试从一个最简单的 webpack 配置入手，从工具设计者的角度开发一款低配版的 Webpack。 假设某一天，我们接到了需求，需要开发…"}, {"id": "6844903591417757710", "title": "实战笔记：Jenkins打造强大的前端自动化工作流", "desc": "公司的前端构建及部署工作都是人工去做，随着业务扩大，项目迭代速度变快，人员增多，各种问题都暴露出来，本文是对前端自动化工作流进行探索后的一篇经验分享，将通过一个简单案例分享一下基于Jenkins的前端自动化工作流搭建的过程，搭建完这套工作流，我们只需要在本地发起一个git提交，…"}, {"id": "6998951353754058766", "title": "Webpack 打包后解析原理", "desc": "前言 通过前两篇文章 从0到1实现一个 Hello Webpack Webpack 基础配置 我们可以知道 webpack 的安装与使用，以及一些基本配置，最终可以实现一个自动构建过程，那么构建之后的"}, {"id": "6844904131035922446", "title": "跟着\"呆妹\"来学webpack(基础篇)", "desc": "你盼世界，我盼望你无bug。Hello 大家好！我是霖呆呆！ 先简单说一下标题的前因后果，避免吃瓜群众不明白何为\"呆妹\"。 设计师，配几个狗头的表情包。 好嘞。 所以这波安排一下\"呆妹\"吧，谁叫我是一个信守承诺的博主呢。 （希望大家不要像此博主一样为了人气不择手段败坏掘金的风气…"}, {"id": "6844904183917871117", "title": "在淘宝优化了一个大型项目，分享一些干货（Webpack，SplitChunk代码实例，图文结合）", "desc": "本项目是淘系用户增长团队的一个大中台系统，单页应用，涵盖很多业务功能，运用了很多懒加载页面组件来提升性能，首屏时间 1s 左右，体验良好。然而大项目文件很多，导致构建和发布时间很长，内存占用较大。我的任务是尽可能优化与此相关的问题。 首先不难发现问题并不在用户体验上，而在于开发…"}, {"id": "6907040632045305863", "title": "基于webpack打包多页应用,对前端工程化的思考", "desc": "..."}, {"id": "6991766176212729887", "title": "[vite]大型react项目从webpack迁移到vite到底能快多少", "desc": "前言 自从尤大vite2.x写完后，好评如潮，我想尝试下vite，看看在本地到底能比webpack快多少，所以拿手头一个比较大的react项目改造下来测试。本文不包含vite原理，vite相关介绍请看"}, {"id": "6972741467605303304", "title": "build时顺便生成个zip压缩包，很难嘛?", "desc": "都1202年了，你还在手动zip压缩？本文就教你使用webpack的FileManagerPlugin插件，妈妈再也不怕我被测试同事催打包了！"}, {"id": "6844904142675279886", "title": "浅谈 webpack 性能优化（内附巨详细 webpack 学习笔记）", "desc": "笔者最近在整理关于 webpack 相关的知识点，一方面是因为自己掌握的知识点比较零碎、不够系统，有时候碰到问题不知从何下手，另外一方面 webpack5.0 已经在路上了，这的确是一个让人头秃的消息。 笔者把系列的文章都扔在了这个仓库：webpack 学习整理文档，有兴趣的同…"}, {"id": "7003252688406183950", "title": "webpack三招必杀技", "desc": "相信每个前端同学一定都使用过webpack，作为一个划时代的构建工具，却有很多同学对他的认识还停留在怎么改个host的认知上。由于现代的脚手架极大地提高了项目搭建的效率，但是工具的便捷性，自动化和完善"}, {"id": "7002179953156423716", "title": "边学边想webpack5源码一起读(4)", "desc": "引言 本文章基于webpack5源码进行解读，编写本文仅为方便作者学习以及记忆，如果有什么说的不对或者瞎猜的不对的地方，请大家指出，请勿乱喷，大家都是自己人感谢大家～ 地址 从本章节开始会开始加上之前"}, {"id": "6998170732588957709", "title": "聊聊webpack解决了什么问题", "desc": "这是我参与8月更文挑战的第18天，活动详情查看：8月更文挑战 浏览器在解析js时的盲点 要理解webpack是个什么东西，解决了什么问题，我们首先要理解前段的一个最大的坑，就是浏览器在解析js的时候，"}, {"id": "6973607639502553095", "title": "10分钟带你升级webpack5", "desc": "前言 最近很多小伙伴们都在问vite都出来了，webpack还有必要升级到5么？vite是不是很快就要取代webpack了？ 针对这个问题，我个人观点是：适合你项目的构建工具就是最好的。当前前端的构建"}, {"id": "6958080070292340749", "title": "从零学习Webpack核心机制Loader、Plugin到彩蛋原理分析", "desc": "一起深入Wepcak , 尽管 Vite 非常火爆确实很香,但是 Webpack 依然在企业占据主导地位以后我也不知道, 学习深入非常有必要，主要介绍loader / plugin 和原理分析，"}, {"id": "6991653445161713671", "title": "Webpack5学习 --- source-map", "desc": "Source map就是一个信息文件，里面储存着位置信息。也就是转换后的代码的每一个位置，所对应的转换前的位置。有了它，进行调试时，调试工具将直接显示原始代码，而不是转换后的代码。"}, {"id": "7001481323919441957", "title": "【8.28】webpack 打包性能优化", "desc": "这是我参与8月更文挑战的第26天，活动详情查看：8月更文挑战 1. 使用 gzip 压缩打包后的 js 文件 这个方法优化浏览器下载时的文件大小（打包后的文件大小没有改变） webpack.confi"}, {"id": "6956522989810614308", "title": "谈谈tree-shaking", "desc": "在前端领域中，tree-shaking指的是消除没被引用的模块代码，减少代码体积大小，以提高页面的性能。 在传统"}, {"id": "6844903998634328072", "title": "Webpack 4 Tree Shaking 终极优化指南", "desc": "几个月前，我的任务是将我们组的 Vue.js 项目构建配置升级到 Webpack 4。我们的主要目标之一是利用 tree-shaking 的优势，即 Webpack 去掉了实际上并没有使用的代码来减少包的大小。现在，tree-shaking 的好处将根据你的代码库而有所不同。由…"}, {"id": "6993275177647751182", "title": "webpack 学习系列(二)：你可能不知道 tree shaking", "desc": "相信使用过 webpack 的小伙伴，对 tree shaking 功能都不会陌生。**tree shaking**, 通常用于移除 javascript 上下文中未使用的代码(dead-code)。"}, {"id": "6899648307736526855", "title": "不会吧不会吧！不会还有人npm start不能冲进5s内吧！", "desc": "随着项目不断迭代，所需的静态资源、依赖库和插件越来越多，需要遍历的文件也呈指数式增加，导致每次编译的速度非常慢，再加上笔者接手的是类游戏化的Phaser项目，光是游戏引擎也需要消耗资源，固对项目进行编译时的优化。 通过看到Time:xxx ms的信息，是不是觉得整个项目直接芜湖…"}, {"id": "6993980561471569956", "title": "webpacak5 入门01 代码分离", "desc": "代码分离. 这一章的目的在于重用以及基本的缓存 首先第一部分在于提出公用的，比如都是 loadsh 是公用的部分。 如果正常发布的话，index.js 和 another-module.js. 都会打"}, {"id": "6888528583623933966", "title": "【前端工程化】篇四 席卷八荒-Webpack（进阶）", "desc": "声明：本篇文章基于webpack v4.43.0，如按照文中代码执行报错，请检查依赖模块版本是否和示例代码仓库中一致。 *温馨提示：*本篇内容更偏实战，涉及大量代码，如有代码密集恐惧症的老爷，请速速离场。 在上一篇的内容中，介绍了webpack的核心概念以及常用的核心配置，并尝…"}, {"id": "6992225481382690829", "title": "Webpack的ModuleFederation原理分析及发散", "desc": "光会用怎么行？尝试分析了一下ModuleFederation黑科技背后的秘密，以及在其原理基础上浪了一把~"}, {"id": "6844903987129352206", "title": "Webpack源码解读：理清编译主流程", "desc": "webpack的熟练使用已成为当代前端工程师必备的生存技能。毋庸置疑，webpack已成为前端构建工具的佼佼者，网络上关于如何使用webpack的技术文档层出不穷。但鲜有能将webpack的构建流程讲清楚的。本文尝试从解读源码以及断点调试的方式，来探究 webpack 是如何一…"}, {"id": "6844904149746745357", "title": "探索webpack4与webpack5多项目公共代码复用架构", "desc": "先抛出一个尖锐问题：MPA 多页应用或微前端架构，如何处理页面的公共部分。 引入公共模板，这样在访问页面时会直接渲染公共部分。 但如果是现代化工程（比如 React），可前后端又未分离的MPA项目（页面仍由后端渲染，Dom 渲染交由 React 接管），我们就会将构建后的资源文…"}, {"id": "6844903555673882632", "title": "手把手教你撸一个 Webpack Loader", "desc": "经常逛 webpack 官网的同学应该会很眼熟上面的图。正如它宣传的一样，webpack 能把左侧各种类型的文件（webpack 把它们叫作「模块」）统一打包为右边被通用浏览器支持的文件。webpack 就像是魔术师的帽子，放进去一条丝巾，变出来一只白鸽。那这个「魔术」的过程是…"}, {"id": "6961724298243342344", "title": "有点难的知识点：Webpack Chunk 分包规则详解", "desc": "Chunk 是什么？Webpack 如何根据 entry、异步模块、runtime 配置组装 Chunk？"}, {"id": "6844904138954801166", "title": "前端工程化：webpack-chain", "desc": "webpack-chain 是什么？通过链式的方式修改webpack的配置。 一些列出本人常用的使用webpack-chain的方式修改webpack配置. 整个文件为： 有时候需要xx插件在aa插件之前调用。 有时候需要xx插件在aa插件之后调用。 webpack4.x默认使…"}, {"id": "7000305600068321294", "title": "你不得不懂的 webpack", "desc": "这是我参与 8 月更文挑战的第 8 天，活动详情查看： 8月更文挑战 1、webpack 简介 2、安装 webpack 2.1、环境准备 安装 node 版本参考官⽹发布的最新版本，可以提升 web"}, {"id": "6844904161515929614", "title": "揭秘webpack插件工作流程和原理", "desc": "通过插件我们可以扩展webpack，在合适的时机通过Webpack提供的 API 改变输出结果，使webpack可以执行更广泛的任务，拥有更强的构建能力。 本文将尝试探索 webpack 插件的工作流程，进而去揭秘它的工作原理。同时需要你对webpack底层和构建流程的一些东西…"}, {"id": "6914174100193673229", "title": "parcel 打包工具", "desc": "webpack官网的首屏图片就已经很清楚的描述了他的工作原理，这里我们来简单理解一下webpack打包的核心工作过程。 我们以一个普通的前端项目为例，在我们的项目中一般都会散落着各种各样代码及资源文件，webpack会根据我们的配置找到其中的一个文件作为打包的入口，一般情况这个…"}, {"id": "6988082769268047886", "title": "基于Ice.js构建项目的webpack打包优化实践", "desc": "由于目前本地启动dev服务大概需要1min,云上构建生产版本至少需要5min。生产版本的资源体积也较大，虽然是内部项目，但该做的还是得做，因此决定从加快构建速度、减小资源体积2个方面进行优化。"}, {"id": "6987305781834022949", "title": "Webpack 热更新原理", "desc": "用过 webpack 的同学应该都知道，有一个特别好用的『热更新』，在不刷新页面的情况下，就能将代码推到浏览器。 今天的文章将会探寻一下 webpack 热更新的秘密。"}, {"id": "6844903504792797197", "title": "webpack & HTTP/2", "desc": "HTTP/2 可以多路复用，所有模块都可以并行使用同一个连接，因此多个请求不再需要多余的往返开销。每个模块都可以独立缓存。 很遗憾，现实并不如意。 下面的文章详细解释了相关信息，并且做了一些实验来验证。你可以阅读它们（或者跳过它们，只看总结）。 The Right Way to…"}, {"id": "6844903549139173384", "title": "从搭建vue-脚手架到掌握webpack配置（二.插件与提取)", "desc": "很多插件功能是在开发环境（development）用到的但是在生产环境（production）用不到的，反之亦然。比如 ...... 第二种方法涉及到二次封装，就像官方vue-cli构建的项目一样，分成了三个配置文件，对目前的我们来说比较复杂，我们使用第一种方法，设置环境变量来…"}, {"id": "6844904167081771022", "title": "webpack4配置总结(六)", "desc": "上一篇整理了plugins的配置。这篇开始整理webpack其他的一些配置项。 resolve是指定webpack打包构建过程中模块如何解析的相关配置。比如代码中的模块路径怎么解析，文件名怎么解析。这里简单整理一下两个配置项extensions及alias。 extension…"}, {"id": "6844903503463186446", "title": "Webpack 核心开发者 Sean Larkin 盛赞 Vue", "desc": "dev.io 近日邀请了 Webpack 核心开发者 Sean Larkin 回答开发者提问，其中几个问提比较有意思，和掘金的小伙伴们分享一下。 有一个开发者问 Sean 如何成为一个热门项目的核心作者。Sean 没有一上来就说该做什么，而是先告诉提问者需要明确自己是否对该项目…"}, {"id": "6844903942736838670", "title": "从0搭建自己的webpack开发环境（一）", "desc": "自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 执行npm run build，默认会调用 node_modules/.bin下的webpack命令，内部会调用we…"}, {"id": "6844903573386428423", "title": "webpack针对循环引用以及赋值export的处理注意事项", "desc": "从上面两段代码的📢处代码行可以看到，使用赋值语句export的代码打包后，对exports上的属性的赋值将在import(也就是__webpack_require__)后，另一种使用申明函数语句export的代码打包后，对exports上的属性的赋值将在import(也就是_…"}, {"id": "6984797197309050910", "title": "webpack5 文档笔记", "desc": "webpack5 的文档笔记 起步 安装需要的webpack 新建配置文件 webpack.config.js 添加内容 资源管理配置 加载css 首先下载需要的loader yarn add sty"}, {"id": "6947577318760316964", "title": "webpack5以上抽离配置文件（生产开发分明）", "desc": "在我们开发过程中，经常在webpack.config.js文件中配置很多东西，不管是开发环境下，还是生产环境下。但是当我们在生产环境下打包时，其实很多我们开发环境下的配置时用不到的。那么当我们把所有的配置写在一个文件中时，那时不太稳妥的。 因此我们需要抽离配置文件。 最后我们还…"}, {"id": "6922330710158573581", "title": "配置babel解决webpack打包ES6语法报错", "desc": "这个错误意味着你的代码里有es6语法，webpack不能打包es6，需要babel转换。 所以本文就讲一下webpack中如何配置babel来打包es6语法的代码。"}, {"id": "6844904119128293384", "title": "不懂Webpack4的前端不是好工程师（进阶篇）", "desc": "包含了 Tree Shaking，Code Spliting，打包环境区分，缓存，shimming 等内容，继续扩展 Webpack 的基础知识面。 执行npx webpack打包后，打算dist/main.js可以看不到没有用到的minus方法也一并打包了，这种就造成我们打包…"}, {"id": "6844903548858138631", "title": "全新打包工具parcel零配置vue开发脚手架", "desc": "parcel-plugin-vue这个插件会通过vueify来生成对应的代码，parcel会自动加载parcel-plugin开头的依赖。 只需要执行npm run dev 和 npm run build 就可以进行开发和构建。"}, {"id": "6844904015566733319", "title": "分享一个egg + webpack4多页面开发脚手架", "desc": "egg是一款优秀的企业级node框架，比较常用的使用场景是：1.用来做BFF层，2.用来做全栈应用，3.做服务器端渲染页面，SEO优化。理论上它属于服务器端的开发，浏览器端的代码还是需要有一套机制来进行组织，这样我们前后端开发起来才能比较好的进行融合，如html、css、js这…"}, {"id": "6917155155737575437", "title": "webpack--学习记录--基础一", "desc": "1、初始化一个项目，要有package.json文件在目录文件中执行npminit-y之后就会自动创建一个package.json2、安装webpack、webpack-cli3、在目录下创建一个sr"}, {"id": "6854573213070917639", "title": "搭建一个基于react+TS+antd的组件库(2)", "desc": "上一篇主要讲述了npm package的发布、更新、删除、开发过程中的调试，以及拥有一个私有库的几种方式，这篇来讲讲怎么把我们写的代码编译打包（即各种语法转换成ES5）出来后，各个环境（浏览器、node）都可以使用，且不局限引用方式，即可以用ES6的import，node的re…"}, {"id": "6844903503064743943", "title": "基于 react, redux 最佳实践构建的 2048", "desc": "前段时间 React license 的问题闹的沸沸扬扬，搞得 React 社区人心惶惶，好在最终 React 团队听取了社区意见把 license 换成了 MIT。不管 React license 如何，React 都是一个值得好好学习的优秀视图库。 本项目算不上什么大型项目…"}, {"id": "6844904063612485646", "title": "Webpack源码分析 - css是怎样被处理的", "desc": "很久很久以前我们在写页面时，通常将css单独写成文件引入，有时也直接在html里写css非常方便，这时页面也不多动效也不需要，写几个页面一把梭就能应付。 渐渐地网页成了大众获取信息的主要方式，这时的网站信息也越来越丰富，对网页的质量要求越来越高，这一时期一些前端自动化构建工具慢…"}, {"id": "6921682416465608711", "title": "Webpack的hash策略", "desc": "每个文件都具有相同的哈希值，因为它hash是基于我们使用的所有源文件生成的。 如果我们重新运行该构建而不更改任何内容，则生成的hash将保持不变。 如果我们仅编辑一个文件，则hash值将发生变化，并且所有生成捆绑的名称中都会包含此新hash。 chunkhash是根绝不同的入口…"}, {"id": "6844903831562616839", "title": "Webpack原理简单讲解", "desc": "webpack是JavaScript应用程序的静态模块打包器,webpack处理应用程序时,将递归构建一个依赖关系图,依赖图映射了项目中需要的每一个模块,并打包生成一个或多个bundle. entry属性将告诉webpack从哪个模块开始构建依赖图,并计算出所有这个模块直接或间…"}, {"id": "6844903976794587149", "title": "Vue-Cli项目webpack打包优化", "desc": "所以分享下我的经验。 最后是mian.js的修改，我看网上不少都是要把包的引入去掉，但是我发现不需要，而且去掉了就报错了。 以上如果有哪里说得不对或者建议，欢迎的大家的留言分享交流，谢谢。"}, {"id": "6915635012536631309", "title": "webpack搭建React项目（1）", "desc": "根据webpack官网的解释来说，webpack是一个现代 JS 应用的 bundler，翻译过来就是打包器。webpack会根据模块之间的依赖最终合并模块形成一个或者多个 bundles。 添加 dist 文件夹，在 dist 文件夹添加一个index.html文件，插入&#…"}, {"id": "6904937858042183693", "title": "聊一聊 webpack 中的 preloading 和 Prefetching", "desc": "首次访问时，index.js 1 MB，lodash.js 1 MB ， 需要加载的大小是 2 MB，而且此时可以进行并行加载，速度一般会比上面的快。 业务代码改变用户再次访问时，index.js 1 MB，由于 lodash.js 文件并没有发生变化，所以无需再次加载，因为浏…"}, {"id": "6938759466158391304", "title": "梳理 Webpack 热更新 | 技术点评", "desc": "在 webpack.config.js 文件中设置 devServer.hot 为 true，启用 HMR 特性。另外要用上 HMR 特性则还需要配置 HotModuleReplacementPlugin 插件。如果不想配置这个插件，也可以在 webpack-dev-serve…"}, {"id": "6847902219803574285", "title": "NPM脚本支持多环境配置打包", "desc": "1.使用cross-env插件2.脚本命令编写3.使用weback.DefinePlugin()方法4.使用总结"}, {"id": "6844903920318316552", "title": "Webpack4配置【基础篇】", "desc": "1. 什么是webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 2. webpack核心概念 En…"}, {"id": "6875190650754023438", "title": "系列连载｜真·手撸前端工程设施（1）", "desc": "社区对于使用 Typescript 的好处讨论甚多， 本文就不做过多阐述， 反正就是， 用就完事儿。 eslint 是一个代码检测工具，它遵循一定的规则， 使用它能够很好的避免开发者写出 💩 一样的代码， eslint 基本的工作原理是 1.使用 parser 解析代码 2.…"}, {"id": "6896834197055373319", "title": " Webpack学习笔记（二）", "desc": "webpack-dev-server 是 Webpack 官方推出的一款开发工具，根据它的名字我们就应该知道，它提供了一个开发服务器，并且将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。 可能大家都听说过'热更新'这个词，在使用Vue或React官方提供的脚…"}, {"id": "6844903581909270536", "title": "webpack小记", "desc": "入口文件，可以是对象，数组，字符串。 对象，key是可以做输出名字。 path，输出目录，绝对路径。 alias，设置别名。 noParse，如果确定一个模块没有其他的依赖，可以配置这项。可以提高打包的速度 rules，是一个规则数组，每一项是一个对象，配置loader。 在w…"}, {"id": "6844903813682315277", "title": "基于webpack4.x项目实战2 - 配置一次,多个项目运行", "desc": "今天我们继续来webpack4.x的实战第二部分，只需要配置一次，就可以多个项目一起使用。 我们可以引用公共项目的代码，所有项目共享。 我们引入了commander这个库来接收一些命令，比如产品名--dirname=xxx(也可以为-d xxx)、端口号--port=xxx，这…"}, {"id": "6869022921638019079", "title": "手把手教你实现一个简易版Webpack", "desc": "作为一名前端开发工程师，想必大家在工作和学习中少不了跟Webpack打交道，本文从手写Webpack的角度，一步一步带你实现一个简易版的Webpack，顺便让大家了解一下Webpack的原理。 分析入口文件，读取模块并递归读取模块所依赖的文件内容，生成AST语法树。 使⽤@ba…"}, {"id": "6938326935273635848", "title": "webpack初学第二篇：什么是loader(上)", "desc": "这是今天抽空学习做的学习笔记呀，今天了解了一点点loader，学了一些有关使用loader进行静态资源打包的方式，比如 css文件，sass文件，图片等打包。还没学完，明天继续学。要下班啦，回家做饭洗衣服了~ loader可以将文件从不同的语言(比如TypeScript)转换为…"}, {"id": "6844904032964722696", "title": "webpack源码分析 - 调试", "desc": "webpack源码写的还是比较绕，各种回调，递归和异步跳来跳去，刚开始跟代码时容易迷失方向。console.log在处理复杂流程就稍显薄弱，调试简单的代码还行，但是遇到各种异步方法和递归调用时，只通过log打印出来的东西很难看得懂。看代码时有时候需要我们深入到各个子流程中，有时…"}, {"id": "6844904050853429262", "title": "Webpack实战（六）：如何优雅地运用样式CSS预处理", "desc": "目前比较流行的几种主要是Sass、LESS、Stylus、PostCSS，今天我主要分享的是Sass、LESS在webpack中的配置及使用情况。 Sass本身是对CSS的语法增强，它有两种语法，现在使用更多的是SCSS（对CSS3的扩充版本）。所以你会发现，在安装和配置loa…"}, {"id": "6899094440829255688", "title": "Webpack中Source Maps的底层原理与使用", "desc": "当我们使用webpack打包源代码的时候，可能很难追踪到原始的报错位置。比如：我们把多个js源文件打包到一个bundle.js里，当其中某一个源文件出错时，浏览器的报错只会指向bundle.js，这样很不利于代码调试。 Webpack中的Source maps，正是为了解决这个…"}, {"id": "6844903725291569159", "title": "用webpack写个现代的JavaScript包", "desc": "webpack 作为目前主流的构建工具，其较快的版本迭代和复杂的配置方式，使得每次开发前不得不规划相当部分时间来调试。这里将记录整个环境的搭建过程，为新手提供基础思路。 以上三个作为开发一个组件(package)是基础中基础的需求，当然还有更多细节内容需要添加，由于篇幅过长另加…"}, {"id": "6844903760041345037", "title": "Web字体图标-自动化方案", "desc": "Web从诞生之日起是为了展示图片和文字的，最典型的代表就是img和span。这是构建丰富的Web页面的基石，也是理解浏览器表现（Browser performance）的基础。本文将从从图片中的小图标切入，介绍一下Web中小图标的技术方案的演进。 笔者本来打算从Image Sp…"}, {"id": "6901635487581093895", "title": "webpack 基础配置解析", "desc": "入口（entry）：webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 输出（output）：webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。 loader：能够去处理那些非 JavaScript 文件（webpack 自身只理解 Ja…"}, {"id": "6902761903605415950", "title": "重学webpack(开发环境的配置)", "desc": "实际的工作场景中我们往往会确定一个入口文件，例如叫做index.js文件,该文件会引入所有依赖文件，例如.less样式文件、.sass样式文件、Jquery等第三方文件，有的这些文件是无法被浏览器解析直接呈现出来的，如果我们一个一个的手动去调整文件在大型项目中是十分繁琐易错的，…"}, {"id": "6844904100534943757", "title": "从零配置webpack 4+react脚手架（二）", "desc": "你可能也注意到了，html文件中的关于js的引用是我们手动写的，那假如我们改了输出路径或打包编译之后的文件名，那我们岂不是还要手动去修改html文件中的引用？我们怎么做到，像create-react-app中那样一旦你修改了某个文件内容，页面会自己刷新？我们来一步一步实现它们，…"}, {"id": "6959751222572089352", "title": "webpack打包js文件，无法被引用", "desc": "使用webpack打包插件的错误姿势，尝试了各种姿势没有一种是可行的，最重要的是不知道败在了哪一步。"}, {"id": "6844904047229566989", "title": "webpack 4 源码主流程分析（七）：构建 module（下）", "desc": "runLoaders 运行结束后，回调里得到经 loader 编译后的模块代码字符串 result 和对应的 resourceBuffer。 在回调里执行了 createSource 后，判断 loader 的 result 是否有第三个参数对象并且里面存在 webpackAS…"}, {"id": "6844904103848443912", "title": "如何使用 splitChunks 精细控制代码分割", "desc": "前端小伙伴都知道，为了降低包大小，经常会把依赖的前端模块独立打包，比如把 vue、vue-router 打到一个单独的包 vendor 中。另外，常会将存在多个路由的复杂页面的每个页面都单独打一个包，只有访问某个页面的时候，再去下载该页面的js包，以此来加快首页的渲染。 无论是…"}, {"id": "6947851867422621733", "title": "Webpack-chain 从入门到深入", "desc": "webpack 的核心配置的创建和修改基于一个有潜在难于处理的 JavaScript 对象。虽然这对于配置单个项目来说是没有什么问题的，但当你团队中有比较多项目，并且尝试所有项目共享 webpack 配置文件时，你会觉难以入手，因为你需要考虑构建配置的可扩展性，比如某个子项目有…"}, {"id": "6919684767575179278", "title": "webpack4 之 cacheGroups 分包【究极奥义】", "desc": "近来遇项目打包之事，撰文记之。以期分享，皆有所获。 基于这个两个前提，我们再进行下一步。 其中 analyzerMode 的设置比较重要。 得出如上图的分包并不难，vue-element-admin 自带这些配置。 如果你暂时还看不懂这些配置项，先别急，后面会一一陈述。 你只用…"}, {"id": "6844903617971879949", "title": "手把手教你撸一个简易的 webpack", "desc": "随着前端复杂度的不断提升，诞生出很多打包工具，比如最先的grunt，gulp。到后来的webpack和Parcel。但是目前很多脚手架工具，比如vue-cli已经帮我们集成了一些构建工具的使用。有的时候我们可能并不知道其内部的实现原理。其实了解这些工具的工作方式可以帮助我们更好…"}, {"id": "6844903688222277640", "title": "优秀前端必知的话题：我们应该做些力所能及的优化", "desc": "在 Web 应用开发过程中，我们经常谈及到的就是优化，而优化往往又是既简单而又复杂的过程，优化这个命题很广，最终体现出来的都是用户体验问题，我们一切优化都是为了用户体验。 为什么说简单？在现代 Web 开发生态中，有非常优秀的工具链帮助我们做一些很实际的优化工作，例如 webp…"}, {"id": "6986560320315588645", "title": "我是这样搭建React+TS的通用webpack脚手架的（阶段二）", "desc": "回顾上一阶段，搭建了的是一个适配了普通的 js 代码的基础 webpack 框架：我是这样搭建React+TS的通用webpack脚手架的（阶段一）。但是，还存在几个主要问题：没有装载任何 ui 框"}, {"id": "6942362094264287268", "title": "按需打包 UI 组件库原理探究", "desc": "总算给自己找了一个相对合理的理由，哈哈。既然有人这么想，跟随一起探索下哈。 Antd 4.X 版本是利用 webpack 基于 ES modules的 treeshaking 实现的按需加载。 根据入口文件，递归查询相关依赖，然后通过各种 loader 和各种 plugin ，…"}, {"id": "6983974056991129631", "title": "使用 Webpack 🔧 构建 Shadow DOM 组件", "desc": "借助 Webpack 构建工具，构建可阅读性与可维护性更高的 Shadow DOM 组件，解决一些开发痛点。"}, {"id": "6844903782371819527", "title": "全新版本仿网易云音乐来啦", "desc": "在前端技术领域中，我们可以切身感受得到技术的更新、变革的速度是非常快的，所以工程师们都会需要时常关注和学习一些新技术、新标准。 因为在工作中负责项目的技术栈相比于业界来说，算比较落后了，所以自己动手来开发一个音乐类 web app，可以尝试一些新技术栈，或者往一些特定方向深挖学…"}, {"id": "6977632707790503967", "title": "完结！手把手教你使用webpack打包前端组件（三）", "desc": "回顾前两篇文章中，我们从一个现成的`webpack-template`中，逐步逐步地修改构建出了一个组件调试的页面，当组件调试没问题之后，我们就要对组件进行一个打包操作让其他用户可以使用。"}, {"id": "6998756141966721037", "title": "webpack系列学习笔记", "desc": "本文整理了webpack前端资源构建工具以及静态模块打包器相关知识总结，如果对答案有不一样见解的同学欢迎评论区补充讨论，当然有问题，也欢迎在评论区指出。 参照引用尚硅谷webpack教程视频"}, {"id": "6990927763884474376", "title": "Webpack5 系列（一）：基础篇", "desc": "基础篇主要介绍：为什么使用 Webpack， Webpack 打包流程， Webpack 的本源， Webpack 的配置文件， 简化 Webpack 打包流程。"}, {"id": "6989506173447700511", "title": "通过Webpack 打包vue脚手架的初步教程", "desc": "配置开发时的前端工程（vue-loader+webpack） 好，到这里，我们项目的大概的初始化工作就完成了。接下来我们就基于这样的目录，填充一下更丰富的细节。 我们在工程目录下新建一个src文件夹用"}, {"id": "6995505488355917855", "title": "深入浅出webpack-loader", "desc": "webpack-loader 如何加载资源模块 如我们需要加载xxx.less文件的话，那么我们一般会选择三个loader,他们分别是less-loader,css-loader,css-loader"}, {"id": "7003985371063124005", "title": "Webpack打包速度优化实践", "desc": "随着项目的增大，webpack的打包速度已成前端工程师的“不可承受之重”。最近对团队内某项目的打包速度进行了一些优化，本文没有具体的配置教程，只提供一些优化思路，供启发和参考。 更换更快的打包工具 1"}, {"id": "6992790939664121893", "title": "DescriptionDataMatcherRulePlugin | webpack5 报错问题", "desc": "背景 vue-loader@16.3.1 webpack@5.48.0 我装的最新的 webpack4升级webpack5遇到的其中一个问题 就在我一通操作，美滋滋的升级webpack5之后，它报错了"}, {"id": "6844903858179670030", "title": "实现一个简单的Webpack", "desc": "大家好，我是神三元，今天通过一道面试题来和大家聊一聊webpack。 我相信，尽管很多开发者会根据官方文档进行webpack的相关配置，但仍然并不了解Webpack究竟是起什么作用的，在前端工程化扮演者什么角色，观念仍然简单地停留在“代码打包工具”上。真的是这样吗？ 相信这个定…"}, {"id": "7002582652872032270", "title": "深入 Webpack5 等构建工具系列三(5) - webpack 对字体文件的打包", "desc": "这是我参与8月更文挑战的第29天，活动详情查看：8月更文挑战 开发中，除了图片资源，可能还会有其它的资源需要打包，比如说字体文件。如果我们需要使用某些特殊的字体或字体图标，就会引入很多字体相关的文件，"}, {"id": "6989491439243624461", "title": "webpack4 从零搭建 vue 项目开发环境", "desc": "前言 我相信不少朋友和我一样，刚开始学习 vue 的时候，都是用 vue-cli创建的项目，vue-cli确实是个好东西，让我们不需要关心 Webpack 等一些繁杂的配置。 然后直接开始写业务代码。"}, {"id": "6844903726981840904", "title": "webpack系列之一总览", "desc": "webpack 对于每个前端儿来说都不陌生，它将每个静态文件当成一个模块，经过一系列的处理为我们整合出最后的需要的 js、css、图片、字体等文件。来自官网的图很形象的阐述了 webpack 的功能 —— bundle js / css / ... （打包全世界ヾ(◍°∇°◍)…"}, {"id": "6844904195963912205", "title": "实现自定义 Webpack Loader", "desc": "以上实现的自定义 loader，比较基础，属于入门级。"}, {"id": "6969858414130233351", "title": "webpack 插件入门", "desc": "最近写了一个移动端项目，不过每次 build 的时候还需要手动上传服务器感觉很不方便，毕竟每次删除文件夹然后拖拽上传的过程太重复了，本着不重复造轮子的原则去 Github 翻了一下，发现 Upload"}, {"id": "6916111018653384711", "title": "webpack4打包优化", "desc": "随着项目迭代，需要的前端依赖、js、css、静态资源等不断增加，代码越来越冗余，导致打包后的文件过大，打包速度也变得越来越慢。最近的项目打包时间已经近5分钟，再加上jenkins部署时的依赖安装、文件上传等，一次构建需要7-8分钟，这样的速度，严重影响到了开发及发版效率。 因此…"}, {"id": "6844903709873274894", "title": "webpack+git开发环境将git中tag自动显示到web中", "desc": "每个文件里面记录着commit 标识,也就是该tag是在哪个节点上的,这里我们暂时不用处理那么深入(也许这个功能在别的地方能用到). 那我们就可以获取这些文件名称,然后再进行遍历得到tag编码最大的那个就好了,(通常tag都是逐渐增大的). 获取到最大的tag后导出一个对象出去…"}, {"id": "6844903516843016199", "title": "webpack构建下换肤功能的实现思路", "desc": "到这里，运行 webpack && node cssExtract.js,index.html就变成上面期望的那样，我们得要了皮肤文件的一个mapping,并保存在window.cssUrls中，接下来，通过切换按钮的方式切换皮肤\b还是什么其他的就可以自由发挥了."}, {"id": "6844903846330777608", "title": "webpack 代码分离快速指北", "desc": "js 代码的分离操作，首先要考虑的就是对异步代码的分离。这里使用 dynamicImport cacheGroups: 缓存组。 reuseExistingChunk: 表示可以使用已经存在的块，即如果满足条件的块已经存在就使用已有的，不再创建一个新的块。 如果是动态 impo…"}, {"id": "6844903557125111816", "title": "前端每周清单第 49 期：Webpack 4 Beta 尝鲜，React Windowing 与 setState 分析，Web Worker 实战", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID: frontshow），及时获取前端每周清单。 iOS 11.3 与 macOS 10.…"}, {"id": "6898345812003454983", "title": "Webpack性能优化", "desc": "这篇是B站公开课的部分笔记，关于性能优化，老师讲得不太多但是很精炼。 对性能的评估一般从体积和编译速度两个方面出发，Webpack性能优化也可以从打包结果优化和构建过程优化两个维度来入手。 1. 使用TerserPlugin terser是uglify-es的一个分支，保留了与…"}, {"id": "6844903783038730248", "title": "前端资源加载重试", "desc": "对于TO C的应用，用户网络千差万别，总有各种网络问题导致资源加载失败，使得访问时出现白屏，样式错乱等。资源加载重试，则是提高用户体验中重要的一环。"}, {"id": "6938656367393636360", "title": "webpack基本配置", "desc": "学习到了webpack的配置，截止到目前，还是挺复杂的，版本问题经常出bug。留个笔记记录一下吧~ 从本质上讲，webpack是一个现代的JavaScript应用的静态模块打包工具。 gulp更加强调的是前端流程的自动化，模块化不是它的核心。如果工程模块依赖非常简单，甚至没用到…"}, {"id": "6957516618905862175", "title": "webpack学习笔记(一) 核心概念", "desc": "这篇文章我们先来简单看看 webpack 中几个的核心概念，并粗略学习一下配置文件的写法......"}, {"id": "6844903509112930317", "title": "【译】如何在生产环境中部署ES2015+", "desc": "大部分前端开发人员热衷于使用新的 JavaScript 语言特性来书写 JS 代码，例如 async 、 await 、 classes 、 arrow functions 等。然而，尽管目前所有的前沿浏览器都能运行 ES2015+ 代码（译注：ES2015及俗称的ES6），自…"}, {"id": "6844903541635547150", "title": "使用 Webpack 打包单页应用的正确姿势", "desc": "前言：在现代前端工程中，模块化已经成了前端项目组织文件的标配，网站上线前都会把需要的相关模块预先打包、处理一番。然而打包的方式多种多样，如何才能最优雅的分离业务代码和依赖库、如何才能最高效的利用缓存？本文将会和大家分享饿了么前端团队总结的各方案优劣、踩过的坑，以及最终的解决方案…"}, {"id": "6914955583166627853", "title": "Webpack 懒加载源码逐行解读 探究原理与实现", "desc": "至此， webpack的懒加载实现就讲完了。是不是感觉非常简单呢"}, {"id": "6844903972055023630", "title": "webpack 4 源码主流程分析（十四）：webpack 优化", "desc": "前面一至十一章，介绍了在 development 的模式下，整个完整了构建主流程。在了解构建流程的基础上，本章整理一些与 webpack 优化相关的知识点。 我们参考 production 模式里，里面已经做了大部分的优化，如压缩，Scope Hoisting， tree-sh…"}, {"id": "6844903856489381896", "title": "webpack HRM", "desc": "Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对…"}, {"id": "6844903954258591758", "title": "十分钟上手webpack打包配置", "desc": "webpack其实就是一个打包工具。它可以将各种当下主流的sass，less，tsx,vue,jsx,json甚至png,svg等各种格式的文件转化为浏览器可以识别的html，css，js和图片资源文件。将他们按照各种依赖关系，整合在一起，输出到一个bundle文件中。 web…"}, {"id": "6910071686373064718", "title": "webpack4.0各个击破（3）—— Assets篇", "desc": "一. Assets资源的基本处理需求 二. webpack处理引用资源 webpack通过file-loader处理资源文件，它会将rules规则命中的资源文件按照配置的信息（路径，名称等）输出到指定目录，并返回其资源定位地址（输出路径，用于生产环境的publicPath路径）…"}, {"id": "6844903920574136334", "title": "webpack深入学习笔记", "desc": "1. 先查找是否有开源的css模块的Loader 2. 安装对应的Loader Loader是转换器，那Plugin就是插件，插件是作用在Loader上的，相当于功能的拓展。 1. 查找相应的插件Plugin 2. 安装相应的插件 3. 在配置文件中添加plugin参数，插件参…"}, {"id": "6933131280410214407", "title": "Webpack4散记（2）dll", "desc": "所谓dll：动态链接库。这本是个windows范畴的叫法。 这两天对webpack自带的DllPlugin和DllReferencePlugin两个插件做了一下研究，感觉在开发阶段的性能优化方面更适用。 这个方案的核心思想是空间换时间：先使用DllPlugin生成dll包（包含…"}, {"id": "6916435372947800071", "title": "初识 Webpack", "desc": "Webpack 是一个流行的前端项目构建工具（打包工具），可以解决当前 web 开发中所面临的困境，是⼯程化、⾃动化思想在前端开发中的体现。 工作的重心放到具体的功能实现上，提高了开发效率和项目的可维护性。。 npx webpack -v 检查是否安装成功 npx(npx 的原…"}, {"id": "6844903858552979470", "title": "webpack 之 LoaderRunner 全方位揭秘", "desc": "绝大多数人都在使用 webpack 作为构建工具。那么 loader 作为处理各种资源的工具，大家肯定也不会陌生。很多人没写过 loader，但是都对 loader 的具体怎么写，怎样执行的一无所知。那么本文就对 3.0.0 版本做一个全方位的揭秘。 所谓 loader 只是一…"}, {"id": "6844904158164680717", "title": "webpack(三)-性能优化", "desc": "寻找第三⽅模块，默认是在当前项⽬录下的node_modules⾥面去找，如果没有找 到，就会去上⼀级目录../node_modules找，再没有会去../../node_modules中找，以 此类推，和Node.js的模块寻找机制很类似。 默认情况下，webpack会从⼊口文…"}, {"id": "6844903566637793293", "title": "基于 Webpack 开发、调试和构建多页面站点（普通 Web 站点）的前端工程化方案", "desc": "基于 Webpack 开发、调试和构建多页面站点（普通 Web 站点）的前端工程化方案，同时适用于 PC 端和移动端。"}, {"id": "6844903605288304648", "title": "从开发到发布一款基于Vue2x的图片预览插件", "desc": "项目地址:vue-picture-viewer先来看下DemoLiveDemo关于开发Vue插件的几种方式（具体请移步官网）Vue官网我采用第一种方式来编写这个插件1.第一步创建项目vueinitwe"}, {"id": "6844903735081041928", "title": "webpack-tapable-0.2.8 源码分析", "desc": "webpack 是基于事件流的打包构建工具，也就是内置了很多 hooks。作为使用方，可以在这些钩子当中，去插入自己的处理逻辑，而这一切的实现都得益于 tapable 这个工具。它有多个版本，webpack 前期的版本是依赖于 tapable 0.2.8 这个版本，后来重构了，…"}, {"id": "6844903509712699399", "title": "Webpack-源码三，从源码分析如何写一个plugin", "desc": "经过上一篇博客分析webpack从命令行到打包完成的整体流程，我们知道了webpage的plugin是基于事件机制工作的，这样最大的好处是易于扩展。社区里很多webpack的plugin，但是具体到我们的项目并不一定适用，这篇博客告诉你如何入手写一个plugin，然后分析源码相…"}, {"id": "6844903509431681031", "title": "webpack中hash和chunkhash是不是很眼熟？", "desc": "后者很容易理解，因为chunk在webpack中的含义就是模块，那么chunkhash根据定义来就是模块内容计算出来的hash值。 这里我们还得提一个问题，比如像vue这些框架，把js和css共同放在一个里面会时，我们一般会用一个插件叫extract-text-webpack-…"}, {"id": "6844903745059291149", "title": "记一次 react 15.3.1 老项目升级到 react 16.7.0 之路", "desc": "互相交流学习，请加我微信:iyangyuanjian，QQ:6245089141、前言该项目是公司内部服务与外部服务的中台系统，我称之为大杂烩项目始于：2015年10月8号18:31:39秒恩，没错，"}, {"id": "6844903606886334477", "title": "Webpack 打包优化之体积篇", "desc": "谈及如今欣欣向荣的前端圈，不仅有各类框架百花齐放，如Vue， React， Angular等等，就打包工具而言，发展也是如火如荼，百家争鸣；从早期的王者Browserify, Grunt，到后来赢得宝座的 Gulp， 以及独树一帜的 fis3, 以及下一代打包神器 Rollup…"}, {"id": "6948753133866582047", "title": "webpack缓存优化", "desc": "babel解析js是非常耗时的，想象一下，假如我们有100个js文件，某一时刻只修改了其中一个，构建的时候还是会对这100个文件进行解析，这显然是不够高效的。这时候我们可以给babel加一个缓存，再次构建时，对那些没有发生修改的js文件，直接从缓存中读取解析结果而不需要重新解析…"}, {"id": "6940057840006463518", "title": "从零学脚手架(七)---webpack-dev-server使用", "desc": "使用vue-cli 、react-cli脚手架时，执行yarn start命令会启动一个本地服务器，浏览器访问服务器就可以预览代码，并且代码文件更新后页面会重新加载数据，非常方便，这个功能就叫做dev-server。 在webpack中，由webpack-dev-server提…"}, {"id": "6884421864991653902", "title": "webpack的安装与使用（一）", "desc": "最近发现大部分程序员对webpack的理解都基于各种框架给我们设置好的配置，没有去深入了解，包括我自己本身，于是打算自己分享一下自己学习webpack配置的过程。第一章节介绍了："}, {"id": "6948727661233438751", "title": "写一个简单的webpack打包工具", "desc": "我们在项目中新建一个bin文件夹，在bin目录下创建start.js文件，这个文件的主要作用就是将webpack的基础配置传入编译模块（compiler），然后开启编译过程。 用babel.transformFromAst将ES6的AST转换成ES5的AST，并将AST转换成代…"}, {"id": "6844903587751919624", "title": "vue-cli webpack3 扩展多模块打包", "desc": "场景在实际的项目开发中会出现这样的场景，项目中需要多个模块（单页或者多页应用）配合使用的情况，而vue-cli默认只提供了单入口打包，所以就想到对vue-cli进行扩展实现首先得知道webpack是提"}, {"id": "6899075267982327816", "title": "写自己的UI库时遇到的问题", "desc": "1. 在examples/main.js中引用index.less文件，运行npm run dev时报错如下： 于是google之后发现，很多在做项目或自己的UI库时都会遇到这个问题，是因为用vue-cli 2.0构建项目时在webpack.base.conf.js中配置了一遍…"}, {"id": "6844904181866709005", "title": "webpack中关于Loader插件的使用", "desc": "webpack识别不了除js文件以外的资源文件，这个时候我们就要用到Loader来帮忙打包。"}, {"id": "6844903560421834760", "title": "前端每周清单第 50 期: AngularJS and Long Term Support, Web 安全二三论，React 与 Clean Code", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID: frontshow），及时获取前端每周清单。 TypeScript 2.7 发布: 本…"}, {"id": "6898526711810359304", "title": "webpack配置指南", "desc": "本篇文章主要配置webapck的流程，以及遇到的问题。都是基础的配置，有的不一定适合项目中，熟练掌握后可以运用自如。 webpack-dev-server是webpack官方提供的一个小型Express服务器。使用它可以为webpack打包生成的资源文件提供web服务"}, {"id": "6844903944091598862", "title": "从0搭建自己的webpack开发环境（二）", "desc": "通过使用不同的loader，Webpack可以把不同的文件都转成JS文件，比如CSS、ES6/7、JSX等。 通过对loader的使用，我们了解到loader可以把其他类型模块都处理成JS模块，以便加载使用。这其实就是webpack中非常重要的混淆依赖中的一部分。"}, {"id": "6844904051574833159", "title": "关于webpack问答记录...", "desc": "webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模…"}, {"id": "6844903570836291591", "title": "【Webpack的使用指南 02】Webpack的常用解决方案", "desc": "【Webpack的使用指南 02】Webpack的常用解决方案"}, {"id": "6844903861451227150", "title": "编写一个webpack的loader（1）", "desc": "第一个 loader 的传入参数只有一个：资源文件(resource file)的内容。compiler 需要得到最后一个 loader 产生的处理结果。这个处理结果应该是 String 或者 Buffer（被转换为一个 string） ，代表了模块的 JavaScript 源…"}, {"id": "6844903864592777229", "title": "webpack系列之六chunk图生成", "desc": "这篇文章主要是通过源码去探索下 webpack 是如何通过在编译环节创建的 module graph 来生成对应的 chunk graph。 我们都知道 webpack 打包构建时会根据你的具体业务代码和 webpack 相关配置来决定输出的最终文件，具体的文件的名和文件数量也…"}, {"id": "6844903607960092685", "title": "webpack从0到1使用指南", "desc": "关于为什么要使用webpack，我比较认同的一种说法是： webpack可以很好地管理你开发中遇到的各种HTML、JS、CSS以及各种图片资源文件，同时对应不同的资源，webpack还提供了对应的Loaders将其进行转化为适用于浏览器使用的格式 后会无期里面，阿吕说过这么一句…"}, {"id": "6844903561403301896", "title": "webpack-loader实现一个简化版gitbook", "desc": "最近在看weppack-loader，不看不知道，当我翻到markdown-loader的时候，大吃一惊，简直精简的不能再精简了，除去require和export语句，一共就有四行。基本上loader的作用一目了然：在js进入执行之前对其做改动。 babel-loader是最常…"}, {"id": "6844903509054193671", "title": "在线追踪压缩后的JS出错代码", "desc": "解决思路对于不要压缩，这点肯定是不能妥协的，用户体验是坚决不能牺牲的，但是能不能从压缩着手呢？答案是肯定的，第一时间，我们应该就会想到sourcemap，在sourcemap上来解决问题怎么利用sou"}, {"id": "6972946891734515719", "title": "webpack入门须知", "desc": "什么是webpack webpack是一个用于现代javascript应用程序的静态模块打包工具,在使用webpack处理应用程序的时候,他会根据我们命令行的参数中或者是配置文件中定义的模块列表开始处"}, {"id": "6906742300454584334", "title": "webpack之初探Tapable", "desc": "webpack 的强大，离不开 Tapable 库的功劳。在整个打包构建的流程中，会涉及很多个阶段，每个阶段都会调用相应的钩子。钩子里可以挂上插件，当触发钩子的 call 方法时，里面的插件就会一一被通知执行，而 Tapable 库就是提供这些钩子。 注册：通过基类实例的 ta…"}, {"id": "6844903558991593485", "title": "使用 SVG 图标: (2) 编写 Webpack plugin", "desc": "在上篇文章中，主要讨论了 gulp-svg-sprites 的使用以及 Icon 组件的编写。上文中我们是手动复制 SVG symbol 文件的内容粘贴到 index.html。这样操作起来十分不方便，所以在本篇文章中我们通过编写 webpack 插件去实现操作的自动化。 1.…"}, {"id": "6844903588049715208", "title": "Webpack入坑之旅のdemo篇", "desc": "咳咳，其实之所以有本文，只是一个怎么学也学不进去怎么记也记不住API的webpack入门萌新的曲线救国之路。嗯，做个demo以增加对webpack的亲近感，正所谓生活就像 哔 ，与其想要反抗不如躺下享受。【笑CRY】 首先我们需要利用npm-link来实现一个全局命令，类似于w…"}, {"id": "6844903988849016845", "title": "Webpack-基础篇之资源的输入输出", "desc": "context的目的就是在多入口的情况下让entry的编写更加简洁；同时也可以省略，默认为根目录。 上面配置的意思是我们提取了一个叫vendor的chunk name，并且以数组的形式将第三方库房里进去，那么问题来了，我们没有设置入口路径，webpack如何打包的呢？我们可以使…"}, {"id": "6844903648540131342", "title": "浅析Service Worker", "desc": "1、https: Service Worker必须是https协议的，但本地环境下http://localhost或者http://127.0.0.1也可以的。 1、service worker让离线缓存成为可能，offline情况下也可以访问页面。然而销毁比较困难，更新会有问…"}, {"id": "6935989575009599525", "title": "641 webpack 配置和css处理：默认打包，配置文件，依赖图，css-loader，style-loader，less-loader", "desc": "windows系统不需要加后面的参数，只需要写npx browserslist即可。"}, {"id": "6904512596280508423", "title": "webpack小记", "desc": "--- # 主题列表：juejin, github, smartblue, cyanosis, channing-cyan, fancy, hydrogen, condensed-night-purp"}, {"id": "6914093373221502990", "title": "webpack代码拆分", "desc": "入口点：使用entry配置手动拆分代码。 防止重复：使用Entry依赖项或SplitChunksPlugin对重复数据块进行重复数据删除和拆分。 动态导入：通过模块内的内联函数调用拆分代码。 拆分代码的最简单，最直观的方法。更手动的，并且有一些陷阱。 index.js,prin…"}, {"id": "6913848284599549966", "title": "webpack 打包工具", "desc": "webpack 作为一个模块打包工具，本身就可以解决JavaScript 模块化代码打包整合的问题，它可以将项目中零散的 js 文件打包到同一个 js 中。 webpack 的核心代码是一种被称作 Webpack Bootstrap 的代码，在这段核心代码中，__webpack…"}, {"id": "6844903622208454670", "title": "Parcel React 开发服务器热更新实战", "desc": "Parcel 是 Web 应用打包工具，适用于经验不同的开发者。它利用多核处理提供了极快的速度，并且不需要任何配置。 官网教程没有实现devSever和动态更新相结合具体部署步骤。 本文通过极少的配置项实现基于Parcel打包，React开发环境实时热更新，作为官网教程的延申。…"}, {"id": "6844903886696906766", "title": "前端模块化二——webpack项目中的模块化", "desc": "本文章为第一篇关于前端模块化前端模块化一——规范详述的续篇。 主要将结合webpack实际项目来讲解这些规范，包括webpack项目中用到的NodeJS模块的其路径分析、文件定位、模块解析。 以及webpack对CommonJS、AMD、CMD、ES6模块化的支持情况、使用。 …"}, {"id": "6844903540868005895", "title": "加速Webpack-缩小文件搜索范围", "desc": "Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 根据导入语句去寻找对应的要导入的文件。例如 require('react') 导入语句对应的文件是 ./node_modules/react/react.js，require('./ut…"}, {"id": "6844903949741506568", "title": "webpack 实战(1) - 入门篇", "desc": "这篇专栏文章介绍了 webpack 的概念与基础用法，并且介绍了常用的实际应用场景，相信看完后就可以搭建一套自己的 web 构建程序。 path： 打包后的文件目录。 filename：打包后的文件名字。可以用 [name] 的形式对文件名占位 url-loader: 内置了 …"}, {"id": "6915665292370640910", "title": "webpack优化生成代码（2）", "desc": "babel-loader始终是项目处理任务最多的 loader，尤其是 React 开发过程中，有大量的 JSX 需要去解析，编译。从babel-loader的配置项入手可以进行一些优化。babel-loader使用的插件集合主要是@babel/preset-env和@babe…"}, {"id": "6844903866081755144", "title": "webpack 配置多页面应用的一次尝试", "desc": "多页面，首先最重要的就是处理多个 html 模板和对应的多个入口文件。 babel-loader 解析 ES6 语法。 MiniCssExtractPlugin 进行 css 压缩。 html 中 img 标签的图片可以被解析。 如果 img 标签的 src 为空的话，就报错 …"}, {"id": "6903067416570544141", "title": "利用 stats.json 定位 @nrwl/react webpack 配置问题", "desc": "团队使用NX这一 monorepo 工具来搭建 React 应用。NX 基于 React 应用在 webpack 打包时添加了url-loader的相关配置。但是同事反馈该url-loader针对部分引用的图片文件不起作用。 url-loader，简而言之，可以将应用中引用到的…"}, {"id": "6952906106490322981", "title": "从编码到发包实现一个简单的loader", "desc": "从编码到发包实现一个简单的loader 需求：实现一个loader，在$ajax请求接口函数里包裹上async await标识"}, {"id": "6844903630420590606", "title": "webpack之babel配置和HMR", "desc": "webpack 是前端开发最常用的模块打包器之一，我们可能是使用github上提供的脚手架如react-boilerplate，也有可能根据自己的项目来写webpack配置。无论你是属于哪一种情况，你还是要熟悉webpack的相关配置才能更好的使用它。 接下来主要介绍webpa…"}, {"id": "6844903779498721294", "title": "工程优化暨babel升级小记", "desc": "这里删除了'babel-preset-stage-2'，因为为了避免概念模糊不清以及防止出现由于提案的删除或变更而导致不可预见问题，故而babel@7+中删除了阶段预设。 其他依赖包从v@6+升级到v@7+，并采用babel@7+中的最新官方包名称。 用于antd按需加载的ba…"}, {"id": "6844903508135657480", "title": "基于webpack构建的angular 1.x工程（angular篇）  ", "desc": "上一篇基于webpack构建的angular 1.x 工程（一）webpack篇里我们已经成功构建了整个项目的打包配置。接下来我们要继续让angular在工程里跑起来。 之前的工程由于是用gulp打包的，具体原理我不太懂，不过貌似会把所有的js自动注入到index.html中。…"}, {"id": "6938692094873567263", "title": "webpack4学习（2）-优化", "desc": "inline：map.js内联，在代码最未。增加文件体积 eval： map.js内联，在每个文件代码后嵌入。增加文件体积 [hash]每次webpack构建会生成一个唯一的hash，每次重新打包hash都会变。缓存无效 [chunkhash]:根据chunk生成hash，如果…"}, {"id": "6901309809664983054", "title": "前端模块化-webpack", "desc": "webpack在打包的时候，遇见图片文件等，根据我们配置文件中的配置匹配到对应的文件加载器，文件加载器遇见这样的文件，先是将我们导入的文件，拷贝到输出的目录，然后将拷贝的目录的输出路径作为当前模块的返回值返回，这样对于我们的应用来说，所需要的资源就被发布出来了，同时可以通过模块…"}, {"id": "6844903593464561678", "title": "1分钟了解借助webpack对项目进行分析优化", "desc": "进入公司之后，接手的便是前人留下来的一个大项目。庆幸的是整个项目拥有完善的产品功能文档，但是由于项目过于庞大，老旧。包含了打包过慢，冗余文件过多等诸多问题。想要快速的解决这些问题，想要完全把功能重构一遍的话，成本太高了。一个一个文件来过，时间成本也比较大。因此在此篇文章中，我们…"}, {"id": "6844904117647704077", "title": "💪从零开始学习webpack系列十（图片处理）", "desc": "图片处理引入图片的方式在JS动态创建img标签引入但是这样还是不行，还需要file-loader进行解析安装yarnaddfile-loader-D打包后就会看到有一张图片在css中背景图片引入css"}, {"id": "6844903763950436365", "title": "在2019使用差异化服务", "desc": "如果你正在阅读本文，那么你可能就是那种一直在寻找务实，前瞻性思维方式来提高网站速度的人。所以，当我读了由菲尔·沃尔顿写的一个被称为差异化服务的指南后，我很感兴趣。如果你还没有听说过这种技术，其实就是你可以为你的站点编译和提供两个独立的JavaScript捆绑包： 一个捆绑包包含…"}, {"id": "6844903655301185550", "title": "ES6深入浅出 模块系统", "desc": "一步，一步前進の一步。 模块化主要是帮助我们更好的组织代码，模块允许我们将相关的变量和函数放在一个模块中。在 ES6 模块化之前，JS 语言并没有模块的概念，只有函数作用域和全局作用域非常容易发生命名冲突。之前的 RequireJS、SeaJS、AMD、UMD、CMD啥的，在一…"}, {"id": "6844904143962767368", "title": "基于vue-cli2.0项目中Webpack的升级与优化（未完待续）", "desc": "在基于vue-cli2.0脚手架开发的项目至今已经有一年半的时间了，因为业务在不断迭代的关系，项目的代码已经达到8w行了，从而导致了webpack打包编译的速度越来越慢。为了项目的长治久安，我决心要对这个项目中的webpack进行升级与优化。 如果存在以下错误，那是由于extr…"}, {"id": "6844904110471266318", "title": "webpack的初体验", "desc": "整个配置中我们使用 Node 内置的 path 模块，并在它前面加上 __dirname这个全局变量。可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作 当你在本地安装 webpack 后，你能够从 node_modules/.bin/webpack 访问它…"}, {"id": "6844903507691044872", "title": "如何配合Webpack模块打包器使用Polymer库", "desc": "今天我怀着十分激动的心情，来给大家炫耀一下一个新工具polymer-webpack-loader加载器，它能理解消化HTML文件的导入，并输出Webpack能打包的模块。"}, {"id": "6844903537650958350", "title": "你所不知的Webpack-多种配置方法", "desc": "除了通过最常见的导出一个 Object 来描述 Webpack 所需的配置外，还有其它更灵活的方式，以简化不同场景的配置。 下面来一一介绍它们。 在大多数时候你需要从同一份源代码中构建出多份代码，例如一份用于开发时，一份用于发布到线上。 如果采用导出一个 Object 来描述 …"}, {"id": "6844903517434413063", "title": "JavaScript开发工具简明历史", "desc": "JavaScript开发要用到的工具越来越多，越来越复杂，为什么呢？你真的弄明白了吗？"}, {"id": "6844903829566128141", "title": "Webpack4入门系列(一)", "desc": "webpack是现代JavaScript应用的静态打包工具。当webpack处理应用时，它内部会生成一个映射你项目需要的每个模块的依赖图，并生成一个或多个包。 自从版本4.0.0后，webpack不需要配置文件就能打包你的项目，然而如果有需要，它也是极易配置的。 这篇文档旨在提…"}, {"id": "6844904032864043015", "title": "webpack知识点", "desc": "hash是跟整个项目的构建相关，构建生成的文件hash值都是一样的，所以hash计算是跟整个项目的构建相关，同一次构建过程中生成的hash都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。 如果出口是hash，那么一旦针对项目中任何一个文件的修改，都会构建整个…"}, {"id": "6844904086534356999", "title": "webpack中tapable原理详解，一起学习任务流程管理", "desc": "学习webpack源码时，总是绕不开tapable，越看越觉得它晦涩难懂，但只要理解了它的功能，学习就会容易很多。 如上例子所示，每一种hook都会有两个方法，用于添加任务和触发任务执行。在同步的hook中，分别对应tap和call方法。 1. 并行 2. 串行可熔断 3. 串…"}, {"id": "6844903934918656013", "title": "webpack-从零开始定制一个vue-cli（第一小步）", "desc": "用vue的都知道vue-cli是一个强大的构建vue项目的工具。vue-cli3.0前，它所有的配置都能看到，到vue-cli3.0后所有的配置都隐藏了。最近刚好有点空闲时间，就试着开始搭建了一个自己的vue-cli。这个是第一步：基于webpack4搭建基本的vue开发环境。…"}, {"id": "6844903650934915080", "title": "如何写一个js模块打包器(翻译)", "desc": "在看阮一峰老师的每周分享后，看到了一篇关于如何写一个模块打包器的一篇英文文章，之前基本没有了解过，只知道如何使用webpack等，所以这一篇对我来讲很及时，好记性不如烂笔头，所以先尝试着把它翻译出来。 大家好！。。。（客套话）欢迎来到我的酒馆，今晚累的够呛，但只要有客人来玩我都…"}, {"id": "6844904072294858759", "title": "Webpack 核心模块 tapable 解析(各个Hook详解)", "desc": "Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，是对前端项目实现自动化和优化必不可少的工具，Webpack 的 loader（加载器）和 plugin（插件）是由 Webpack 开发者和社区开发者共同贡献的，而目前又没有比较系统的开发文档，想写加载…"}, {"id": "6844903564758745102", "title": "webpack 源码探索之插件机制", "desc": "最近在一直在为面试做准备，搜了很多大佬记录的面试经验和面试内容，对自己不太熟悉和已经记忆模糊的知识点内容进行复习巩固，争取能够有一个好的状态。这篇文章以我的经验讲述了我是如何从源码的角度了解到 webpack 插件机制，也简单描述了 webpack 编译构建的机制。 使用 vs…"}, {"id": "6898288448986152973", "title": " Webpack学习笔记（三）", "desc": "在之前的几章里面，我们介绍了webpack的打包编译功能。能通过loader、plugin机制帮助我们构建代码。虽然构建代码很大程度上便利了我们的生产环境，但是我们实际的代码和我们开发的代码会有很大的差异，当出现错误的时候，我们很难直接定位到源代码中对应的位置。 而Souce …"}, {"id": "6935945840900964365", "title": "模块化开发", "desc": "由于早期的前端技术标准根本没有预料到前端行业没有今天这样一个规模，所以说很多设计上的遗留问题就导致了现在去实现前端模块化的时候会遇到很多问题。虽然说现如今一些问题都被一些标准或者工具去解决了，但是它的一个演进过程是值得思考的，这个过程就是模块化思想在前端领域的实践过程。这个过程…"}, {"id": "6936500100537516046", "title": "webpack进阶(代码转换/依赖分析)", "desc": "JavaScript 是一门编译型语言。"}, {"id": "6904476635559362567", "title": "webpack之小白篇", "desc": "由于对webpack的了解是一个小白阶段，所以我通过观看视频，以及书籍，针对webpack的相关知识进行了学习，来总结记录一下，以便后来观看，于是开启了我的掘金之旅，请多多指教。 由于前端发展迅速，编写的源代码不能直接运行，需要构建工具将源代码转换成可以执行的HTML,java…"}, {"id": "6974314276878188558", "title": "webpack入门级理解", "desc": "首先，我们要知道的是webpack只干了一件大事儿：递归构建了一个依赖关系图，并打包生成了一个或多个bundle。"}, {"id": "6983226811349991460", "title": "webpack详解", "desc": "目录 1.认识webpack 2.安装webpack 3.webpack的起步 4.webpack的配置 5.loder的使用 6.webpack中配置vue 7.pulugin的使用 8.搭建本地f"}, {"id": "6942687041180139528", "title": "webpack编译打包 JS / TS", "desc": "@babel/preset-env设置useBuiltIns：\"entry\"时，需要手动引入polyfill，设置useBuiltIns：\"usage\"时，polyfill作为全局对象引入，容易造成全局变量污染。@babel/plugin-transform-runtime可以…"}, {"id": "6909482744225464333", "title": "Webpack学习笔记七：其他文件的打包", "desc": "上一节我们介绍了如何对css做兼容性处理，以及如何将代码中的css单独提取成css文件，并对其进行压缩处理。结合前几个章节的内容，我们已经知道了在webpack中如何对js以及css文件处理。那么除了js与css文件外，类似于 html资源、 图片资源 以及 其他的资源 又该怎…"}, {"id": "6909459619324788750", "title": "webpack-loader简简单单配置入门", "desc": "大部分场景我们只需要test匹配即可，但应对一些复杂的情况我们可以通过以下规则进行匹配。 { test: ... } 指定特定后缀名文件 { include: ... } 指定特定的文件路径 { exclude: ... } 排除特定的路径 也可以是一个对象：use: { lo…"}, {"id": "6896763503676588040", "title": "Webpack 系列之模块对象", "desc": "Webpack 的事件流机制是靠 Tapable 实现的，Tapable 是 Webpack 自带的模块，不需要单独安装，在 Webpack 被安装的同时它也会一并被安装。Tapable 主要提供了以下钩子，分为同步 / 异步，异步又分为并行和串行。 所有类型的钩子都有一个可选…"}, {"id": "6844903638192619533", "title": "如何使用JavaScript控制台改进工作流程", "desc": "作为Web开发人员，很有必要了解如何调试代码。后台开发我们经常使用外部库来记录日志，并在某些情况下格式化显示日志，前端我们会使用断点和控制台，但是我们浏览器的控制台比我们想象的要强大得多。 当我们考虑控制台时，首先想到的是console.log，对吧？但是它比我们想像中使用的方…"}, {"id": "6889823675600601096", "title": "webpack5.0+SSR尝鲜【排坑记录】", "desc": "因为Node.js 服务器是一个长期运行的进程 当代码进入进程时，它将进行一次取值并留存在内存中。也就是会把vue实例保存到内存中 假如说不用函数返回新的实例，那么每个人访问同一个页面时都会共用同一个实例，那么就会造成数据的污染。 首屏只渲染一个路由，但是其他路由的逻辑混淆再j…"}, {"id": "6844903606450126861", "title": "换个角度学 Webpack", "desc": "对 Webpack 可以说既熟悉也陌生，熟悉是因为工作中天天都在用到，陌生则是没怎么从头到尾去了解过，都是别人配好的，网上一些学习 Webpack 的文章都是上来就说怎么配怎么配，好吧，我脑子不够灵光记不住，于是乎换一种理解的方式来学习 Webpack。"}, {"id": "6844903705762873352", "title": "基于 Babel 来实现一个前端模板", "desc": "先前我们前端模板用的是 primer-template，这是一个语法和 EJS 类似的轻量级的 JS 模板。但是它不支持全局变量、不支持嵌套函数、不支持 HTML Encode 等。综合考虑了下决定还是基于 Babel 自己重新来撸一个吧。"}, {"id": "6980238993296195621", "title": "Umi使用webpack5 Module Federation", "desc": "Umi使用Webpack5 Module Federation 探索，可以动态运行另一个JavaScript应用的代码，同时可以共享一依赖。"}, {"id": "7004297344300777502", "title": "Webpack5 系列（五）：Tree Shaking", "desc": "一、前言 上一篇讲到对JS语法的处理，本篇将介绍 Tree Shaking 。 我们经常会在主文件或者组件文件中引入其他模块中的代码，但实际上我们只用其中的一部分，剩下的代码则不需要引入。然而在默认情"}, {"id": "7004125458723766280", "title": "webpack如何转译commonjs模块和es模块", "desc": "webpack如何转译commonjs模块和es模块的导入和导出，以及如何写出一个更好的模块。..."}, {"id": "6924258563862822919", "title": "Webpack5 新特性业务落地实战", "desc": "Webpack5 在 2020 年 10 月 10 日正式发布，并且在过去的几个月中快速演进和迭代，截止 1 月 28 日，Webpack5 已经更新了 18 个 minor 版本，带来了许多十分吸引人的新特性。据官网介绍，Webpack5 整体的方向性变化有以下几点： 最后的…"}, {"id": "6844903718387875847", "title": "脑阔疼的webpack按需加载", "desc": "随着单页应用发展的越来越庞大，拆分js就是第一要务，拆分后的js，就可以根据我们需求来有选择性的加载了。 这里就添加了一句，chunkFilename而已，chunkFilename的作用就是用来给拆分后的chunk们起名字的配置项。 还是只打包出了一个main.js，毫无变化…"}, {"id": "6844904007362674701", "title": "webpack 中那些最易混淆的 5 个知识点", "desc": "前两天为了优化公司的代码打包项目，恶补了很多 webpack4 的知识。要是放在几年前让我学习 webpack 我肯定是拒绝的，之前看过 webpack 的旧文档，比我们内部项目的文档还要简陋。 但是最近看了一下 webpack4 的文档，发现 webpack官网的 指南 写的…"}, {"id": "6984252133453332487", "title": "✌️✌️✌️ 续篇 | 使用现成webpack模板 | 学习效率大大提升", "desc": "在开发者成长的路上，学习是必不可缺的，在传统页面中我们调试可能需要手动去配置一些选项，使用现成webpack模板你可能只需要配置一些额外的选项，这可以大大提升我们的学习效率！"}, {"id": "7003667868868935687", "title": "webpack—使用 Babel 处理 ES6 语法（转成ES5）", "desc": "Babel: 下一代 JavaScript 语法的编译器。 webpack如何配置，实现es6转es5呢？看这篇就够了"}, {"id": "7000925144545755166", "title": "webpack掠影-3", "desc": "前面我们已经讨论过如何让 webpack 处理 CSS，并提取出文件，以及图片的处理。接着我们讨论一下在 webpack 中配置 babel、压缩js/css 文件"}, {"id": "6992371317605400590", "title": "为什么 Webpack 使用 tapable 插件系统（包含设计思想、使用手册和插件系统对比）", "desc": "tapable 是为了使系统更容易扩展而抽象的库。它要求将程序设计为一套流程，然后开发者可以在任意的流程节点中进行扩展，达到开发者想要扩展的目的。"}, {"id": "7002800224871645215", "title": "webpack 配置详情", "desc": "1.entry 1.创建文件 2.修改配置文件 运行指令:webpack 2.output 1.创建文件 2.修改配置文件 运行指令:webpack 3. module 1.创建文件 2.修改配置文件"}, {"id": "6844903636963688456", "title": "手写一个webpack4.0配置", "desc": "确认过眼神，你还是没有准备秋招的人？时间仓促。自京东6月8号开启管培生的招聘，就意味着秋招的开始。然而你还在等着秋天的到来？今年形势应该更为严峻，随着各大技术(vue,webpack，react，微信小程序)生态越来越成熟，这也意味着我们要更加深入的去了解他们，掌握他们。比如你…"}, {"id": "7001476161960149029", "title": "手写mini-webpack", "desc": "前言 前面两个小节已经系统介绍了webpack中两个核心概念:plugin和loader. 今天将plugin和loader串联起来,从0手写一个基于插件体系搭建的程序架构,完成一个mini模仿版的w"}, {"id": "7002232726996647967", "title": "还在手动调整检查代码格式？？手把手教你eslint+prettier自动验证代码风格、保存格式化代码", "desc": "这是我参与8月更文挑战的第30天，活动详情查看：8月更文挑战 前言 正式安装前，先介绍下我项目的环境：vue2.5.2 + webpack3.6.0（如果你是 react项目的话需要安装其它包噢，我没"}, {"id": "6953790342613172237", "title": "一文搞定webpack构建优化策略", "desc": "当项目越来越复杂时，会面临着构建速度慢和构建出来的文件体积大的问题。webapck构建优化对于大项目是必须要考虑的一件事，我们将从速度和体积两方面来探讨构建优化的策略。"}, {"id": "6844904180285456398", "title": "『Webpack系列』—— 路由懒加载的原理", "desc": "说起路由懒加载，大家很快就知道怎么实现它，但是问到路由懒加载的原理，怕有一部分小伙伴是一头雾水了吧。下面带大家一起去理解路由懒加载的原理。 路由懒加载也可以叫做路由组件懒加载，最常用的是通过import()来实现它。 然后通过Webpack编译打包后，会把每个路由组件的代码分割…"}, {"id": "6953042611963691021", "title": "彻底解决新手对webpack的恐惧！", "desc": "前言 首先抛出结论，webpack是一个非常简单的工具，毫无难度可言。webpack阻碍很多人的根本原因是大家对一些概念的不熟悉、对webpack丰富的loader和plugin望而怯步。当你把概念弄"}, {"id": "7002592996419960862", "title": "webpack5——为什么选择 webpack", "desc": "想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的..."}, {"id": "6844903799736254477", "title": "前端构建秘籍", "desc": "随着前端构架工具的不断发展，提供了很多提高我们的开发体验和开发效率的能力，同时构建已经成为前端技术栈中常见的技术。 webpack 也是众多构建工具中崭露头角一员，早期的 webpack 配置复杂难懂，随着其发展，相关配置也不断简化，性能也不断提高，但是对于深入使用的开发人员，…"}, {"id": "6932736907830886413", "title": "用webpack从0到1打包一个按需加载的vue组件库", "desc": "在vue项目开发中，我们会将经常用到的逻辑或模块抽象成组件，对于那些多个项目都有用到的组件，可以考虑封装成组件库，发布到npm。每次要到只需要npm install xx一下，就不用来回拷贝了。下面我们就从0开始来打包一个vue组件库。 组件在使用之前都需要注册组件，注册组件可…"}, {"id": "6938255425238204447", "title": "掌握源码阅读的技巧 - Webpack 篇", "desc": "网上能搜到一些答案，但是这些答案我一一看过了，要么过于肤浅留于表面，要么冗长繁杂难以卒读。 如果面试岗位的工资是 20k 以上，面试官必定会追问到更深层次。 因此，我花了一个星期把 Webpack 5 的源码逐行扫了一遍，理出了主要脉络。整个阅读过程我录制成了视频，总时长不到 …"}, {"id": "7002782428024537096", "title": "深入浅出webpack", "desc": "目录 1、入门 1-1 前端的发展 模块化 CommonJS 优点：代码可在nodejs环境下复用 通过npm发布的第三方模块都采用CommonJS规范 缺点：必须通过工具转化为ES5，否则无法在浏览"}, {"id": "6844903655770963976", "title": "前端工程不了解？带你踩坑加爬坑。", "desc": "由于webpack在4.0后，新增mode配置项，它为我们默认设置了production。但是该警告并没有影响build的结果暂且忽略。 可以看到dist目录已经生成了名为my-first-webpack.bundle.js文件。 OK，最基本的配置已经完成，接下来引入Reac…"}, {"id": "6844903752835547144", "title": "使用webpack4提升180%编译速度", "desc": "使用webpack4提升180%编译速度"}, {"id": "6988057258550624293", "title": "浅谈Webpack Plugin", "desc": "你想深入学习webpack吗？ 你想自己开发一个webpack plugin吗？ 如何开始去写一个属于自己的plugin?"}, {"id": "7004807329023688740", "title": "超级简单的webpack实现，理解webpack核心原理", "desc": "超级简单的webpack实现，理解webpack核心原理 先给出项目地址：https://github.com/luch1994/mini-webpack 在demo文件夹下，有一个index.js，"}, {"id": "6895546761255845901", "title": "webpack的异步加载原理及分包策略", "desc": "webpack ensure 有人称它为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 script 对象，加入到 document.head 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后…"}, {"id": "6844903553127940110", "title": "webpack增量打包多页应用", "desc": "技术：好的，这就改。 这种方案，很快就被自我否定了。 这种方案，也思索了很久，后来也被否定了。 经过前面两个问题后，我发现思考的方向完全是错误的，总是妄想改变webpack的打包方式，简直就是跟它的理念对着干。 可以看到这一次生成的hash是4897.... 但是输出的每个文件…"}, {"id": "6976082291428704292", "title": "webpack5 热更新从配置到原理", "desc": "概述 项目里用到的刷新方案有两种，一般为了区分称为热更新和热重载 热重载 ： 顾名思义重新加载，使用 window.location.reload() 刷新界面以达到更新的目的 热更新：只更新修改的文"}, {"id": "6844903751203962893", "title": "【新手向】Vue.js + Node.js(koa) 合体指南", "desc": "Webpack 是大家熟知的前端开发利器，它可以搭建包含热更新的开发环境，也可以生成压缩后的生产环境代码，还拥有灵活的扩展性和丰富的生态环境。但它的缺点也非常明显，那就是配置项又多又复杂，随便拿出某一个配置项（例如 rules， plugins， devtool等等）都够写上一…"}, {"id": "6955430382485553166", "title": "Webpack5 搭建 Vue3 + TS 项目", "desc": "笔者两年前曾写过一篇文章《Webpack4 搭建 Vue 项目》，后来随着 webpack5 和 vue3 的面世，一直想升级下我这个 createVue 项目。"}, {"id": "6964341775561392135", "title": "Webpack 原理系列六： 彻底理解 Webpack 运行时", "desc": "本文继续剖析 Webpack 的实现原理，主要内容：ChunkGraph 构建完毕后，Webpack 接下来会做什么事情？什么是运行时？如何收集运行时依赖？"}, {"id": "6940998541284212749", "title": "做webpack性能优化的一段经历｜项目复盘", "desc": "回忆往昔岁月，我做前端开发至今已3年有余，做过的项目大部分都是业务需求迭代，技术优化经验相对较少。去年承蒙leader信任，给予机会开始做公司项目的技术优化。技术优化的首次任务，就是对整体前端项目进行性能优化（编译优化+构建体积优化）。 项目简介：我们团队主要做的是SaaS项目…"}, {"id": "6844904067844538382", "title": "从零开始配置 react + typescript（三）：webpack", "desc": "本篇为 从零开始配置 react + typescript 系列第三篇，将带大家完成模板项目的 webpack 配置。整个项目的配置我力求达到以下目标： 灵活： 我在配置 eslint 是选择使用 js 格式而不是 json，就是为了灵活性，使用 js 文件可以让你使用导入其它…"}, {"id": "6982813323217600543", "title": "工程自动化导入:require.context", "desc": "require webpack帮我们把项目打包到dist目录下，不会是无脑把所有文件都打包，会先静态解析，把我们需要用的文件打包，比如没有任何地方引用的图片，打包后，这个图片就不会出现在dist/st"}, {"id": "6987998229485289486", "title": "qiankun使用webpack5 module federation实践", "desc": "微前端使用module federation的单独构建颗粒化到组件。qiankun 是否能用module federation？"}, {"id": "6942076401986043918", "title": "Webpack5 基础 & Vue3 项目搭建", "desc": "创建 webpack-demo-main 文件夹。 在该文件中，我们新增 private: true 参数，该参数是确保私有。移除掉 main 参数。 output 指示 webpack 如何去输出、以及在哪里输出你的「bundle、asset 和其他你所打包或使用 webpa…"}, {"id": "6987267444230324261", "title": "2.Webpack开发环境配置", "desc": "1. 前言 本文将会从文件出发，根据文件的类型去讲如何打包，需要使用哪些loader或plugin。 从篇幅考虑，只会列出必要的代码，完整的代码在这里 2. 资源打包 2.1. 打包样式资源 我们通常"}, {"id": "6891424083801145358", "title": "让webpack5再飞一会儿，夯实webpack4吧（优化篇）", "desc": "海阔凭鱼跃，天高任鸟飞。Hey 你好！我是秦爱德。😄 上篇文章，介绍了webpack的入门基础配置（传送门🚀🚀🚀）。那现在我们就来讲一讲如何通过优化配置项来提高我们的项目构建性能吧。 从项目实战角度出发，我们更关心的还是从项目开发到发布上线。所以优化项可以分为以下几个维…"}, {"id": "7001443156537376799", "title": "面试基础复习--webpack面试题(一)", "desc": "这是我参与8月更文挑战的第27天，活动详情查看：8月更文挑战 建议先观看webpack官方文档，了解基础概念，然后看这些整理的面试真题，加深对概念的理解。每天量不多，后续会持续更新，，， 概念题"}, {"id": "6996471938780495902", "title": "想聊聊 webpack, 如何来配置 webpack", "desc": "webpack 的基本使用 什么是 webpack 概念：webpack 是前端项目工程化的具体解决方案。 主要功能：它提供了友好的前端模块化开发支持"}, {"id": "6996971834612645896", "title": "webpack深入开发之--Loader", "desc": "当在项目中需要对我们的文件进行处理，但是现有loader无法满足要求的时候， 那么自己开发一个loader，就显得比较重要了。希望通过我的例子，对大家有所帮助"}, {"id": "7003515107183427620", "title": "手摸手写个webpack loader", "desc": "目录： 基本概念 loader开发入门 本地loader调试 发布并引用loader Demo: 雪碧图loader 1. 基本概念 众所周知，webpack是个模块打包器。但是webpack只能处理"}, {"id": "6867797346550284296", "title": "Webpack漫谈", "desc": "1. 核心概念 entry：入口。webpack是基于模块的，使用webpack首先需要指定模块解析入口(entry)，webpack从入口开始根据模块间依赖关系递归解析和处理所有资源文件。 output：输出。源代码经过webpack处理之后的最终产物。 loader：模块转…"}, {"id": "6844903495959576583", "title": "webpack：从入门到真实项目配置", "desc": "自从出现模块化以后，大家可以将原本一坨代码分离到个个模块中，但是由此引发了一个问题。每个 JS 文件都需要从服务器去拿，由此会导致加载速度变慢。Webpack 最主要的目的就是为了解决这个问题，将所有小文件打包成一个或多个大文件，官网的图片很好的诠释了这个事情，除此之外，Web…"}, {"id": "6855129007785328653", "title": "初学者应该看的 Webpack 完整指南（2020）", "desc": "如今，CLI工具（如create-react-app或Vue -cli）已经为我们抽象了大部分配置，并提供了合理的默认设置。 即使那样，了解幕后工作原理还是有好处的，因为我们迟早需要对默认值进行一些调整。 在本文中中，我们会知道 webpack可以做什么，以及如何配置它以满足我…"}, {"id": "6844903678646681607", "title": "通过vue-cli3构建一个SSR应用程序", "desc": "Vue.js构建的应用程序，默认情况下是有一个html模板页，然后通过webpack打包生成一堆js、css等等资源文件。然后塞到index.html中 更有好的SEO。由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 Client Bundle，给浏览器用。和纯Vue前端…"}, {"id": "7003735671579869198", "title": "3、webpack的配置文件说明", "desc": "当使用webpack打包时会默认先找配置文件（webpack.config.js），没有的话会使用webpack的默认配置项；webpack默认配置文件名为`webpack.config.js`"}, {"id": "6844903952140468232", "title": "辛辛苦苦学会的 webpack dll 配置，可能已经过时了", "desc": "前段时间写了一篇详解 webpack4 中易混淆知识点的文章，没想到收获了近 600 个赞，在这里对各位老铁抱拳感谢。上篇文章我费了很多时间去构思 demo 和原创作图，就是想把一些概念彻底讲清楚，看评论区的反响我感觉还是做到了自己设定的目标。 如果大家看过一些 webpack…"}, {"id": "6989774092882673671", "title": "使用Webpack5搭建Vue开发环境项目实战！", "desc": "使用Webpak5.x + babel7.x 搭建前端项目开发环境，对比wepack 4.0版本的一些变化"}, {"id": "6933950353582850062", "title": "Webpack5 搭建 react 脚手架", "desc": "Webpack 5 发布也有挺长时间了，现在在公司用的脚手架还是 v4 版的，听说 v5 版本更新的重点主要是针对构型性能的优化。听起来感觉挺香的，就想去用 Webpack 5 搭建一个架手架 看看整体感觉如何，因为我现在主要是用 React 开发 所以就以 React 为例搭…"}, {"id": "6989774026193240101", "title": "webpack5.0工程化实战（1）搭建vue开发环境", "desc": "本质上webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图"}, {"id": "6984983458544091172", "title": "react+ts+webpack搭建electron项目", "desc": "一份基础模板，用来创建react+ts+webpack+electron的项目，可以扩展，根据习惯来更多的自定义配置"}, {"id": "6998856707107455013", "title": "webpack5——loader", "desc": "loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 \"load(加载)\" 模块时预处理文件。"}, {"id": "6945994800898244645", "title": "彻底搞懂webpack原理：手写webpack核心代码", "desc": "面试经常问到的一个问题就是webapck的原理，要理解一个东西的原理，最深刻的方式就是自己去实现一次。下面我们就一起手写webpack核心代码，彻底搞懂webpack原理。 1、能将模块化的js文件，打包生成一个js文件，模块中的ES6代码转换为ES5代码，在html文件中引入…"}, {"id": "6844903711643271182", "title": "webpack4配置详解之慢嚼细咽", "desc": "经常会有群友问起webpack、react、redux、甚至create-react-app配置等等方面的问题，有些是我也不懂的，慢慢从大家的相互交流中，也学到了不少。 ​ 今天就尝试着一起来聊聊Webpack吧，旨在帮大家加深理解、新手更容易上路，都能从0到1搭建配置自定属于…"}, {"id": "6998852632517279781", "title": "webpack5——输出(output)", "desc": "可以通过配置 output 选项，告知 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 entry 起点，但只能指定一个 output 配置。"}, {"id": "6858905382861946894", "title": "Webpack配置全解析（优化篇）", "desc": "在上一篇文章Webpack配置全解析介绍了Webpack中loader和plugins的一些基本用法，当loader和plugins使用较多后项目也会越来越耗时，因此这次我们继续学习如何优化webpack的配置来让我们的项目运行的更快耗时更短。 本文将从缩小文件搜索范围、减少打…"}, {"id": "6901807555316547597", "title": "jsliang 求职系列 - 31 - Webpack", "desc": "都 2020 了，不会点 Webpack 好像有点说不过去。 但是事实上如果不是分配到【架构组】之类的团体中，感觉接触 Webpack 的概率会少点吧。 Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。 当 Webpa…"}, {"id": "6990276371708641317", "title": "webpack打包优化", "desc": "1、按需引入组件 例如引入 element-ui ，用到哪些组件就引哪些 2、externals 属性 webpack的externals属性，将公共的或不常改动的第三方包名称，配置在属性中，打包时会"}, {"id": "6921484505094029325", "title": "webpack系列学习-提取公共资源", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 打包后文件中只有函数a，而没有函数b。从而达到优化无用代码效果 可以下载调试。"}, {"id": "6946428442762035208", "title": "前端真实mock数据解决方案", "desc": "我们在项目完成之后，有时候会有一些小的调整，比如：文案的修改，fixbug，很小的功能调整。 寻找账号很费时间，找到了，还不一定有这个权限。不同的账号，可能数据结构有差异，更有的时候，开发环境突然清库，发现没有任何数据，因此还是很难得到我们想要的数据 开发环境的不稳定(数据经常…"}, {"id": "6939497591021240350", "title": "webpack多页面打包方法工具和模板", "desc": "该方法接收一个Array数组类型的参数，即需要打包的的src/pages下的自定义目录列表。 htmlWebpackPlugins属性的值为html-webpack-plugin插件生成实例的配置对象。 setEntryAndHtmlPlugin方法主要调用了handleCus…"}, {"id": "6946486038248292360", "title": "前端打包路（1） - 基本原理&发展历史&webpack初介绍", "desc": "前端打包、构建、gulp、grunt、webpack、rollup、一堆名词，之前没有好好的系统性学习过，这次抽空系统的捋一捋。。。 可以说随着node的出现，前端变得越来越复杂，因为js代码不再是只能运行在浏览器里面的弱鸡语言，随之带来的是同样在服务器上运行的能力。我认为带来…"}, {"id": "6844903557653594119", "title": "WebPack持久缓存学习小结", "desc": "使用webpack构建工程的时候，我们往常会把功能不同的代码打包到不同的包里(如lib,vendor,业务代码)。 而持久缓存的目的就是每一次更新线上代码的时候，尽可能使内容未做更改的模块的名字和之前保持一致。 [hash]： 整次build生成一个唯一的hash值，赋给所有生…"}, {"id": "6844903615199445000", "title": "EasyPack - 可视化 Webpack 构建工具 1.0.3 更新", "desc": "关于easy-pack之前写过一篇EasyPack - 也许是最方便的 webpack 构建工具. 在掘金有反馈说希望支持webpack4。于是，就有了1.0.3。 安装包下载尝试在 github release 中发布，但每次上传都报不明错误。 可以自行下载项目 build …"}, {"id": "6844904081970970631", "title": "webpack 原理解析简述", "desc": "本文面向那些需要或者想了解开发 webpack plugin 和想要深究 webpack 源码但是无处下手的人群。这篇文章会带你大致了解 webpack 原理与执行流程，具体的源码限于篇幅暂不讨论，后面会考虑出一系列 webpack 源码解析系列与 webpack 经典插件解析…"}, {"id": "6844903564691636231", "title": "Abstract Syntax Tree 抽象语法树简介", "desc": "在使用前端许多工具插件的时候，我们大多知道每个工具库、每个插件能做什么，不过很多同学其实并不清楚背后用到的技术，如webpack、rollup、UglifyJS、Lint等很多的工具和库的核心都是通过Abstract Syntax Tree 抽象语法树这个概念来实现对代码的检查…"}, {"id": "6844903713199357960", "title": "轻松发布 react 组件到 npm", "desc": "如果你平时想发布一个自己的 React 组件，发现它并没有和发布其他 JavaScript 库一样简单，首先它得对 JSX 进行转化，并且得使用 babel 把语法转化为 ES3，还得忽略掉一些项目里已用到的库，如 react、react-dom 等等，还得编写 TypeScr…"}, {"id": "6844903655049527309", "title": "深入浅出 sideEffects", "desc": "最近在给团队对 webpack 中的 sideEffects 字段用途进行微分享，于是乎，我最后就整理成一篇文章，希望帮助更多的人理解 sideEffects 的作用。"}, {"id": "6844903556261085192", "title": "vue无缝滚动的插件开发填坑分享", "desc": "//5.Fixing a bug. add a overflow:hidden on the child element vue-seamless-scroll发现bug或者有什么不足望指点,感觉不错点个star吧。"}, {"id": "6901576138808623117", "title": "使用webpack搭建一个vue插件", "desc": "作为一个现代前端，webpack多多少少都有接触过，但是我们平常都是直接使用脚手架工具搭建项目，自动集成了webpack，对于如何从0到1搭建一个webpack工程我们并不熟悉，那么我们今天就一起手把手来搭建一个基于webpack的vue插件，相信在这个过程中我们能够对webp…"}, {"id": "6844903656932769805", "title": "配置Tree Shaking来减少JavaScript的打包体积", "desc": "为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。 小编推荐：Fundebug专注于JavaScript、微信小程序、微信小游戏，Node.js和Java线上bug实时监控。真的是一个很好用的bug监控服务，众多大佬公司都在使用。 如今一个网页应…"}, {"id": "6844903863099588622", "title": "为什么我要构建这个脚手架", "desc": "本文不是什么技术性介绍文章，准确地说算是自己的成长记录吧。刚参加工作时，组里使用的脚手架是由 leader 使用 webpack, gulp 搭建的多页面应用脚手架 fex。当时只需知道怎么使用就行了，不过为了能更好地工作，对 fex 怎么构建一直很好奇，也一直关注相关的技术栈…"}, {"id": "6844904166767214600", "title": "webpack4配置总结(四)", "desc": "上一篇整理了loader的使用，这篇整理一下babel跟postcss-loader的配置。 其实，.babelrc配置文件是用来支持我们在使用babel解析编译代码时，使用一些插件来处理高版本语法或者提案语法。插件跟预设的区别在于，预设其实是一些插件的组合，它方便我们处理一类…"}, {"id": "6844903829591293959", "title": "webpack4+babel7入门到精通(二、样式的处理)", "desc": "一、webpack使用css样式1、安装包2、在webpack.config.js中的module配置规则(use中是一个数组,从后面解析到前面)3、在src中创建一个css的文件夹,里面创建a.cs"}, {"id": "6844903577119358983", "title": "了解webpack-4.0版本（一）", "desc": "近期发布了 webpack 4.0.0 的 beta 版本,如果想了解和之前版本的区别，不妨先自己搭建一个webpack的简单应用体验一下。 在bundle.js中，生成一个字执行函数，把要打包的js定义为实参，传入到自执行函数当中。 在package.json中 配置 \"de…"}, {"id": "6914937301382463496", "title": "基于webpack4.x模块依赖加载流程", "desc": "模块依赖加载解析commonJS和ESModule的导入导出有区别模块依赖加载流程总结"}, {"id": "6844903606777298951", "title": "从零开始到发布上线，如何自定义一个webpack loader", "desc": "前两天在使用webpack搭建移动端web的时候,需要使用到flexible.js动态修改html的font-size。考虑到只有几行代码，我想把flexible.js镶嵌到<head>中,同时我希望能够随时修改它的源码,并且最后输出到html中是压缩过后的代码。 由于没有找到…"}, {"id": "6900006699483004942", "title": "大家都知道的webpack优化策略", "desc": "输出日志优化friendly-errors-webpack-plugin——优化构建时命令行显示日志webpack.base.conf.js：启用quiet后，除了初始启动信息之外的任何内容都不会被打"}, {"id": "6844903944003518478", "title": "Webpack高级概念", "desc": "一. tree shaking 二. 开发和生产模式下的打包模式区分 三. code splitting 四. Caching 五. webpack打包分析 六. Prefetching和Preloading 七. Css 代码分割 八. Shimming 九. 环境变量的使用"}, {"id": "6844903853419134983", "title": "webpack4系列实践笔记", "desc": "webpack 是目前 javascript 主流的工程自动构建工具，目前 Vue，React 以及 Angular 等项目脚手架都是基于 webpack 进行构建的。 为了避免每个demo都在本地安装一遍 webpack 和 webpack-cli ，这里推荐使用全局安装的方…"}, {"id": "6844903827007602696", "title": "webpack系列-loader", "desc": "每一个loader都是无状态的，确保loader在不同模块转换之间不保存状态。"}, {"id": "6844903944829845512", "title": "从0搭建自己的webpack开发环境（三）", "desc": "@babel/core是babel中的核心模块，@babel/preset-env 的作用是es6转化es5插件的插件集合，而babel-loader是webpack和loader的桥梁。"}, {"id": "6844904192658636807", "title": "从零构建React项目（二）：webpack 配置", "desc": "在上一篇文章中，只是添加了webpack最基本的配置，所以在这片文章中详细的记录一下webpack常见的一些配置及优化内容。 1. loader options: 为loader提供额外的配置选项。 默认的loader执行顺序是从后往前进行执行，也可以通过手动定义顺序。 2. …"}, {"id": "6931314833388388366", "title": "手把手教你用webpack搭建react项目", "desc": "以上两种形式是等价的，但是babel在转义的时候会优先去查找.babelrc文件，如果不存在，才会考虑其他的路径。"}, {"id": "6844903845466750990", "title": "一次create-react-app创建项目升级webpack的流水账", "desc": "升级webpack-manifest-plugin即可。 运行通过，提交代码，PR。 所有问题都可以通过仔细阅读error trace加上善用google搞定。"}, {"id": "6844903601802838024", "title": "LegoFlow 2.0 开源更轻、更强的前端工作流客户端", "desc": "内置集成 Webapk 4、Gulp 4、Babel 7 等前沿构建工具模块，无需配置安装复杂的系统环境，致力打造更轻、更强的前端工作流客户端。"}, {"id": "6943035000543510558", "title": "Webpack - loader和plugins", "desc": "loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 \"load(加载)\" 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeSc…"}, {"id": "6844903745034125326", "title": "webpack性能榨汁机", "desc": "原有项目是线上和本地公用一套dll配置，因为antd这类ui库需要按需加载所以不能放到dll中，这时可以单独写一个dll配置，将所有第三方库添加到dll中。 一个新问题，因为没有import插件，导致所有antd组件样式丢失。这时我在index-template.html中加入…"}, {"id": "6844903556311433230", "title": "🚀webpack 4 beta — try it today!🚀", "desc": "webpack 4 公测啦，快来看看有什么新东西"}, {"id": "6844903741884203016", "title": "webpack build后生成的app、vendor、manifest三者有何职能不同？", "desc": "从截图上看也看出，vendor的文件大小最大，因为其包含了vue整一个框架的代码，以及webpack的模块化代码。 2，观察了一下，webpack应该是会在最后一个CommonsChunkPlugin产出的chunk注入webpackJsonp的定义,以及异步加载相关的定义,而…"}, {"id": "6847902219824545805", "title": "webpack3.x升级4.x之后打包大小优化", "desc": "上一篇我们讲到，webpack3.x 升级 4.x 时遇到的问题、原因和解决方案，今天讲一下 webpack 4.x 的打包优化。 能够看到有好几个文件比较大，但是并不清楚具体包含哪些模块，哪些模块适合单独提取，哪些模块不适合提取，这个时候就需要用到打包分析的工具。 这里我们使…"}, {"id": "6844903923266879501", "title": "Webpack知识点速记", "desc": "Webpack是一个模块打包工具，在Webpack里一切文件皆模块。通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合的文件。Webpack专注构建模块化项目。 Webpack可以看作是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript…"}, {"id": "6949059549269590024", "title": "webpack学习记录（一）", "desc": "Webpack: 是一个模块打包工具。是一个打包模块化js的工具，它会从入口模块出发，识别出源码中的模块化导入语句，递归的找出入口文件的所有依赖，将入口和所有依赖打包到一个单独的文件中。安装方式：全局"}, {"id": "6844903534954020878", "title": "Parcel,0配置打包typescript和react", "desc": "平常打包工具我们会去选择Webpack，但是我们都发现去使用webpack要么就去社区里找配置好的或者自己去看文档去配一大堆插件啊等等，但是我们在开发中还会遇到很多问题。有一句话说得好，配好了的Webpack就别动了。。因为下一步你继续配的话，你也不知道会发生什么。 现在很多人…"}, {"id": "6844903510098591757", "title": "Vue.js SSR Step by Step (3) - 改造 vue/webpack 脚手架 ", "desc": "通过前面两篇文章，写了一个简单的支持 vue 同构的 webpack 配置，但是还没有 dev server，不能热更新和实时编译，用于开发还是非常的麻烦。 Vue 官方的 webpack 脚手架只是针对客户端的，功能强大，配置齐全。所以在这个官方脚手架的基础上改了一个支持 #…"}, {"id": "6844903822452621326", "title": "[Vue warn]: $attrs is readonly；Webpack externals 配置", "desc": "不将Vue打包到bundle中，而是让打好的包bundle去它的运行环境中找Vue的依赖。让运行环境决定用哪个版本的vue。"}, {"id": "6914566764135350285", "title": "webpack 代码分割", "desc": "webpack 中 optimization配置 还可以 将node_modules中代码单独打包一个chunk最终输出，如果是多入口，可以 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk"}, {"id": "6844903967801999367", "title": "[译] webpack 更新日志(一)", "desc": "我们尝试通过持久化存储优化构建性能。 我们尝试采用更好的算法与 defalut 来改善长效缓存。 我们尝试通过更好的 Tree Shaking 和代码生成来改善 bundle 的大小。 我们尝试清除内部结构中奇怪的代码，同时在不影响 v4 功能基础上实现了新特性。 我们目前尝试…"}, {"id": "6844903625060253710", "title": "webpack 划重点", "desc": "最近开始有精力比较细致的研究 webpack，暂时没有能力产出整篇的干货，本文用于记录在学习的过程中对于一些易混淆或者文档不清晰的地方所做的一些研究性探索。如果错误，请斧正。 看到这里，自己感觉比较疑惑了，入口文件是相对路径./examples/main,相对于当前路径查找，但…"}, {"id": "6844904070688276487", "title": "webpack简单使用与优化", "desc": "关于webpack的使用，在这借鉴官方文档，做一些简单总结。 webpack4以后会有默认的配置体系，简单来说项目根目录下默认会有个webpack.config.js的配置文件，其中入口文件为src/index.js，打包出口文件夹为dist，一般来说我们平时项目也是按这个规则…"}, {"id": "6948383177077424142", "title": "tapable钩子实现", "desc": "最近在阅读webpack源码的时候，发现在webpack的编译器（compiler.js）里用到了tapable，于是查资料学习了以下，这里做一个学习记录。 异步钩子分为异步并发（Parallel）执行和异步串行（Series）执行，从hook名字我们就可以看出来。"}, {"id": "6844903543485235213", "title": "webpack实用小功能", "desc": "配置很简单，那它的作用是什么呢？overlay的作用是可以在浏览器打开的页面显示终端编译时产生的错误。通过配置该属性，以后在写代码的时候，编译如果出错了，我们就不需要打开终端看到底是什么报错了，可以直接在页面里看到错误，对于开发而言确实很方便。 我们最容易遇到的问题代码全部打包…"}, {"id": "6844903588175544334", "title": "webpack用法小结", "desc": "根据文档的定义：本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这…"}, {"id": "6942510487321968653", "title": "webapck 模块化原理", "desc": "最近在阅读react-loadable源码时，发现import方法返回的结构是一个promise。于是就好奇webpack 是如何实现异步加载文件，并且加载完成后返回了一个promise。遂决定简单写一个demo 一探究竟 由上面文件可知，webpack打包后生成一个自运行函数…"}, {"id": "6869759140223254541", "title": "跟着网友从0配置webpack+react搭建HelloWord", "desc": "安装结束之后，我们在 config 这个文件夹下新建两个文件，分别为 webpack.prod.config.js 和 webpack.dev.config.js ，这两个文件分别对应生产和开发两个环境的配置。 运行打包，不出意外，失败。。。 test 规定了作用于以规则中匹配…"}, {"id": "6844903605598683143", "title": "React v16 与 Webpack v4 的多特性模板项目", "desc": "题注：欢迎加入阿里南京前端团队，欢迎关注阿里南京技术专刊了解更多讯息。 React & Webpack Boilerplate V4 是笔者前端常用模板集锦项目 fe-boilerplate 的一部分，尽可能地使用无异议的工具，提供直观且简洁明了的方式；相较于 create-r…"}, {"id": "6844904168126152711", "title": "学习webpack中的核心概念", "desc": "直接本地输入基础路径可以进入，但一刷新页面空白，怀疑是路径配置不对，资源没有加载成功。 webpack.config中，output项的publicPathc：影响资源生成路径。 devServer中的publicPath：影响资源在本地开发环境（浏览器）中的访问，换句话说，这…"}, {"id": "6844903972948426759", "title": "💪从零开始学习webpack系列四（解析HTML）", "desc": "「minfiy」：是否进行页面压缩。布尔值，默认是 fasle"}, {"id": "6910919582207180813", "title": "webpack学习记录(5)-开发过程中的基础构建", "desc": "前面了解了一些Webpack的基础配置，那么下面就了解一些在实际开发过程中的应用。 这里会分为开发环境和生产环境来分别简述。 注：以下功能都是基于Webpack版本^4.43.0调试。 开发过程中，每次修改后需要编译代码时，如果手动运行npm run build会显得很麻烦，W…"}, {"id": "6907627139198107655", "title": "Webpack学习笔记六：css兼容性处理以及文件提取", "desc": "上一节我们学习到webpack中如何处理css文件，以及在使用了 css预处理器 后又改怎么处理。文章末尾我们也提到了两个需要解决的问题： 上一节中我们使用到了 style-loader 、 css-loader 以及 sass-loader 三种loader，在这三种load…"}, {"id": "6854573221112233997", "title": "webpack:从入门到实践", "desc": "1. webpack是什么 官网对webpack的定义是这样的：webpack是一个现在javascript应用程序的静态模块打包工具。自从出现模块化以后，大家可以将原本一坨代码分离到各个模块中，但是这个引发了一个问题，就是js的每个文件都需要去服务器那，这就导致加载速度变得很…"}, {"id": "6844903925611495432", "title": "【webpack】配置", "desc": "Webpack 会按照数组里的顺序去 package.json 文件里寻找，只会使用找到的第一个。 也就是说当遇到 require('./data') 这样的导入语句时，Webpack 会先去寻找 ./data.js 文件，如果该文件不存在就去寻找 ./data.json 文件…"}, {"id": "6909648962693627912", "title": "webpack4.0各个击破（2）—— CSS篇", "desc": "一. CSS文件基本处理需求 二. 解决方案的升级 在不使用构建工具的时代，开发者使用预编译语言来实现变量定义，选择器嵌套等一些刚需，再使用函数功能来实现一些更为复杂的需求，例如编写简单的@mixin px2rem( )函数来将开发中使用的px单位转换为rem单位，达到移动端自…"}, {"id": "6844904121527435278", "title": "大话webpack-完善功能", "desc": "在主页中引入已有的静态资源文件，我们在public栏中放入js文件夹(用于存放已有的静态资源文件)，index文件直接引入，那可不会允许你这样。webpack：我都已经跟你把转义和输出都写好了，你还自己引入文件，我才不在帮你把外部文件再转义好加进来了呢，太麻烦我了？那只能再给他…"}, {"id": "6924933697150353415", "title": "Webpack系列(二):核心概念", "desc": "1.零配置-创建文件夹coremodule-npminit-y生成默认内容的package.json文件-npminstall-Dwebpack@4.43.0webpack-cli@3.3.12 安装"}, {"id": "6844903559805272077", "title": "Gulp&Webpack搭建属于自己的特性化前端脚手架", "desc": "之前看了很多教程,比如vue的脚手架,gulp的脚手架和大牛自己写的脚手架。发现没有什么是银弹能够满足公司业务的需要又能够开发的爽。所以结合公司业务的特性,自己动手用gulp和webpack写了一套适合我司的脚手架。 上面只列出了三点。其实适用范围还有挺多。 当然还有一些就不一…"}, {"id": "6844903853402357767", "title": "demo12 webpack 处理 scss", "desc": "1.如何处理scsssass-loader>css-loader>style-loader(以<style>标签形式添加到html中)或sass-loader>file-loader>style-lo"}, {"id": "6844903878933102599", "title": "心理学之茶哥分享：前端包管理工具整理", "desc": "大家好，今天由我给大家带来前端心理学茶哥的分享总结。 茶哥是位声音酥酥的小姐姐👧，总结的知识点也是满满的干货，接下来我将对茶哥分享的内容进行整理，以供大家查阅。 我们将这些名词分下类，前面几个包管理工具，中间部分是构建类的工具，后面的一部分是模块定义规范。 虽然很久以前前端可…"}, {"id": "6997797576951103496", "title": "webpack打包（上）", "desc": "模块化解决了解决了开发中的代码组织问题，但模块化本身存在如ESM 本身存在环境兼容、模块化的模块文件过多，网络请求频繁、所有的前端资源都需要模块化等问题，看webpack如何解决。"}, {"id": "6844903846993461256", "title": "深入理解 Webpack 打包分块（上）", "desc": "随着前端代码需要处理的业务越来越繁重，我们不得不面临的一个问题是前端的代码体积也变得越来越庞大。这造成无论是在调式还是在上线时都需要花长时间等待编译完成，并且用户也不得不花额外的时间和带宽下载更大体积的脚本文件。 然而仔细想想这完全是可以避免的：在开发时难道一行代码的修改也要重…"}, {"id": "7002029842891800589", "title": "webpack4.0基础篇", "desc": "webpack就是为打包而生的。 一、准备 学习webpack首先需要安装nodejs，并且作者也强调新版本的nodejs会提高webpack的打包速度。 安装好node后就可以在项目命令行中执行下面"}, {"id": "7002250229705605150", "title": "深入 Webpack5 等构建工具系列三(4) - Asset Modules type", "desc": "这是我参与8月更文挑战的第28天，活动详情查看：8月更文挑战 前面三篇文章讲了 webpack 加载处理其它资源，主要讲了如何加载图片资源，有两种 loader 可以选择。一个是 file-loade"}, {"id": "6844903591174471687", "title": "webpack从此不再是我们的痛点 — 核心基础", "desc": "WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。并且跟具你的在项目中的各种需求，实现自动化处理，解放我们的生产力…"}, {"id": "6982589071151333383", "title": "Webpack打包", "desc": "一、模块打包工具 1.1、模块打包工具 - 概要 1.2、Webpack 快速上手 1.3、Webpack 配置文件 1.4、Webpack 工作模式 1.5、Webpack 资源模块加载 1.5.1"}, {"id": "6936187592878587934", "title": "Webpack、Gulp构建工具使用方法及步骤", "desc": "1. 配置打包的入口与出口 2. webpack自动打包 3. 配置生成预览页面 1. 打包处理 css 文件 2. 打包处理 less 文件 3. 打包处理 scss 文件 4. 配置 postCSS 自动添加 CSS 的兼容前缀 5. 打包样式表中的图片和字体文件 6. 打…"}, {"id": "6844903608689885197", "title": "ES6核心特性", "desc": "这部分着重介绍：babel 编译ES6语法，如何用webpack实现模块化。 ES6 提供了许多新特性，但并不是所有的浏览器都能够完美支持。下图是各个浏览器对ES6兼容性一览表(以export为例) 由上图可知，有些浏览器对于ES6并不是很友好，针对 ES6 的兼容性问题，很多…"}, {"id": "6844903680307625997", "title": "webpack SplitChunksPlugin实用指南", "desc": "提到前端打包工具，毫无疑问想先到的是webpack。但是前端发展地很快，时不时会有新东西出现，打包工具这边之前也出现parcel和rollup。各种工具的碰撞，相互汲取优点，促进技术的发展。 webpack4中支持了零配置的特性，同时对块打包也做了优化，CommonsChunk…"}, {"id": "6844903585071775752", "title": "multipages-generator今日发布👏！妈妈再也不用担心移动端h5网站搭建了！", "desc": "multipages-generator（简称MG）是一个为移动端h5量身打造的网站脚手架，用它可以让你相对的以正确的姿势、迅速的身手、专注于业务，愉快的进行h5开发，以及有配套的快速发布流程。 现在在手淘，京东，今日头条，美柚等过亿用户的手机app中的，都常见h5网页，他们有…"}, {"id": "6994049958080938014", "title": "Webpack5 系列（二）：静态资源的处理", "desc": "这一篇文章将会介绍如何利用 webpack 中的 Loaders 对静态资源做处理，Loaders 是 webpack 的核心概念之一。"}, {"id": "7002026029237665806", "title": "webpack5入门到精通（五）(编译JS)", "desc": "为了让javascript在低版本的浏览器中得以兼容，需要在打包时候将ES6+代码转为ES5。使用preset-env、polyfill、corejs等解决方案。"}, {"id": "6988874055474479135", "title": "webpack搭建vue项目", "desc": "一、入门 1.1 初始化项目 新建一个目录，初始化npm webpack是运行在node环境中的,我们需要安装以下两个npm包 如果下载不了，安装淘宝镜像： 如果出现（cnpm : 无法加载文件 C:"}, {"id": "6844903573503868941", "title": "React入门---react脚手架", "desc": "React是Facebook研发的一款前端框架(MVC框架：侧重于view层操作)，目前在行业内广泛使用。为了让框架的体积变得更轻量级，设计者们把其定义为“渐进式”框架,也就是: 这样的操作有好处，也有弊端，麻烦的是，开发中我们需要不断的安装各种组件，而且react独有的jsx…"}, {"id": "6844903957769224206", "title": "webpack原理", "desc": "webpack早就已经在前端领域大放异彩，会使用和优化webpack也已经是中、高级工程师必备技能，在此基础之上再对webpack的原理进行理解和掌握，必定会在未来的开发中事半功倍。若是对于webpack不熟悉可以查看之前的文章进行学习和了解。 由于本人能力一般、水平有限，所以…"}, {"id": "7001835358878957604", "title": "Webpack的浅入浅出", "desc": "主要简述了Webpack的简单实用与配置；以及关于vue的相关配置、plugin的简单介绍，以及最后配置文件别名等内容"}, {"id": "6983253064392114183", "title": "webpack工程化实战", "desc": "项目准备 初始化 .npmrc 在为了解决npm龟速下载的糟糕体验时，我们一般会将npm源设置为淘宝镜像源 但是大家想想，万一某个同学克隆了你的项目之后，准备在他本地开发的时候，并没有设置淘宝镜像 源"}, {"id": "6844903826630115335", "title": "mini-css-extract-plugin插件快速入门", "desc": "webpack 4.0以后，官方推荐使用mini-css-extract-plugin插件来打包css文件（从css文件中提取css代码到单独的文件中，对css代码进行代码压缩等）。 把所有配置文件放到项目的根目录下，运行package.json中的命令即可。当然，webpac…"}, {"id": "6911945908226080782", "title": "基于webpack打包多页应用,对前端工程化的思考(下)", "desc": "下面我们接着上一篇文章，谈论些更多有意思的东西。 单页面应用中,有很多框架都做了该功能,比如基于vue的Nuxt.js,基于react的UmiJS。比起单页面,多页面中并没有路由嵌套,路由传参等复杂的路由结构,所以在多页面中实现路由自动生成要比单页面简单些。 自动生成路由最主要…"}, {"id": "7004340117112356900", "title": "webpack打包公用库", "desc": "1.基础配置 1.1 library命名 如果我们打包的⽬的是⽣成⼀个供别⼈使⽤的库，那么可以使⽤ output.library 来指定库的名称，库 的名称⽀持占位符和普通字符串： 1.2 libra"}, {"id": "7004860251077869599", "title": "从0开始搭建一个可用的vue3-webpack5-template（三）", "desc": "前言 在上一篇文章中，我们对配置进行了抽离和优化，在这篇文章中，我们会进一步的完善和优化我们的template,这一篇文章的代码可以在vue3-webpack5-templatetag1.0.0中看到"}, {"id": "6869915676501835783", "title": "面向未来的前端构建工具-vite", "desc": "如果近期你有关注 Vue 的动态，就能发现 Vue 作者最近一直在捣鼓的新工具 vite。vite 1.0 目前已经进入了 rc 版本，马上就要正式发布 1.0 的版本了。几个月前，尤雨溪就已经在微博介绍过了 vite ，是一个基于浏览器原生 ESM 的开发服务器。 早期 We…"}, {"id": "6991630925792542750", "title": "学习 Webpack5 之路（基础篇）", "desc": "本文从 webpack 是什么、为什么选择 webpack、webpack的基本概念介绍 3个角度进行讲述，从 Webpack 基础着手，和你一起了解 webpack。"}, {"id": "6982755090071289892", "title": "使用 airpack 让多个项目共享 webpack 配置", "desc": "airpack 是一个 webpack-cli 的包装器。旨在让你更优雅的使用 webpack。它可以自动帮你从项目依赖、项目目录、命令行参数读取 webpack 配置，并以更合适的方式合并它们。"}, {"id": "6960914598476120072", "title": "万字长文系统梳理 Webpack 基础（上）", "desc": "1 Webpack 简介 1.1 概述   webpack是一个开源的JavaScript模块打包工具，核心功能是解决模块之间的依赖，把各个模块按照特定规则和顺序组织在一起，最终合并为一个或者多个JS"}, {"id": "6960917040131473444", "title": "万字长文系统梳理 Webpack 基础（中）", "desc": "1 代码分片   代码分片（code splitting）是webpack所特有的一项技术，可以将代码按照特定的形式进行拆分，不用一次全部加载而是按需加载，能有效降低首屏加载资源的大小。 1.1 Co"}, {"id": "6960914042861027342", "title": "万字长文系统梳理 Webpack 基础（下）", "desc": "1 开发优化 1.1 webpack 插件 1.1.1 webpack-dashboard   webpack-dashboard是用来优化webpack日志的工具。   根目录下为webpack.c"}, {"id": "6986510642165334029", "title": "基于webpack的移动端适配方案", "desc": "在移动端开发的过程中，一个最常见的问题就是适配不同的屏幕宽度。目前比较常见的适配方案有rem和vw，它们都是css中的相对单位。"}, {"id": "7007625498691895310", "title": "Webpack Loader学习笔记", "desc": "在webpack打包工具中，loader作用就是将源代码转换成javascript格式的目标代码。本文用以作个人学习记录。"}, {"id": "6943793273395740680", "title": "手把手教你写一个Vue组件发布到npm且可外链引入使用", "desc": "我们为什么要写个组件上传到npm镜像上呢，我们肯定遇到过这样一个场景，项目中有很多地方与某个功能相似，你想到的肯定是把该功能封装成Component组件，后续方便我们调用。但是过了一段时间，你的Leader让你去开发另一个项目，结果你在哪个项目中又看见了类似的功能，你这时会怎么…"}, {"id": "7007679827188645925", "title": "Webpack--初识（基础概念）", "desc": "Webpack作为一个模块打包器，相信前端开发小伙伴对它都有个或多或少的了解。 如果你刚刚接触，希望这篇文章可以为你打开初识Webpack的大门。"}, {"id": "6859888538004783118", "title": "「一劳永逸」由浅入深配置webpack4", "desc": "webpack在前端化过程中十分重要，所以花了一段时间学习webpack，以及webpack4新特性，本文是按照从易到难的过程，梳理部分webpack概念，常见的loader，plugins，webpack4新特新，还有部分高级概念。 Output: 如何命名输出文件，以及输出…"}, {"id": "7006238446347894791", "title": "自定义loader", "desc": "配置 绝对路径配置loader 使用resolveLoader.modules配置，进行自动搜索 编写用法 loader是一个函数，会通过loader runner进行调用，函数内通过this调用lo"}, {"id": "7005850071275143204", "title": "【webpack】整理（一）", "desc": "目录 Webpack 的热更新原理 如何处理样式文件 图片/字体文件处理 入口配置 出口配置 每次打包前清空dist目录 一、Webpack 的热更新原理 Webpack 的热更新又称热替换（Hot "}, {"id": "7001827142052872228", "title": "如何配置webpack的入口和出口", "desc": "本文已参与掘金创作者训练营第三期「高产更文」赛道，详情查看：掘力计划｜创作者训练营第三期正在进行，「写」出个人影响力 没有前言，直接单刀直入，讲讲如何配置webpack 配置webpack主要是配置出"}, {"id": "6972378623281987621", "title": "那些高级/资深的前端是如何回答JavaScript面试题的 （二）", "desc": "看完这篇文章，你要是还搞不懂webpack编译流程算我输！ 教会你面试话术！ 教会你如何分析源码！ 教会你如何写一个webpack！"}, {"id": "6968988552075952141", "title": "手把手带你入门Webpack Plugin", "desc": "关于 Webpack 在讲 Plugin 之前，我们先来了解下Webpack。本质上，Webpack是一个用于现代 JavaScript 应用程序的静态模块打包工具。它能够解析我们的代码，生成对应的依"}, {"id": "7005419871320145933", "title": "webpack相关知识点", "desc": "整理了一下webpack的知识。包括Webpack的作用、打包的流程、loder和plugin的配置，编写思路以及它们的区别等，简单介绍了一下babel。"}, {"id": "7005745689879642142", "title": "【webpack系列】5. 从源码角度分析webpack热更新流程", "desc": "之前文章从源码简单详细介绍了webpack整体流程、loader触发时间和过程、模块解析原理和plugin原理核心的知识，这篇文章来说说webpack的热更新相关原理，解开心中的一些疑惑。 1. 什么"}, {"id": "7004740971824939045", "title": "目标是实现webpack打包零配置", "desc": "目标是实现webpack打包零配置（配置在内部已默认设置，可重写覆盖） 包括创建项目、本地运行项目、打包线上项目 基本功能 SPA/MPA 单选 Router、Vuex 多选 esl"}, {"id": "6954891826604015630", "title": "主流前端代码构建工具评测", "desc": "本文简单介绍了主流的打包工具，并借助Tooling.Report从6个维度对部分工具进行了横向比对。"}, {"id": "6844904100052615181", "title": "精读《Webpack5 新特性 - 模块联邦》", "desc": "我们知道 Webpack 可以通过 DLL 或者 Externals 做代码共享时 Common Chunk，但不同应用和项目间这个任务就变得困难了，我们几乎无法在项目之间做到按需热插拔。 模块联邦是 Webpack5 新内置的一个重要功能，可以让跨应用间真正做到模块共享，所以…"}, {"id": "6844903577815613453", "title": "移动spa商城优化记（一）---首屏优化篇", "desc": "随着公司业务的不断壮大，最近老是有用户反应公司APP内的商城打开比较慢，这可不行啊，慢了容易流失用户，流失用户减少公司业绩，公司业绩少我的年终奖就少…………，所以为了公司，也为了自己，开始优化之路。 商城系统是去年开发的，是一个基于vue2.0的spa项目，最好的优化思路当然是…"}, {"id": "6977714585235095583", "title": "gulp甜心🍩，有些事webpack不方便做，你帮办了吧", "desc": "gulp往往在wabpack不方便的情况给予帮助，二者相互结合，也恰恰呼应了Moderate的主张，中庸兼容，保中守和。"}, {"id": "6959755835354382367", "title": "webpack之外的打包工具（Rollup，Parcel）", "desc": "webpack之外的打包工具（Rollup，Parcel） 我们接触最多的可能是webpack，但现在其实还有很多其他的打包工具，所以在此文章做一个整理，让我们有更多的角度去认识打包工具的发展，也有助"}, {"id": "6844903733885665294", "title": "用于前端开发的webpack4配置[带注释]", "desc": "随着web开发变得越来越复杂，我们需要使用工具来帮助我们构建现代化网站。这是一个完整通过复杂webpack4配置的线上生产例子。 构建现代化网站已经成为自定义应用程序开发，网站期望能做的更多，具有传统应用的功能，而不仅仅是一个推广网站。 随着一个流程变得复杂时，我们就会将它分解…"}, {"id": "6844903779712630797", "title": "webpack系列之三resolve", "desc": "webpack 的特点之一是处理一切模块，我们可以将逻辑拆分到不同的文件中，然后通过模块化方案进行导出和引入。现在 ES6 的 Module 则是大家最常用的模块化方案，所以你一定写过 import './xxx' 或者 import 'something-in-nodemod…"}, {"id": "6844904164707794951", "title": "Webpack 如何配置热更新", "desc": "是指 Hot Module Replacement，缩写为 HMR。对于你需要更新的模块，进行一个\"热\"替换，所谓的热替换是指在不需要刷新页面的情况下，对某个改动进行无缝更新。如果你没有配置 HMR，那么你每次改动，都需要刷新页面，才能看到改动之后的结果，对于调试来说，非常麻烦…"}, {"id": "6987704172116181029", "title": "初识webpack", "desc": "前端发展史 早期阶段 早期前端只负责写静态页面，纯粹的展示功能，js也就是简单的做一些表单的验证，特效渲染等 现阶段的Web 前端可以管理数据以及和用户互动。由于用户交互、数据交互的需求增多，也就出现"}, {"id": "6990267165697900575", "title": "为什么我从 Webpack 转向了 Snowpack？", "desc": "Webpack 有何劣势？ 很长一段时间里，Webpack 几乎成为了前端代码打包的标准，它拥有灵活的打包配置、可拓展的插件机制、大量官方提供的插件用以支持不同类型的文件。Webpack 通过模块之间"}, {"id": "6976447193049726983", "title": "Webpack插件(Plugin)开发——获取git版本信息", "desc": "Webpack插件(Plugin)开发——获取git版本信息，手把手教你实现一个webpack插件开发和发布"}, {"id": "6990611449341181989", "title": "webpack实现Tree Shaking", "desc": "TreeShaking顾名思义是将代码中未使用的代码删除掉，从而减小整个文件的打包体积。 让我们先来看看没有进行Tree Shaking之前的打包文件： mamth.js: 入口文件： webpack"}, {"id": "6847902222873788430", "title": "『Webpack系列』—— loader配置详解", "desc": "从语法角度看，loader是一个普通的Node.js模块，只是必须以函数格式导出来供使用。如果有必要可以使用一切Node.js功能模块。 从功能角度看，loader是在Webpack中作用于指定格式的资源文件并将其按照一定格式转换输出。例如：less-loader将less文件…"}, {"id": "6844903584933347335", "title": "webpack4.0打包优化策略(一)", "desc": "happypack提供的loader，是对文件实际匹配的处理loader。这里happypack提供的loader与plugin的衔接匹配，则是通过id=happypack来完成。\b\b 资料:happypack原理解析-淘宝前端\b 将web应用依赖的基础模块抽离出来，打包\b到单…"}, {"id": "6844903582639063047", "title": "webpack4之基础篇", "desc": "1. 什么是webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 2. webpack核心概念 En…"}, {"id": "6867774131061030925", "title": "前端开发中常用的webpack优化和相关原理", "desc": "webpack优化方向关于webpack的优化，通常我们是划分为开发体验和输出代码质量两方面来考虑的(一）优化开发体验通常是从优化构建速度和使用体验【开发环境】缩小文件的搜索范围（loader配置in"}, {"id": "6984297236851064862", "title": "webpack 从 0 到 1 构建 vue", "desc": "酷炫动画的页面，高度复杂的页面功能，页面内容支持预加载(图片、骨架屏) ，这些高要求导致了项目的增加更多的代码。代码的增多，使得由来代码需要被组织的需求，由此产生了模块化。"}, {"id": "6952703369135800350", "title": "Webpack打包文件分析与动态加载原理", "desc": "一、构建结果分析先从一个简单的模块开始。假设我们有一个hello模块如下，使用webpack进行构建后，得到的结果如下，我们的代码经过webpack构建后，生成的是一个IIFE。该自执行函数先定义了一"}, {"id": "6983985071699001357", "title": "webpack5新特性", "desc": "webpack5 已经发布，列举了主要的新特性及使用方法：内置静态资源、长期缓存、更好的treeshaking、模块联邦。"}, {"id": "7002101664471580680", "title": "认识webpack、安装、配置", "desc": "认识webpack、基于webpack3的安装、起步、配置、loader使用、配置vue、plugin插件使用、配置分离"}, {"id": "6995131387145617416", "title": "使用gulp及webpack写入全局数据", "desc": "这是我参与8月更文挑战的第11天，活动详情查看：8月更文挑战 前言 在现在普遍前端工程化的时候，我们时常会使用webpack/gulp等打包工具来打包项目以便开发与上线。 我们在代码中也会写入全局不可"}, {"id": "6955266854839386119", "title": "webpack5上手指南", "desc": "前言 webpack5正式发布已经大半年了，一直囔囔着要去看看这次更新带来了哪些新特性，但是因为实在是太（xue）忙（bu）了（dong），所以一直没有去实践。但作为一名热爱学习的切图仔，让我不学那是"}, {"id": "7005090801210359822", "title": "使用webpack 遇到的一些问题", "desc": "无法加载文件 webpack.ps1,因为在此系统上禁止运行脚本；总显示要安装`webpack-cli`，安装后再次执行还是提醒安装"}, {"id": "6978663149947846669", "title": "Webpack5源码分析二-Webpack5实现ESModule模块化的原理", "desc": "Webpack 作为前端使用最广泛的打包工具，它支持 CommonJS、AMD 和 ES module 模块化。本文将从源码分析 Webpack5 是如何帮助我们实现代码中支持ESModule。"}, {"id": "6992884343446192165", "title": "三天看懂Webpack", "desc": "这是我参与8月更文挑战的第1天，活动详情查看：8月更文挑战 Webpack-01 在网页中会引用哪些常见的静态资源？ JS .js .jsx .ts（TypeScript） CSS .css .les"}, {"id": "6844904146827476999", "title": "深入webpack打包原理，loader和plugin的实现", "desc": "1. webpack打包基本原理 1. 处理单个模块（以入口为例） 我们可以看到，入口文件index.js的所有内容都以字符串形式输出了，我们接下来可以用正则表达式或者其它一些方法，从中提取到import以及export的内容以及相应的路径文件名，来对入口文件内容进行分析，获取…"}, {"id": "7005847989918908423", "title": "每日一记：webpack部分", "desc": "五个核心 loader介绍 处理css 资源模块 在 webpack 5 之前，通常使用： raw-loader 将文件导入为字符串，在应用程序中通过 import xx from 'xx.xx'直接"}, {"id": "6854573219245441038", "title": "源码篇（三）：手写webpack版mini源码分析项目构建过程。附送简版webpack源码", "desc": "本文适合2~4年的前端开发人员的进阶，且对vue或者react搭配webpack有一定的经验。如果webpack的基本使用都未了解，建议实践后再看本文。 本文是原创，均为本人手写。部分思维, 借鉴了“宫小白”的webpack文章。文章结尾标注了“感谢”。 此前有人关心博客源码的…"}, {"id": "6844903789388890119", "title": "我是如何让公司后台管理系统焕然一新的(上) -性能优化", "desc": "马上到了金三银四的时间，很多公司开启了今年第一轮招聘的热潮，虽说今年是互联网的寒冬，但是只要对技术始终抱有热情以及有过硬的实力，即使是寒冬也不会阻挠你前进的步伐。在面试的时候，往往在二面，三面的时面试官会结合你的简历问一些关于你简历上项目的问题，而以下这个问题在很多时候都会被问…"}, {"id": "7004704884867989541", "title": "【基础篇】webpack5搭建Vue3+Typescript 基础开发环境", "desc": "从零开始，使用webpack5搭建Vue3+Typescript 基础开发环境，摸清脚手架搭建思路。"}, {"id": "6844903614759043079", "title": "一步一步的了解webpack4的splitChunk插件", "desc": "webpack4出了两个月，发现大家包括我对splitChunk的使用都还是在摸索阶段。我也看了挺多别人的配置demo，都觉得不太满意或者没得到太好的解惑，issue 下面的问题也没什么人回复，只能自己操作了，顺便记录下来，如果大家有更好的，欢迎评论区留下地址。 maxAsyn…"}, {"id": "6998069501690380295", "title": "webpack的watch模式下因 loader 缓存导致的问题", "desc": "webpack的watch模式下会产生一个问题，修改完其中一个文件后，这个文件重新走loader，其他没有修改的文件不会再走loader，导致本次编译后统计的资源丢失。"}, {"id": "6968364739625746463", "title": "尝鲜 vite，和 webpack 比还缺哪些好用插件？", "desc": "与 webpack 在全过程依赖 babel-loader 处理代码不同的是，vite 在开发过程中使用 esbuild 构建。"}, {"id": "6987691433276735502", "title": "webpack基础知识总结", "desc": "什么是webpack？ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 为什么要使用webpack？ 现在很多网页都"}, {"id": "6993324029713055751", "title": "webpack之loader详解", "desc": "基础概念 webpack是一款强大的模块打包工具,它可以引入配置文件完成前端高度定制化的构建工作. webpack默认只能理解JavaScript和JSON文件,但实际工作中各种需求层出不穷,文件类型"}, {"id": "6844903748783996942", "title": "📚免费的渐进式教程：Webpack4的16篇讲解和16份代码", "desc": "首先，没有标题党！这套教程确实是免费的，并且针对每节讲解准备了对应的代码，代码环境是webpack4。 课程以常见的webpack4用法为主线，按照从易到难的顺序，逐步引导搭建，渐进式教程真香。 说句实在话，webpack4其实完全靠文档，但是刚入手的时候还是有个简易教程比较好…"}, {"id": "6992390913808924685", "title": "webpack 开发环境的基本配置", "desc": "创建配置文件 1. 创建文件 和src同级创建webpack.config.js 2. 配置内容如下 打包样式资源 1. 创建文件 2. 下载安装loader 包 npm i css-loader s"}, {"id": "6985156076123619342", "title": "轻松搞定 webpack loader （基础>>>深入）", "desc": "我们根据三个问题深入学习 loader 。 什么是 loader ，它能干什么? 为什么需要 loader ? 如何使用 loader ，有哪些要掌握的核心?"}, {"id": "6953408023217831973", "title": "【Webpack】聊聊 Source Map 的使用", "desc": "为什么要在 Webpack 中使用 Source Map？以及 Webpack 提供了哪些 Source Map 的使用方式？我们应该在开发环境和生产环境如何使用 Source map？"}, {"id": "6844903713312604173", "title": "干货！撸一个webpack插件(内含tapable详解+webpack流程)", "desc": "Webpack可以将其理解是一种基于事件流的编程范例，一个插件合集。 而将这些插件控制在webapck事件流上的运行的就是webpack自己写的基础类Tapable。 将plugin控制在webapack事件流上运行（如下图）。后面我们将看到核心的对象 Compiler、Com…"}, {"id": "6844903588607557639", "title": "带你走进webpack世界，成为webpack头号玩家。", "desc": "最近朋友圈被《头号玩家》刷爆了，斯皮尔伯格一个资深电影导演，把对过去经典的致敬，对未来的憧憬浓缩在这一部电影中，可以说让观众燃了起来。 观望整个前端开发，不断的演化，发展迅速。前端开发从最开始切页面, 前端自动化构建工具日新月异，从最初的Grunt,Gulp到现在前端项目可以说…"}, {"id": "6969443457450393607", "title": "webpack 编译原理(How webpack compiles)", "desc": "大力智能前端基础架构团队在为业务项目优化编译速度的过程中，对基于 webpack 的编译过程进行了研究。本文对此进行展开在源码层面讲解 webpack 的编译原理。"}, {"id": "6995743236941692936", "title": "Webpack配置-source-map", "desc": "初识source-map 一般我们打包发到服务器的代码都是被压缩丑化之后的，有些项目配置了一下浏览器兼容的插件之后，会将es6的代码转换成 es5,这样我们在开发调试的时候如果是部署到测试服的项目出问"}, {"id": "7005817236090781733", "title": "webpack打包公共库", "desc": "webpack如何打包一个公共库呢，有兴趣的童鞋请往下冲~~ 一、创建项目 新建项目文件夹，文件夹下创建src文件夹，src文件夹中创建index.js和other.js。 index.js: 初始化"}, {"id": "6998860493490225189", "title": "webpack5——配置", "desc": "你可能已经注意到，很少有 webpack 配置看起来完全相同。这是因为 webpack 的配置文件是 JavaScript 文件，文件内导出了一个 webpack 配置的对象..."}, {"id": "6998865245326278664", "title": "webpack5——模块解析", "desc": "resolver 是一个帮助寻找模块绝对路径的库。 一个模块可以作为另一个模块的依赖模块，然后被后者引用..."}, {"id": "6994267191516332046", "title": "前端工程化之3分钟讲清楚最经典的前端打包工具webpack基础", "desc": "概念 Webpack 是一种前端资源构建工具，一个静态模块打包器。一个前端项目中包含了很多资源，但是浏览器并不一定全部认识，比如sass、less、ts，包括js里的高级语法。这些资源如果想在浏览器中"}, {"id": "6998810700688654373", "title": "前端工程化-webpack归纳与总结", "desc": "这是我参与8月更文挑战的第21天，活动详情查看：8月更文挑战 目前前端已经全面进入模块化和工程化的阶段,不仅有我们炒常用webpack项目构建工具,尤大又推出了更快的vite(下文讲解),本文主要对模"}, {"id": "6900400789949267975", "title": "实现一个移除 console.log 的 webpack 插件", "desc": "本文目的，实现一个可以移除项目中 console.log 的 webpack 插件。借此，我们可以学习一下webpack 插件怎么写。 本来以为比较简单，但还是花了我一个上午的时间。 此时我们运行 yarn build 就会在 dist 目录打包出一个 main.js。我们使用…"}, {"id": "6961299855981428750", "title": "写了个 babel-plugin，我收获了不止一点", "desc": "一、问题引出 我们知道 react 中一切皆组件，公共组件一般都会在 src 目录下新建 components 目录来存放。那么问题来了：如果组件拆分得细而多，那么文件数量自然而然就多了起来，我们在使"}, {"id": "6995469197673234469", "title": "写给走近webpack的自己：webpack notebook", "desc": "前言： hello guys！注意标题~ 本文旨在记录学习、自娱自乐。 如果能帮到一些同样对webpack不甚了解的同学我会很开心，但请各路神仙勿喷勿喷哈。"}, {"id": "6997322527512985614", "title": "手撸一个webpack骨架屏插件", "desc": "一直在做移动端开发, 用到了骨架屏, 发现公司的骨架屏是基于chrom插件生成的, 即在浏览器中运行网页地址, 然后基于插件生成(前人实现的, 具体的逻辑没有深入), 那么我们可不可以在代码打包的时候"}, {"id": "6995931392009830431", "title": "webpack5 整理使用", "desc": "各人学习笔记，完全 没有 任何参考性。 webpack解决了什么问题？ webpack 是前端静态资源（模块）构建工具，静态模块打包器。 其是由nodejs编写的前端资源加载/打包工具，由nodejs"}, {"id": "6949798690135801864", "title": "带你解析微前端新方案-Module Federation", "desc": "webpack5模块联邦为我们提供了一种在应用程序之间共享代码的新方法。用白话来说，模块联邦提供了一种模块间共享代码的能力，为前端代码组织结构提供新的思路。来一起深入探究下，揭开他滴面纱"}, {"id": "6844903646535106568", "title": "手把手教你用原生JavaScript造轮子（一）——分页器（文章内容已过期，可不看）", "desc": "日常工作中经常会发现有大量业务逻辑是重复的，而用别人的插件也不能完美解决一些定制化的需求，所以我决定把一些常用的组件抽离、封装出来，形成一套自己的插件库。同时，我将用这个教程系列记录下每一个插件的开发过程，手把手教你如何一步一步去造出一套实用性、可复用性高的轮子。 要开发一个J…"}, {"id": "7000251029518286884", "title": "webpack掠影-1", "desc": "什么是 webpack，从零配置 webpack，最后一起看看webpack源码中的奥秘，不来看看吗"}, {"id": "6971607960531238926", "title": "Webpack配置环境变量 - 避免踩坑", "desc": "今天来讲一下Webpack配置环境变量，那么环境变量是干啥的。我们在开发项目中都会遇到这种场景，区分开发环境、生产环境、测试环境，不同场景请求不同的接口Api...."}, {"id": "6872505128939683848", "title": "Webpack5 跨应用代码共享 - Module Federation", "desc": "Webpack 5 的消息尽管已经出来了许久，但是正式版一直还未发布。Webpack 5 的 ChangeLog 中，除了常规的性能优化、编译提速之外，有一个比较让人期待的功能就是 Module Federation。Module Federation 可以强行翻译成「模块联邦…"}, {"id": "6966785086473633806", "title": "Webpack 原理系列七：如何开发 Loader", "desc": "阅读了 20+ 个开源项目，我总结出来的关于 Webpack Loader 的关键知识点，走过路过进来看看呗。"}, {"id": "6844903661726859272", "title": "Vue项目骨架屏注入实践", "desc": "相比于早些年前后端代码紧密耦合、后端工程师还得写前端代码的时代，如今已发展到前后端分离，这种开发方式大大提升了前后端项目的可维护性与开发效率，让前后端工程师关注于自己的主业。然而在带来便利的同时，也带来了一些弊端，比如首屏渲染时间(FCP)因为首屏需要请求更多内容，比原来多了更…"}, {"id": "6915638604056231949", "title": "webpack搭建React项目（2）", "desc": "之前通过一些 webpack 的简单配置，项目可以使用 React 来编写基本组件了，但是每次编写组件，都需要重新执行webpack命令打包，然后再手动在浏览器中打开页面才能看到开发结果，这是十分影响开发效率的，我们要的效果yarn start启动项目运行，在开发过程中使用ct…"}, {"id": "6844904137960718344", "title": "Webpack - 性能优化", "desc": "1、对MVVM架构的理解？ 2、对Vue生命周期的理解？ 3、Vue异步请求适合在哪个生命周期中调用？ 4、Vue组件之间如何通信？ 5、computed和watch有什么区别？ 6、Vue是如何实现"}, {"id": "6914855529085042696", "title": "webpack5源码导读：如何实现自定义 target", "desc": "webpack5 正式版已经发布三个月了，目前最新版本是 5.11.1。具体的迁移指南请参考 webpack 官方的文档： 建议参考 webpack 官方的这些文档，比参考一些不完全、不准确的翻译有效的多，唯一的问题是有可能每个词都认识，连在一起却不知道是什么意思。 1. 阅读…"}, {"id": "6844903605829369863", "title": "Webpack基本架构浅析", "desc": "前言截止到今日webpack的star数超过4万了，发展速度还是很快的。今日早读文章由网易考拉海购@Gloria投稿分享。正文从这开始～随着掌握的前端基础知识越来越多，对技术的要求逐渐不满足于实现即可"}, {"id": "6861102079550128136", "title": "webpack基本使用（一） webpack整体了解", "desc": "1.webpack简介webpack官网中对其定义为一个静态模块打包器(modulebundler)。从中可以看出：webpack最基本的作用是打包功能。webpack打包生成的文件是静态资源。2.打"}, {"id": "6844903538246549511", "title": "Webpack实战-为单页应用生成HTML", "desc": "在简单的项目里因为只输出了一个 bundle.js 文件，所以手写了一个 index.html 文件去引入这个 bundle.js，才能让应用在浏览器中运行起来。 在实际项目中远比这复杂，一个页面常常有很多资源要加载。接下来举一个实战中的例子，要求如下： 项目采用 ES6 语言…"}, {"id": "6844903825170497550", "title": "webpack基础配置", "desc": "学习了下webpack华丽花哨让人头疼的基础配置，赶紧来做个记录。 安装完成后在根目录下建立个webpack.config.js,我们来看看基础配置项都有哪些。 文件入口是src目录下的index.js,打包好的js都放入static目录下的js目录中。 在package.js…"}, {"id": "6844903577765281806", "title": "使用import配合React-Router进行code split", "desc": "代码分片可以让你把应用分成多个包，使你的用户能逐步加载应用而变得流行起来。在这篇文章中，我们将会看一下什么是代码分片和怎么去做，了解怎么去配合React Router去实现它。 现在是2018年。你的用户不需要为了一小块内容而去下载整个应用。如果一个用户下载所有的代码，仅仅是为…"}, {"id": "6936405338388168735", "title": "优化项目", "desc": "如果没有这个设置，项目首屏加载时会加载整个网站所有的JS文件，所以将JS文件拆开，点击某个页面时再加载该页面的JS是一个很好的优化方法。 这里用到的就是vue的组件懒加载。在router.js中，不要使用import的方法引入组件，使用require.ensure。 默认情况下…"}, {"id": "6913747549287350285", "title": "webpack css篇", "desc": "私有前缀postcss-loader(样式处理工具)autoprefixer(私有前缀的插件)npminstallpostcss-loaderautoprefixer-D分离cssnpminstall"}, {"id": "6844903498153197575", "title": "keep-loader for webpack", "desc": "keep-loader用于在不同的打包环境下需要生成不同的代码的场景，就像C/C++中的宏特性一样。提供了一种在源码中控制打包阶段生成不同代码的能力。 注意：打包的时候，keep-loader的keep参数的值代表当前打包环境。keep-loader会根据这个环境参数决定打包过…"}, {"id": "6935846715488632863", "title": "[ webpack ]webpack 构建基本配置参数", "desc": "每个前端项目或者说每一个HTML页面，都有着不同的静态资源，其中js文件有相互之间又有着不同的依赖，img图片需要进行图片压缩合并，css文件有需要进行浏览器样式的兼容写法，这些都可以通过webpack这个工具把所有不同的文件用一个引子进行打包最终生成一份 html ，css …"}, {"id": "6844903922033770510", "title": "从零实现一个 JS 模块打包器", "desc": "2019 年的前端技术栈，无论你是用 Vue 还是用 React ，应该都离不开一样工具 -- webpack。webpack 极大的简化了前端开发的构建过程，只需提供一个入口文件，webpack 就能自动帮我们分析出相关依赖，构建出 bundle 包。 webpack 很强大…"}, {"id": "6854573217173110792", "title": "Webpack的基本使用总结", "desc": "帮postcss找到package . json中browserslist里面的配置，通过配置加载指定的css兼容性样式 package . json中eslintConfig中设置"}, {"id": "6844903813346770958", "title": "【Vue】Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路", "desc": "最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题： 没有实现JS压缩、CSS兼容等功能。 在开发模式下…"}, {"id": "6844903655406043143", "title": "终极蛇皮上帝视角之微信小程序之告别“刀耕火种”", "desc": "这样一来和日常开发前端页面的体验相比来说，简直就像在刀耕火种。 在 webpack-simple 中文件结构和小程序相似。 而在 webpack-vue 中还增加了 vue-loader，因此你甚至还能利用 .vue 文件编写单文件组件。 既然用 webpack 来编译源代码，…"}, {"id": "6844903812700831751", "title": "webpack手动配置笔记", "desc": "通过 @vue/cli 搭建交互式的项目脚手架。"}, {"id": "6943447859756793864", "title": "Webpack4散记（5）写一个loader", "desc": "loader是一个function，使用commonjs导出。（模块管理、导出类型） loader的作用是转换资源。（函数需要返回值） loader这个函数需要使用this上下文，来使用LoaderAPI提供的接口。(不能是箭头函数） 代码剥离和代码压缩两个行为合并，偏离最初的…"}, {"id": "6844903954225053704", "title": "webpack基础配置详解", "desc": "webpack基本配置webpack&&webpack-cliwebpack-dev-serverWebpackDevServer本地服务webpack-dev-server基础配置webpack-d"}, {"id": "6844903635130793997", "title": "javascript模块化发展历程", "desc": "一个模块就是实现特定功能的文件, 逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部使用的话直接引入对应的package即可. 就好像作家会把他的书分章节和段落；程序员会把他的代码分成模块。 就好像书籍的一章，模块仅仅是一坨代码而已。 …"}, {"id": "6844903537093132301", "title": "webpack 为什么这么难用？", "desc": "如今对于每一个前端工程师来说，webpack 已经成为了一项基础技能，它基本上包办了本地开发、编译压缩、性能优化的所有工作，从这个角度上来说，webpack 确实是伟大的，它的诞生意味着一整套工程化体系开始普及，并且慢慢统一了前端自动构建的让前端开发彻底告别了之前的刀耕火种时代…"}, {"id": "6980582674641453064", "title": "解决webpack5 webpack devServer可以重新编译但浏览器不能自动刷新的问题", "desc": "使用webpack5，browserslist会导致devServer重新编译但浏览器无法自动刷新。想要实现局部刷新，可以使用 webpack自带的HotModuleReplacementPlugin"}, {"id": "6844904005286494215", "title": "从零开始构建一个webpack项目", "desc": "新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。 输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你…"}, {"id": "6995442242315878413", "title": "webpack5 入门04 环境变量", "desc": "01. 简介 这一章东西比较少，但是可以延伸的比较多。 项目肯定分环境，你可以依据环境打包你需要的 JavaScript 我知道的一般3中方式 不同的 config , 使用 merge , 在命令行"}, {"id": "6844904163369811981", "title": "大声对webpack4.0说声你好之webpack的基本使用(一)", "desc": "首先很感谢看到这篇文章的各位朋友，我是一个比较热爱技术的菜鸟，写这篇文章是对我看到某课网《从基础到实战 手把手带你掌握新版Webpack4.0》的总结，也算做自己的一次学习记录，如果对您有帮助我表示很荣幸，但如果您看到了我的错误总结还请您不吝赐教。 Webpack 是一个开源的…"}, {"id": "6895375915140939790", "title": "webpack 按需加载模块 import()", "desc": "随着产品的不断演化发展，整个应用常常不可避免的变得越来越庞大，此时首屏渲染时间或者首次加载时间都会加长。然后性能优化就会被排上日程。在众多的性能优化方案中，对模块做按需加载，无疑是最有效的方法之一。使用 webpack 的 import() 方法即可轻松实现模块的按需加载。 我…"}, {"id": "6867083171125526535", "title": "H5 基础脚手架：极速构建项目", "desc": "这个插件大杀器，放在最后隆重介绍一下，随便放上去就行，为模块提供中间缓存的。 构建速度从最开始的 7s 优化到最后的 2.5s（主要是二次构建，缓存提效，你就说爽不爽吧）。 此项目是从零开发，后续此系列博客会根据实际开发进度推出（真 TMD 累），项目完成之后，会开放部分源码供…"}, {"id": "6910913987613818894", "title": "Webpack5热替换，压缩JS、CSS、图片，基础优化新方法", "desc": "Webpack5自带，不用安装。暂时忘记UglifyjsPlugin ParallelUglifyPlugin和环境变量吧 cache不再单独配置。遵循webpack的cache设置（与optimization同级） sourceMap不再单独配置。遵循webpack的devt…"}, {"id": "7000314900002111519", "title": " Webpack5的一些新特性", "desc": "8月更文挑战,Webpack5的一些新特性，以及webpack5做了哪些优化，模块联邦、tree-shaking、缓存优化..."}, {"id": "6844903569917739021", "title": "webpack打包之后的文件过大的解决方法", "desc": "以前一直使用create-react-app这个脚手架进行react开发，后面因为一些自定义的配置，转而使用webpack搭建一套自己的脚手架。但是在使用webpack打包之后发现，纳尼？怎么文件这么大？？？ 于是研究了一下如何处理webpack打包之后文件太大的情况，简单记录…"}, {"id": "6844903593271787533", "title": "vue-cli 3.0 特性速读", "desc": "最近的开发项目中使用了vue-cli 3.0，使用体验可以说非常棒了，模板更加制定化，配置更加简洁。以下总结下应用过程中的一些经验。 打包后的文件，对引用资源注入了预加载（preload/prefetch），启用 PWA 插件时注入 manifest/icon 链接，并且引入(…"}, {"id": "6844904168868544525", "title": "从零构建到优化一个类似vue-cli的脚手架", "desc": "想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 vue-cli 等脚手架开发，一是方便省去了好多配置上的功夫，二是 vue-cli 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。 但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就…"}, {"id": "6844903692726976519", "title": "多页应用 Webpack4 配置优化与踩坑记录", "desc": "最近新起了一个多页项目，之前都未使用 webpack4，于是准备上手实践一下。这篇文章主要就是一些配置介绍，对于正准备使用 webpack4 的同学，可以做一些参考。 webpack4 相比之前的 2 与 3，改变很大。最主要的一点是很多配置已经内置，使得 webpack 能“…"}, {"id": "6870312297055649800", "title": "webpack搭建项目流程(纯干货)", "desc": "对于前端同学来说webpack应该一点不陌生，现在应该大部分的工程都在使用webpack来进行构建。 现在很多的框架都已经提供相应的脚手架命令行工具，直接执行之后就会生成对应的模板项目。 但是我们仍然需要知道webpack的工作原理到底是什么？知道之后也方便我们对现有的项目进行…"}, {"id": "6844903966896029703", "title": "从零配置webpack 4+react脚手架（一）", "desc": "如果你和我一样学习了webpack相关的教程，并跟着webpack官方指南进行了一些简单的配置，但是不知道如何去使用它，那么这个系列的文章将通过搭建webpack+react脚手架给予你一定的配置经验，写这个系列的文章一是为了方便以后自己有配置需求时可以及时回顾，二是加强自己对…"}, {"id": "6844903830266576909", "title": "webpack系列之五module生成1", "desc": "对于 webpack 来说每个文件都是一个 module，这篇文章带你来看 webpack 如何从配置中 entry 的定义开始，顺藤摸瓜找到全部的文件，并转化为 module。 webpack 入口 entry，entry 参数是单入口字符串、单入口数组、多入口对象还是动态函…"}, {"id": "6919651702303883272", "title": "不小心将 Webpack 升级后我搞定了微前端。", "desc": "昨天项目升级的时候，把Webpack升级了一个版本。瞬间让我囧大了，你懂的，我就不说了。反正给我一顿操作啊，终于摆平了。再梳理项目的时候，我用Webpack新版本的模块联邦还真实现了应用程序和应用程序"}, {"id": "6859539849972711437", "title": "JS SDK 构建实现 Webpack VS Rollup", "desc": "最近一段时间在开发 JavaScript SDK，讲究 原生、短小、快速、清晰、可读性、可测试性 等等。 而 SDK开发 关键的一环则是 打包， 恰恰打包这一环决定了 SDK 的体积（短小）、引入方式（原生）,一部分速度问题（快速）。 开发过程中分别使用 Webpack5 与 …"}, {"id": "6850418117500715015", "title": "『Webpack系列』—— MiniCssExtractPlugin插件用法详解 ", "desc": "用某度翻译后：“该插件将CSS提取到单独的文件中。它为每个包含CSS的JS文件创建一个CSS文件。它支持CSS和SourceMap的按需加载。” 搭建个简单的Wenpack Demo，演示一下。 先安装MiniCssExtractPlugin插件。 安装成功后，在webpack…"}, {"id": "6844903998537859086", "title": "webpack从入门到进阶", "desc": "在我们平时的开发中，会经常使用到webpack，但很多时候我们都不做任何配置(webpack4)也可以进行开发，但是默认的配置真的够我们使用了吗？所以本文将带你开启webpack的大门。 本身是一个函数，接受源文件作为参数，返回转换的结果。 ⽂件监听是在发现源码发⽣变化时，⾃动…"}, {"id": "6844903861832941575", "title": "前端路由&webpack基础配置,原理", "desc": "1. SPA 2. 前端路由: 3. 前端模块化 4. webpack基础配置 自定义解析和转换文件,配置module,通常是配置module.rules里的 Loader。(资源加载器) 6. webpack打包原理 7. webpack与gulp的区别 8. webpack…"}, {"id": "6844903860150992903", "title": "webpack学习之路（一）基础配置", "desc": "webpack是个模块打包机，无论什么资源都会被打包成模块，模块之间是有引用关系的，所以会构建一个关系依赖图，那么我们需要一个入口文件，从这个入口开始一步一步查找依赖关系，加载模块。 filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 mode是we…"}, {"id": "6844903870599020557", "title": "webpack 多页面应用配置小结", "desc": "今年公司一直在推行前后端分离开发，刚好有个活动开发的需求，于是想用react多页面应用去实现。该项目在create-react-app(@3.0.1)脚手架的基础上开发。 自此一个基于CRA的多页面应用webpack配置完成了，其他配置优化可根据自身需求调整。 配置后不需要手动…"}, {"id": "6844904190465032199", "title": "从零学习webpack4.0模块打包工具", "desc": "首先webpack是一个基于nodejs的打包工具，使用webpack，可以使我们的代码耦合度降低。拆分成模块化开发。 以前我们操作dom，需要把js代码全部写在一起，但是这样很不容易管理和维护，所以出现了webpack我们可以将文件按需导入和导出，用webpack会帮我们根据…"}, {"id": "6844903823840919565", "title": "图解ChunkSplitPlugin", "desc": "chunk(module 的集合)在 webpack 解析的依赖图中以父子关系联系起来的。最初CommonsChunkPlugin被设计用于 chunk 之间避免重复依赖，但是性能远远不是最优解。 在 webpack 4 中，内置了ChunkSplitPlugin用于替代Com…"}, {"id": "6844903570454609934", "title": "使用Webpack的代码拆分在Vue中进行延迟加载", "desc": "随着 Vue 应用程序越来越大，打包一个 build.js ，文件大小可能会有将近 1MB 。使用 Wepack 的代码拆分，延迟按需加载 Components、Router、Vuex modules ，会让 build.js 文件体积减少，首屏加载时间降低，用户体验更好。"}, {"id": "6844903871387533325", "title": "webpack入门学习笔记03 —— 自定义脚本，帮助项目管理", "desc": "1. 写在前面 经过前两章博客的基础讲解，我们知道如果想要打包编译项目，可以执行 npx webpack 命令，然后webpack就会根据配置文件 webpack.config.js 来对项目进行打包编译。但是现在我们可能遇到以下需求： 每次打包编译的时候，都要使用 npx w…"}, {"id": "6844903623713882120", "title": "webpack运行Babel教程", "desc": "由于低版本的浏览器没有支持ES6语法，这就意味着代码会出错。例如，在IE 10浏览器中，会出现\"语法错误\"： 当你使用更高版本的JavaScript语法时，比如ES7，低版本的浏览器将无法运行。为了兼容低版本的浏览器，比如万恶的IE，我们不得不使用Babel，将ES6、ES7等…"}, {"id": "6922976276579876877", "title": "webpack系列学习-loader编写", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 使用loader-utils包。先安装下。 通过 this.async来返回一个异步函数。第一个参数是Error, 第二个参数是处理的结果 2.缓存条件：loa…"}, {"id": "6904570163455066120", "title": "webpack系列之浅谈热加载", "desc": "webpack 是个很强大的构建工具，其丰富灵活的配置决定了使用也不简单。在面试中经常能遇到 webpack 相关的问题，如果平常只是使用脚手架如 vue-cli 而没有好好深入学习研究 webpack 的话，估计答不上什么。我相信，如果没有深入了解，部分面试官也问不出什么。可…"}, {"id": "6902441939560300558", "title": "Webpack学习笔记一：一些基础知识", "desc": "在日常开发过程中，相信大家都会使用到脚手架，比如 vue-cli 等等。诚然，脚手架可以让我们的日常开发更加便利，但是久而久之，逐渐依赖脚手架进行开发的我们，可能会对一些工具的使用逐渐生疏，比如 webpack 。尤其在公司的技术栈日趋稳定之后，我们手动配置 webpack 的…"}, {"id": "6844903687572160526", "title": "Nuxt升级2.0.0时出现的问题", "desc": "喜大普奔，Nuxt终于正式发布2.0了，最近趁热把博客从1.4升级到了2.0，并且用Typescript重构了下，可以点Jooger.me看下，在升级Nuxt过程中出现了一个小问题关于release2"}, {"id": "6913849719433363464", "title": "手写webpack前奏：拆解loader", "desc": "众所周知，loader执行顺序是从后向前，其实它还可以挂载一个pitch方法，执行顺序是从前向后，接收的参数是执行本loader之前和之后的参数的绝对路径。"}, {"id": "6844904136798896135", "title": "Webpack那些你不知道的事", "desc": "随着前端工程化的不断发展，构建工具也在不断完善。Webpack藉由它强大的扩展能力及万物皆模块的概念，逐渐成为前端构建工具中的小王子，随着webpack4的不断迭代，我们享受着构建效率不断提升带来的快感，配置不断减少的舒适，也许你已经可以熟练使用Webpack进行项目构建，但是…"}, {"id": "6882003085795786766", "title": "Webpack构建工具", "desc": "根据Webpack中文网给出的概念，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，…"}, {"id": "6844903917847838733", "title": "记录一个小问题：clean-webpack-plugin 路径不匹配问题", "desc": "今天在改造之前的一个老项目的webpack配置时，使用clean-webpack-plugin插件清除打包文件dist目录。得到一个error: 在官方NPM地址也没有找到答案。"}, {"id": "6978490896505372702", "title": "前端性能优化之三：webpack打包调优", "desc": "相信每个用过 webpack 的同学都对“打包”和“压缩”这样的事情烂熟于心，但是有些时候，我们在打包时会发现问题，构建的时间过长，打包体积过大"}, {"id": "6939708814555873311", "title": "652 webpack代码分离：多入口起点，入口依赖，SplitChunks，动态导入，代码懒加载，optimization.chunkIds、runtimeC", "desc": "optimization. runtimeChunk配置"}, {"id": "6844903639996170248", "title": ".vue文件中style标签的几个标识符", "desc": "项目中使用了elementUI框架, 与.vue文件. 现状: <template>中使用$style:[类名], <style module>进行了样式的绑定. 个人认为使用$style这种方式的绑定, 写起来很麻烦. 不仅仅是麻烦更重要的是, 没有办法直接影响和修改elem…"}, {"id": "6917150269193060365", "title": "webpack开篇杂论", "desc": "webpack是一个javascript的静态模块打包器，因为本身只能处理js，json文件，有了loader概念，使用loader可以处理css，html等等一些文件类型。我们想要更多的功能，更广的任务处理，有了plugins这个概念，plugins可以让我们有各种各样的功能…"}, {"id": "6844903845617745928", "title": "关于Android工程师转成vue的三两事儿(4)--webpack", "desc": "如上图所示，新建了一个项目。 在这里扯一句闲话，可能很多教程谈到安装webpack都会让你选择直接-g，但是我并不推荐你这么做,我总感觉-g之后就成了全局变量，但是我并不是每个项目内都能用到这个所谓的webpack，将webpack的作用域设置为项目内，功能与全局没有差别。 如…"}, {"id": "6844903566755250184", "title": "webpack深入 ——使用篇（一） | 席小白的边缘世界", "desc": "webpack 作为现在最通用的一个JavaScript 打包器,其特点就是高度可配置，不过这也导致了webpack的配置相当繁琐与难以理解，有时候你配错一点东西就会造成整个打包失败，尤其是不同版本的webpack的配置还有些许不同，更是让人难受（ps.所以Parcel才会打着…"}, {"id": "6844903518705287181", "title": "WebGL2系列之图元重启", "desc": "在使用WebGL绘制图形的时候，大多数情况下，绘制一个图形的时候，其各个图元都是相连的。 但是在一些情况下，我们需要绘制图元不相连的图形，如果绘制的模式是gl.TRAINGLES或者gl.LINES，也是可以达到的，但是如果绘制的模式是gl.TRAINGLE_STRIP，gl.…"}, {"id": "6844903535436365832", "title": "Webpack自动化构建实践指南", "desc": "由于现在的博客是使用wordpress搭建，自己得经常修改过一些代码，但是修改第三方源码真的比较痛苦，于是决定计划开始使用React + Node.js / Python开发新博客项目，最终替换当前博客代码，方便以后博客的维护和更新，也能实现自我开发技术，架构设计，解决问题能力…"}, {"id": "6844903503542878215", "title": "《深入理解ES6》阅读笔记 --- 用模块封装代码", "desc": "不知不觉《深入理解ES6》阅读笔记就写到了最后一篇，完结之后可能会开启另外的一个系列，分享自己的知识点，让阅读到的人有一点点的收获，以及自己的成长。最后一篇主要是来写一写用模块封装代码的事情，回顾历史"}, {"id": "7007986437131894821", "title": "Webpack —— 多入口出口配置", "desc": "对于项目中要面对多入口和多出口的情况，该如何配置webpack呢？ 这里有3种配置方案，快来看看吧～"}, {"id": "7007802443761188894", "title": "webpack5---3 css兼容性处理", "desc": "在实际项目中css需要兼容不同的浏览器，那么就需要使用插件将写好的css代码，做兼容性处理。这里我介绍下在 webpack5 中处理兼容性 此时webpack提供了postcss-loader和对应插"}, {"id": "7007401152086016013", "title": "webpack核心概念理解和拓展", "desc": "webpack核心概念理解，函数插桩，自动埋点，loader，plugin，chunk，hash、chunkhash、contenthash"}, {"id": "6874123325912645645", "title": "webpack快速实践教程", "desc": "入口即应用程序执行的入口文件，每个应用程序都有一个唯一的入口文件和方法，webpack根据入口文件生成应用程序依赖关系图，并把依赖项生成至bundles文件中。 loader类似中间件，使webpack可以解析并打包除js文件以外的文件。 loader用来处理某些特殊的文件或模…"}, {"id": "6844904104817328141", "title": "你不知道的 Webpack 性能优化配置", "desc": "开发环境：速度快，调试更友好。eval-source-map / eval-cheap-module-source-map chunkhash：根据 chunk 生成 hash 值。如果打包来源于同一个 chunk，那么 hash 值就一样 「contenthash」：根据文件…"}, {"id": "6844903987632685063", "title": "关于moment打包的那些事", "desc": "在项目中经常用到moment库，有没有发现引入moment之后，项目build完的文件大小明显大了不少，下面就来分析一下原因, 以及如何做优化。 只有几行代码， 编译出来的文件相差那么大。网上搜了一波才知道, 打包时把所有的locale都打包进去了, 初步解决方案是用webpa…"}, {"id": "6844903673357713422", "title": "webpack多页面入口生产项目开发配置", "desc": "这不是一个纯粹的学习帖子，最开始为了生产项目考虑的。公司有个新的、小的活动项目。以此为假想，所以我希望学习一些新的技术应用在上面；这个新的项目是作为旧项目的一个子系统存在的，所以又必须在一定程度上保持一致。 而这个旧项目的原有使用构建工具fis的版本比较老旧，不敢升级，怕出什么…"}, {"id": "6899623827337281544", "title": "深入学习webpack plugin到手写一个plugin", "desc": "Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。"}, {"id": "6844904176527343629", "title": "webpack 如何同时输出压缩和未压缩的文件", "desc": "不过这样的缺点就是我们需要运行两次。 不过这个有个缺点就是未压缩的文件没有 sourcemap。 这个时候生成的就完美了。"}, {"id": "6844903925171093518", "title": "webpack系列之七-附dependencyTemplates依赖模板", "desc": "webpack 对于不同依赖模块的模板处理都有单独的依赖模块类型文件来进行处理。例如，在你写的源代码当中，使用的是ES Module，那么最终会由 HarmonyModulesPlugin 里面使用的依赖进行处理，再例如你写的源码中模块使用的是符合 CommonJS Modul…"}, {"id": "6844903742186209287", "title": "webpack4源码分析", "desc": "tabpable是一个事件发布订阅插件，它支持同步和异步两种；在需要使用的类上继承tabpable，并且该类的构造函数中使用this.hooks添加事件名称。 要使用订阅功能，需要先拿到上面说到的类实例，通过实例对象.hooks.break.tap来订阅。 在需要触发的时机调用…"}, {"id": "6955030383083814948", "title": "webpack 系列之入门", "desc": "本文以项目角度去讨论一个webpack工程项目如何实现从0到1搭建。属于webpack入门系列第一篇。"}, {"id": "6976414542871920676", "title": "从了解Webpack到搭建vue开发环境", "desc": "最近刚好利用vue-cli创建Vue项目，其中对于打包的原理还是不够了解，在此记录一下。本人水平有限，本着分享快乐的精神主旨，希望能给大家提供一些参考，如果有错误的地方希望大家不吝指正。"}, {"id": "6844903594223730702", "title": "使用webpack搭建基于typescript的node开发环境", "desc": "正在学习node.js，这里介绍使用webpack来搭建基于typescript的node开发环境。"}, {"id": "6990897835470389284", "title": "webpack5打包vue项目", "desc": "webpack.config.js package.json 一些依赖说明 1）处理样式 less-loader 识别并转换less文件为 css css-loader 识别css文件 style-l"}, {"id": "6976556037130649630", "title": "webpack性能优化", "desc": "对CSS文件进行代码分割 场景 使用style-loader打包后会自动帮我们在html文件中加入<style>并将CSS往里填充，当CSS代码成千上万时，将会产生庞大的html。我们能不能在打包时将"}, {"id": "6844903633708908551", "title": "浏览器缓存和webpack缓存配置", "desc": "协商缓存：也称304缓存，向服务器发送请求，由服务器判断请求文件是否发生改变。如果未发生改变，则返回304状态码，通知客户端直接使用本地缓存；如果发生改变，则直接返回请求文件。 强缓存是最彻底的缓存，无需向服务器发送请求，通常用于css、js、图片等静态资源。浏览器发送请求后会…"}, {"id": "6844903927687675912", "title": "webpack优化", "desc": "原有的vue-cli,create-react-app在项目较大时编译时间过长，扩展性不好。重写了一套，优化了构建速度和体积。主要从以下优化了webpack 开启多线程压缩有多种方式，happy-pack/thread-loader/parallel-webpack等，ha…"}, {"id": "6844903593762357261", "title": "react技术栈全家桶（总结及感悟）", "desc": "react确实是一个神奇而优雅的框架。在从事react项目之前，一直是在做angular的，angular是一个全面和庞大的框架，在起初设计的时候什么都有，复杂程度也很高，所以用angular做项目基本上不需要其他的辅助库来配合。但是react项目真的是不一样了，要是只会一个r…"}, {"id": "6844903612804497421", "title": "从实践中寻找webpack4最优配置", "desc": "笔者最近在准备给fle-cli升级到webpack4版本，觉得有必要将探索过程的经验分享给大家，遂决定写这篇文章。（不知道fle-cli？看这里） webpack本身及社区工具存在或多或少的问题，未经时间沉淀，维护成本高。 然而现在，笔者认为以上这些已经成熟，是时候来一波升级了…"}, {"id": "6844903714935799822", "title": "webpack雪碧图生成", "desc": "先说下我们希望达到的效果。 4、在sass中编写，按需合并。 一种是以webpack-spritesmith、postcss-sprites为代表的插件，webpack-spritesmith主要的运行方式是会预先把sprite目录中的图标拼合好，页面主要依赖生成后的雪碧图。而…"}, {"id": "6927999024683286536", "title": "webpack基础知识总结", "desc": "入口起点指示webpack应用使用哪个模块来作为构建内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点依赖的。 默认值是./src/index.js，我们可以通过webpack config中的entry属性来指定一个/多个不同的入口起点。 outp…"}, {"id": "6965737365864349710", "title": "webpack —— babel", "desc": "一、简单介绍一下babel 官网介绍：Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本"}, {"id": "6941573363609370661", "title": "Webpack中loader的编译缓存", "desc": "编程界常见的两大“换”：【用时间换空间】与【用空间换时间】。 用时间换空间，常见于网络通信时对传输内容的编码和压缩，通过发送端花费计算时间编码、压缩和接收端花费计算时间解码、解压缩，减少传输内容体积，从而达到整体效率最优。 用空间换时间，常见于把需要较长I/O时间或者昂贵计算才…"}, {"id": "6844904181590032392", "title": "webpack之基本概念", "desc": "webpack从入口文件开始找与其直接或间接的依赖来构建依赖图。入口可以有多个 webpack只能识别js和json文件，loader 用于转换某些类型的模块。 plugin功能极其强大，可以用来处理各种各样的任务，包括：打包优化，资源管理，注入环境变量等等。 在上面的示例中，…"}, {"id": "6844903972944248846", "title": "💪从零开始学习webpack系列二（配置文件）", "desc": "基本配置配置文件在项目根目录新建webpack.config.js采用node.js写法导出一个对象「入口文件」entry：默认值是./src/index.js，可以自己指定文件也可以对象语法使用场景"}, {"id": "6844903865419218951", "title": "Webpack 4 构建大型项目实践 / 起步", "desc": "Webpack 是一个 Javascript 应用程序的静态模块打包器，它会读取 Javascript 文件所需依赖，并把他们打包到一个或多个目标文件。 准备安装 Webpack 之前请确认你已安装 Nodejs 最新稳定版本，过旧版本可能会缺少 Webpack 需要的包。 如…"}, {"id": "6844903577417154574", "title": "H5 Audio ES6版 系列教程之二", "desc": "为保证功能的正常，基本的浏览器检测是必要的。 Audio 内置方法和属性在不同浏览器下表现不一致或未实现等情况，此时应该区分浏览器类型及版本。 生成播放器的 DOM 结构，并插入到文档树中。 使用数组来存储 DOM 结构，通过配置项选择性地往数组里 push 相应的 DOM，最…"}, {"id": "6902755586413166605", "title": "webapck 基础 (小白篇)", "desc": "代码通过 Webpack Compile 进行编译打包，然后将编译好的文件传输给 Bundle Server （服务器），让文件以 server 的方式被 浏览器 访问到。 代码通过 Webpack Compile 进行编译打包，将代码发送给 HMR Server 知道哪些 j…"}, {"id": "6844903657784377351", "title": "browserify源码解析1——打包后文件解析", "desc": "四篇文字介绍browserify部分打包原理即所需基础——篇1打包后文件解析。"}, {"id": "6844903925796044814", "title": "【webpack】总览", "desc": "1. babel-loader 2. vue-loader Vue Loader v15是通过插件VueLoaderPlugin将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块。例如，如果你有一条匹配 /\\.js$/ 的规则，那么它会应用到 .vue 文件里的 <…"}, {"id": "6844903865150603277", "title": "webpack入门学习笔记01 —— webpack基本简介", "desc": "1. 写在前面 很多从事前端开发的程序员，都会接触到 webpack 非常熟悉的概念，但是我想很多人对webpack只是一知半解，知道这是一个打包器，可以将我们编写的Vue代码、React代码打包编译成原生的JS代码，方便浏览器识别。 但是对于webpack更底层的知识，比如：…"}, {"id": "6844903605930033166", "title": "[简单翻译+再加工] 从头开始创建一个 React 应用", "desc": "并不详细介绍 React 的写法。主要内容是 如何从无到有，创建并运行起来一个 React 应用。 React 简介 一句话介绍： React 是用于构建用户界面的 JavaScript 库。针对的是 View 层。 虽然 …"}, {"id": "6844903861769994248", "title": "webpack 4 的从零开始", "desc": "最近的项目开始了优化的工作，趁此机会重新学习了一波 webpack 4，希望把部分学习过程分享给大家。 工欲善其事，必先利其器。了解工具是很重要的，但在开始之前，我们要问自己一件很重要的问题：“该工具解决了什么问题？” webpack 是一个 模块打包器，它可以合并一组模块和他…"}, {"id": "6844903507133218829", "title": "webpackmonitor - 一个统计检测 Webpack 状态的插件", "desc": "Webpack Monitor is a configurable Webpack plugin that captures relevant statistics on your production builds, and an interactive analysis t…"}, {"id": "6916844223958351885", "title": "使用webpack+vue进行单页/多页应用配置-[七日打卡2]", "desc": "Single Application Page简写为SPA，不是那个斯霸，也不是那个SAP。 SPA可以理解成一个应用程序中只有一个 html 文件作为程序的入口，如果需求中有多个子页面跳转的话，一般是通过前端路由机制实现切换的。 简单来说就是由多个单页应用构成的一个应用。 我…"}, {"id": "6844903541425831944", "title": "优化Webpack构建性能的几点建议", "desc": "在开发现代 Web 应用的过程中，Webpack 和我们的开发过程和发布过程都息息相关，如何改善 Webpack 构建打包的性能也关系到我们开发和发布部署…"}, {"id": "6844904131136749575", "title": "AST抽象语法树(Abstract Syntax Tree)", "desc": "JavaScript Parser，把js源码转化为抽象语法树的解析器。 浏览器会把js源码通过解析器转为抽象语法树，再进一步转化为字节码或直接生成机器码。 一般来说每个js引擎都会有自己的抽象语法树格式，Chrome的v8引擎，firefox的SpiderMonkey引擎等等…"}, {"id": "6844903887082782728", "title": "react服务端渲染实践2: 数据预渲染", "desc": "上一章节，我们了解了react 服务端渲染的工程化配置，这一章节讲解如何进行数据预渲染，这是服务端渲染的核心目的。 无论是 react 的服务端渲染数据预取，还是 vue 的服务端渲染数据预取，都离不开状态管理工具，这里使用到的是 redux，如果不懂 redux 的使用，建议…"}, {"id": "6844903536149397518", "title": "Web开发这十年", "desc": "Web 开发这十年都发生了怎样的变化？"}, {"id": "6844903972952604679", "title": "💪从零开始学习webpack系列五（解析打包样式）", "desc": "样式处理了解loaderloader对于模块代码的转换，可以预处理文件loader有两个属性test：匹配出文件，是一个正则表达式use：使用哪种loader进行解析安装css-loaderyarna"}, {"id": "6844903918510538760", "title": "基于webpack的组件化pc电商首页项目总结", "desc": "个人练习项目总结... 写这个栏目的目的主要是方便以后自己回头回顾和深入学习一下每一块东西... ​ 在项目过程中由于要用到读取本地的json文件,但是由于webpack打包之后路径会更改的原因会导致路径的书写变得异常困难,于是便想到和vue-cli一样创建一个不会被处理的st…"}, {"id": "6844903508131463181", "title": "在工作过程中，逐步搭建的前后端分离方案和工具", "desc": "在我目前工作环境下，服务端给个接口，我再根据接口所需要传入的参数和返回的数据格式，来调整前端业务逻辑，有时候碰到服务端跑不起来，手头上的工作就没法再继续了，所以我要有个mock server，首先想到的是json-server，但是我们服务端接口并不是标准的REST API，而…"}, {"id": "6951297954770583565", "title": "17项关于webpack的性能优化", "desc": "本文主要优化两个方面：1.优化开发体验 2.优化输出质量.优化开发体验:提升效率,优化构建速度,优化使⽤体验.优化输出质量:优化要发布到线上的代码，减少⽤户能感知到的加载时间,提升代码性能."}, {"id": "7000915735232921631", "title": "webpack构建petite-vue项目，方便小项目的快速开发", "desc": "简介 概述 petite-vue是前段时间刚推出的一个轻量版vue，用法与vue几乎相同，没有jquery那些繁琐的操作和语法，对于熟悉vue语法的用户来说，两分钟就可以上手，唯一的痛点是目前没有什么"}, {"id": "6844903745810104328", "title": "Vue项目Webpack优化实践，构建效率提高50%", "desc": "公司的前端项目使用Vue框架，Vue框架使用Webpack进行构建，随着项目不断迭代，项目逐渐变得庞大，然而项目的构建速度随之变得缓慢，于是对Webpack构建进行优化变得刻不容缓。经过不断的摸索和实践，通过以下方法优化后，项目的构建速度提高了50%。现将相关优化方法进行总结分…"}, {"id": "6991331083962810405", "title": "webpack4的基础使用＋从零开始构建一个vue-cli", "desc": "从webpack4的基础使用包含相关配置对应版本到搭建一个简单的vue-cli，用于webpack学习记录。"}, {"id": "6989982853966594078", "title": "Vue 项目配置 image-webpack-loader", "desc": "最近开发 Vue 项目的时候部署上线越发觉得 dist 包越来越大，通过一步步的排查，才确定了是图片静态资源太大了！虽然可以通过 url-loader 把图片文件转换为 base64，但是这种方式仅适"}, {"id": "7001501408016990244", "title": "Webpack 编译流程", "desc": "本文以此为例子 生成 moduleGraph 数据结构 moduleGraph 通过一个依赖，可以知道这个依赖是谁提供，被谁使用。 通过一个模块，可以知道它提供的依赖，和使用的依赖 Module 模块"}, {"id": "6844903557930418189", "title": "Vue项目自动转换 px 为 rem，高保真还原设计图", "desc": "前端开发中还原设计图的重要性毋庸置疑，目前来说应用最多的应该也还是使用rem。然而很多人依然还是处于刀耕火种的时代，要么自己去计算rem值，要么依靠编辑器安装插件转换。 而本文的目标就是通过一系列的配置后，在开发中可以直接使用设计图的尺寸开发，项目为我们自动编译，转换成rem。…"}, {"id": "7006519574824747045", "title": "cross-env跨平台设置环境变量", "desc": "使用cross-env用于不同环境的变量设置 安装cross-env 在package.json中这样写，设置一个变量，我这里叫DEPLOY 3. 如何获取DEPLOY的值？ process.env."}, {"id": "6968730785725546526", "title": "Webpack5的Module Federation，号称改变JavaScript架构的游戏规则，是什么来头？", "desc": "为了节省维护成本，都会考虑跨项目模块复用，了解到 webpack5 的模块联邦特性，做了一下调研，总结一下。"}, {"id": "7003735012516298759", "title": "1、webpack-模块化打包工具", "desc": "webpack是一个模块打包工具，可以翻译import等简单的语法。 除了能识别ES Moudule规范（import），此外也能识别CommonJS、CMD、AMD等模块化语法。"}, {"id": "6989492187645870110", "title": "前端教你搭建基础的webpack环境（详细）", "desc": "一、前端构建工具 grunt gulp webpack(主流,https://webpack.js.org/) Fis3（百度） 二、webpack是什么 webpack 是一个现代 JavaScri"}, {"id": "6990590387924500493", "title": "webpack5 Module Federation \"微前端\"vue版demo使用示例及实现细节", "desc": "webpack5 Module Federation \"微前端\"vue版demo示例 Module Federation：是webpack5新出的一种“微前端”的概念，此文介绍一下具体的实际操作 vu"}, {"id": "6998858822768918565", "title": "webpack5——plugin", "desc": "插件是 webpack 的 支柱 功能。webpack 自身也是构建于你在 webpack 配置中用到的相同的插件系统之上！ 插件目的在于解决 loader 无法实现的其他事。"}, {"id": "6982157120594509837", "title": "剖析 Webpack SplitChunksPlugin 源码: 学完你也能写一个", "desc": "上个月团队很多人都在反馈有个项目打包速度越来越慢，打包发布一次至少要半个小时，这个速度不仅我们接受不了，测试那边也多次反馈发布进度卡在前端，因此对该项目进行了打包优化."}, {"id": "6922622067149897735", "title": "我对 Webpack 5 真香了。", "desc": "上篇《Webpack5新特性尝鲜（一）：安装与启动》，对比了Webpack4和Webpack5在安装和启动方面的差异。本篇，继续讲解Webpack5的新特性。资源模块处理资源模块（assetmodul"}, {"id": "6860134655568871437", "title": "[2.7w字]我是这样搭建 React+Typescript项目环境的(下)", "desc": "因为 webpack 根本识别不了 jsx 语法，那怎么办？使用 babel-loader 对文件进行预处理。 babel-loader 使用 babel 解析文件；@babel/core 是 babel 的核心模块；@babel/preset-react 转译 jsx 语法。…"}, {"id": "6961678963680739359", "title": "利用联邦模块实现跨应用的代码共享", "desc": "如何实现多个独立项目间的组件共享？联邦模块（Module Federation）是webpack5提供的一个新特性，通过它你只需要几行配置就可以实现，它让我们的可以更加优雅的实现跨应用的代码共享。"}, {"id": "6998850099732283406", "title": "webpack5——entry", "desc": "在 webpack 配置中有多种方式定义 entry 属性。除了解释为什么它可能非常有用，我们还将向你展示如何去配置 entry 属性。"}, {"id": "6991365434834419719", "title": "[基础篇]深入掌握webpack ｜ 8月更文挑战", "desc": "webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。作为一名前端工程师，我们需要学会如何自己配置并构建一个项目。"}, {"id": "6999441916379004936", "title": "webpack造轮子开篇：轮子架构", "desc": "通过再造一个简易的webpack轮子，能够更清晰的跟随webpack作者们的思路，对自己的功力有很大的提升，同时也能够更辩证的看待任何一个框架。"}, {"id": "6997714049219690532", "title": "我的webpack进化史-构建篇", "desc": "webpack热更新是如何实现？babel是干什么的？webpack中react，vue是如何加载的？"}, {"id": "6844903677262561293", "title": "Vue 应用性能优化指南", "desc": "得益于 Vue 的 响应式系统 和 虚拟 DOM 系统 ，Vue 在渲染组件的过程中能自动追踪数据的依赖，并精确知晓数据更新的时候哪个组件需要重新渲染，渲染之后也会经过虚拟 DOM diff 之后才会真正更新到 DOM 上，Vue 应用的开发者一般不需要做额外的优化工作。 但在…"}, {"id": "6844904008432222215", "title": "轻松理解webpack热更新原理", "desc": "一种是页面刷新，不保留页面状态，就是简单粗暴，直接window.location.reload()。 另一种是基于WDS (Webpack-dev-server)的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。…"}, {"id": "6999478823825702919", "title": "webpack 生产环境的基本配置", "desc": "1.提取css 成单独文件 下载安装包 2.下载插件 npm install --save-dev mini-css-extract-plugin 3. 修改配置文件 4 .运行指令: webpack"}, {"id": "6979769284612325406", "title": "「Webpack」从0到1学会 code splitting", "desc": "代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级"}, {"id": "6844903599080734728", "title": "webpack4-用之初体验，一起敲它十一遍", "desc": "在webpack4之前，提取公共代码都是通过一个叫CommonsChunkPlugin的插件来办到的。到了4以后，内置了一个一模一样的功能，而且起了一个好听的名字叫“优化” 好了，就写到这里吧，想必大家也看累了吧，辛苦大家了，哈哈。"}, {"id": "7000933849152782366", "title": "webpack 热更新原理", "desc": "webpack-dev-server相信很多接触webpack的同学都有所耳闻。但是其中的原理又是怎样的呢？怎么做到实时更新的呢？本文将会一一为大家解密。"}, {"id": "7005530386641977374", "title": "webpack 中module、chunk 、bundle 的区别", "desc": "参考链接：https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html 全集链接 ➡️ webpack 易混淆知识点   webp"}, {"id": "7002391689167896607", "title": "【webpack系列】2. 从源码角度分析loader是如何触发和执行的", "desc": "上一篇文章（https://juejin.cn/post/7002027415065083911 ）从打包结果分析了webpack核心执行流程，这篇文章详细说明laoder触发时机和执行过程，一次性解"}, {"id": "7005450458009600036", "title": "Webpack 5 之 模块联合（Module Federation）", "desc": "微前端 在了解 webpack 中 模块联合的之前，我们先了解一下微前端，如果你对微前端不了解可以查阅这里两篇文章《微前端（一）- 理念篇》和《微前端（二）- 实现篇》来熟悉它的基本概念。 通常我们的"}, {"id": "7000953937285103630", "title": "【webpack】webpack初体验 - 安装 - 配置 - 打包发布 - 实战", "desc": "这是我参与8月更文挑战的第8天，活动详情查看：8月更文挑战 今天我们来学习前端打包构建工具——webpack~"}, {"id": "7005187670200549407", "title": "Webpack5 系列（六）：不同模式的区分打包", "desc": "一、前言 上一篇讲到 Tree Shaking 相关的内容，本篇将介绍在不同模式（或称环境）下的打包处理。 二、不同环境下的打包配置 1. 开发环境的配置 2. 生产环境的配置 通过观察，我们会发现不"}, {"id": "7002999632263397413", "title": "webpack5 实现项目工程化", "desc": "手把手 带你学 webpac 基础知识教学 手把手 带你学 webpac 基础知识教学 手把手 带你学 webpac 基础知识教学"}, {"id": "7002027415065083911", "title": "【webpack系列】1. 从源码角度分析webpack打包产出及核心流程", "desc": "webpack一直好像是熟悉的陌生人，最近从源码角度通过debug总算是找到了打包的整个线条，揭开了这神秘的面纱。直接按部就班看源码难免会迷糊，带着自己的疑问反查源码就清晰多了。 先从整体纬度出发，这"}, {"id": "6844903548870721549", "title": "Vue学习看这篇就够", "desc": "可以看看。"}, {"id": "6963056815420473357", "title": "微医前端带你从头建立构建体系【开篇】", "desc": "此文作为构建专栏的目录。 介绍了我司以及写这个专栏的初心和内容形式。 作为开篇还介绍了截止到现在构建工具的历史演进过程。"}, {"id": "6939678015823544350", "title": "【Webpack 进阶】聊聊 Webpack 热更新以及原理", "desc": "模块热替换(hot module replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新所有类型的模块，而无需完全刷新 一种是页面刷新，不保留页面状态，就是简单粗暴，直接 window.location.reload()。 另一种是基…"}, {"id": "6844903853905674248", "title": "关于webpack4的14个知识点,童叟无欺", "desc": "没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切。 Webpack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使…"}, {"id": "6991966321529815053", "title": "万字总结webpack入门进阶知识", "desc": "🤾‍♀️序言 上一篇文章中我们讲到了 webpack 的一些基础特性，但是呢，单单会基础特性还是远远不够的。因此，在今天的文章中，将给大家带来 webpack 的高级特性，包括但不限于 dev 环境和"}, {"id": "6844904169405415432", "title": "Webpack5 上手测评", "desc": "从 2017 年发出关于 v5 的投票开始，到 2019 年 10 月发布第一个 beta 版本，目前是 5.0.0-beta.16。现在在收集使用反馈、生态升级的过程中，相信不久后就可以正式发布了。这次升级重点： 性能改进、Tree Shaking、Code Generati…"}, {"id": "6943164629434499109", "title": "从零配置webpack 5 + React脚手架（一）", "desc": "在开始之前，请确保安装了 Node.js 的最新版本。使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，是理想的起步。使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能以及/或者缺少相关 package 包。 让我们…"}, {"id": "6844903750419611656", "title": "webpack4搭一个简易SPA应用", "desc": "webpack 在如今的前端开发中，算是不可绕过的一个工具吧。特别是在开发SPA应用的时候，无论是开发环境，还是打包上线，都十分依赖webpack。 Let's go。 安装好 webpack 依赖后，创建 src 文件夹，并在 src 中新建一个 index.js。 好，完事…"}, {"id": "6901224334371930119", "title": "打工人，打工魂，打工不懂工具忙死人，教你如何优雅使用webpack5.0", "desc": "1前言相信大家肯定看过很多产品的开箱测评，今天来跑一个软件新版的上手测评—webpack5.0。自从2018年2月，webpack4发布以来，webpack就暂时没有更进一步的重大更新，阔别2年多后，"}, {"id": "6950122785494532127", "title": "webpack开发环境调优（一）｜小册免费学", "desc": "Webpack 作为打包工具的重要使命之一就是提升效率。下面我们记录一些对日常开发有一定帮助的 Webpack 插件以及调试方法，本文主要介绍 “Webpack周边插件“。"}, {"id": "6844904095589859336", "title": "一小时的时间，上手 Webpack", "desc": "为什么要用构建工具？如果你只会js+css+html，最多再加上jquery，那么当你听到构建工具这个说法是不是蒙的？这种情况下我不建议你学习webpack，建议你学下 vue 或者 react 框架，这两个框架都有自己的脚手架，所谓脚手架就是别人用构建工具帮你搭好了原始项目，…"}, {"id": "6844903833097748487", "title": "从零实现一个 Webpack Plugin", "desc": "相比于 loaders，plugin 更加的灵活，因为它能够接触到 webpack 编译器和编译核心。这就使得 plugin 可以通过一些 hook 函数来拦截 webpack 的执行，甚至你可以运行一个子编译器和 loader 串联，像 MiniCssExtractPlugi…"}, {"id": "6844904047221145613", "title": "webpack 4 源码主流程分析（一）：前言及总流程概览", "desc": "此系列文章作为笔记，用于记录分析 webpack 源码主流程的过程。 版本不同，源码略微有差异。 本项目 demo 开源在github，欢迎交流学习。 采用 vscode 来打断点调试分析。 webpack 从配置初始化到打包完成定义了一个生命周期，在这个生命周期中的每一个阶段…"}, {"id": "6948347177471229988", "title": "Webpack Dev Server 4.0.0-beta.2 | EMP进化记", "desc": "为Node.js API移除了openPage选项和--open-page CLI选项，以{open：['/ my-page'，'/ my-other-page /']}取代。和--open-target [URL]（没有[URL]开发服务器将使用host选项值打开浏览器）和-…"}, {"id": "6844904183989010446", "title": "如何提升 Webpack 打包速度", "desc": "前段时间在某个项目进行需求开发的时候，该项目是基于 webpack3 进行打包构建的。在开发过程中我发现打包很慢，开发体验不佳，于是做了简单的优化并梳理了优化方案 进行优化的第一步需要知道我们的构建到底慢在那里。通过 speed-measure-webpack-plugin 测…"}, {"id": "6960870841726795790", "title": "初识webpack", "desc": "什么是webpack？ webpack是一个打包模块化Javascript的工具，他会从入口模块出发，识别出代码中的模块化导入语句，递归的找出入口文件的所有依赖，将入口和其所有依赖打包到一个单独的文件"}, {"id": "6969586812591456270", "title": "玩转 webpack5（上）", "desc": "前言 本篇长文是学习程柳峰老师开设的《玩转 webpack》专栏的实践笔记，和专栏不一样的是，我的实战源码是基于 webpack5，它的配置和源码实现上与 webpack4 有许多不同的地方，感兴趣的"}, {"id": "6844903779117039629", "title": "9102年webpack4搭建vue项目", "desc": "首先祝大家元宵节快乐，最近已经好久没有写过文章了，刚好趁着这几天刚刚上班，领导还没有来，偷偷的写一篇关于webpack搭建vue的博客。因为公司使用vue比较多，构建vue项目使用vue-cli显得有点臃肿，感觉还是自己配置比较好些，所以就有了这篇教程。由于水平有限，欢迎大家指…"}, {"id": "6844903533372768269", "title": "Vue SPA 打包优化实践", "desc": "随着我们的项目的增长，打包会越来越慢。每次打包都会将第三方的js打包一遍，但是这些第三方的不会经常变化，如何能将第三方的js只打包一次呢？ 我们先将路由组件改成异步组件。官方文档 webpack提供了一个插件 DllPlugin ，用于将不常变动的js单独打包。 这里只需要im…"}, {"id": "6844904096718290952", "title": "webpack原理解析（三）plugin机制", "desc": "在之前的文章中，我们了解到了webpack的打包机制和loader，loader 用于转换某些类型的模块，而plugin则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。插件目的在于解决 loader 无法实现的其他事。所以我们很有必要探究一下webpack…"}, {"id": "6844903668634877966", "title": "发布 umi 2.0，可插拔的企业级 react 应用框架", "desc": "距离 umi 1.0 发布 已有半年，umi 在这段时间做了大量的重构和改进，438 个 commit，20 个 beta 版本，今天正式发布 2.0 版本，并调整定位为可插拔的企业级 react 应用框架。 umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架…"}, {"id": "6907220986304102414", "title": "webpack5之原理分析", "desc": "往期文章：webpack5之重新起航整体流程1.webpack:./bin/webpack.js入口2.webpack-cli/bin/cli.js3.webpack-cli/lib/bootstra"}, {"id": "6844903696430530568", "title": "精读《谈谈 Web Workers》", "desc": "本周精读的文章是 speedy-introduction-to-web-workers，是一篇 Web Workers 快速入门的文章，借精读这篇文章的机会，谈谈对 Web Workers 的理解与运用。 高效。 并行。 因为浏览器是单线程的，任何大量耗时的 JS 任务都会卡住…"}, {"id": "6882895689773383694", "title": "如何编写一个 Webpack Loader", "desc": "在平时自己由零搭建项目时，虽然基础配置都比较熟悉，比如配置 file-loader, url-loader, css-loader 等，配置不难，但究竟是怎么起作用的呢，今天就来说说如何编写一个 Webpack Loader。 按我自己的简单理解，loader 通常指打包的方案…"}, {"id": "6844903637697691662", "title": "应用于 Hybrid App 的 Vue 多页面构建", "desc": "本文介绍一款基于 Vue 的使 App 支持离线缓存 Web 资源的混合开发框架。本人小白一枚，请将它视作一份我的学习总结，欢迎大神们赐教。本文多阐述思路，实现细节请阅读源码。 高效率界面开发：HTML + CSS + JavaScript 被证实具备极高的界面开发效率。 跨平…"}, {"id": "6918310795629559822", "title": "前端工程化之动态导入文件", "desc": "随着项目越来越大，业务需要越来越多，我们项目的目录层级也是非常的多。如果还是通过import分别引入文件，那是非常的不科学的。 要是有几个文件，还好。几十个，几百个，就非常头疼了。怎么解决这个问题了？ 我们就要用到 Webpack 中的require.context()方法，动…"}, {"id": "6844904004942741511", "title": "手动搭建一个webpack项目", "desc": "首先我们要理解什么是webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每…"}, {"id": "6844903865419202573", "title": "Webpack 4 构建大型项目实践 / 处理 html", "desc": "上一节我有提到 Webpack 只能处理 Javascript 文件，这显然不能满足用户的日常使用需求，所以 Webpack 提供了 loader 和 plugins 两个配置选项，用于扩展 Webpack 的处理类型。本节要讲的 HtmlWebpackPlugin 就是专门用…"}, {"id": "6907575758068121607", "title": "React 学习12-2 -- webpack必会内容（一）", "desc": "@TOC前言一、介绍1.安装脚手架2.这个去掉重新安装会保留版本3、全局的server安装npminstall-gserveserve-sbulidnpmrunbuild打包serve-sbuild这"}, {"id": "6905300227889201159", "title": "新手入门webpack4踩坑记录", "desc": "最近在工作过程中遇到一个需求，需要将前端项目打包为静态资源并且部署到CDN。这个对于我这个刚入行的前端小菜鸟来说，完全是一脸懵逼，大概只知道这个跟webpack有关。因为项目的基础搭建工作是另一位老鸟搭建的，期间我只会写写业务代码。这次的任务对我来说是个挑战，所以只能硬着头皮上…"}, {"id": "6844904191052251143", "title": "webpack的基本使用及常用的loader配置", "desc": "1. webpack的基本使用 2. webpack的自动打包 3. webpack的预览页面 4. webpack配置自动打开浏览器 5. webpack中打包的规则 6. 打包处理css的loader加载器 7. 打包处理less的loader加载器 8. 自动添加兼容前缀…"}, {"id": "6844904116204863495", "title": "【webpack 系列】进阶篇", "desc": "本文将继续引入更多的 webpack 配置，建议先阅读【webpack 系列】基础篇的内容。如果发现文中有任何错误，请在评论区指正。本文所有代码都可在 github 找到。 之前我们配置的是一个单页的应用，但是我们的应用可能需要是个多页应用。下面我们来进行多页应用的 webpa…"}, {"id": "6844903507556843534", "title": " Vue.js SSR Step by Step (1) - 实现简单的client-only vue-webpack 配置", "desc": "一直都觉得SSR是一个挺麻烦的事情，牵扯的知识范围还挺大的，尤其是用vue-cli 工具，屏蔽了许多配置的细节。 但在使用SSR，不用Nuxt.js 的时候来做SSR，还是挺难上手的，索性好好捋一遍这方面的相关知识，总结成了一个系列的文章。作为 SSR 文档的一个补充，希望对大…"}, {"id": "6844903630126972942", "title": "提高webpack构建速度之DllPlugin与DllReferencePlugin的使用", "desc": "模块化打包工具webpack以其“黑魔法”构建的方法深受前端er喜爱，但面对慢如龟毛的编译速度，怎么能忍。本文旨在通过介绍 DllPlugin 与 DllReferencePlugin 的使用方法，加速webpack的编译过程。同时，生成的依赖库也能解决缓存问题，为页面又加快几…"}, {"id": "6844903630047281165", "title": "react 按照一级路由 分包加载", "desc": "利用React Loadable 和 import，将react项目按照一级路由进行拆包（后期也能方便以二级路由进行拆包），并探究了React Loadable原理，以及import是如何异步加载js。"}, {"id": "6844903619901259789", "title": "webpack运行Babel教程", "desc": "Babel是转码器，webpack是打包工具，它们应该如何一起使用呢?"}, {"id": "6844903625592946701", "title": "前端技术周刊 2018-06-22：Webpack 生存指南", "desc": "Nodejs 发布了六月安全更新，建议开发者更新到 10.4.1 版本，包含对 HTTP/2 拒绝服务攻击、TLS 拒绝服务等的预防。🔗 五月底，欧盟的通用数据保护协议 GDPR 进入强制执行阶段，用户数据采集方式的不合规将导致欧盟追责，此举将影响各大全球化公司。对用户隐私的…"}, {"id": "6844904116448149517", "title": "实现一个简易版Webpack", "desc": "一个简易版的Webapck完成了。"}, {"id": "6844903623999111182", "title": "webpack实战（二）：真实项目中应用系统配置", "desc": "上篇文章讲的是框架的配置方案，本文讲的是应用系统的配置方案。 这里，我们先梳理一下框架和应用的关系。这里我在框架配置中自定义了一个webpack插件，其作用就是生成一个loader.js文件，应用系统直接在页面中加载该文件，就会自动加载框架相应的资源文件。即，我们这里的目的是让…"}, {"id": "6844903693863616525", "title": "Webpack in Node：前端模板开发工具TDS", "desc": "一个适合小页面的模板开发工具，基于webpack，支持热重载，将css、js打包到一个html模板文件中。 这个小工具的适用场景不广，但设计思路能带来不小的启发。 TDS其实是为了一些小型的广告模板服务的，当年接手这一块只能手动生产这些模板，开发维护起来特别麻烦 （没错，本人就…"}, {"id": "6844903919231959053", "title": "使用webpack从头搭建 react开发项目 一", "desc": "-D就是--save-dev 这样安装的包的名称及版本号就会存在package.json的devDependencies这个里面。 devDependencies 里面的插件只用于开发环境，不用于生产环境 备注： 如果webpack.config.js存在在根目录里, 则web…"}, {"id": "6844904200065777672", "title": "webpack学习记录(一)", "desc": "1. webpack是什么？ 默认：默认只能处理JavaScript，其他类型文件需要配置loader或者plugins进行处理。 打包：将各个依赖文件进行梳理打包，形成一个JS依赖文件。 功能强大，loader和plugins可以根据个人需要随意配置。例如将es6转成es5的…"}, {"id": "6844904134068404238", "title": "webpack学习笔记（一） --  webpack背景介绍", "desc": "为了统一开发者和项目之间的差异，我们需要一些行业化的标准去规范模块的实现方式。"}, {"id": "6883033280078315527", "title": "Webpack Loaders 详解", "desc": "webpack loaders是webpack实现对非js文件打包的重要工具，本文章主要记录自身对loaders工作流程的学习。 针对特定结尾文件，使用loaders有两种方法，第一种是use属性配置为数组，包含所需要的loader，第二种方法是use属性配置为对象，可以进行o…"}, {"id": "6939407043233054750", "title": "webpack入门（三）", "desc": "loader是干什么用的呢？实际上，webpack在打包过程中，只能认识js和json文件，如遇到css和图片等类型的文件，他并不能识别，无法进行继续打包，会抛出错误。loader的作用就是让webpack去处理一些除了js和json文件类型以外的文件，并将它们转换为有效模块，…"}, {"id": "6909339148797083662", "title": "Webpack4.0各个击破（1）html篇", "desc": "一. webpack中的html 对于浏览器而言，html文件是用户访问的入口点，也是所有资源的挂载点，所有资源都是通过html中的标记来进行引用的。而在webpack的构建世界里，html只是一个展示板，而entry参数中指定的javascript入口文件才是真正在构建过程中…"}, {"id": "7006523017417195528", "title": "Webpack 中的 module、chunk、bundle 究竟是什么？", "desc": "如题，在研究 Webpack 时，这个问题也曾经困扰了我很久。 到目前为止，在我看来，这些术语可以这样理解： module：不同文件类型的模块。Webpack 就是用来对模块进行打包的工具，这些模块各"}, {"id": "7003243510606331940", "title": "Webpack5 Module Federation 简单探索", "desc": "Module Federation中文释义为模块联合，是在webpack5提出的一个概念。它为我们提供了一种新的构建模式：程序子模块之间可以单独开发、构建、部署，互不影响。"}, {"id": "7000169577007022094", "title": "Webpack5基本了解使用", "desc": "webpack5 此版本重点关注以下内容: 通过持久缓存提高构建性能. 使用更好的算法和默认值来改善长期缓存. 通过更好的树摇和代码生成来"}, {"id": "7007384274114445349", "title": "webpack05 10 publicPath", "desc": "说来惭愧，这个参数其实我一直没有管，为什么呢? 因为我司有负责这方面的同事，一般有什么新项目就这方面就直接分配给他负责，所以一般没有管这个。 所以 webpack 的配置，我一直只是大概知道有哪些功能"}, {"id": "7007334685793583112", "title": "浅析webpack的按需加载（源码解读）", "desc": "最近看了吴浩麟的《深入浅出webpack》有了一些收获，在这里和大家分享一下里面的按需加载章节和webpack按需加载的源码实现。由于书出的比较早，书中webpack版本为3.4.0，故本文的所有代码"}, {"id": "6992763396676386823", "title": "🥙前端小白快速入门webpack指南", "desc": "一、什么是webpack? 概念：webpack是前端工程化的具体解决方案。 主要功能：它提供了有好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端JavaScript的兼容性、性能优化等强大的功"}, {"id": "7002814357998403591", "title": "后端视野学 Webpack ，文武双全？", "desc": "咱们这篇从六点去归纳了 webpack 的基本使用，后端的同学可以锦上添花，再不济看完后也可以和前端妹子有些共同话题~！前端的同学可以温故知新，也不免是为自己巩固基础!"}, {"id": "6844904152389124103", "title": "搭建一个vue-cli4+webpack移动端框架（开箱即用）", "desc": "这是基于 vue-cli4 实现的移动端框架，其中包含项目常用的配置，组件封装及webpack优化方法，可供快速开发使用。 在一两年前，vue-cli3已经声驾到3.0+版本，但是由于旧项目一致习惯于vue-cli2的脚手架的使用，之前也写过一篇 搭建一个vue-cli的移动端…"}, {"id": "6992887038093557796", "title": "谈一谈Webpack 的SplitChunks", "desc": "webpack官网中，有这么一句话，我不是很认同： 可以说，性能优化最重要的部分就是懂得如何分包了。因此，就来谈谈webpack中的分包。"}, {"id": "7004833974652502047", "title": "从0开始搭建一个可用的vue3-webpack5-template（二）", "desc": "前言 在第一篇文章中，我们搭建了一个基于webpack5的vue3项目，现在我们就开始对这个乞丐版配置进行完善。"}, {"id": "6844903943873675271", "title": "每日优鲜供应链前端团队微前端改造", "desc": "我所在团队是做toB业务的，技术栈是Vue，团队目前有十多个典型的toB业务（菜单+内容布局），这些业务都是服务于一个大平台的，因为历史原因，每个业务都是独立的，都有一个html入口，所以当用户在这个大平台上使用这十多个业务的时候，每当切换系统时，页面都会刷新，体验很差；在开发…"}, {"id": "7006958488651825188", "title": "webpack5 09 webworker", "desc": "首先得明白什么是webworker, 大致上理解就是web端得多线程。在里面做任何事情不阻塞线程，但是里面不能执行dom操作。 这是前提，很早就有了，详情可见这个阮一峰这这篇文章 https://ww"}, {"id": "7005856298008838175", "title": "手写webpack", "desc": "手写webpack 通过fs读写文件: 通过'@babel/core'对文件进行解析 读取依赖和内容(定义complier方法) babel.parseSync:可以将内容转换为抽象语法树（本质是用的"}, {"id": "7004002018935177223", "title": "基于ast生成webpack打包器原理", "desc": "基于ast生成webpack打包器原理 虽然 Webpack 看上去无所不能，但从其本质上来说，Webpack 实质就是一个“前端模块打包器”。前端模块打包器做的事情很简单：它帮助开发者将 JavaS"}, {"id": "7004267670832955423", "title": "【webpack系列】3. webpack是如何解析模块的", "desc": "上两篇文章分析了webpack整体打包流程（https://juejin.cn/post/7002027415065083911） 和loader触发时机及执行过程（https://juejin.cn"}, {"id": "6859538537830858759", "title": "面试官：webpack原理都不会？", "desc": "前一段时间我把webpack源码大概读了一遍，webpack 到4.x版本后，其源码已经比较庞大，对各种开发场景进行了高度抽象，阅读成本也愈发昂贵。 过度分析源码对于大家并没有太大的帮助。本文主要是想通过分析webpack的构建流程以及实现一个简单的webpack来让大家对we…"}, {"id": "6986533364438138894", "title": "前端历史项目的 Vite 迁移实践总结", "desc": "当前，前端社区用 Vite 替代 Webpack 的呼声正日趋高涨。但对于长期维护的业务项目，很多同学可能仍然对上车存有疑虑——Vite 真的足够支撑非玩具级的项目吗？为此本文会分享一个实际案例"}, {"id": "7004000204655427597", "title": "徒手搞定Vue + Webpack配置，不用Vue-CLI", "desc": "现在我们开发Vue项目几乎都是用Vue-CLI去创建项目，因为它提供了几乎我们所有需要的功能，不再需要我们去自己配置像webpack、eslint、sass/less、unit test/e2e te"}, {"id": "7006235844449304606", "title": "手摸手写个webpack plugin", "desc": "手摸手写个打包完就发通知邮件的插件~高效摸鱼 目录 1. 基本概念 2. 使用方法 3. 源码学习 4. 开发实战 5. 其他"}, {"id": "7001013395692617735", "title": "esbuild快速打包助力webpack开发研效", "desc": "背景 随着项目开发周期越来越长，项目越来越来大，基于webpack构建的项目打包速度会越来越长。 如果采用ts + tsx构成，开发环境下编译速度慢的情况会非常明显 目前接手项目的打包速度如下 首次打"}, {"id": "6844903895911645198", "title": "webpack学习之路（七）source map", "desc": "我们用webpack打包文件之后，会生成一个编译压缩过的js文件。如果出现问题，这种代码是很难排查问题的，无法定位到源码。这种时候就需要source map。 webpack中提供了很多种source map的格式。 一般来说，我们在开发环境使用，线上环境是关闭的。 我们来跑一…"}, {"id": "6844903520403980301", "title": "Parceljs和Webpack在React项目上打包速度对比", "desc": "最近这几天前端圈子估计都被Parceljs刷屏了。Parceljs主要特点为： 在Parcejs的官方网站上给出了与其它的打包工具的构建速度的对比结果，但是并没有给出测试的项目地址，所以花了点时间在React上做了下面的测试。 两个项目都非常小，一共只有4个组件。引入了reac…"}, {"id": "6844903773509255181", "title": "使用 Webpack 进行生产环境配置（附 Demo）", "desc": "本文从代码压缩、代码拆分、样式分离等三个方面对生产环境的代码进行了优化。只是最简单的一些配置，如果真正运用到项目中，还需要根据项目添加更多配置。 uglifyjs-webpack-plugin 更多配置请参考：插件文档。 optimize-css-assets-webpack-…"}, {"id": "6988726696899772452", "title": "webpack5学习 --- 邂逅webpack", "desc": "webpack 是一个现代 JS 应用程序的静态模块打包器。webpack在进行项目构建时会递归地构建一个依赖关系图,通过依赖关系图找到项目所有所需要的模块，并将这些模块打包成一个或多个bundle。"}, {"id": "6988527907404513288", "title": "在SPA模式网页版本检测方案", "desc": "背景 解决思路 标记版本: 在vue.config.js中每次编译生成一个版本号 使用html-webpack-plugin插件将版本号插入到index.html的mate标签 在webpack编译结"}, {"id": "6988502927723724831", "title": "Webpack", "desc": "Webpack是干嘛的 将一个或多个 JS 文件打包成对应的文件  将一个或多个 CSS 文件打包成对应的文件  压缩代码  将高版本的 JS转译成低版本的 JS 代码分析 webpack-dev-s"}, {"id": "6844904082272960520", "title": "从零开始的vue-cli（简易版）", "desc": "这里将介绍如何从零开始搭建一套包含调试，构建的vue脚手架，其中主要是对webpack的学习，以及现在一些常用的集成在脚手架中前端功能的使用比如：babel,代码压缩，代码热更新等等。本文适合掌握了前端基础以及vue相关知识的程序猿观看学习，最主要的是要有颗热爱这个行业的心（滑…"}, {"id": "6981339197386784776", "title": "levi_webpack总结", "desc": "webpack 模块打包原理 webpack 模块打包原理 下面谈谈我的理解 javascript 万物皆对象，每个实例都有一个proto属性，指向了他构造函数的原型对象 每个构造函数都有一个 pro"}, {"id": "6850418117538136071", "title": "从零配置你的Webpack", "desc": "上篇文章简单的介绍了一下，前端进阶之脚手架的搭建。其实我个人认为重要的还是Webpack的配置出来的template，至于脚手架的交互体验可以后期去优化，也可以更加的个性化。但是我们的核心还是放在Webpack等一系列的配置上。 相信来到这里的小伙伴，都是有一些些前端的经验了，…"}, {"id": "6844903648422526989", "title": "谈谈常用Babel配置与babel-preset-env", "desc": "“用于编写下一代JavaScript的编译器”。随着时间推移，JavaScript也在慢慢进化，新的特性和语法随之出现，然而各个浏览器厂商并没有完全的支持，所以要有个工具，把新的特性和语法翻译成浏览器都认可的标准语法，Babel应运而生..."}, {"id": "6917166262494134285", "title": "webpack从零开始", "desc": "webpack 是核心，webpack-cli是给我们提供了相关的命令，能够基于webpack相关命令进行编译和打包。 webpack webpack-cli是用来在开发时将代码编译打包的，打包出的代码部署在服务器上，在生产环境下发布。所以在生产环境下是不需要编译打包的，因此要…"}, {"id": "6844903656127463438", "title": "webpack4实操笔记", "desc": "webpack四个核心概念搭建环境及配置基本框架全局安装文件夹初始化文件夹/文件环境局部安装配置基础配置配置package.json简化命令行配置本地服务器（设置默认页面为dist里面的内容）加载CS"}, {"id": "6985035503594635278", "title": "关于webpack", "desc": "随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如react的jsx代码必须编译后才能在浏览器中使用；又如sass和less的代码浏览器也是不支持的。 而如果摒弃了这些开发框"}, {"id": "6844904042246881293", "title": "webpack proxy 使用（代理的使用）", "desc": "这两天的开发中遇到一些需要代理才能解决的问题, 在这里记录一下, 方便以后的查阅."}, {"id": "6923991709667819534", "title": "Webpack模块化原理图解", "desc": "这时模块a，模板b中的代码都暴露在全局环境中，如果模块a中定义了一个方法del。同学b并不知道，在模块b中也定义了一个方法del。这时便造成了命名冲突的的问题。如图 C同学开发了一个公共的工具库utils.js，D同学开发了一个公共的组件tab.js，tab.js依赖utils…"}, {"id": "6844903794371723277", "title": "Loader学习，简析babel-loader", "desc": "继上两篇文章webpack工作原理介绍（上篇、下篇）,我们了解到Loader：模块转换器，也就是将模块的内容按照需求装换成新内容，而且每个Loader的职责都是单一，只会完成一种转换，所以我们一般对源文件的处理，也是由多个Loader以链式顺序执行的方式来进行多次装换，然后得到…"}, {"id": "6847902219833081864", "title": "webpack3.x升级4.x之后打包速度优化", "desc": "上一篇我们讲到，webpack3.x 升级 4.x 后打包大小优化，今天讲一下 webpack 4.x（webpack 4.43.0） 的打包速度优化，其实在升级了 webpack4 之后对于打包速度就已经有了很大的提升，但是查找时间（缩小范围）、loader 处理时间（多进程…"}, {"id": "6844903768081989645", "title": "一个合格的Webpack4配置工程师素养：第三部分", "desc": "之前有提过webpack根据不同的环境我们会加载不同的配置。我们只需要提取出三部分。 我们这里现在简单分层：正式项目最好创建一个config/webpack目录管理。 下面是源代码。 很明显上面watch模式效率不高而且很不方便, 编译完还需要刷新页面, webpack可以开启…"}, {"id": "6844903905764048909", "title": "Webpack 打包后代码执行时机分析与优化", "desc": "代码执行时机将决定着是否能够正常执行，当依赖文件没加载完成就开始执行、使用对应模块，那么将会导致执行异常。这在“存在资源加载失败时，加载重试影响原来文件的执行顺序”的场景下尤为常见。 webpack 构建除了进行模块依赖管理，实际上，也天然地管理了 entry 与 chunk …"}, {"id": "6844903539316097037", "title": "webpack提取第三方库的正确姿势", "desc": "我们在用webpack打包是时候，常常想单独提取第三方库，把它作为稳定版本的文件，利用浏览缓存减少请求次数。常用的提取第三方库的方法有两种"}, {"id": "6969745246921949191", "title": "Webpack", "desc": "本文内容来自三十分钟掌握Webpack性能优化 什么是Webpack 它是一个模块打包器，它分析各个模块的依赖关系，最终打包成我们常见的静态文件，.js、.css、.jpg、.png等文件。 webp"}, {"id": "6961651436228706311", "title": "Webpack 打包后的源码分析", "desc": "打包后的源码分析 如何实现的懒加载 import() 嗯可以实现指定模块的懒加载操作 当前懒加载的核心原理就是 jsonp t 方法可以针对于内容进行不同的处理（处理方式取决于传入的数值 8 6 7 "}, {"id": "6844903909740281869", "title": "webpack 4 新增 sideEffects 配置的作用和注意事项", "desc": "我们看一下打包后的结果, 注意要在 production 模式下打包. 结果如下所示, 我去掉了无关的 webpack 启动代码 我们在 Array 原型链上定义了一个新方法 sum, 这是具有副作用的. 然后在 b 模块中调用了该方法, 但是作为 b 模块的维护者, 我又希望…"}, {"id": "6954387759834333221", "title": "Webpack——【入门篇-下篇】", "desc": "本系列为Webpack——入门篇，跟着此文档，可轻松入门webpack，分为上篇、中篇、下篇；此篇为下篇"}, {"id": "6918998088010956807", "title": "Webpack5的事件流和插件机制", "desc": "前面2篇我们已经讲了webpack的运行原理和loader的原理，本篇我们来讲一下webpack的事件流和插件的机制。本系列一共分为三篇 什么是webpack的事件流，这里引入深入浅出的webpack里面的一段话。 Webpack 就像一条生产线，要经过一系列处理流程后才能将源…"}, {"id": "6903708885417361416", "title": "webpack之常用配置（三）", "desc": "我们可以使用懒加载的方式引入模块，比如说当触发了某个条件，在通过import的方式引入模块。这样可以使得项目的性能会更加的好。 同样的路由懒加载的意思，表示当我们监听到路由变化了，才会去引入对应的页面模块。 Shimming：在打包过程中，有时候需要对代码兼容。这种兼容不局限于…"}, {"id": "6844903496836186119", "title": "webpack 前端多页项目工程", "desc": "webpack 前端多页项目工程，适用于展示型站点，比如官网。"}, {"id": "6844903890542919693", "title": "Webpack CommonsChunkPlugin插件研究", "desc": "公司的旧项目仍然在使用Webpack3。提取公共代码依然使用的是CommonsChunkPlugin插件，所以需要研究一下CommonsChunkPlugin的用法。 但是官方文档的对于此插件的解释，让我感受不到这个插件的默认行为是什么，只是简单的知道它要做的事情是分离代码块。…"}, {"id": "6925235061306425352", "title": "webpack打包koa项目配置解析", "desc": "以前刚接触webpack的时候，我对它繁琐复杂的配置一个头两个大，后来项目渐渐做的多了，懂得多了，就渐渐熟悉了，而且也深深的理解了它的好处。 不管是做前端项目，还是用node做后端项目，只要和js相关的，都可以用webpack辅助构建，它可以提供es6语法的支持、开发热更新、部…"}, {"id": "6844903602528452615", "title": "webpack雪碧图生成", "desc": "先说下我们希望达到的效果。 4、在sass中编写，按需合并。 一种是以webpack-spritesmith、postcss-sprites为代表的插件，webpack-spritesmith主要的运行方式是会预先把sprite目录中的图标拼合好，页面主要依赖生成后的雪碧图。而…"}, {"id": "6844903871781830664", "title": "前端战五渣学前端——初探Parcel急速打包", "desc": "parcel是什么呢？？？首先我们得了解，parcel做的事情跟webpack差不多，只是差不多。之前在官网出现过类似“开箱即用”、“0配置打包”等字样，看样子是一个主打简洁的一个打包工具。 之前我接触的打包工具有什么gulp，grunt，webpack，还听说过browser…"}, {"id": "6844903542868672520", "title": "react-router browserHistory刷新页面404问题解决", "desc": "使用React开发新项目时，遇见了刷新页面，直接访问二级或三级路由时，访问失败，出现404或资源加载异常的情况，本篇针对此问题进行分析并总结解决方案。 那么我们怎么处理才能正常访问，各页面路由呢？博主追踪溯源，查找文档配置后解决了问题，本篇就是对整个解决问题过程的总结。 在使用…"}, {"id": "6844903747051585550", "title": "webpack.optimize.CommonsChunkPlugin 详解", "desc": "多入口文件，需要抽出公告部分的时候。 单入口文件，但是因为路由异步加载对多个子chunk, 抽离子每个children公共的部分。 把第三方依赖，理由node_modules下所有依赖抽离为单独的部分。 混合使用，既需要抽离第三方依赖，又需要抽离公共部分。 如果entry和Co…"}, {"id": "6916164437854388231", "title": "webpack代码优化", "desc": "代码分离是webpack最重要的特性，可将代码分离到不同的bundle中，方便资源的按需加载或并行加载，从而影响加载时间。 防止重复：使用Entry dependencied或者 SplitChunksPlugin去重和分离chunk。 动态导入：通过模块的内联函数调用来分离代…"}, {"id": "6844903509880471566", "title": "一次webpack体验", "desc": "这个是公司要做的一个官方网站。由于项目比较简单，要求是单页的，没有页面跳转，所以只有一个 .html 文件。项目用了比较常规的 bootstrap + jquery 的开发，这个也没啥好说的。考虑到 CDN 的可控性，所以把所有 bootstrap 的资源都下载到了本地进行引用…"}, {"id": "6844903848440496142", "title": "Webpack构建多页应用心得体会", "desc": "Webpack构建的基于zepto的多页应用脚手架，本文聊聊本次项目中Webpack构建多页应用的一些心得体会。 由于公司旧版的脚手架是基于Gulp构建的zepto多页应用（有兴趣可以看看web-mobile-cli），有着不少的痛点。例如： 需要兼容低版本浏览器，只能采用pr…"}, {"id": "6918326827132026888", "title": "手动搭建一个支持TypeScript的React脚手架", "desc": "这样，在运行npm run build的时候就会打包了。 ！！！注意webpack只负责将文件打包到dist目录下，当dist目录存在文件，重名的文件将覆盖，不重名的文件不删除。 这个HtmlWebpackPlugin会自动以外链的方式注入dist下面的index.ts到pub…"}, {"id": "6922638162808274957", "title": "问诊webpack：从何而来，去往何处", "desc": "webpack是一个很重的话题，网上关于如何写配置、如何写loader、写plugin的文章一搜一堆。甚至业内为了调侃webpack配置的复杂性，发明了一个工种“webpack配置工程师”。 如何写配置、loader、plugin，在我看来是一种“查阅性知识”。用的时候，能快速…"}, {"id": "6949469590208380941", "title": "webpack入门", "desc": "学习 webpack 基本配置, 解析 es6, css/less, 图片, 除此之外还可以了解文件监听及热更新"}, {"id": "6917947305555558413", "title": "Webpack 性能优化", "desc": "1. 文件监听 2. webpack-dev-server 自动打开浏览器，保存自动刷新 devServer: 打包的模块是放在内存中的，从而提升打包速度. contentBase：告诉服务器内容的来源。仅在需要提供静态文件时才进行配置. 3. Hot Module Repla…"}, {"id": "6844903821408206855", "title": "从基础到实战 手摸手带你掌握新版Webpack4.0详解 一起读文档", "desc": "1. 1 什么是WebPack webpack 是一个现代 JavaScript 应用程序的静态模块打包工具：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并生成一个或多个 bundl…"}, {"id": "6844903652956585992", "title": "手摸手，带你用合理的姿势使用webpack4（下）", "desc": "推荐先阅读 webpack 入门教程之后再来阅读本文。 webpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。 webpack 4 的Code Splitting 它最大的特点就是配置简单，如果…"}, {"id": "7001764134970720293", "title": "手动实现一个webpack", "desc": "前言 一般我们前端工程化都是离不开webpack，我们不要对于webpack原理有太多的抗拒，现在来手动实现一个非常简易的webpack，初步了解webpack的构建流程。 webpack4.x的使用"}, {"id": "7002591579059781668", "title": "webpack5——依赖图、target", "desc": "每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 依赖关系。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 依赖 提供给应用程序。"}, {"id": "7002592523101306916", "title": "webpack5——模块热替换", "desc": "模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。"}, {"id": "6844903593556836359", "title": "vue多页面开发和打包的正确姿势", "desc": "两套源码的话，后台可能开两个端口，然后需要用nginx反向代理可能比较麻烦，而且前端开发也比较麻烦麻烦，毕竟需要维护两个git仓库，两套git上线流程，可能会损耗很多时间。 对自己的技术(盲目)自信,也想尝尝鲜，分析出需求也不算很复杂。选了第一种方案，就是多个单页面应用在一套源…"}, {"id": "6844903640902156301", "title": "React 16 加载性能优化指南", "desc": "关于 React 应用加载的优化，其实网上类似的文章已经有太多太多了，随便一搜就是一堆，已经成为了一个老生常谈的问题。 但随着 React 16 和 Webpack 4.0 的发布，很多过去的优化手段其实都或多或少有些“过时”了，而正好最近一段时间，公司的新项目迁移到了 Rea…"}, {"id": "7000752862653317150", "title": "提升 webpack 构建速度", "desc": "这是我参与 8 月更文挑战的第 9 天，活动详情查看： 8月更文挑战 随着版本的迭代，业务的发展，代码会越来越多，这时候 webpack 的构建速度有可能就会变慢。 构建时间的长短直接关联着我们的工作"}, {"id": "6992738808517099528", "title": "webpack实战之手写一个简易的loader和plugin", "desc": "🔔序言 对于 webpack 来说， loader 和 plugin 可以算是需求程度最为广泛的配置项了。但是呢，单单止步于配置可能还不够。"}, {"id": "6992364056250171422", "title": "万字总结webpack实战案例配置", "desc": "🛴序言 在前面的两篇文章中，我们讲解了 webpack 的入门知识。但是呢，入门知识了解了之后，总得应用到具体的案例当中来。 因此，在下面的"}, {"id": "6987219589612601357", "title": "基础篇 - 从构建层面看 import 和 require 的区别", "desc": "前言 一切的一切，都是因为群里的一个问题 虽然说最近在做 webpack 相关的事情，但是也没有对着干问题做过相关的研究，网上很多文章包括 vue 都介绍了建议使用 import ，但是没有说为什么要"}, {"id": "6992001722268778509", "title": "vue升级webpack5 | 八月更文挑战", "desc": "vue升级webpack5 webpack5已经发布快一年了，其中有很多新功能让人跃跃欲试，身为技术热爱者的我们怎么能够停滞不前呢 🐶，今天就来学习一下用webpack5搭建项目和新特性了解。 升级v"}, {"id": "7002605709854851109", "title": "为什么webpack 打包速度慢", "desc": "为什么webpack 打包速度慢 webpack在首次打包的时候，需要做长时间的准备工作，比如加载插件等； 解决webapck打包速度慢的"}, {"id": "6844903651291447309", "title": "三十分钟掌握Webpack性能优化", "desc": "Webpack是现在主流的功能强大的模块化打包工具，在使用Webpack时，如果不注意性能优化，有非常大的可能会产生性能问题，性能问题主要分为开发时打包构建速度慢、开发调试时的重复性工作、以及输出文件质量不高等，因此性能优化也主要从这些方面来分析。本文主要是根据自己的理解对《深…"}, {"id": "6998845241449480205", "title": "webpack5——概念", "desc": "webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)..."}, {"id": "6962853443891363854", "title": "【建议收藏】你不得不知道的webpack性能优化", "desc": "前言 在上一篇文章从0到1手把手带你捋一套webpack+vue项目模板中，主要讲解了一个单页项目从npm init开始如何手动搭建前端单页脚手架之后，这篇文章就继续跟大家一起分享一下如何从webpa"}, {"id": "7001741793641365535", "title": "webpack掠影-5", "desc": "前面我们练习 webpack 中暴露全局变量和 webpack 内置插件的使用，今天我们练习多页面应用的配置和 sourceMap、另外，webpack 还可以将重复使用的模块抽离成公共模块...."}, {"id": "6844903544756109319", "title": "Tree-Shaking性能优化实践 - 原理篇", "desc": "一. 什么是Tree-shaking 上图形象的解释了Tree-shaking 的本意，本文所说的前端中的tree-shaking可以理解为通过工具\"摇\"我们的JS文件，将其中用不到的代码\"摇\"掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当…"}, {"id": "7000567910905151501", "title": "webpack掠影-2", "desc": "前面我们已经学习了如何让 webpack 工作，包含开发时的 webpack-dev-server 和 用于生产环境的 webpack 打包输出文件。今天我们进一步了解 w"}, {"id": "6998683154714198024", "title": "Webpack的基本配置与使用", "desc": "Webpack就是一个前端资源加载/打包工具,他会根据项目的模块依赖进行静态分析,然后将这些模块按照指定的规则打包生成对应的静态资源"}, {"id": "6999453054051287077", "title": "一篇文章带你掌握 Webpack 中常用 loader 和 plugin 的作用", "desc": "平常我们开发时很少摆弄 webpack 配置，都是大佬给我们配好了，我们吭呲吭呲写业务代码就好了，对很多常用的 loader 和 plugin 大概知道它是干嘛的，但实际上底下做了什么事情却像隔了层雾"}, {"id": "6990616281556713485", "title": "webpack相关面试问题", "desc": "1、webpack中的modules是什么？ 2、chunk和bundle分别是什么？有什么区别？ 3、Plugin、Loader分别是什么？ 4、Compiler和Complation是什么？ 5、"}, {"id": "6844903817322954759", "title": "24 个实例入门并掌握「Webpack4」(一)", "desc": "它将查找 ./src/index.js 作为默认入口点。 而且，它会在 ./dist/main.js 中输出模块包，目前代码量小，可以格式化看效果 拥有 2 个配置文件在 webpack 中是的常见模式。 webpack4 引入了 production(生产) 和 develo…"}, {"id": "7002423892891402253", "title": " webpack掠影-7", "desc": "webpack 模块懒加载、webpack 的 dll 配置及使用、webpack 使用 happypack 加速打包过程"}, {"id": "6920543483908325383", "title": "webpack打包公共类库怎么做?", "desc": "周五了，何不给自己加个餐呢，想着第二天不用上班了，就感觉要起飞有木有，所以写篇文章再下班吧。 一个关于前端日志打印的库。 npm地址 如何用webpack打包公共类库，兼容不同环境，不同场景。 日常的日志调试是个很基础的东西，console.log也是我们每天都经常使用的东西，…"}, {"id": "6936084555476500488", "title": "50行代码实现组件使用次数统计", "desc": "最近有个领导想让我们搭组件库，然后我就想知道目前项目中使用的三方组件库哪些组件使用频率最高。本来想去咨询小伙伴，但是小伙伴太忙了，只能自己弄了。我就想能不能通过 webpack 来实现我的想法 做这个的意义是什么呢，比如是我们自己的组件库上线以后可以统计组件引用次数，并且以某个…"}, {"id": "7002044049603428382", "title": "webpack 优化配置", "desc": "HMR 1.创建文件 2. 修改配置文件 运行指令: webpack source-map 1.创建文件 2. 修改配置文件 运行指令: webpack oneOf 修改配置文件 运行指令:webpa"}, {"id": "7001537120397426701", "title": "Webpack4 进阶 [ 核心配置与实战 ]", "desc": "前言 前边有写过关于 webpack 的核心配置概念与基础实践，今天主要分享 webpack 针对各种情况的配置与实战 webpack 配置概念 webpack 基础实践 这里需要知道一个前提 loa"}, {"id": "6989477897505341453", "title": "10步从 webpack 迁移到vite 过程 实录", "desc": "10个步骤，轻松把 webpack 老项目 迁移到 vite, 体验 风驰电掣的感觉,一起行动起来吧！"}, {"id": "7004472272975036430", "title": "webpack5学习笔记", "desc": "一、webpack 五个核心概念 Entry 入口指示webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图 Output 输出指示 webpack 打包后的资源 bundles 输出到哪里"}, {"id": "6859569958742196237", "title": "你的 import 被 webpack 编译成了什么？", "desc": "这两个语句我们应该经常能看到，第一个import就不用说了，可以说现在的前端项目随处可见，第二个import可以在需要懒加载的地方看到，比如vue-router的懒加载配置，但是大家好像却从来都没太深究过这个东西。 import是es module提供的一个加载模块的方法，目前…"}, {"id": "6991627519833309215", "title": "react-从零开始搭建项目-webpack配置", "desc": "上一篇 react-从零开始搭建项目-项目框架搭建 前言 上一篇我们简单搭建了一个项目目录，但是发现无法将html文件与index.js文件连接起来，也无法使用ES Module的import语法，更"}, {"id": "6989790267243135013", "title": "webpack常见面试问题整理", "desc": "1.webpack是什么？ webpack一个用于现代javascript应用程序的静态模块打包工具 2.webpack的配置有哪些？ 入口（entry）,出口（output）,mode,plugin"}, {"id": "6994629577087647780", "title": "三分钟学会 webpack 的启动流程", "desc": "每次打包都是调用 npm run build 之类的命令，今天我们就来聊聊，调用 npm run build 之后的如何查找 webpack-cli，以及没有安装 webpack-cli 时引导用户的"}, {"id": "6844903974810681358", "title": "webpack优化的一些基本方法", "desc": "对于我们引入的一些第三方包，比如jQuery，在这些包内部是肯定不会依赖别的包，所以根本不需要webpack去解析它内部的依赖关系，可以在webpack配置文件中的module属性下加上noParse属性，它的值是一个正则表达式，用来匹配无需解析的模块，这样可以节约webpac…"}, {"id": "7001055586615820302", "title": "深入 Webpack5 等构建工具系列三(1) - file-loader 加载图片资源", "desc": "这是我参与8月更文挑战的第25天，活动详情查看：8月更文挑战 前期准备 接上篇文章，做如下准备操作： 删除 02_webpack配置文件(css) 目录下的 node_modules 和 build "}, {"id": "7002047753928835086", "title": " webpack掠影-6", "desc": "resolve.alias、resolve.moduloes、resolve.extensions配置详解；HMR 详解、webpack-merge 用法示例"}, {"id": "6882551009219575815", "title": "嗯，手搓一个TinyPng压缩图片的WebpackPlugin也SoEasy啦", "desc": "曾经发表过一篇性能优化的文章《前端性能优化指南》，笔者总结了一些在项目开发过程中使用过的性能优化经验。说句真话，性能优化可能在面试过程中会有用，实际在项目开发过程中可能没几个同学会注意这些性能优化的细节。 若经常关注性能优化的话题，可能会发现无论怎样对代码做最好的优化也不及对一…"}, {"id": "6981627458449571877", "title": "Webpack5源码分析三-ESModule和CommonJS模块的互相导入", "desc": "本文将从源码分析 Webpack5 如何实现 ESModule 和 CommonJS 模块的互相导入。"}, {"id": "6979879230297341989", "title": "我是如何把vue项目启动时间从70s优化到7秒的", "desc": "可怕的启动时间 公司的产品是一个比较大的后台管理系统，而且使用的是webpack3的vue模板项目，单次项目启动时间达到了70s左右 启动个项目都够吃一碗豆腐脑了，可是没有豆腐脑怎么办，那就优化启动时"}, {"id": "6844904131719593992", "title": "webpack原理系列-tapable用法(SyncHook篇)", "desc": "Webpack本质基于事件流，流程就是将各个插件串联执行，实现此功能的核心就是tapable，webpack中负责编译的Compiler是基于tapable实现。"}, {"id": "6844903972948410381", "title": "💪从零开始学习webpack系列三（配置开发环境）", "desc": "配置开发环境webpack-dev-serveryarnaddwebpack-dev-server-D「contentBase」：指定文件目录「compress」：启用gzip压缩「port」：端口号"}, {"id": "6844903919764635662", "title": "webpack一学就会", "desc": "webpack可以简单理解为前端打包工具，本文是实现js文件和css文件以及实现图片打包的完整过程。 复制该地址如上图中的http://localhost:19369/粘贴到浏览器的地址栏中 即可打开页面。 注意：在分别进行js,css以及图片打包时，可以删除dist文件夹，以…"}, {"id": "6898501926967574541", "title": "模块化开发与规范化标准", "desc": "通过script添加 type = \"module\" 的属性，就可以以 ES Module 的标准执行其中的JS代码。使用： 代码拆分（code splitting）：挑选有需要的代码打包。当实际中需要到某个模块，再通过异步去加载它，实现增量加载或者渐进式加载 解决方式1：跨域…"}, {"id": "6844903856099295240", "title": "01-为什么选择选择webpack", "desc": "在说明为什么选择使用webpack，让我们回顾一下在bundler出现之前我们是如何在web上使用JavaScript的。 在浏览器中运行JavaScript有两种方法。 第一种，每个功能都作为一个脚本引入;这方式很难扩展，因为加载太多脚本会导致网络瓶颈。 第二种，使用一个包含…"}, {"id": "6844903556621795341", "title": "探索webpack热更新对代码打包结果的影响（二）", "desc": "在前一篇文章最后，我们已经锁定问题——热更新过程中导致入口文件module.exports输出的对象无法被正确挂载到window上。而至于真实情况是就是没有挂载还是挂载后被冲掉（复写）了，这个就是这篇文章中需要探索的。 探索前务必要先看一下Webpack热更新的源码知道其原理。…"}, {"id": "6844903503127642125", "title": "如何变更一个非相关文件但引发 webpack 重新构建", "desc": "如何变更一个非相关文件但引发 webpack 重新构建"}, {"id": "6844903920280535047", "title": "使用webpack 搭建react项目 二", "desc": "enforceExtension: enforceExtension如果是true，将不允许无扩展名(extension-less)文件,默认如果 ./foo 有 .js 扩展，require('./foo') 可以正常运行。但如果启用此选项，只有require('./foo.…"}, {"id": "6844904117648031758", "title": "💪从零开始学习webpack系列十一（文件分类）", "desc": "文件分类图片分类「outputPath」：输出，上面的是输出到img目录下css分类只需要在filename加上文件夹的名字就可以了但是css里面的引入背景图片的地址会发生错误，在改造一个css规则J"}, {"id": "6844903577693978632", "title": "ES3-Compatible Webpack Plugin", "desc": "Sometimes, we may need to write a plugin to do something when building with Webpack, like optimizing chunks of code, or replacing code ..."}, {"id": "6844903538313658381", "title": "如果你遇到了 webpack-dev-server 在 UC 浏览器里跑不起来的问题", "desc": "WhatkindofchangedoesthisPRintroduce?bugfixDidyouaddorupdatetheexamples/?NoSummaryTherewerepriorissue"}, {"id": "6844903887078424583", "title": "react服务端渲染实践1: 工程化配置", "desc": "本文面向有 webpack 经验以及服务端经验的同学编写，其中省略了部分细节的讲解，初学者建议先学习 webpack 以及服务端相关知识再阅读此文，文末有此配置的 git 仓库，可以直接使用。 为什么需要服务端渲染，这个问题社区中很多关于为什么使用服务端渲染的文章，这里不细说。…"}, {"id": "6844903520882130951", "title": "前端吐槽与parcel极简入门", "desc": "文章链接前端吐槽与parcel极简入门"}, {"id": "6844903512950702093", "title": "实现一个自己定制的函数库-单测编写篇", "desc": "单测的意义就在于当你重构代码的时候，能够避免你的新代码不出现以前解决的问题，虽然它很重要，但是工作中总是会把它忽视，因为太耗时间了。但我们要搭建的函数库大概当然是我们积累的精华代码，它值得我们花点功夫编写单测。"}, {"id": "6844903512468357133", "title": "ivweb 程柳锋：Fis3构建迁移Webpack之路", "desc": "Webpack从2015年9月第一个版本横空初始至今已逾2载。它的出现，颠覆了一大批主流构建如Ant、Grunt和Gulp等等。腾讯NOW直播IVWEB团队之前一直采用Fis构建，本篇文章主要介绍从Fis迁移到webpack…"}, {"id": "6844903581145890824", "title": "[英] 机器学习驱动打包——JavaScript工具的未来", "desc": "Tools based on machine learning techniques allow us to perform data-driven chunk clustering and pre-fetching for single-page applications."}, {"id": "6844903520265748487", "title": "无需每个项目都下载依赖的基于 webpack 全局安装的命令行工具", "desc": "命令安装如果你用的是Linux或Mac，可能会遇到权限不足的导致zls无法使用，所以请安装完成之后执行下面的命令给予权限。首次安装可能比较久，因为要把相关功能依赖全部下载安装完毕，不过相对于以后建立开"}, {"id": "6844903953059037198", "title": "webpack 相关", "desc": "grunt、gulp 是基于任务运行的工具：它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的社区，丰富的插件，能方便的打造各种工作流。 webpack 是基于模块化打包的工具：webpack 把一切都当做模块，当 webpack 处理程…"}, {"id": "6844903943319863304", "title": "学习webpack之一：从最简单的webpack说起", "desc": "看了很多webpack的教程，大多是上来就讲一堆配置，一堆插件的使用。这种文章看起来有点类似于官方文档，或者新华字典。我想回归初心，换一种方式，基于实际使用出发，一步一步介绍webpack。 从一个最简单的例子开始，这个例子只为了描述最简单的webpack功能，实现一个最简单的…"}, {"id": "6844903845424791559", "title": "关于Android工程师转成vue的三两事儿(4)--webpack", "desc": "如上图所示，新建了一个项目。 在这里扯一句闲话，可能很多教程谈到安装webpack都会让你选择直接-g，但是我并不推荐你这么做,我总感觉-g之后就成了全局变量，但是我并不是每个项目内都能用到这个所谓的webpack，将webpack的作用域设置为项目内，功能与全局没有差别。 如…"}, {"id": "6844904202515251208", "title": "webpack升级之旅（2->4）", "desc": "前言需要升级的包webpack(^2->^4)babel全家桶(babel-core、babel-preset-env、babel-transform-runtime...^7)，都升级为@babel"}, {"id": "6844904070554075143", "title": "Webpack教程~保姆级入门篇", "desc": "通过官网的指引安装好webpack,在项目根目录添加 webpack.config.js 的文件. webpack.config.js 遵循的是 commonJS 规范,依次文件采用 module.exports={[key]:[value]} 的方式,来暴露具体的配置。 指定…"}, {"id": "6890815562012852238", "title": "webpack从0到1 - 上", "desc": "大家好，我是Frank。相信大家都对webpack不陌生，今天我们一起来学习下webpack该怎么用。 webpack5.x已经在今年10.1国庆期间发布上线，但是考虑到不稳定性，和生态插件的更新，所以本次分享仍以webpack4.x版本为主。(webpack@4.43.0，w…"}, {"id": "6844903832678318094", "title": "使用webpack4.x定制自己的前端开发环境", "desc": "⚠️为什么需要这个插件？为什么要动态插入？ 主要是因为我们进行打包 为了防止浏览器缓存，往往需要给打包出来到文件添加[hash]。 DefinePlugin 是 webpack 内置的插件，可以使用 webpack.DefinePlugin 直接获取。 我们一般会把开发的所有源…"}, {"id": "6925338426539507720", "title": "Webpack(三):自定义Loader", "desc": "1. 在 src 下新建 my-first-loader.js 文件,要遵循 laoder 的用法准则 2. 在 webpack.config.js 文件中添加以下内容: 3. 使用命令行 npm run dev 进行打包 4. 访问 dist 文件夹下的 index.html…"}, {"id": "6899737005706608647", "title": "babel-loader运行过程", "desc": "（如果这个阶段不使用任何插件，那么babel会原样输出代码。） 那这里配置的@vue/babel-preset-ap其实是和@babel/preset-env作用是一样的包括很多的plugins去处理ES6+的语法如果不包含的在plugins里扩充。 注意很重要的一点就是，ba…"}, {"id": "6979477239175839758", "title": "webpack的简单实现", "desc": "webpack浅析 一、什么是webpack webpack是一个用于现代javascript应用程序的静态模块打包工具，webpack会根据应用的入口(entry)，遍历各个文件的依赖，构建依赖图谱"}, {"id": "6844903535918710791", "title": "译：Code Splitting with Vue.js And Webpack", "desc": "用webpack来打包你的单页应用的一个可能的缺点是你可能会得到一个非常大的打包文件，有时甚至会有几兆大小。 随之带来的问题是用户在屏幕上看到任何东西之前，必须要下载整个文件并运行它。如果用户使用的是网络连接不好的设备，这个过程可能需要很长时间。 Code splitting …"}, {"id": "6844904078011531272", "title": "怎样编写一个通用 webpack 构建配置", "desc": "loaders - 是一个函数，接受源文件作为参数，返回转换结果。 webpack 本身只支持 js 和 json 两种文件类型，通过 loaders 可以去支持其他文件类型并且将他们转换成有效的模块，还能添加到依赖模图中。 核心思想： 代码集成到主干之前，必须通过自动化测试，…"}, {"id": "6844903645394272270", "title": "Webpack 黑魔法之 CSS Entry", "desc": "大家都知道 webpack 的 Entry 都是 js，如果想输出 css 文件只能在 js 文件里导入 css，所以很多人都会想要是 entry 也可以是 css 那多好，这样就可以任意输出 css 。那么问题来了：怎么让 webpack 支持 css 作为 entry 呢？"}, {"id": "6844903886080180238", "title": "webpack4详细教程，从无到有搭建react脚手架（一）", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器，前端模块化的基础。作为一个前端工程师（切图仔），非常有必要学习。 webpack官网的文档非常的棒，中文文档也非常给力，可以媲美vue的文档。建议先看概念篇章，再看指南，然后看API和配置总览。看完指南…"}, {"id": "6900957929923411975", "title": "webpack入门必备（二）：优化配置", "desc": "1. 加快构建速度 1. exclude、include范围 PS. 相比exclude可以多用include 2. noParse 3. IgnorePlugin 例如: moment (2.24.0版本) 会将所有本地化内容和核心功能一起打包，我们就可以使用 IgnoreP…"}, {"id": "6844903918778974215", "title": "掌握Webpack4（实战篇三）", "desc": "这里会有选择是 React/Vue/JavaScript，我们统一都先选择 JavaScript。选完后会在项目的根目录下新建一个 .eslintrc.js 配置文件 @babel/parser 是 Babel 中使用的 JavaScript 解析器。"}, {"id": "6904119760691789831", "title": "webpack项目如何正确打包引入的自定义字体？", "desc": "一. 如何在Vue或React项目中使用自定义字体 总结一下就是：用户借助该规则，可以为引入的字体包命一个名字，并指定在哪里可以找到它（指定字体包的存储路径）后，就可以像使用通用字体那样去使用它了。 例如现在的需求是：需要在项目中使用 KlavikaMedium-Italic …"}, {"id": "6919390022042910733", "title": "webpack ", "desc": "... ... ... ..."}, {"id": "6924507659391467533", "title": "了解webpack", "desc": "2 . 服务器端模块化规范 上述的模块化标准存在一定的差异性与局部性，并不是通用的模块化标准，因此在ES6的语法上，定义了通用性的ES6模块化规范。 小结：推荐使用ES6模块规范， ES6模块化是浏览器端和服务器端通用的规范. 在前端开发中 vue, react, angula…"}, {"id": "6924501705421750286", "title": "不理解webpack的Loader，Plugin嘛，开发一个试试", "desc": "模块打包工具的由来*.模块化带来的问题1.ESModules存在环境兼容问题2.模块文件过多，网络请求频繁3.所有的前端资源都需要模块化，不仅仅是JavaScript模块(html,css模块)打包到"}, {"id": "6844903567069970439", "title": "下一代零配置打包工具 Parcel 初体验", "desc": "过于复杂繁琐的 webpack 配置一直是前端项目里的一个痛点，而新一代的“零配置”打包器 parcel 正在解决这个问题，春节回来之后的这几天我尝试把手上的业务迁移到 parcel 构建，下面就是一些踩坑心得。 先说结论： parcel 极其适合小型单页 React 页面的打…"}, {"id": "6844903847513571335", "title": "webpack4 sideEffects实战轻松搞懂", "desc": "没有搜到任何的 111 or 2222。证明没有打包进来。 看到多了一个文件。 搜到 111 和 2222，没有333。证明a,b打包进来，c没有打包进来。 因为a是函数自执行，a又引用b,so。。。 搜到的 111，2222，333。证明当--mode development…"}, {"id": "6844903885614628871", "title": "Webpack 4 动态切割JS注入文件名", "desc": "昨天重新把我们公司的引流页做了二重封装，遇到一个问题。 webpack 切割的时候如何加个可以跟随文件名变化的前缀。 大体就是就是 [request] 可以拿到实际解析的文件名，来取代默认的索引递增的方式。"}, {"id": "6844904053252554760", "title": "从零实现简易版Webpack", "desc": "市面上现在有很多bundler，最著名的就是webpack，此外常见的还有 browserify，rollup，parcel等。虽然现在的bundler进化出了各种各样的功能，但它们都有一个共同的初衷，就是能给前端引入模块化的开发方式，更好的管理依赖、更好的工程化。 一般项目需…"}, {"id": "6844903566826881038", "title": "基于 Webpack 开发和构建多页面站点", "desc": "基于 Webpack 开发、调试和构建多页面站点（普通 Web 站点）的前端工程化方案，同时适用于 PC 端和移动端。 webpack报错no postcss config... 使用 ES6 语法开发时，可按需引入 polyfill，提高浏览器兼容性。"}, {"id": "6942668052425080869", "title": "Webpack 学习笔记", "desc": "webpack是前端构建工具，会递归解析入口所需要加载的资源文件，用不同的loader处理文件，用plugin来扩展webpack的功能，输出一个或多个bundle。 webpack的本质：JS静态打包工具，当处理应用时，会在内部构建一个依赖图 dependency graph…"}, {"id": "6844903961460211726", "title": "仿 vue-cli 搭建属于自己的项目", "desc": "前段时间学习了webpack4的相关配置， webpack4入门篇，之前的所有项目都是使用vue-cli来搭建的，刚好公司最近有个新的项目要启动，想提升自己的逼格，正好也可以巩固之前学习的webpack4的内容，决定自己用webpack来搭建一个属于自己的脚手架。 ###1. …"}, {"id": "6844903518751424520", "title": "分享一个比较全的webpack配置，分为基础和适配antdesign的配置", "desc": "We provide some common configurations that saves a lot of time when you initially learn how to config webpack for developing. Happy coding!"}, {"id": "6914966788145053704", "title": "webpack[初体验]", "desc": "说明这次是跟着腾讯课堂的课程学习webpack相关的知识并且用react+webpack的方式做一个简单的小demo项目初始化初始化项目安装react相关包安装webpack此时package.jso"}, {"id": "6844903586241986574", "title": "React基础——更快的开发", "desc": "Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload. Hot Module Replace…"}, {"id": "6844903905088765959", "title": "Multi-pages Tpl files and Webpack entries automatic generates solution", "desc": "Our cms is build up as a multiple pages application. For the frontend our project using webpack multi entries&multi outputs.eg. For the bac…"}, {"id": "6844903782489260040", "title": "Webpack 是怎样运行的?（二）", "desc": ""}, {"id": "6844903828848902158", "title": "webpack4.0入门指南（二）转换es7语法解析静态资源", "desc": "之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。 把之前demo3文件夹一份命名为demo4。 在demo4路径下执行 webpack，就看到打包成功了打开demo4/index.js文件控制台就输出。 为了从 Java…"}, {"id": "6844903648019873800", "title": "寻找项目中顶级Vue对象 (一)", "desc": "在调试Chrome的时候, 发现不能找到vm这个对象. 在window下面也没有看到这个对象. 产生了好奇心. 找到了new Vue的运行栈. 但是没能确定在Vue中具体的运行过程. 应该是在import的时候, webpack就把引入的Vue对象放到了某个地方, 保存起来了.…"}, {"id": "6847902215949172749", "title": "webpack学习记录（二）", "desc": "1. Module module 是用来配置处理模块的规则，有以下三个主要部分。 同 noParse 配置项的区别在于，parser可以精确到语法层面,可以更细粒度地配置哪些模块语法被解析、哪些不被解析，而 noParse 只能控制哪些文件不被解析。 2. Resolve Re…"}, {"id": "6844903840597164045", "title": "webpack4-01:概念与零配置Hello World", "desc": "本人才疏学浅，如有描述不对，或者理解错误的地方欢迎指出。会及时改正！ 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency gr…"}, {"id": "6844903818094706702", "title": "webpack系列-优化", "desc": "\"modules\": false 的含义是关闭 Babel 的模块转换功能，保留原本的 ES6 模块化语法。"}, {"id": "6920858981472829447", "title": "webpack基础学习-入门篇", "desc": "本文对webpack做个基础的讲解，后续会陆续推出相关的进阶文章，希望大家可以通过文章能够对webpack有个全新的认识。 说白了，就是一个模块化的打包工具，可以处理各js模块之间的依赖关系，将其打包成浏览器认识的js文件(现代浏览器到目前为止是不支持js模块化的，如果有一天支…"}, {"id": "6844903848285339662", "title": "从0开始，自己实行webpack打包，不会打我（手动滑稽）", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。 接下来我们从0开始，一步一步实现我们的打包，作为入门，希望大家有所收获。 注意： npx 会帮你执行依赖包里的二进制文件。 接着在terminal输入'npm run …"}, {"id": "6844903919957573646", "title": "Webpack的几点性能优化", "desc": "对于打包来说，loader越多说明代码需要转换的越多，则效率就越低，因此在优化loader的时候，可以选择loader的搜索范围。 为什么不去查找node_modules路径下的文件呢？因为node_modules中使用的代码都是编译过的，因此无必要再去处理一下。 DllPlu…"}, {"id": "6844903853381386248", "title": "demo04 webpack + babel7", "desc": "babel 7 于 2018 年 8 月份发布，在 babel 7 中，所有官方包更名为以 @babel 为开头,并且 babel 7 推荐使用 babel.config.js 来配置 babel 。 分别用 ie,Chrome 浏览器打开，并查看控制台。"}, {"id": "6844904020872544263", "title": "webpack入门学习手记（五）", "desc": "前几天朋友聚餐突然想到，再过不到半年时间，第一批20后即将出生。这种感觉就像是，现在的90后看60后~ 一不小心我们这些90后在20后的眼中就变成了上个世纪的人。o(╯□╰)o 回顾webpack这个系列，结合自己使用的一个过程，是时候结束一下了。 我在项目中发现，有些时候cs…"}, {"id": "6899087872431751176", "title": "Webpack安装入门实例应用", "desc": "从上面可以就可以看出来Scss比CSS方便多了，其中Scss 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。 Python的安装教程可以看菜鸟教程Python安装教程，在使用的时候推荐安装Anaconda包，他里面集成了很多常用的第…"}, {"id": "6955043522089058340", "title": "最简易版 webpack，带你从基础进入 webpack 世界", "desc": "webpack 是目前前端主流的打包工具之一，但对于刚入门的同学来说，webpack 其实还是有点复杂的。可能大部分只会使用 creact-react-app 这种一键式脚手架对项目进行构建（包括我）"}, {"id": "6844903860637532168", "title": "复习webpack4之如何编写loader", "desc": "这次学习webpack4不仅仅要会配置，记住核心API，最好还要理解一下webpack更深层次的知识，比如打包原理等等，所以可能会省略一些比较基础的内容，但是希望我可以通过此次学习掌握webpack，更好地应对以后的工作。 我在之前的文章中，已经把webpack基础的内容基本上…"}, {"id": "6844903508282441735", "title": "小议webpack下的AOP式无侵入注入", "desc": " "}, {"id": "6844903845638701069", "title": "一文教你构建自己的library以及webpack优化和npm版本控制", "desc": "可以点个star，谢谢! 这套UI费了几个月时间和很多心血，现在已经趋于完善，你完全可以在你的生产环境中试着使用。对于性能的考虑，以及js/css压缩，按需引入等等都已经很完善。这套UI库富含移动端可能碰到的手势组件、弹出组件、懒加载、滚动加载等等... webpack4的pr…"}, {"id": "6844903746841870350", "title": "加快webpack:改善构建性能", "desc": "Keep webpack Fast: A Field Guide for Better Build Performance"}, {"id": "6844903922155388935", "title": "【webpack】指南", "desc": "开发环境(development)和生产环境(production)的构建目标差异很大。 在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localh…"}, {"id": "6844903841515700237", "title": "webpack4-05-配置vue相关", "desc": "在安装vue-template-compiler、vue包时，两个包的版本必须保持同步，这样 vue-loader 就会生成兼容运行时的代码。这意味着你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。 发现完美的跑起了一个简单的vue…"}, {"id": "6844903841138229256", "title": "复习webpack4之打包分析,Preloading,Prefetching", "desc": "这次学习webpack4不仅仅要会配置，记住核心API，最好还要理解一下webpack更深层次的知识，比如打包原理等等，所以可能会省略一些比较基础的内容，但是希望我可以通过此次学习掌握webpack，更好地应对以后的工作。 根据官方文档，我们可以使用命令行配置webpack -…"}, {"id": "6844904130981396493", "title": "Webpack上手指北", "desc": "近几年，打包构建工具层出不穷，前有Grunt、Gulp，后有Webpack、Rollup等，它们各有优势，均受到部分开发者的欢迎，本文聊聊Webpack的使用。 1）需要手动维护文件的加载顺序。且多个js之间通常有依赖关系，难以清晰分辨谁依赖了谁。 2）每一个<script>标…"}, {"id": "6844903516981657613", "title": "前端每周清单第 41 期 : Node 与 Rust、OpenCV 的火花，网络安全二三事", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID ： frontshow），及时获取前端每周清单。 PWA 是否能带来新一轮大前端技术洗牌…"}, {"id": "6844903647961186311", "title": "service worker 概述", "desc": "1、https: Service Worker必须是https协议的，但本地环境下http://localhost或者http://127.0.0.1也可以的。 1、service worker让离线缓存成为可能，offline情况下也可以访问页面。然而销毁比较困难，更新会有问…"}, {"id": "6844903825275355150", "title": "webpack总结", "desc": "1. gulp和grunt 与 webpack的区别 webpack：webpack更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js文件、css文件等）都可以看成模块。 2. 常见的 Loader 和 Plugin style-loader：把 CSS 代码注入到 …"}, {"id": "6844903509540732935", "title": "Webpack-源码四，从源码分析如何写一个loader", "desc": "从黑盒和白盒两个角度讲讲如何写一个loader以及loader这个东西是如何在webpack中运作起来的。loader相当于一个翻译器，具体的loader会有很大不同，比如less-loader和ejs-loader内部代码肯定差异极大，这里只以最简单的loader举例，入坑以…"}, {"id": "6858287170122481678", "title": "Webpack学习-深入浅出", "desc": "个人觉得 Webpack 应该是现代化前端开发的基石，也是目前前端生产力的代名词。 随着前端应用的日益复杂化，我们的项目已经逐渐膨胀到了不得不花大量时间去管理的程度。而模块化就是一种最主流的项目组织方式，它通过把复杂的代码按照功能划分为不同的模块单独维护，从而提高开发效率、降低…"}, {"id": "6844904040501870600", "title": "webpack的基本配置都掌握了么？", "desc": "识别的代码。 主要是对预设(presets)和插件(plugins)**进行配置。 ES5。 css-loader：用于加载.css文件并转换成commonjs对象。 style-loader：将样式通过style标签插入到head中。 向左执行，所以会先进行css的样式解析后…"}, {"id": "6844903520517226509", "title": "iKcamp&掘金Podcast直播回顾（12月2号和9号的两场）", "desc": "12月2号－哈志辉－前端工程化沪江CCtalk实践12月9号－陈达孚－PWA实现渐进式Web应用"}, {"id": "6844903919093547016", "title": "为什么webpack配置中常常用path库处理路径", "desc": "1.兼容windows和mac/linux路径写法问题 。 windows使用\\进行分割目录 而mac或linux使用的是/ 如果你的脚本执行命令与其在同一目录下，那么恭喜你侥幸成功。为什么说侥幸呢 ，这是因为其相对路径并不是相对于当前配置文件，而是相对于pwd。像下面这样 你…"}, {"id": "6901593079229186056", "title": "webpack系列之loader实现", "desc": "webpack 是个很强大的构建工具，其丰富灵活的配置决定了使用也不简单。在面试中经常能遇到 webpack 相关的问题，如果平常只是使用脚手架如 vue-cli 而没有好好深入学习研究 webpack 的话，估计答不上什么。我相信，如果没有深入了解，部分面试官也问不出什么。可…"}, {"id": "6844903567384379406", "title": "[英] webpack 4: released today!!", "desc": "🎼webpack4:released today!!✨Codename:Legato 🎶Todaywe’rehappytoannouncethatwebpack4(Legato)isavailable"}, {"id": "6844903565014597645", "title": "爱搞事情的webpack", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个…"}, {"id": "6844903831692656654", "title": "webpack 基础", "desc": "最近有机会系统地总结一下 webpack 相关的东西，写篇文章来记录一下。写这篇文章一半是为了自己看，一半给别人看。如果有人看了这篇文章感觉很有用，真是我莫大的荣幸。 首先这不是 《深入浅出 webpack》， 也不是《一篇文章带你玩转 webpack》，更不是 《学习 web…"}, {"id": "6939688096896122894", "title": "从零学脚手架(六)---production和development拆分", "desc": "webpack打包时分为开发模式（development）和发布模式（production），在前面使用命令参数做了简单区分。 但这种方式区分在做定制化模式时有些不太方便，所以需要对两种模式做彻底拆分。 之前介绍过，webpack可以使用 --config 参数指定配置文件，所…"}, {"id": "6844903917386465287", "title": "Webpack源码分析(1)--之 流程总览", "desc": "这就是整个过程了。"}, {"id": "6844903734107979789", "title": "从i18n国际化来学习如何创建Webpack插件", "desc": "插件向第三方开放了 Webpack 引擎中完整的能力，它比 loader 能做更多的事情，这些构建的回调完整的构成了一个 Webpack plugin 的存在，因此我们需要理解一下 Webpack 底层内部的特性来做相应的钩子，这是一件很有趣的事情，学习完我们将用插件来解决一个…"}, {"id": "6844903504830545927", "title": "mock-stores——简单易用的数据mock方案", "desc": "mock-stores是一款简单易用的数据mock npm包，可以针对无法拦截ajax请求或者非ajax请求的项目做mock，简单易用仅需三步，便可完成整个过程。优点有： 首先在你项目的根目录下，创建mock目录，然后在该文件夹下创建js/json文件，存放服务端返回的json…"}, {"id": "6884516427827838983", "title": "Vue项目嵌入编辑器的坑和前端工程化解决方案", "desc": "上周项目用了许久的百度编辑器Ueditor应为太久不维护要更换编辑器了。 预研后选择stackedit作为新的编辑器（虽然也好久没维护了），但耐不住功能比Ueditor多啊，后面还能进行二次开发。 1、编辑器自己有开后端去运行，要把他改造成纯前端编辑器。 怎么办呢，只能从头 g…"}, {"id": "6879278241656340494", "title": "Webpack的入门知识", "desc": "原始的时候我们编写网页程序，主要是编写HTML文件，接着通过scrpit标签引入一个index.js文件辅助编写一些业务逻辑和DOM操作。若JS处理逻辑过多，index.js文件就会膨胀，而且编写逻辑主要以面向过程为主，不好维护和扩展。 接着可以考虑一些例如面向对象的思想，将i…"}, {"id": "6844903573403222029", "title": "为什么我们不用sourcemap了？hey-cli默认关闭打包配置", "desc": "随着代码增多，我们需要对代码进行压缩。 代码压缩后进行调bug定位将非常困难，于是引入sourcemap记录压缩前后的位置信息记录，当产生错误时直接定位到未压缩前的位置，将大大的方便我们调试。 阮一峰写的一篇文章，JavaScript Source Map 详解，大家如果感兴趣…"}, {"id": "6844903567304851464", "title": "前端每周清单第 52 期: Webpack 4.0，GraphQL 安全加固，去中心化的 Web", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID: frontshow），及时获取前端每周清单。 Webpack 4.0.0 发布: 本周…"}, {"id": "6902717075551174669", "title": "使用babel和webpack优化项目", "desc": "组件化、模块化、自动化、工程化是现在考核一前端项目是否为一个优秀项目的标准之一，从而应运而生了一些列前端模块化、工程化的工具库。babel和webpack就是其中的优秀代表，那你了解他们么？你知道如何通过babel和webpack来优化前端项目么？ webpack是一款前端构建…"}, {"id": "6844903954388631566", "title": "学习webpack之二：基础配置", "desc": "上一篇博客起了个头，介绍了为什么要用webpack，用webpack可以做什么，以及最简单地配置。这篇博客将结合实际需求，一步一步的引入一些配置，所有内容基于实际需求出发。 上一篇博客说到，entry是webpack打包的入口文件，webpack会从这个入口文件开始，寻找该入口…"}, {"id": "6844903502502690830", "title": "webpack watch 篇（一）", "desc": "webpack watch 实现"}, {"id": "6844903975322386439", "title": "使用 webpack 提升页面性能", "desc": "webpack 是一个 js 代码模块化的打包工具，藉由它强大的扩展能力，随着社区的发展，逐渐成为一个功能完善的构建工具。在使用 webpack 的时候，如果你不注意使用它的方式方法很有可能会发生意料之外的问题，比如性能问题。我们都知道 webpack 可以帮助我们打包和压缩代…"}, {"id": "6945841189425774628", "title": "二、Webpack配置应用", "desc": "1. source-map 2. eval-source-map 3. cheap-module-source-map 4. cheap-module-eval-source-map 实时打包，不需要每次修改代码后手动打包。 4. Webapck插件的应用 1. clean-w…"}, {"id": "6844903608022990861", "title": "EasyPack - 也许是最方便的 webpack 构建工具", "desc": "项目中都会用到 webpack,但每个项目的重复配置太多，还经常会因为某个版本升级，导致原先的配置失效，重新花时间去整理。 很多 webpack 工具或者 CLI 都把配置包装起来，不利于二次开发，遂想把webpack配置模块化，简单化，可视化。 EasyPack只专注在构建方…"}, {"id": "6844903508135657479", "title": "基于webpack构建的angular 1.x 工程（一）webpack篇", "desc": "现在AngularJS都已经出到4.x的版本了，可我对它的认识还是停留在1.x的版本。 之前用它是为了搭配ionic来写web手机天气 应用（用来应付我大学里一门学科的课设的︿(￣︶￣)︿）。之后就因为它太难学而没有继续深入下去。 现在就职的公司也有个项目是做混合式的手机app…"}, {"id": "6844903842782396424", "title": "webpack4.x实战五，js支持ES6；css支持less、浏览器兼容", "desc": "ECMAScript 6.0, 是JaveScript的下一个版本标准, 2015.06发版。 css3 目前有些语法需要添加浏览器前缀。"}, {"id": "6953825997477609508", "title": "webpack-dev-middleware@1.12.2 源码解读", "desc": "​ webpack-dev-middleware 是express的一个中间件，它的主要作用是以监听模式启动webpack，将webpack编译后的文件输出到内存里，然后将内存的文件输出到epxres"}, {"id": "6844903841842855950", "title": "升级优化Webpack4，使你的打包速度提升200%以上！", "desc": "1. 配置中可优化的点 先说一下我在升级中发现的可以优化的点，大家有什么建议和想法可以一并提出。 优化第三方库最简单粗暴并且及其有效的一个方式就是使用webpack的DllPlugin。它可以将我们经常使用但是修改频率极低的第三方库与自己的代码完全分离开， 每次打包的时候会根据…"}, {"id": "6894931482825981959", "title": "webpack5发布简译", "desc": "2020 年真是多事之秋，疫情啊、牛市啊就这样措不及防地来了。。。 前端里也是，被社区推动着学习，之前不小心在 twitter 上刷到 React 17 发布，看完后幸好没什么大改动（hooks 就已经喝够一壶了）。接着掘金里狂刷 Vue 3.0 发布，大航海时代神马的醉了，不…"}, {"id": "6844904093777920008", "title": "关于webpack中file-laoder的publicPath路径问题", "desc": "Specifies a custom public path for the target file(s). 发现问题并最终找到答案。这说明我一开始的质疑是对的，也说明我不是按部就班的按照文档来写，每个步骤都走通了，为以后进一步学习打好基础。 另外，第一次看别人的源码，感觉好意…"}, {"id": "6844903926714646536", "title": "手把手教你撸一个webpack配置", "desc": "在模块化的开发过程中我们经常会使用webpack来帮助我们搭建一个良好的开发环境，提升开发效率；很多人对webpack的那么多配置项感到无从下手，下面是我总结的如何构建一个简单的webpack配置。"}, {"id": "6844904105203204103", "title": "认识Webpack概念", "desc": "在前端模块化开发的今天，我们在工作中经常会接触到一些编译构建工具，如Parcel（极速零配置Web应用打包工具），Rollup（新一代JavaScript模块打包器），Gulp（基于流的自动化构建工具），Webpack（JavaScript应用程序的静态模块打包工具）等等。这其…"}, {"id": "6844904019228377096", "title": "从零学习搭建webpack工程(一)", "desc": "一 、初始化项目，实现webpack打包。 1、新建文件夹webpack-tempalate，cd到当前文件夹,打开git bash 使用命令npm init -y生成 package.json。 2、安装 wenpack，webpack-cli，执行命令npm install…"}, {"id": "6844903695029633038", "title": "webpack4 系列教程(十三)：自动生成HTML文件", "desc": "0. 课程介绍和资料 1. 为什么要自动生成 HTML？ 看过这个系列教程的朋友，都知道在之前的例子中，每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。 但在真实生产环境中，一次运行webpack后，完整的index.html…"}, {"id": "6844903998525276174", "title": "前端模块化学习", "desc": "1. 模块化相关规范 2. webpack"}, {"id": "6844904065080492040", "title": "Webpack4 基础入门与实践", "desc": "自从出现前端模块化以后，我们就可以将原本是一坨的代码分离到一个个的模块中。但是由此引发了一个问题，每个 JS 文件都需要浏览器通过网络请求向服务器去获取，这样会导致页面加载速度变慢。 Webpack 最主要的目的就是为了解决这个问题，将项目中所有应用的文件和模块打包成一个或多个…"}, {"id": "6844904190662148110", "title": "Webpack多入口多出口打包组件：MultiZipPlugin", "desc": "由于业务上有一个需求，需要每次将webpack输出的文件再打一个zip包，但是找了找没有找到合适的插件，于是自己写了一个。"}, {"id": "6907876546619555848", "title": "前端工程精讲", "desc": "##一开发效率1.1Mock工具Mock.jsAjax请求拦截Mock.mock方法支持传入Ajax请求的url和typeMock.setup方法设置拦截Ajax请求后的响应时间数据验证Mock.va"}, {"id": "6844904050169741320", "title": "Webapck 简单配置", "desc": "任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有 依赖关系。这使得 webpack 可以接收非代码资源(non-code asset)（例如 images 或 web fonts），并且可以把它们作为 依赖 提供给你的应用程序。 此依赖图会映射项目所需的…"}, {"id": "6844903847916208135", "title": "Webpack的坑位整理", "desc": "webpack现在是主要的打包工具了，现在网络上也有很多资料可以学习了。这里主要\b整理了一些基础概念，但没有所有的写，只是把之前遇到的问题记录了一下。 webpack是一个js应用程序的模块化打包器，它将递归地构建一个依赖关系图，其中包括应用程序需要的每个模块，然后将所有模块打…"}, {"id": "6844903853389791240", "title": "demo10 关于JS Tree Shaking", "desc": "借助于 es6 (es2015) 模块系统 (import 和 export) 的静态解析，webpack 能够利用 Tree Shaking 进行按需加载，移除掉没有被引用的模块，从而减少包的大小，缩小应用的加载时间，从而提高性能体验。 UglifyJSPlugin 的作用在…"}, {"id": "6844903861455421453", "title": "编写一个webpack的loader（2）", "desc": "默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。但是有些情况下，我们需要操作二进制数据。这种时候，只需要设置一个raw属性，传给loader的就是二进制数据。 其实raw-loader只是通过功能来区分的。同样在内部可以实现同步loader和异步lo…"}, {"id": "6907527714542993416", "title": "Webpack入门配置总结", "desc": "先安装依赖插件， 必须要安装style-loader 。 原理是 webpack默认要把 以.css结尾的放到style标签中。 创建一个webpack配置文件：webpack.config.prod.js 用在生产模式时使用。 并在package.json文件中重新配置bui…"}, {"id": "6844904045686046734", "title": "详细的 webpack4 多入口配置", "desc": "本文主要是多入口配置，希望能在无框架开发网页时提高开发效率，对代码进行打包优化。本文有什么需要改善的地方，还望各位多多指教。 后文省略 module.exports 等代码，不再赘述。 在配置 output 之前配置这个插件是为，每次打包前可以删除 dist 目录，保证没有冗余…"}, {"id": "6844903542029811725", "title": "通过Scope Hoisting优化Webpack输出", "desc": "它又译作 \"作用域提升\"，是在 Webpack3 中新推出的功能。 单从名字上看不出 Scope Hoisting 到底做了什么，下面来详细介绍它。 让我们先来看看在没有 Scope Hoisting 之前 Webpack 的打包方式。 从中可以看出开启 Scope Hoist…"}, {"id": "6844903886700937229", "title": "前端模块化一——规范详述", "desc": "模块化——这个东西可以说在研发圈子里，耳熟能详，家喻户晓。 接触过es6 的import，nodejs 的require，webpack下的import或者require。那么他们之间到底有什么区别？ CommonJS 听说过，nodejs的模块化实现？AMD听说过，也听说过C…"}, {"id": "6953818433779662862", "title": "webpack:source-map", "desc": "本文从构建后代码，到浏览器为什么可以看到源码映射来讨论，不研究构建部分。 源码的目录树怎么生成的，在构建后代码的哪里有体现？ 源码的代码部分有构建后代码的哪里提供的？ 构建后代码和源码的位置映射关系维"}, {"id": "6844904169023733773", "title": "Webpack-bsv-极简React项目脚手架", "desc": "一直以来做的react项目都是自己配置webpack的，之前每次新项目都是copy一下上一个项目的配置文件，npm i后就能愉快地跑起来了。copy多了也就想写一个npm包，以后直接npm i这个包就可以愉快地玩耍了，还可以让公司其他小伙伴们用，何乐不为呢。 虽然说这是一个极简…"}, {"id": "6844903858401968141", "title": "[译]在生产环境中使用ES2015+代码", "desc": "我最近交流过的前端开发人员都喜欢使用 async/awiat、classes、箭头函数这些新特性去编写他们的JavaScript代码。尽管所有的现代浏览器都可以运行ES2015+的代码并且原生支持上面提到的新特性，但是绝大多数开发人员还是会把他们ES2015+的代码编译成ES5…"}, {"id": "6844903560514109448", "title": "vue canvas动效组件插件库制作", "desc": "See the GitHub 查看历史版本. 欢迎给出一些意见和优化，期待你的 Pull Request。"}, {"id": "6844903694169800717", "title": "蚂蚁金服可视化图形语法 G2 3.3 发布：琢·磨", "desc": "经过两个多月密锣紧鼓的开发，400+次提交，G2 3.3版本今天终于和大家见面了。自上次3.2版本发布以来，我们收到不少图表组件相关的需求和吐槽，团队的工程师们和设计师们倾力合作，为大家带来更丰富、体验更好的图表组件。同时，3.3版本为 G2 带来新的图表成员：小提琴图，并为大…"}, {"id": "6844903592780906503", "title": "探寻 webpack 插件机制", "desc": "webpack 可谓是让人欣喜又让人忧，功能强大但需要一定的学习成本。在探寻 webpack 插件机制前，首先需要了解一件有意思的事情，webpack 插件机制是整个 webpack 工具的骨架，而 webpack 本身也是利用这套插件机制构建出来的。因此在深入认识 webpa…"}, {"id": "6903817916504866824", "title": "重学webpack(配置详解)", "desc": "第一种写法：执行webpack指令之后，我们会发现webpack自动构建输出了一个JS文件(即build/built.js文件)，又因为我们使用了插件new HtmlWebpackPlugin()，这个插件会自动帮我们生成了build/index.html并自动帮我们引入了打包…"}, {"id": "6867805422883962888", "title": "你真的理解 Webpack?请回答下列问题", "desc": "Chinese一文搞定Webpack面试EnglishWebpack实战与Webpack类似的工具还有哪些谈谈你为什么选择使用或放弃webpackLoader和Plugin的不同有哪些常见的Loade"}, {"id": "6844903840861388807", "title": "Webpack核心概念解析", "desc": "终于忙完了论文，可以愉快的开始学习了，重拾起重学前端、webpack以及Vue的源码解读作为入职前的复习吧。整个webpack系列将分成五个大的部分进行，以webpack4.0为文档进行解读，从简单的概念解读到最后的实现。 在配置中，有三个loader,执行顺序是从下到上，从右…"}, {"id": "6844903684833280013", "title": "搭建Typescript+React项目模板(3) --- 整理项目和杂项", "desc": "在上一篇提升开发体验中，我们一下子集成了一堆插件和功能进去，导致项目结构比教混乱，重点问题就在webpack的相关配置项目录build文件夹中，所以今天的工作较为轻松，重点就是进行项目结构整理，然后再进行一些杂项的添加。 那么当前最先需要做的工作就是进行build文件夹下web…"}, {"id": "6971020543558582309", "title": "webpack5 的使用（六）：优化", "desc": "这是我参与更文挑战的第7天，活动详情查看： 更文挑战 前言 如果你坚持到了这个章节，就已经写好了一个比较完整的 webpack 项目了。不过，项目还缺少一些优化。 下面将从优化打包体积和优化构建速度两"}, {"id": "6844903917835255815", "title": "Webpack 3 - 打包从优化到放弃", "desc": "某一天，我突然发现构建项目会经常失败，直接报错：FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory，这个错误很明显就是内存不足导致的构建失败。由于项目是在CI / …"}, {"id": "6989616397320110087", "title": "Webpack5学习 --- 模块化原理", "desc": "webpack作为前端静态模块化打包工具，最基础也是最核心的功能就是实现前端模块化。在webpack中支持目前市场上主流的各种模块化机制（如ESM, CJS, AMD, CMD等）。"}, {"id": "6844903824482811912", "title": "如何优雅的自配Vue2.6.10+webpack4.29.6？", "desc": "webpack4与vue2.6已经出来一段时间了，忙于业务一直没有时间做升级，cli又不能满足业务上的需求，决定抛弃脚手架手撸一个最新的基于vue的webpack项目。 一系列操作之后，package包出现了，我们先下载关于webpack的依赖包，输入指令。 7、配置html。…"}, {"id": "6844903880371732494", "title": "Webpack打包优化", "desc": "对于使用vue开发项目的FE来说,打包上线这个环节相信大家都不陌生。本文主要是介绍如何通过webpack(实践版本:webpack4.16.5)的配置来提高打包构建速度以及减小包的体积。 使用optimize-css-assets-webpack-plugin 来压缩css。在…"}, {"id": "6844903801774669837", "title": "JavaScript 差量更新的实现", "desc": "传统的JavaScript 资源加载，一般是通过CDN 存放或者伺服在本地服务器，通过设置maxage、Last-Modified、 etag 等来让浏览器访问后缓存，减少重复请求，但在产品的更新很多时候往往都是修改少量内容，hash 改变之后，用户就需要全量下载整个Javas…"}, {"id": "6844903589240913933", "title": "webpack dllplugin的使用姿势", "desc": "之前在上家公司，主要负责系统后台的业务，由于业务代码较冗余，一直在尝试使用webpack dllplugin，由于业务线的耽误，一直没有时间优化，今天有时间，重新梳理了一下，整理一下，分享给大家，webpack dllplugin的正确姿势 part I：webpack dll…"}, {"id": "6970864974801403918", "title": "开发CopyWebpackPlugin插件", "desc": "这是我参与更文挑战的第7天，活动详情查看： 更文挑战 注：以下是个人理解、如有不对还望指正！ loader和plugin区别 loader : 文件加载器、告诉webpack如何转化和处理某一类型文件"}, {"id": "6942873034302685197", "title": "webpack优化打包", "desc": "每一个设备终端可能对于babel-pollyfill的需求不一样，甚至不需要，那么，动态babel-pollyfill需要通过User Agent的判断，进行按需加载。"}, {"id": "6844903669435990024", "title": "React+Webpack性能优化", "desc": "例如这样就可以直接使用React的压缩版本，每次构建时不必再次解析。还可以通过别名引用文件，而不必再打长长的引用路径： 但这样的缺点是会无法使用Tree-Shaking，所以一般对React这种整体性比较强的库使用比较好，而像lodash这样的工具库还是使用Tree-Shaki…"}, {"id": "6844903552813367310", "title": "vue-cli之webpack3构建全面提速优化", "desc": "在这其中，相信很多人都会选择官方的vue-cli初始化工程模板，然后通过引入第三方组件框架和工具的方式进行开发构建，我个人也十分推崇这种做法。但是vue-cli初始化的项目模板毕竟是面向所有开发者的，在兼容性方面会有一定妥协。相信很多人都已经搜索过各类的webpack构建优化文…"}, {"id": "6844903961871253511", "title": "webpack 4.x之搭建前端开发环境", "desc": "以后npm直接替换成cnpm使用。 在开始搭建前首先看一下我们能从本教程学习到什么. ※注：本文代码区域每行开头的 “+”表示新增，“-或者D”表示删除，“M”表示修改，“...”表示省略。 dist为最终编译出来的生产环境代码，src为开发环境代码。 调整 package.j…"}, {"id": "6844903936072105992", "title": "GraphQL 项目中的前端 mock 方案", "desc": "在使用 GraphQL （以下简称 gql）的前端项目中，往往需要等待后台同学定义好 Schema 并架设好 Playground 以后才能进行联调。如果后台同学阻塞了，前端只能被动等待。如果对于 gql 项目来说也能够和 REST 一样有一套 mock 方案就好了。经过一系列…"}, {"id": "6844903924806189070", "title": "Webpack优化——将你的构建效率提速翻倍", "desc": "0. 背景 随着构建体系不断完善、构建体验不断优化，webpack 已经逐渐成为了前端构建体系的一大霸主，对于工作中的真正意义上的前端工程项目，webpack 已经成为了我们前端构建技术选型的不二选择，包括 create-react-app 以及 vue-cli 等等业内常见的…"}, {"id": "7002837689120604191", "title": "3. Webpack生产环境配置", "desc": "与上一篇文章不同的是，本文会从文件内容的角度出发，介绍样式、html、js的文件提取、兼容性处理和压缩。可能不会深入介绍每个配置项，有需要可以挨个去查阅官方文档~"}, {"id": "6985111949784645646", "title": "一种前端项目依赖管理的未曾设想的道路", "desc": "当前吐槽的 node_modules 的依赖问题，从 2020 年回过头来看，不仅没有解决，反而越来越明显。 解决方法是关注点分离，将业务依赖和工具依赖单独放置，本文针对从这个思路出发开开脑洞"}, {"id": "7005207310062583821", "title": "论如何填满 webpack5 升级“天坑”", "desc": "在现代前端工程化的历史中，webpack 这个炙手可热的模块打包工具占据着打包编译界的半壁江山，它拥有丰富的插件生态和强大的编译能力，也正因为其过于“强大”导致在升级时会出现各种各样的兼容等问题，这点"}, {"id": "6981336952704335908", "title": "关于webpack性能优化，我们能做些什么？", "desc": "本文首发于：https://github.com/bigo-frontend/blog/ 欢迎关注、转载。 我们做了啥 Bigo前端组计算平台前端组基于amis框架，参考之前的文章：https://g"}, {"id": "6844903624632434702", "title": "Webpack 4 配置最佳实践", "desc": "Webpack 4 发布已经有一段时间了。Webpack 的版本号已经来到了 4.12.x。但因为 Webpack 官方还没有完成迁移指南，在文档层面上还有所欠缺，大部分人对升级 Webpack 还是一头雾水。 不过 Webpack 的开发团队已经写了一些零散的文章，官网上也有…"}, {"id": "6999188157992271886", "title": "Webpack5 系列（四）：Babel 的配置", "desc": "Babel 版本更新后，很多内容已经发生变化，官方文档也是晦涩难读。本篇将介绍对于项目中 JS 文件的处理。"}, {"id": "6993109621393063967", "title": "手写一个简易bundler打包工具带你了解Webpack原理", "desc": "🥝序言 我们都知道， webpack 是一个打包工具。在我们对它进行配置之前，它也是经过一系列的代码编写，才生成的打包工具。那这背后，又做了"}, {"id": "6883305742422507533", "title": "vite虽香，但webpack还是要学的", "desc": "entry是整个配置文件的入口，没有之一。 entry有两种入口，四种配置。 既然有入口，那就肯定有出口啦！就好像人，要吃饭也要拉*。这里的出口就是打包好的东西要把它放在哪里。 module.rules就是loader的配置位置，loader用于解决一些代码的兼容性。 plug…"}, {"id": "7005568031917260830", "title": "webpack5学习 --- 代码压缩", "desc": "Terser是一个JavaScript的解释(Parser)、Mangler(丑化)/Compressor(压缩)的工具集。Terser可以帮助我们压缩、丑化我们的代码，让我们的bundle变得更小。"}, {"id": "6844904030649614349", "title": "看完这篇还搞不懂webpack，求你打我", "desc": "webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。有人就会问为什么要webpack？webpack是现代前端技术的基石，常规的开发方式，比如jquery,html,css静态网页开发已经落后了。现在是MVVM的时代，数据驱动界面。webpack它做的事情是，分析你的…"}, {"id": "6944940506862485511", "title": "分享15个Webpack实用的插件！！！", "desc": "初衷： 分享一下工作中实用的几个Plugin，希望对大家有些帮助，不喜勿喷。 用途： 将css样式从js文件中提取出来最终合成一个css文件，该插件只支持webpack4之前的版本，如果你当前是webpack4及以上版本那么就会报错。 上面配置中，extractTextPlug…"}, {"id": "6969748500938489892", "title": "万字长文：关于sourcemap，这篇文章就够了", "desc": "而今，只要是工程化的项目，大多离不开 sourcemap 的身影，一言蔽之：构建处理前的代码和处理后的代码之间的桥梁。但却很少有同学真的去深入了解它的运作原理。"}, {"id": "6989129270744481829", "title": "webpack常用的打包配置", "desc": "webpack打包 webpack在项目根目录创建一个webpack.config.js文件 webpack.config.js 主要有五个属性 下面有打包css less html 字体文件 图片 "}, {"id": "7002477797264326670", "title": "解决px2rem-loader转换1px安卓手机不显示的问题", "desc": "webpack配置了px2rem之后，老项目有的border写的是1px solid xxx;这种写法写的描边在安卓部分手机上描边消失了, 这里有解决方案！"}, {"id": "7006596211352272909", "title": "记录一次安装webpack-dev-server报错", "desc": "报错信息如下 应该是国内淘宝源导致的安装失败，执行下面命令打开配置。 删掉淘宝源，重新安装，问题解决"}, {"id": "6988895405404586020", "title": "webpack 工作流程", "desc": "webpack 构建打包流程、webpack核心概念、前端工程化、前端学习、知识总结、新手、欢迎大佬指正、"}, {"id": "7004746225236836360", "title": "初窥 webpack+vue+ts+jquery", "desc": "webpack+vue+ts+jquery 学习，并简单理解一下。 TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。"}, {"id": "6844903520865386510", "title": "import、require、export、module.exports 混合使用详解", "desc": "自从使用了 es6 的模块系统后，各种地方愉快地使用 import export default，但也会在老项目中看到使用commonjs规范的 require module.exports。甚至有时候也会常常看到两者互用的场景。使用没有问题，但其中的关联与区别不得其解，使用起…"}, {"id": "6960490563455942692", "title": "webpack打包优化方向指南(理论篇)", "desc": "对一位合格的前端开发工程师来说，完成业务功能的需求开发只是基本的要求，能够及时准确地发现系统中存在的性能瓶颈，并且给出合适的解决方案，这才是区分初，中级前端工程师和高级前端工程师的重要依据"}, {"id": "6844903624418525191", "title": "记一次对webpack打包后代码的失败探究", "desc": "所谓的基本版，就是我只引入了一个test.js,代码只有一行var a = 1。打包之后，发现生成的文件main.js并没有多少代码，只有90行不到。 截取出真正执行的代码就更加少了，只有下面4行。我们接下去就从这几行代码中看下打包出来的文件的执行流程是怎么样的。 首先很明显，…"}, {"id": "6895934650150027278", "title": "webpack解析css等样式文件", "desc": "！注意：这里只会把使用了 MiniCssExtractPlugin.loader 的样式文件合并成一个之后通过link外链样式引入到页面，而没有使用该加载器的样式还是通过style内嵌样式引入到页面内。"}, {"id": "6860712430394310669", "title": "学习 HMR 原理的小记", "desc": "Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对…"}, {"id": "6844903773144350727", "title": "针对 Source Maps 的一篇介绍（翻译）", "desc": "组合并且压缩你的JavaScript 和 CSS文件是提高性能最方便的方式之一。但是当你需要调试这些压缩后的代码的时候会发生什么呢？它可能是异常噩梦。不过不用怕，这里有一个通过source maps的name来解决的问题的方案。 source maps提供了一种将压缩后的文件代…"}, {"id": "6938714938344996895", "title": "webpack性能优化点(上篇)", "desc": "前言:在前端领域,性能优化大概分散在三个纬度:构建性能:传输性能:运行性能:其中运行性能跟我们书写代码的方式是跑不掉的,在本章节里我们就不多聊,如果想了解如何优化运行性能,我推荐大家看一本书《高性能J"}, {"id": "6921546670442446861", "title": "Webpack4散记（1）写一个插件", "desc": "想学习一下写webpack插件，起步就遇到障碍。 从网上找了一个demo，是通过二次调用html-webpack-plugin来对index.html进行自定义修改。但运行时遇到报错。关键信息： 搜索了一下，资料不多，大致找到原因是webpack4对Tapable对象重写造成h…"}, {"id": "6844903829121728525", "title": "一步步使用 webpack 第一篇：使用 webpack 编译 es6 代码", "desc": "团队使用的 webpack 功能很强大，有时候会碰到编译失败的情况，总得找工具的作者解决问题，自己很少去追究原因，感觉对于 webpack 的认知总是一知半解。因此，从本篇文章开始，自己从零开始配置 webpack，认真体验一下配置过程。文章内容过于简单，如果有 webpack…"}, {"id": "6844904003545858061", "title": "蛋糕分割整合工具——Webpack-前端工程化", "desc": "Web 前端开发这几年发展非常迅速，非常多的开发框架和构建工具的涌现，敬爱的前端攻城狮，可能你昨天还在用的工具、插件，到了今天可能就过时了。到了今天，外面的世界已经变了。 所谓工程化，可以简单认为是将框架的职责拓宽再拓宽，主旨是帮业务团队更好的完成需求，工程化会预测一些常碰到的…"}, {"id": "6844904058021478414", "title": "Webpack源码分析 - 目录解析及优化", "desc": "AMD... 我们可以使用它导入各种第三方库及项目文件，也可以使用别名来简化路径。我们知道，虽然CommonJS是node原生支持的依赖管理方法，但是我们打包项目时不是node来加载要打包的文件，而且查找规则也和node的不一样，所以Webpack实现了自己的一套文件查找方法。…"}, {"id": "6844903863196057614", "title": "使用DllPlugin和DllReferencePlugin提高打包速度", "desc": "在项目开发过程中，遇到需要优化打包速度的问题。我们可以通过分离第三库的形式优化构建速度。 在项目中我们经常会用到jquery，vue，echarts等第三方库。我们可以把这些第三库和自己的开发代码分离开来，只需要在第一次构建的时候进行打包，以后就不会再去编译这些第三方库，从而优…"}, {"id": "6879386888998748167", "title": "【打包工具】Webpack-1", "desc": "webpack是一个模块打包工具，由于前端大量地采用模块化开发，所以模块打包工具应运而生，诸如parcel、webpack等都是时下流行的优秀的打包工具。 模块打包，通俗地说就是：找出模块之间的依赖关系，按照一定的规则把这些模块组织合并为一个JavaScript文件。 Webp…"}, {"id": "6915659426850570253", "title": "webpack搭建React项目（7）", "desc": "安装@types的类型声明包。当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能，声明文件是以index.d.ts的一个文件，一般放在项目的根目录中，或者可以通过package.json中的typings/types属性来指定项目中声明文件的位置…"}, {"id": "6844903506361450504", "title": "webpack配置之后端渲染", "desc": "2017年, vue, react, angular 已经占据前端的主流, 不得不承认这也是前端的未来发展方向. 但是后端渲染的开发方式仍然很常见, 不管是个人项目还是商业项目, 后端渲染搞起来真是糙猛快. 但是借着前端发展的东风, 后端渲染也有很大的改进空间. 这里就介绍一下…"}, {"id": "6844903570668519431", "title": "追溯 React Hot Loader 的实现", "desc": "如果你使用 React ，你可以在各个工程里面看到 Dan Abramov 的身影。他于 2015 年加入 facebook，是 React Hot Loader 、React Transform、redux-thunk、redux-devtools 等等的开发者。同样也是 R…"}, {"id": "6844903509360394247", "title": "在线追踪压缩后的JS出错代码", "desc": "深入了解sourcemap映射原理前，最好读一下阮老师的文章《JavaScript Source Map 详解》。 读完之后，我们就大致了解了sourcemap的几个概念，接下来我们具体分析一下 1. sourcemap文件结构 2. 分析位置 3. 记录完整的映射关系 根据不…"}, {"id": "6844903504784572423", "title": "从零开始基于vue2 webpack3构建多页应用", "desc": "序：基于vue2和webpack3进行的多页面应用构建，github地址：https://github.com/FedWithMori/vue2-webpack3。 任何一个项目开始构建之前最先要做的就是先确定我们项目的目录结构，包括开发目录和生产目录。 1. 开发目录 2. …"}, {"id": "6963295568722395150", "title": "webpack核心理念浅析", "desc": "webpack核心理念浅析 这段时间在琢磨自己手写一个构建工具，不过在这之前，我们先试着梳理一下webpack的理念，毕竟它山之石可以攻玉，有助于我们想好该如何设计自己的项目。 简介 这是关于webp"}, {"id": "6844904142033387528", "title": "从零开始学webpack：进阶配置", "desc": "mocker-api是一个为 REST API 创建mock的webpack-dev-server中间件。在后端服务还没有完成的时候，可以通过这个中间件进行mock数据 DefinePlugin的键值都是一个标志符或者多个用 . 连接起来的标志符"}, {"id": "6898645158963707917", "title": "webpack|透过webpack打包文件看模块化", "desc": "最后，__webpack__require__函数返回module.exports，这样，导入方也就拿到了依赖模块的导出值。 定义取值函数n，功能，根据模块导出值类型去区分取值，commonJS则返回export本身，es模块则返回export的default。"}, {"id": "6898908682533208072", "title": "编写一个 Webpack Loader", "desc": "webpack 只能理解 JavaScript 和 JSON 语言。loader 可以让 webpack 能够去处理其他类型的文件语言，并将它们转换为webpack所能识别的模块，以供应用程序使用"}, {"id": "6844903574086909965", "title": "webpack的进阶用法(一)", "desc": "由于每次构建项目前并不会自动的清理目录，会造成输出文件越来越多。这时 我们就得手动清理输出目录的文件的麻烦。 一般情况下也可以通过npm scripts设置命令行的方式进行构建目录的清理。 插件的形式清除构建目录，默认会执行删除output值得的输出目录。 Trident和Op…"}, {"id": "6844903828458848263", "title": "webpack基本使用", "desc": "4. 转换es6语法以及校验 5. 全局变量引入的问题(以jquery为例)"}, {"id": "6844904176875470862", "title": "webpack的学习记录(ing)", "desc": "一步一步学习webpack,以此作为学习记录。一次小功能配置提交一次git。 动手敲一遍，过一遍文档印象会更加深刻。 2.使用clean-webpack-plugin插件，可以在每次打包时候清理dist目录。 PostCSS是一种插件系统。使用PostCSS 可以写未来的css…"}, {"id": "6844903548832972807", "title": "webpack对于公共资源的提炼之webpack.optimize.CommonsChunkPlugin", "desc": "vue-cli打包，使用了两次CommonsChunkPlugin,对于因此生成的两个js文件的作用分析"}, {"id": "6844904182533603335", "title": "Webpack(系列三)：热模块更新和使用 Babel处理 ES6语法", "desc": "2. 对于自己开发的第三方模块或者ui组件库时，另一种方式更加合理，不会污染全局变量"}, {"id": "6844903556336582670", "title": "配置webpack实现移动端项目手机同步预览", "desc": " "}, {"id": "6844903554281390087", "title": "开发一个webapck v3 的 loader", "desc": "有时候，市面上的webpack loader并不完全符合我们的需求，所以，我们不得不自己从0开始写一个，或者是在别人写的loader基础之上进行修改。 无论哪种，都需要我们对webpack加载loader的方式有所了解。 说点题外话，不知道为什么webpack官网对loader…"}, {"id": "6903036493385334798", "title": "webpack入门学习 --Halo", "desc": "之前一直不理解webpack和vue-cli什么关系，看了webpack文档发现，vue-cli就是帮你配置webpack，配置一个跟vue相结合的配置，如果webpack学的很好，那你甚至可以自己‘vue-cli’一个项目。 npm init还有一种npm init -y这个…"}, {"id": "6844903570706268168", "title": "Library项目的Webpack配置", "desc": "知乎上有个提问，叫“如何成为高级Webpack配置工程师”，戏谑Webpack已经复杂到成为一门专业学问了。但Webpack确实是非常复杂的，一般人只能做到入门而无法精通。Webpack的复杂性在于要完成各种各样的功能，即不仅要处理js、css、html、图片、字体等各种格式的…"}, {"id": "6844903561348775944", "title": "用一个hello world项目学习webpack", "desc": "即webpack打包的入口js文件，可以根据项目实际情况配置成但入口或者多入口,webpack会根据入口文件内的引入的文件绘制依赖图，将该模块和模块对应的依赖都打包到一个文件中。 即webpack打包后的输出，即使此时的entry中存在多个入口，也只提供单一的输出配置。 web…"}, {"id": "6844903856954949645", "title": "03-webpack核心概念", "desc": "本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个…"}, {"id": "6844903861539307528", "title": "从负一开始构建一个基于webpack4的项目", "desc": "项目目录下多了个package.json，里面记录了项目相关的信息。 命令完成后，项目中多了一个 node_modules文件夹，该文件夹是用来存放项目中安装的依赖包，以后项目依赖的包也都会在里面。 长征才刚刚开始... webpack只认识js，图标、字体、css等其他的就需…"}, {"id": "6844903576528125966", "title": "一些运用webpack的方法或者说策略", "desc": "运行npm install --save-dev extract-text-webpack-plugin安装抽取CSS文件的插件。 运行cnpm i optimize-css-assets-webpack-plugin --save-dev安装插件到开发依赖。 服务员，打包一个…"}, {"id": "6844903856980099085", "title": "【新手向】如何写一个超超超简单的 webpack?", "desc": "一. 准备活动 首先创建两个项目，一个叫 webpack-project，另一个叫 mn-webpack 。前者用于观察打包结果，后者用于简单实现 webpack。 项目建立好之后，首先进入到 webpack-project 中，新建一个 src 文件夹和webpack.con…"}, {"id": "6844903866010435591", "title": "webpack入门学习笔记02 —— 初始化一个webpack项目", "desc": "1. 写在前面 现在我们就开始正式学习 webpack 了，webpack是帮助我们打包编译项目的，所以在正式开始之前，我们需要初始化一个基于webpack的项目。 2. 初始化一个基于webpack的项目 这一步简单，我们可以使用 npm 或者 yarn 包管理工具来帮助我们…"}, {"id": "6844903972336041991", "title": "徒手撸一个简单的React开发环境", "desc": "如今，前端工程化越来越成熟，也涌现出越来越多的高效工具让开发变得简单，我们可以更加专注于业务层面，我们可以通过脚手架轻松搭建一个功能完善的React开发环境，但是在这样的“方便”下，我们越来越忽视了Webpack和babel的重要性，本文只是记录通过Webpack和Babel搭…"}, {"id": "6897387132952772616", "title": "webpack基础配置", "desc": "💎我这里安装的是webpack 3.x.x，配置过程中发现不同版本的webpack配置方式区别挺大的... webpack --config config_filename 指定使用特定的配置文件进行webpack打包，比如开发环境、生产环境各自的打包配置文件。 如果配置创建…"}, {"id": "6844904190901256200", "title": "webpack4核心模块tapable源码解析", "desc": "webpack打包是一种事件流的机制，它的原理是将各个插件串联起来，那么实现这一切的核心就是我们要讲解的tapable. 并且在webpack中负责编译的Compiler和负责创建bundles的Compilation都是tapable构造函数的实列 基于 \"webpack\":…"}, {"id": "6844903539966214158", "title": "将typescript+react的webpack项目迁移到parcel", "desc": "Parcel, 是一个网络应用打包工具, 适用于经验不同的开发者. 它利用多核处理提供了极快的速度, 并且不需要任何配置. 对于现阶段来说, 对已有的成熟的webpack项目, 玩一下还是可以的, 但是不建议公司项目迁移, 坑必须还是很多的. 不过现在新开了一个issue, 利…"}, {"id": "6844903822058323975", "title": "webpack4打包工具", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 …"}, {"id": "7007053787290402830", "title": "前端闲聊系列（1）：打包器的开发环境和library打包", "desc": "现在开启一个新的系列，主要是对前端常见的知识点从较高层次谈一下理解，不会过多深究细节。 概览 根据打包使用场景的区分，环境可以分为开发环境和生产环境，在各个环境的我们想达到的目的不一样，因此要做的事也"}, {"id": "7007342178695381028", "title": "webpack插件使用记录", "desc": "记录几个平时自己使用的webpack插件 webpack-bundle-analyzer、 progress-bar-webpack-plugin、webpack-build-notifier"}, {"id": "7007715351932698655", "title": "webpack-bootstrap解析", "desc": "1. 整体结构：立即执行函数 2. 立即执行函数的实参部分：{} 以文件相对于根目录的路径为key，文件内容为value value都是匿名的函数表达式，该函数会接受三个参数 ⁉️ module, e"}, {"id": "7005001569879982087", "title": "前端脚手架 webpack 迁移 Vite2 踩坑实践", "desc": "项目背景 首先介绍一下我的个人开源项目 X-BUILD ，是一款前端脚手架，从2017年2月至今已有4年多的时间，目前我正在针对 vue3 做一套全新的版本，全面使用 Vite 作为构建工具，在这个过"}, {"id": "7004856581233836040", "title": "跟着官方文档学习webpack", "desc": "前言 webpack在日常开发中常常会用到，但在开发中只是了解一些基本配置，并没有深入的去学习每个插件的作用是什么。这次读取了一遍webpack的文档，写下这篇文章也是对自己学习内容的一个梳理过程。 "}, {"id": "6999943217265246244", "title": "关于 webpack 的一些优化方案", "desc": "在开发环境和生产环境中，这两个环境下构建的目标存在很大差异，在开发环境中，我们需要的是强大的`source map`、实时加载、热更新等能力的配置。..."}, {"id": "6991774994552324133", "title": "学习 Webpack5 之路（实践篇）", "desc": "本篇将从实践出发，在第一章节《基础配置》中使用 webpack 搭建一个基础的支持模块化开发的项目，在第二章节《进阶配置》中使用 webpack 搭建一个 SASS + TS + React 的项目。"}, {"id": "6989973871663251487", "title": "基于 vue3 + webpack 5 + sass+ vw 适配方案+axios 封装，从0构建手机端模板脚手架", "desc": "Webpack5正式发布也有很长长长一段时间了,上手了一段时候后发现真香。webpack5的新特性使得我们在配置上比以往版本更加方便了，构建速度也有了质的飞跃。本文着重为大家讲解从 0 到 1 搭建 "}, {"id": "7007068354800254983", "title": "读一读 Webpack 中的模块化产物", "desc": "随着 ECMA Script 的发展， 浏览器以及Node.js 对于 ES Module（以下简称 ESM） 的原生支持，不管是在 Node.js 服务端编写接口 APi，还是在浏览器端编写脚"}, {"id": "6996665311260835854", "title": "webpack快速入门教程", "desc": "webpack快速入门教程 1、了解Webpack相关 什么是webpack Webpack是一个模块打包器(bundler)。 在Webpack看来, 前端的所有资源文件(js/json/css/i"}, {"id": "6844903673009553416", "title": "2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文", "desc": "文章涉及的内容可能不全面，但量很多，需要慢慢看。来源于各个地方，我花了很长的时间整理，希望对大家有帮助。但是难免会有打字的错误或理解的错误，希望发现的可以邮箱告诉我236490794@qq.com，我会及时的进行修改，旨在能帮到大家，谢谢。 意义：根据内容的结构化（内容语义化）…"}, {"id": "7004618095775973390", "title": "手摸手带你写一个简易版的webpack", "desc": "大家好,我是作曲家种太阳 之前对webpack了解的只限于表面,业务项目中用到了配置再去网上去搜索用法, 虽然能勉强应付的过去,但是对webpack内部的运行机制并谈不上透彻,直到最近开始系统学习,才"}, {"id": "7004377706653564935", "title": "vite vs webpack vs esbuild", "desc": "本篇文章分享下题目中三种打包工具在开发和生产模式中的实际使用感受，希望能对你有所帮助。我使用的技术栈是react+typescript+express，开发模式使用打包工具自带的开发服务器，生产模式使"}, {"id": "7005755090552225805", "title": "90行代码实现模块打包器", "desc": "大家好，我卡颂。 今天来聊聊如何用90行代码实现一个现代JS模块打包器。 我们的打包器虽然迷你，但是实现了webpack的核心功能。 而且，我知道你看到大段代码头疼，所以这篇文章都是图。看完感兴趣的话"}, {"id": "6844904094281236487", "title": "「吐血整理」再来一打Webpack面试题", "desc": "本文已收录在Github github.com/Geekhyt，欢迎Star。 从头发的浓密程度和干练的走路姿势我察觉到，面前坐着的这位面试官也是一把好手。我像以往一样，准备花3分钟的时间进行自我介绍。在此期间，我的目光被16寸的MacBook Pro所吸引，这次的自我介绍我做…"}, {"id": "7004710821318115336", "title": "从0开始搭建一个可用的vue3-webpack5-template（一）", "desc": "最近对知识点查漏补缺，发现对工程化这一块掌握的不太好，之前的项目又都是基于vue-cli搭建的，所以打算用webpack5手动搭建一套vue3的开发环境。"}, {"id": "7006675512290443295", "title": "用 webpack-chain 来配置 webpack5", "desc": "缘由 webpack 虽然不陌生，但实际配置起来，相信大部分人并没有觉得多轻松。以前在使用 umi 框架时，接触了一点 webpack-chain，感觉很不错的样子。最近想试试 webpack5 的模"}, {"id": "7002362205396008991", "title": "2021前端面试知识点总结之webpack篇", "desc": "webpack是什么？ 是一个用于现代javaScript应用程序的 静态模块打包工具。 当webpack处理应用程序时，会在内部构建一个依赖图，此依赖图对应影射到项目的每个模块，并声称一个或者多个b"}, {"id": "7007428801739096078", "title": "写篇文章让自己学会webpack——（2）关于webpack配置", "desc": "直接说明：安装webpack后你是找不到（新手）配置文件，官方设置的默认配置文件webpack.config.js。所以你vue-cli创建项目更是看不到。 找不到配置文件没关系，我们先记住名字web"}, {"id": "6994346951739179039", "title": "万字长文，带你从零学习Webpack", "desc": "一直以为，我的Webpack就是复制粘贴的水平，而对Webpack的知识真的很模糊，甚至是纯小白。所以前段时间开始对Webpack进行比较系统的学习。 学习完成后，我抽空整理了笔记，前前后后也花了一周"}, {"id": "6911170146526560263", "title": "webpack中object-defineproperty-ie8的使用，处理ie8兼容性", "desc": "按理说webpack5也可以使用的，大家可以试试不用使用：直接将这段代码粘贴到你html模版里面截图"}, {"id": "6844903520924073997", "title": "基于gulp+webpack 快速搭建的前端自动化脚手架", "desc": "适用于中小型项目，快速构建前端项目框架。比如运营活动页，官网类，简单移动端项目，小demo测试等"}, {"id": "6844903966912806926", "title": "从零配置webpack 4+react脚手架（三）", "desc": "这一节我们将在脚手架中引入CSS，SASS，LESS，并且实现代码压缩，以及PostCSS的使用。 wbpack只能编译js文件，css文件是无法被识别并编译的，我们需要loader加载器来进行预处理。 遇到后缀为.css的文件，webpack先用css-loader加载器去解…"}, {"id": "6844903552574324744", "title": "webpack开发和生产两个环境的配置详解", "desc": "目录webpack.base.conf.jswebpack.dev.conf.jswebpack.prod.conf.js一开始在接触webpack的时候，简直痛不欲生，现在回头看，做个注释，当然参考"}, {"id": "6844904138996727822", "title": "Webpack 实战入门系列（三）：生产配置、样式文件分离及输出清理", "desc": "现在vue、react很流行，新项目基本用这些新框架，组件化开发确实是趋势，但是他们再怎么发展也离不开构建工具，顶多在webpack等工具上进行再封装。现在vuecli3出来后，我感觉学习成本反而变高了，直观感觉就是文档不清爽，知识零碎。其实回到本源，vuecli3就是基于we…"}, {"id": "6844903830392569864", "title": "一步步使用 webpack 第五篇：使用 webpack 编译 TypeScript 代码", "desc": "上一篇文章中，使用 webpack 完成了 vue 代码的编译 。接下来在 vue 单文件组件的基础上，将 js 升级为 ts ，使用 webpack 编译 TypeScript 代码。 本文的目的是：完成 .ts 文件以及 vue 单文件页面中 TypeScript 代码的编…"}, {"id": "6844903607532257294", "title": "webpack（2）——配置项详解", "desc": "... 1. mode mode 配置项是 webpack4 新增的配置项，这个配置项是必须的。 当人对于初学者来说，对于 webpack 的优化还有一段距离，首先我们大体了解一下即可。 它还有很多其他的优化默认值，但是效果可能并不美好，因为它针对的某些特定的大型项目，而我们只…"}, {"id": "6844903620786257934", "title": "[实用] 如何配置 iview 调试环境", "desc": "1. 在开发环境中使用源码 从 package.json 文件来看，入口指向：dist/iview.js。 这是我们日常使用的 iview 代码，单纯从调用的角度来说，这完全没有问题，还省性能；但作为调试就稍显麻烦，想找个组件的源码都麻烦。 2. 使用 babel-loader…"}, {"id": "6922632582270025742", "title": "webpack系列学习-详细的实现简易webpack", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 生成AST树，需要借助babylon，先安装下。 现在getAST方法写好了，我们来测试下。在lib目录下创建test.js 进行依赖分析，需要借助babel-…"}, {"id": "6844903593015771143", "title": "从0搭建一个Weex项目", "desc": "然后在根目录下新建index.html文件。 entry文件夹是webpack打包的入口，page文件夹是各个.vue页面。 weex最常见的使用场景就是编写某一个页面而不是整个APP，即开发一个一个的页面，然后把这个页面放到native端呈现。所以我们的weex-starte…"}, {"id": "6844903998705664008", "title": "webpack 4: 代码拆分、代码块关系图及优化插件splitChunks", "desc": "webpack4 对 chunk graph(代码块关系网格) 进行了一些重大改进并用新的优化策略实现了 chunk spliting（对CommonsChunkPlugin的一种改进）。 我们看下老 chunk graph 的一些缺点。 在老的 chunk graph 中，c…"}, {"id": "6844903778068463630", "title": " Webpack学习－工作原理（上）", "desc": "对于webpack的认识始终停留在对脚手架的使用，不得不说脚手架既方便又好用，修改起来也方便，只需要知道webpack中各个配置项的功能，于是对于我们来说，webpack始终就是一个黑盒子，我们完全不清楚里面是如何去运作的。打包时报错，就只能借助google来协助帮忙解决问题，…"}, {"id": "6844903961552486408", "title": "到底什么是PostCSS【译】", "desc": "我最近在一些工作流当中采用了PostCSS —— Meteor工作流、简单的React和Webpack工作流。我知道我必须得去使用它，因为所有人都很兴奋地去用，而且它也确实从没让我失望过。你将会看到一些我还没不太知道PostCSS是什么之前的一些想法。 我尽力一条条阐述清楚。这…"}, {"id": "6844904136517877767", "title": "编写一个简易webpack", "desc": "借鉴他的思路，我们也可以很快写出来一个简单的 webpack，首先 (function(modules) {...}) 内部的代码基本上可以写死，也就是我们等会需要写的 init.js，接着看，这是一个自执行的函数， 传入的是一个对象，首先执行的是主入口的文件，然后再分别去找他…"}, {"id": "6844903989293613070", "title": "vue2+webpack4搭建项目", "desc": "（css-loader：加载由 vue-loader 提取出的 CSS 代码。 ） 后缀为.vue 文件是不可以在浏览器里直接运行的，我们得让它运行起来。 现在我们要在项目根目录下新建一个webpack.config.js文件，webpack（号称打包一切）它做的事情是，分析你…"}, {"id": "6923014755103801351", "title": "通过webpack偷偷搞点事情", "desc": "前言：随着项目的迭代，项目的代码量越来越大，客户端访问速度越来慢，此时webpack在优化打包体积和配合浏览器进行资源缓存上起到很大作用。 众所周知webpack打包最终会通过output输出到指定目录下指定的文件名filename，如果filename写死成某个文件名，例如i…"}, {"id": "6844903794594021390", "title": "Webpack系列-第三篇流程杂记", "desc": "入口处在bulid.js,可以看到其中的代码是先实例化webpack，然后调用compiler的run方法。 可以看出options保存的就是本次webpack的一些配置参数，而其中的plugins属性则是webpack中最重要的插件。 调用run时，会先在内部触发before…"}, {"id": "6844903496894906381", "title": "为什么我们要做三份 Webpack 配置文件", "desc": "在知乎上我们常常会看到有同学发问：BAT等大型网站的前端工程是如何组织管理的？这的确是一个可以发散的很广的Q&A，我想如果要我回答这个问题，不如先从Webpack配置说起。时至今日，Webpack已经"}, {"id": "6844904070705053703", "title": "做一个 “Webpack 配置工程师”", "desc": "Webpack 是一个模块打包工具。 因为浏览器并不支持 JS 的模块化导入。这时候 Webpack 便派上用场了。 上面的例子中，我们可以将 test.js 和 index.js 打包成一个文件 main.js ，然后在 index.html 引入 main.js。 📦 W…"}, {"id": "6915658828268863502", "title": "webpack搭建React项目（6）", "desc": "使用resolve.extensions可以配置文件的默认后缀名，默认是['.wasm', '.mjs', '.js', '.json']。当省略文件后缀名时，webpack 会尝试对文件名依次添加后缀名并解析，如果找到相关后缀的文件就停止解析。例如import \"./data…"}, {"id": "6844903620991811592", "title": "【CSS模块化之路2】webpack中的Local Scope", "desc": "CSS是一门几十分钟就能入门，但是却需要很长的时间才能掌握好的语言。它有着它自身的一些复杂性与局限性。其中非常重要的一点就是，本身不具备真正的模块化能力。 1. 面临的问题 你可能会说，CSS有@import功能。然而，我们都知道，这里的@import仅仅是表示引入相应的CSS…"}, {"id": "6844903919793995790", "title": "Webpack3 代码分割 CommonsChunkPlugin", "desc": "hello ~ 亲爱的看官老爷们大家好 ~ 最近一直在学习 webpack 的相关知识。曾几何时我总觉得 webpack 的体系庞大而难以掌握，一直回避不愿去学。然而伟人鲁迅曾说过： 世上太多事会因无法掌握而使你狂躁不安，最好的解决方法就是硬着头皮开始做！ 因而就从比较简单的 …"}, {"id": "6844903630340882446", "title": "webpack多页面构建优化不完全指北", "desc": "自从新项目的技术栈启用vue以后，项目的构建工具也自然而然的从原来的内部的工具切换成了webpack，在感受到HMR，各式各样loader的强大后，也随着项目的逐渐变大，依赖的模块越来越多，webpack的构建效率成为了制约团队开发效率的短板。因此，我们来介绍一下多页面下，我们…"}, {"id": "6844903600611819534", "title": "用whistle实现map local", "desc": "路径匹配会匹配该路径及其子路径的url，并把超出的路径自动补齐到本地指定的文件路径，如配置规则 www.test.com/abc E:\\workspace\\test 后，请求 http://www.test.com/abc，https://www.test.com/abc/in…"}, {"id": "6933130887517356040", "title": "webpack4.0笔记", "desc": "Ⅰ. 开发环境配置 1. 安装依赖 2. module的use数组里面loader执行顺序 3. 处理 css文件 4. 处理scss/less文件 5. 处理html资源 6. 打包图片资源 7. 打包其他资源 8. 开发服务器devServer 9. 各种打包报错 报错 2…"}, {"id": "6900095458409414669", "title": "webrpack之 tapable", "desc": "SyncBailHook就是根据每一步返回的值来决定要不要继续往下走，如果return了一个非undefined的值 那就不会往下走，注意 如果什么都不return 也相当于return了一个undefined。 它的每一步都依赖上一步的执行结果，也就是上一步return的值就…"}, {"id": "6942111447098851342", "title": "webpack4基础总结", "desc": "webpack是什么 Webpack可以看做是模块打包机：它做的事情是，分析你的项⽬结构，找到JavaScript模块以及其它的⼀些浏览器不能直接运⾏的拓展语⾔（Scss，TypeScript等），并"}, {"id": "6844903670291628039", "title": "webpack4+vue2+vuex+rue-router+axios的多页+单页混合应用框架", "desc": "一个集 多页应用 + 单页应用 的混合项目框架。 适用于主要入口页面生成多页，子页面和次要页面使用单页形式的项目。 ES6+ Vue2.0 Vuex Vue-Router Axios Webpack4 npm模块(vue、vuex之类)打包成一个单独的js文件 公共组件和公共函…"}, {"id": "6844903622275252231", "title": "笔记：配合 Vue.js 配置 Webpack（一）Vue.js，Webpack 和 Webapck Dev Server 的基本配置", "desc": "把自己博客上访问最高的一篇内容重写了一遍，为 Webpack 4.12.0 和 Vuejs 2.5.16 做了更新。手动从 npm 新建项目开始，一直到配合 Webpack 完成 Vue.js 的热重载（HMR）结束，比 2016 年时候写的原文更长了点..."}, {"id": "6844903630034698254", "title": "webpack 快速构建 React 学习环境（2）-- 热更新", "desc": "上一篇文章 《webpack 快速构建 React 学习环境（1）》中介绍了构建一个最简单开发环境，这里接着完善这个开发环境，让它用起来更加的趁手。 上一节搭建的开发环境不能热加载，每次文件改动后都需要重新编译，手动刷新页面。虽然使用 webpack --watch 命令在文件…"}, {"id": "6844903601530224647", "title": "我很懒,什么都没留下系列 之 教你上手React服务端渲染（React SSR）&& HMR", "desc": "网上关于React的SSR也很多，但都不够详细，有的甚至让初学者一头雾水。不过这篇文章我将一步步详细的介绍，从0开始配置React SSR，让每个看到文章的人都能上手。 接下来，我们先来看看wepack-dev-server 以及 模块热替换(Hot Module Replac…"}, {"id": "6951419496254930958", "title": "Tapable部分hook源码实现分析", "desc": "介绍Webpack如何和各个插件配合实现打包的？主要就是借助于 tapable 这个库。下面我参考 tapable 的源码，简单实现其中的部分 hook.SyncHook 同步勾子使用示例源码实现抽象"}, {"id": "6858070409678585870", "title": "如何开发 Webpack loader", "desc": "前言webpack能把左侧各种类型的文件（webpack把它们叫作「模块」）统一打包为右边被通用浏览器支持的文件什么是Loader？所谓loader只是一个导出为函数的JavaScript模块，是集成"}, {"id": "6844903541480357895", "title": "vue-cli之webpack3构建全面提速优化", "desc": "本文希望能在耗时优化与构建性能提升之间做一个平衡，即花最少的时间，对官方模板做最少的修改下，赚取最大的构建性能提升！"}, {"id": "6844903751522746381", "title": "[ webpack4 ] 配置属于自己的打包系统教程（一）—— 基础配置篇", "desc": "这里的init表示初始化一个 npm 项目， -y 表示全部选 yes，不加的话会提示输入一些项目信息，比如项目名，版本号，作者... 官方推荐移除文件中的入口配置，这样可以防止意外发布你的代码。 在 webpack 4 中，可以无须任何配置使用，做完上边的操作后可以在命令行输…"}, {"id": "6844903512183144462", "title": "最新vue-cli 2.9.1的webpack存在问题", "desc": "由此可知 在最新版本的vue-cli中webpack版本更新到v3.6.0了。 既然更新了 那就我们就重新开下webpack的配置项。 这里的autoOpenBrowser对应false ,既然我们要改动那就直接改为true就可以。然后在重启下服务 就可以自启动服务了 其中的p…"}, {"id": "6844903873295941645", "title": "webpack入门学习笔记05 —— 使用webpack打包编译css文件", "desc": "1. 写在前面 在前面的博客中，对webpack打包项目进行了简单介绍，而且都是关于打包编译 .js 文件的介绍。我们知道在一个基于webpack的项目中，肯定不止是 .js 文件，还有 .html 、.css、.png 等文件，在后面的博客中会给大家一一讲述，在这篇博客中，我…"}, {"id": "6844903858817204237", "title": "基于 Webpack4 的可插拔式微前端架构 - Puzzle", "desc": "Puzzle 是基于 Vue 和 Webpack4 实现的一种项目结构；业务模块可以像拼图一样与架构模块组合，形成不同的系统，而这一切都是可以在生产环境热插拔的；这意味着你可以随时向你的系统添加新的功能模块，甚至改版整个系统，而不需要全量替换整个项目。 此外当多个项目使用此架构…"}, {"id": "6960950266581647390", "title": "webpack 核心概念及默认配置", "desc": "webpack webpack 核心概念 entry bundle: 经过Webpack 流程解析编译后最终输出的⽂件 output loader plugins mode webpack 默认配置 "}, {"id": "6844903879713226759", "title": "webpack入门(2) - 安装，配置，环境搭建", "desc": "npm init 初始化一个文件夹,出现对话框按确定就行。 npm install --global webpack 全局安装，在c盘下会生成node_modules文件夹中会包含webpack。请注意，这不是推荐的做法。全局安装会将您锁定到特定版本的webpack，并且在使用…"}, {"id": "6844903586384576520", "title": "小马的大前端之路——Node.js初探", "desc": "夜已深，愚人节有没有对中意的女生表白啊。哈哈。。。 小编在这里先祝福大家。 这个周末，本来想把最近还没有整理的几篇文章这里好发给大家的。无奈小编周末有点晕，还没整理好。可能是周六晚上烤串吃多了。 最近有一篇是关于module（模块化） & babel的文章不过还没整理出来。那先…"}, {"id": "6992524978759401508", "title": "Webpack配置-常用Plugin", "desc": "初识Plugin CleanWebpackPlugin 如果没有安装任何插件的情况下如果我们执行 build指令必须手动删除上一次打包的资源，如果不删除上一次打包的资源文件有可能被遗留下来（比如上一次"}, {"id": "6983901110058614815", "title": "2021年必须要掌握的webpack5最佳配置", "desc": "2021年啦，对webpack构建还是cli一揽子计划（啥也不懂），结合官网，决定系统性的学习一下webpack，了解一下webpack之美（生活所迫）"}, {"id": "6850418111599165448", "title": "揭秘webpack按需加载原理", "desc": "当页面中一个文件过大并且还不一定用到的时候，我们希望在使用到的时才开始加载，这就是按需加载。要实现按需加载，我们一般想到的方法：动态创建script标签，并将src属性指向对应的文件路径。但是在实现过程中，存在下面问题： ​ webpcak 的按需加载已经完美解决了上述问题…"}, {"id": "6937125495439900685", "title": "Webpack 案例 —— vue-loader 原理分析", "desc": "OK，如果你不是特别清楚，那接着往下看吧，下面我们会拆开vue-loader的代码，看看SFC内容具体是怎么流转转换，顺便还能学学 webpack loader 的编写套路。 如代码第16行，定义pitcher对象，指定loader路径为 require.resolve('./…"}, {"id": "6927569428984889357", "title": "webpack学习系列(二):  module federation", "desc": "最近，项目组在针对原来的老项目做技术栈升级工作，升级的主要内容是 react 和 antd。经过讨论，最后采取的技术方案是使用 qiankun。具体实施方案为先基于 qiankun 构建一个主应用，然后再部署一个新的子应用，新的子应用使用最新版本的 react、antd 逐步重…"}, {"id": "7000141573480513550", "title": "深入 Webpack5 等构建工具系列二(10) - postcss-preset-env 和配置抽取", "desc": "这是我参与8月更文挑战的第23天，活动详情查看：8月更文挑战 上篇文章我们讲到了 postcss-loader，可以通过它在 webpack 中使用 postcss，然后再借助 autoprefixe"}, {"id": "6939794845053485093", "title": "webpack核心模块tapable用法解析", "desc": "前不久写了一篇webpack基本原理和AST用法的文章，本来想接着写webpack plugin的原理的，但是发现webpack plugin高度依赖tapable这个库，不清楚tapable而直接去看webpack plugin始终有点雾里看花的意思。所以就先去看了下tapa…"}, {"id": "6950115473480482852", "title": "微前端比你想象的要简单", "desc": "webapck5 module federation 简单的方式实现强大微前端架构！跨应用跨技术栈实现共享资源不再是难事！"}, {"id": "6844903545922158599", "title": "webpack多入口文件页面打包配置", "desc": "大多数情况下，我们使用 webpack来打包单页应用程序，这个时候只需要配置一个入口，一个模板文件，但也不尽是如此，有时候也会碰到多页面的项目，而且以我的经验来看，这种情况出现的频率还不低，例如项目比较大，无法进行全局的把握，或者项目需要多次的更新迭代等，都适合做成多页面程序，…"}, {"id": "6983565413833506852", "title": "webpack 通用配置及构建速度，体积优化", "desc": "webpack基本配置，修改代码，自动编译，热更新，文件指纹，代码压缩，webpack 通用配置及构建速度，体积优化，多页面应用，source map 定位源代码，webpack打包组件库，"}, {"id": "6971987696029794312", "title": "webpack中fullhash、chunkhash和contenthash的区别", "desc": "hash通常被作为前端静态资源实现增量更新的方案，通过在文件名中带上一串hash字符串，告诉浏览器该文件是否发生更新，从而决定是否要使用缓存机制。 webpack打包时的hash有三种：fullhas"}, {"id": "6999205780922744846", "title": "一文了解webpcak在Vue中的使用", "desc": "一，认识webpack Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个"}, {"id": "6844903908670717960", "title": "[译] 愿未来没有 Webpack", "desc": "现在是 1941 年。你的名字是 Richard Hubbell。你在 CBS 旗下的一个试验性的纽约电视演播室工作。你将要主持一场重大电视新闻广播，这是世界上首批电视节目之一，你还有 15 分钟就要上场了。你知道你一会儿要干嘛吗？ 在一个人们只知道收音机的世界里，你会坚信你的…"}, {"id": "6844904200539766797", "title": "图解 webpack（模块化 - CommonJS）", "desc": "在前面一篇文章中 《模块化系列》彻底理清 AMD,CommonJS,CMD,UMD,ES6，我们可以学到了各种模块化的机制。那么接下里我们就来分析一下 webpack 的模块化机制。（主要讲 JS 部分） 提到 webpack，可以说是与我们的开发工程非常密切的工具，不管是日常…"}, {"id": "6844903895584473096", "title": "Webpack tapable 使用研究", "desc": "想研究一下Webpack运行原理，发现都提到了tapable，搞得我云里雾里，那我们就好好研究一番，这到底是个啥库。 可以看到run函数是AsyncSeriesHook类型的钩子函数，这个就是tapable提供的钩子类型了。 想理解Webpack的运行流程，先要了解这个钩子的使…"}, {"id": "6844904162405138445", "title": "霖呆呆的六个自定义Webpack插件详解-自定义plugin篇(3)", "desc": "你盼世界，我盼望你无bug。Hello 大家好！我是霖呆呆！ 有很多小伙伴在打算学写一个webpack插件的时候，就被官网上那一长条一长条的API给吓到了，亦或者翻阅了几篇文章之后但还是不知道从何下手。 而呆呆认为，当你了解了整个插件的创建方式以及执行机制之后，那些个长条的AP…"}, {"id": "6997620603758837797", "title": "深入 Webpack5 等构建工具系列二(3) - webpack 的依赖关系图", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 接上一篇文章，下面我们再来讲一个理论上的东西。 首先，上图： 这是当前项目的目录结构，以及 src 目录下 main.js 文件（目前已被"}, {"id": "6995098632147959815", "title": "前端面试题之——webpack会问到的点", "desc": "大家好，这是一个小白前端的更文挑战。（写错的各位看官包容） 这是我参与8月更文挑战的第1天，活动详情查看：8月更文挑战。"}, {"id": "6994043282699337765", "title": "Webpack 4 项目常用的优化技巧 —— 附上demo", "desc": "文章主要说一下不同环境的区分和一些可以优化的点，多线程、sourceMap、js压缩、提取css、css压缩、多线程、目录清理"}, {"id": "6997991538131206174", "title": "深入 Webpack5 等构建工具系列二(4) - webpack 中 css-loader 的使用和 Rule 配置规则", "desc": "这是我参与8月更文挑战的第17天，活动详情查看：8月更文挑战 接上一篇文章，下面，我们来编写一个案例代码（本案例是在官方文档案例的基础上修改而来）。 创建一个 component.js 文件 通过 J"}, {"id": "6946231743837896734", "title": "详细解读 Webpack 的模块热替换功能", "desc": "在开发 JavaScript 应用程序时，每次我们保存代码更改后，我们都需要重新加载浏览器以刷新用户界面。 像 Webpack 之类的开发者工具可以通过监视模式来监听项目文件的更改。一旦检测到更改，Webpack 就会自动地重新构建应用程序并重新加载浏览器。 我们正在使用的所有…"}, {"id": "6989788448605339656", "title": "《乘风破浪学webpack(二)》", "desc": "续《乘风破浪学webpack》 用一张图总结上篇webpack的内容： 代码仓库地址： https://github.com/dandanloveJM/webpack-demo-1 一、loader和"}, {"id": "6934209878005284871", "title": "Webpack入门配置指南", "desc": "let / const/箭头函数/... / new / class / Promise 进入之前，了解一些工具。 分别是用webpack 转译JS，理解hash的用途，生成HTML， 引入CSS，引入scss，引入less和stylus，引入图片，实现懒加载，点击可到对应模块…"}, {"id": "6868538920796340237", "title": "「Webpack 基础」CSS  loader配置解读", "desc": "作为一个前端开发，离不开webpack打包。webpack 内容比较多，本篇主要对常用的 CSS 相关的 loader 进行系统解读。 在使用webpack打包的时候，需要使用一堆跟css相关的loa"}, {"id": "6990556205336756238", "title": "Webpack 简介和初体验", "desc": "一、Webpack 简介 1.1 webpack 是什么 webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。在webpack 看来, 前端的所有资源文件(js"}, {"id": "6844903635604733959", "title": "如何优雅的升级到webpack4", "desc": "现在距离2018年2月15号webpack4.0.0出来已经有一段时间了，现在已经出了 @vue/cli 3.0，但是楼主还没试过，听说很强大，想要试水的可以看文档 @vue/cli，官方脚手架都用上webpack4了，你项目还停留在webpack3，甚至webpack2，是不…"}, {"id": "6844903880652750862", "title": "CodeSandbox 浏览器端的webpack是如何工作的？ 上篇", "desc": "这期来关注一下CodeSandbox, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 create-react-app、 vue-cli、parcel等等。 可以用于快速原型开发、DEMO 展示、Bug 还原等等. 相似的产品有很多，例如codepen、JSFi…"}, {"id": "6844904087985586183", "title": "webpack优化实践(遇到很奇葩的问题)", "desc": "1. 用include或exclude来避免不必要的转义 2. 开启缓存将转译结果缓存至文件系统 3. DllPlugin/DLLReferencePlugin优化处理 处理第三方库有多种方式，externals、CommonsChunkPlugin、splitChunks、D…"}, {"id": "6844904174258225159", "title": "玩转webpack——从零配置一个react项目", "desc": "近来得闲，重新撸了一边webpack文档，将webpack的用法以及作用基本理清了脉络，虽然各大前端框架的生态系统越来越完善，每个框架基本都搭配了一套标准的脚手架工具，但是那是搭配好的套餐，用起来虽然也还行，还是总觉得哪里不得劲儿，就像开车开了个自动档模式，不能根据自己的项目随…"}, {"id": "6968722488666619935", "title": "webpack多文件入口配置", "desc": "问题 公司项目是基于vue的中后台管理类型的系统，同时在系统中还有一个H5页面用于在移动端查看信息。 所以项目中需要混杂pc端和移动端代码，考虑到pc端依赖很多，为防止移动端的包也包含这些移动端依赖，"}, {"id": "6844903601626677261", "title": "我在日本最大的房地产信息网站做重构", "desc": "去日本之前就对日本互联网产业的各种奇葩现状有所耳闻，自己过来之后更是亲身经历了很多。总的说来有以下几个方面： 日本计算机理论研究其实做的非常不错，但是工业运用方面却做的一般，有点儿不思进取的感觉。不思进取到什么程度呢？比如说日本最大的门户网站Yahoo Japan，搜索引擎竟然…"}, {"id": "6844903636787544071", "title": "2018年6月前端面试经历(下)", "desc": "mountComponent 负责管理生命周期中的 getInitialState、componentWillMount、render 和 componentDidMount。 updateComponent 负责管理生命周期中的 componentWillReceivePro…"}, {"id": "6988833538602696741", "title": "🍭 源码分析：深入浅出webpack-1", "desc": "什么是webpack？ 通过理解不同JS文件间的依赖关系，形成打包文件的工具 模块化的核心 依赖处理 分割作用域 webpack的方案 自己实现一套 exports require 的逻辑来协调不同规"}, {"id": "6844904176422666253", "title": "大声对webpack4.0说声你好之webpack的高级应用(四)", "desc": "接上一讲，如果我们在preset-env设置了\"useBuiltIns\": \"usage\",那么实际上我们不去引入babel/polyfill也是可以的。因为我们在使用useBuiltIns，它会自动帮我们引入，所以这节我们直接可以写es6语法。 这个时候我们虽然实现了效果，但…"}, {"id": "6959357069010927653", "title": "Webpack的基本配置和打包与介绍（二）📦", "desc": "在上一章中我们学习到了webpack的基本安装配置和打包，我们这一章来学学如何使用loader和plugin..."}, {"id": "6996346697538338852", "title": "配置开发环境（webpack）以 支持 开发React", "desc": "当我们为了一支现代的「web 应用」 准备开发环境，这个过程对于新手来说，不是特别的简单，尤其是当前端使用了像React框架的情况，因为社区生态（ecosystem）存在错综复杂的关系。这需要一些"}, {"id": "6844904004435050503", "title": "Webpack插件机制之Tapable-源码解析", "desc": "Webpack的成功之处，不仅在于强大的打包构建能力，也在于它灵活的插件机制。 在学习Webpack的时候，经常可以看到上述介绍。也就是说学Webpack的前提是要学习Tapable。才能更好的学习Webpack原理。 其实tapable的核心思路有点类似于node.js中的e…"}, {"id": "6844903497532473352", "title": "TypeScript 中使用 CSS Modules", "desc": "相当长一段时间 CSS 总是在页面上作为一个全局的存在，以前这个『特性』影响还不算很大，命名上注意一点，比如使用 BEM 也能一定程度上解决问题。 但是随着 web 组件化的需求越来越强烈，CSS 的这种特性开始成为束缚开发者自由飞翔的绳索，每一个 CSS 类名都有可能产生意想…"}, {"id": "6844903860415234055", "title": "webpack学习之路（二）webpack-dev-server实现热更新", "desc": "上一章对webpack的配置有了简单的认识。 这一章，我需要学习的是webpack热更新，因为在开发过程中，不希望当文件更改时，人肉去编译文件，刷新浏览器。 实际操作一下。 这确实是热更新，但是这种是每一次修改会重新刷新整个页面，大家可以打开控制台查看。 显然这还是不满足不我们…"}, {"id": "6878096648199897102", "title": "【升级webpack4】mini-css-extract-plugin 替换 extract-text-webpack-plugin", "desc": "负责的项目webpack的版本是3，最近在学习（折腾）webpack，看了官网的升级指南（https://webpack.js.org/migrate/4/#root）后，就开始对项目的webpack"}, {"id": "6844903856225124365", "title": "从今天开始，学习Webpack，减少对脚手架的依赖(下)", "desc": "答：适合没接触过Webpack或者了解不全面的人。 答：先介绍背景，由背景引入Webpack的概念，进一步介绍Webpack基础、核心和一些常用配置案例、优化手段，Webpack的plugin和loader确实非常多，短短2w多字还只是覆盖其中一小部分。 PWA全称Progre…"}, {"id": "6994803835634106381", "title": "webpack5学习 --- 代码分离(补充)", "desc": "目前所有的webpack配置信息都是放到一个配置文件中，当配置越来越多时，这个文件会变得越来越不容易维护。所以，我们最好对配置进行拆分。同样为了提升加载效率，打包后的文件也需要进行拆分操作。"}, {"id": "6960472347329429511", "title": "分享几个 Webpack 实用分析工具", "desc": "分享几个 webpack 构建过程的分析诊断方法和工具，基于这些工具，你可以：更了解编译产物由那些模块资源组成；更了解模块之间的依赖关系；更了解不同模块的编译构建速度；等等。"}, {"id": "6844904136622751758", "title": "webpack构建速度和体积优化策略", "desc": "缺点：颗粒度太粗，看不出问题所在。 思路：将react, react-dom, redux, react-redux基础包和业务基础打包成一个文件。 方法：创建一个单独的配置文件,一般命名为webpack.dll.js,使用DLLPlugin进行分包，DllReferenceP…"}, {"id": "6844903711630688269", "title": "Vue SSR（Vue2 + Koa2 + Webpack4）配置指南", "desc": "正如Vue官方所说，SSR配置适合已经熟悉 Vue, webpack 和 Node.js 开发的开发者阅读。请先移步 ssr.vuejs.org 了解手工进行SSR配置的基本内容。 从头搭建一个服务端渲染的应用是相当复杂的。如果您有SSR需求，对Webpack及Koa不是很熟悉…"}, {"id": "6844904073817227277", "title": "前端工程化概述", "desc": "前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。 模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作。其中包含 JS 模块化：CommonJS、AMD、CMD 以及 ES6 Module。 CSS 模块…"}, {"id": "6887750775368499207", "title": "webpack devtool篇", "desc": "这个关键词表示每个模块用eval执行，并且存在@sourceUrl，就是说这种配置的devtool在打包的时候，生成的bundle.js文件模块都会被eval包裹，并且后面跟着sourceUrl,指向的是原文件index.js，调试的时候就是根据这个sourceUrl找到的in…"}, {"id": "6952807822203551752", "title": "webpack全方位由浅到深讲解，做到简历上真正所谓的“熟悉”(系列五)", "desc": "编写loader和插件 编写loader 一个最简单的 loader 代码结构 定义：loader 只是一个导出为函数的 JavaScript 模块 多 Loader 时的执行顺序 多个 Loader"}, {"id": "6844903750729990152", "title": "webpack系列之二Tapable", "desc": "上一篇总览 我们介绍了 webpack 整体的编译过程，这次就来分析下基础的 Tapable。 webpack 整个编译过程中暴露出来大量的 Hook 供内部/外部插件使用，同时支持扩展各种插件，而内部处理的代码，也依赖于 Hook 和插件，这部分的功能就依赖于 Tapable…"}, {"id": "6984314261354856455", "title": "Webpack 原理解析及实现", "desc": "Webpack 原理解析及实现 这是Webpack官网的第一句介绍，可以看到几个关键字：静态模块打包工具、依赖图、映射。这也是这类工具的核心功能：将文件映射为依赖图打包。 首先探讨一下这个构建流程。读"}, {"id": "6844903825774493710", "title": "脑壳疼的Webpack-tapable", "desc": "Q1:tapable解决的问题？tapable是个独立的库webpack中大量使用了这个库tapable主要是用来处理事件，解决的问题有点类似EventEmitter，不过功能更加强大Q2:tapab"}, {"id": "6844904133837717511", "title": "探索webpack5新特性Module-federation", "desc": "webpack5的一个重要特性是Module-federation，本文从为什么会出现这个特性，到怎么使用，是什么原理，以及一些应用场景，最后再给出一个demo，从简介绍下该特性。 功能：阅读过webpack3或webpack4构建结果的童鞋应该知道，webpack对外只提供了…"}, {"id": "6844903502586593288", "title": "webpack 应用编译优化之路", "desc": "目前大家使用最多也是最广泛的应用打包工具就是 webpack 了，除去 webpack 本身已经提供的优化能力（例如，Tree Shaking、Code Splitting 等）之外，我们还能做哪些事情呢，本篇主要就为大家介绍下滴滴 WebApp 团队在这条路上的一些探索。 现…"}, {"id": "6844903591484866568", "title": "Webpack 4 使用指南", "desc": "最近想学一学Webpack,在网上看了很多相关文章,但是Webpack更新的太快了,很多文章都不适用weback新的版本,我从头开始研究了一番,在这里和大家分享交流一下,有错误的地方请指出. webpack-dev-server 等... 一 . 搭建一个webpack项目 W…"}, {"id": "6844903885954351117", "title": "Webpack 4 构建大型项目实践 / 优化", "desc": "上一节我们解决了工程的开发调试问题，项目的生产和开发环境也已配置完成，还约定了 Webpack 配置文件规范。但它还很粗糙，这一节我们就来一起打磨这套配置。 在之前的配置中我们使用使用 MiniCssExtractPlugin.loader 来代替 style-loader ，…"}, {"id": "6844903700176044040", "title": "Vue SPA 项目webpack打包优化指南", "desc": "最近一个小伙伴问我他们公司的Vue后台项目怎么首次加载要十多秒太慢了，有什么能优化的，于是乎我打开了他们的网站，发现主要耗时在加载vendor.js文件这个文件高达2M，于是乎我就拿来他们的代码看看，进行了一番折腾。最终还是取得了不错的效果。 对于网页性能，如何提升加载速度、等…"}, {"id": "6992915720967290917", "title": "webpack 配置进阶知识", "desc": "提取css成单独文件 原因 不提取css文件，打包时会放在js文件中，不仅会增加js文件体积，使js文件下载时间延长，而且进行解析js文件往往都是在dom树生成之后，就增加了延迟，影响渲染速度，用户体"}, {"id": "6990186210790473741", "title": "webpack的代理proxy配置", "desc": "webpack请求后台接口时，转发代理proxy的配置。 包括vue-cli2.0+和vue-cli3.0+构建的项目不同配置形式。"}, {"id": "6958811421224206343", "title": "有点难的 webpack 知识点：Dependency Graph 深度解析", "desc": "围绕 webpack@v5.x 的 Dependency Graph 实现，从源码层面分析 webpack 中如何收集依赖，如何存储依赖信息，以及最后又是如何消费这些依赖关系，从而完成资源编译构建过程"}, {"id": "6844904103118651399", "title": "前端构建环境工具之webpack中babel的工作原理", "desc": "所以最终还需要被转化为output这个出口文件，也就是代码的形式。 接下来我们对AST这个节点进行展开，AST在parse后，原来entry文件使用的代码语法为es6(也有可能是es7/8/9/10，这里仅仅举例方便说明)不会发生改变，(transform)改变的仅仅是code…"}, {"id": "6844904160286998536", "title": "webpack(四)-构建速度性能优化", "desc": "项⽬中引⼊了很多第三方库，这些库在很⻓的一段时间内，基本不会更新，打包的 时候分开打包来提升打包速度，而DllPlugin动态链接库插件， 其原理就是把⽹页依赖 的基础模块抽离出来打包到dll⽂件中，当需要导⼊的模块存在于某个dll中时，这个 模块不再被打包，⽽是去dll中获取…"}, {"id": "6844903517530882062", "title": "好用的格式化时间的插件", "desc": "包含多种处理日期类型的方法，日期类型与字符串类型的相互转化，计算时间差等 觉得好的话 可以star一下"}, {"id": "6844903619821568007", "title": "webpack3.X CommonChunkPlugin", "desc": "随着项目一点点的深入，对于webpack的配置也是改了又改，看了又看，这里就再记录一下CommonsChunkPlugin的用法，多用于个人记忆。希望对你有所帮助。 1、name和names a.如果name的值不与任何已存在的chunk相同，则会从options.chunks…"}, {"id": "6907575693970767879", "title": "React 学习12-6 -- React 入门到熟练必会内容（二） 必出精品！！！", "desc": "1."}, {"id": "6844903501269581838", "title": "webpack 4: 新的变化1 (第24–25周)", "desc": "在过去的几周里，我完成和合并了所有webpack4的PR，其中有很多很大的变化。下面是一些重要的变化的总结，这样你在看到下边的更新日志的时候不会觉得惊讶。Sets在API层，现在很多类已经开始使用Se"}, {"id": "6844903501059850248", "title": "一份来自 Treebo 的 React 与 Preact PWA 性能分析报告", "desc": "Treebo是一家印度家喻户晓的经济型连锁酒店，在旅游业中占据了价值200亿美元的市场。他们最近开发了一个新的渐进式应用(PWA)作为默认的移动端体验，最开始使用React,但最后在生产环境转向了Preact。"}, {"id": "6844903502485913613", "title": "《深入理解ES6》阅读笔记 --- 用模块封装代码", "desc": "不知不觉《深入理解ES6》阅读笔记就写到了最后一篇，完结之后可能会开启另外的一个系列，分享自己的知识点，让阅读到的人有一点点的收获，以及自己的成长。最后一篇主要是来写一写用模块封装代码的事情，回顾历史，从最早的立即执行函数，再到require.js，…"}, {"id": "6844903584044154894", "title": "Parcel Vs Webpack", "desc": "爱折腾的前端圈时常会有新轮子诞生，只要是好东西就能快速获得大量关注，资历再好的大哥只要不如新人也很快会被替代。 横空出世的 Parcel 近日成为了前端圈的又一大热点，在短短几周内就获得了 13K 的 Star。 作为前端构建工具新人的 Parcel 为什么能在短期内获得这么多…"}, {"id": "6844904191152881677", "title": "初识webpack", "desc": "什么是webpackwebpack的安装方法//推荐局部安装，当维护一些老项目的时候有可能因为webpack的版本出现一些问题创建一个文件夹打开cmd输入npminit指令安装webpackwebpa"}, {"id": "6844903617074298887", "title": "Vue2 dist 目录下各个文件的区别", "desc": "vue2经过2.2版本升级后,文件变成了8个:vue.common.jsvue.esm.jsvue.jsvue.min.jsvue.runtime.common.jsvue.runtime.esm.j"}, {"id": "6844903519737085959", "title": "无需配置的 Web 应用打包工具 Parcel", "desc": "不知道能不能取代 webpack"}, {"id": "6844903537520951303", "title": "Lerna+webpack+juction来拆分组件库为多个单独的npm包", "desc": "总体的思路, 大致上和lerna-demo差不多, 区别在于会根据现有的目录结构做相应的定制, 所以接下来会简单讲思路, 和遇到的问题. 我是无语线.................................................................…"}, {"id": "6900942038377136142", "title": "HMR简单介绍", "desc": "当我们对代码进行修改时，webpack对代码重新进行打包，并且将新的模块发送到浏览器端，浏览器将旧的模块用新的替换，在不完全刷新页面的情况下，对我们的应用进行局部更新。 在代码中修改js/css时，感觉就像在 Chrome 的开发者工具中直接修改元素样式。 官方文档中说，完全开…"}, {"id": "6844903574204334094", "title": "webpack进阶用法", "desc": "每次构建的时候，我们不会通过webpack自动清理构建目录，而是每次构建之前手动的删除构建目录，其实这样的话，每次构建前不清理目录的话，就会造成构建目录输出的output文件越来越多，针对这个问题利用了npm script 做了目录清理，在每次构建之前npm script里面增…"}, {"id": "6902242468461281293", "title": "webpack系列之plugin实现", "desc": "webpack 是个很强大的构建工具，其丰富灵活的配置决定了使用也不简单。在面试中经常能遇到 webpack 相关的问题，如果平常只是使用脚手架如 vue-cli 而没有好好深入学习研究 webpack 的话，估计答不上什么。我相信，如果没有深入了解，部分面试官也问不出什么。可…"}, {"id": "6844904146684870664", "title": "初识webpack", "desc": "需要./node_modules/.bin/webpack 这一串 所以我们可以通过便捷的方式进行webpack的打包。 这样我们就可以npm run build进行打包。"}, {"id": "6870295721824747533", "title": "webpack4下通用前端配置", "desc": "Web前端应用开发主要术语有：HTML、CSS、DOM、JavaScript，前三者的标准由W3C制定，后者由ECMA制定，可以认为DOM规范提供了前端页面拥抱JS技术的接口。一般Web应用运行在浏览器中，由浏览器内核提供的渲染引擎、JS执行引擎共同完成程序的加载。不同的浏览器…"}, {"id": "6844903853364609031", "title": "demo01 最简单的 webpack 零配置实践", "desc": "webpack4 支持零配置打包(无需 webpack.config.js 配置文件)，首先我们可以直接运行 webpack index.js（入口index.js）进行编译打包。"}, {"id": "6935693683228409870", "title": "webpack4学习（1），基础配置", "desc": "五大模块entryoutputmodulepluginmode解析文件分类样式解析css、less样式兼容postcsspackage.json提取css为单独文件插件mini-css-extract"}, {"id": "6844903654378438670", "title": "Webpack打包实用优化方案", "desc": "目前最火的打包工具莫过于 Webpack 了，关于 Webpack 的优化方案，网上有很多文章可以供大家参考。查阅前人的资料，总结自己在项目中遇到的问题，最终得出一些比较实用的优化方案，本文将与大家一一分享。既然是打包优化，那么我们需要时刻关注以下几点： 减少编译时间 减少编译…"}, {"id": "6948727640844926989", "title": "webpack源码解析（小白入门篇）", "desc": "webpack作为一个打包工具，它的入参是各种静态文件和配置参数，可以实现灵活的可扩展性的插件配置和loaders加载，最后输出打包后的bundle文件。下图是官网中的webpack打包示意图，webpack可以打包全世界！ 在分析源码之前，我们必须要先了解一下Tapable这…"}, {"id": "6844904190951555086", "title": "webpack源码之调试篇", "desc": "学习一个工具或者库的源码之前，得对一个库进行大概的认识，比如源码的目录结构，如何调试等。属于前置的准备阶段。 而webpack是我即vue之后，希望通读的一个工具库。其实在团队中，自己需要去完成一些技术指标，而相应的技术储备是必不可少的。而就前端工程化领域而言，webpack是…"}, {"id": "6966872015659597855", "title": "webpack5（二）浏览器兼容处理-CSS", "desc": "在webpack中通过工程化处理兼容问题，例如对css处理的postcss，对js处理的babel等等工具，这些工具又依赖于browserslist收集的浏览器信息 browserslist 在各大框"}, {"id": "6974670295680417805", "title": "webpack的工作流程", "desc": "webpack在启动后，会从Entry开始，递归解析Entry依赖的所有Module，每找到一个Module，就会根据Module.rules里配置的Loader规则进行相应的转换处理，对Module"}, {"id": "6844903681331036168", "title": "Service Worker学习与实践（一）——离线缓存 ", "desc": "Service Worker本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后…"}, {"id": "6844904021334065165", "title": "【webpack配置工程师】系列一（核心概念篇）", "desc": "webpack 可以把它理解为一款工具，一款帮助我们打包的工具，也可以称之为前端构建工具。 简单来说 webpack 做的事情就是将一些特别复杂且浏览器无法识别东西，通过 webpack 编译、打包后，生成了浏览器可以识别的静态资源。 我们需要做的就是在配置文件中写好配置，然后…"}, {"id": "6844903774310367246", "title": "webpack4.x 性能优化", "desc": "webpack可以说是当下最流行的打包库，当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每一个模块，然后将所有这些模块打包成一个或多个bundle。这篇文章将介绍webpack非常重要的一部分——性能优化。文章的代码的在此： noParse…"}, {"id": "6922255107593601037", "title": "Webpack 5 新特性尝鲜（一）：安装与启动", "desc": "上次发《不小心将Webpack升级后我搞定了微前端。》后，发现大家对Webpack5甚为关心。Webpack5发布已经有一段时间了，很多小伙伴都在考虑要不要升级，有没有升级的必要，不知道升级后有哪些改"}, {"id": "6926453633210925064", "title": "多页面项目优化webpack打包降低上线风险", "desc": "项目中有多个入口，某些入口会提供出去给其他项目使用。这就要求项目的稳定性要高，如果出了问题可能会导致其他的相关联项目也无法正常使用。（要背锅） 由于目前整个项目的打包文件用的同一套版本号，导致当对某个组件进行了修改，进行打包后，所有模块的版本号都会更新，缓存将不能使用，所有模块…"}, {"id": "6844904184672681992", "title": "VUE-cli跨域 proxyTable", "desc": "浏览器有同源策略的限制，所以不是同源的脚本不能被访问，即不能跨域名访问。 所以为了实现跨域，前后端都有很多解决的办法，这里我们就来解决webpack下vue的跨域问题。 1. 增加ProxyTable配置 2. 根据开发和生产环境配置不同地址 1. 在api.js里增加接口地址…"}, {"id": "6978123834217988103", "title": "webpack区分环境以及打包分析", "desc": "development模式和production模式区分打包 development模式和production模式，它们分别用来做什么呢？ 当我们开发一个项目的时候，我们一般用development这"}, {"id": "6844903561311043597", "title": "Webpack最简单的方式Mock API", "desc": "mocker-api 是一个为 REST API 创建 mock 的 webpack-dev-server 中间件。 当您尝试在没有实际的 REST API 服务器的情况下，测试您的应用程序时，这将会很有帮助。 上面的 key 比较特殊，由 methd 和 path 组合，中间…"}, {"id": "6844903501772898318", "title": "前端面试之webpack篇", "desc": "还是以前一样，有些概念面试可能会考，我都用*标记了出来，两句话就总结清楚其余的地方如果你想了解webpack，就仔细看看，虽然本教程不能让你webpack玩的很6，但是懂操作流程够了。面试你一般问你w"}, {"id": "6990565311955075085", "title": "webpack实现懒加载", "desc": "懒加载对页面的优化是非常重要的，当某些一开始不需要的资源我们不应该放在主文件中一起下载，而是等待使用的时候再去下载。懒加载能够减小主文件的大小，加快首屏的显示，缓解服务器的压力等优点。 webpack"}, {"id": "6844903782581534727", "title": "webpack常用优化配置", "desc": "3. HappyPack HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack 4. ParallelUglifyPlugin 5. 服务器自动刷新 6. 区分环境 在开发过程中方便开发调试的环境。 …"}, {"id": "6844904097867382798", "title": "从0到1搭建webpack4.0+react全家桶（上）", "desc": "然后进去文件夹 ，npm init 以后一路回车就行。 初始化完成以后就可以看到已经创建好一个package.json文件了，此时开始创建文件夹和文件。 mode：两种模式打包后会产生不同的文件，development环境下打包后的文件是未压缩的js文件，而production…"}, {"id": "6844903775098896391", "title": "[译] Webpack 4 的故事以及如何用正确的方式去最终配置它【更新版】", "desc": "特别提醒：没有正确的方式。#justwebpackthings 网上有上百万的教程，所以你可能已经看到了上千种配置 Webpack 文件的方式，而且他们都是可运行的例子。为什么会这样？Webpack 本身发展的非常快，很多加载器和插件都必须跟上。这是这些配置文件如此不同的一个主…"}, {"id": "6844904033681948686", "title": "webpack模块异步加载原理解析", "desc": "大多数情况下，我们并不关心 webpack 是怎么做异步加载的，但是作为前端开发工程师我们需要对异步加载有一定的了解。 在讲解之前，先让我们搭建一个简单的webpack工程。 这里我使用了webpack-chain的方式配置 webpack。有兴趣的朋友可以去了解一下。 在讲解…"}, {"id": "6944349196539396133", "title": "【Webpack进阶】Loader深入解析", "desc": "Webpack是如今前端离不开的话题和工具，相信不少同学都曾经感受过被webpack支配的恐惧，但是去深入理解它，可能是脱离苦海的第一步。 在webpack的体系里，loader和plugin无疑是最核心的组成部分，本文会结合webpack的运行机制，介绍loader和plug…"}, {"id": "6870258201384714253", "title": "「webpack 核心特性」模块热替换(HMR)", "desc": "保留在完全重新加载页面期间丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。 这是官方网站对于 HMR 给的解释。 下面我们来慢慢深入了解 Webp…"}, {"id": "6844904106591518727", "title": "使用 webpack4 从0开始搭建 react 项目", "desc": "最近在学习 webpack 基础使用，项目优化等问题。总感觉要写点东西记录一下。如果你对webpack感兴趣的话，可以跟着这篇文章来尝试搭建（大神自行略过），好了废话不多说直接进入正文。 首先在项目下创建 webpack.config.js，下文中会直接使用默认配置中的属性将不…"}, {"id": "6994246693159960583", "title": "webpack 进阶", "desc": "基础搭建 修改源文件 样式处理 集成css样式处理： css-loader style-loader 安装 npm install style-loader css-loader -D 配置 sass"}, {"id": "6994077163276206111", "title": "webpack5 入门03 创建 library", "desc": "其实我们一直在创建library,正常打包就是创建一个library 但是实在比较简单而且只能适用于网页版 javascript. 然而打包出来的东西并不满足现在的 javascript 的协议。 然"}, {"id": "6893097741258326030", "title": "开发一个 Webpack 插件原来这么简单", "desc": "插件是webpack的重要组成部分，为用户提供了一种强大方式来直接触及webpack的编译过程(compilationprocess)。插件能够钩入(hook)到在每个编译(compilation)中"}, {"id": "6972515082928390175", "title": "webpack4升级到webpack5在项目中尝试落地探索", "desc": "有些老项目的包长时间没有更新，导致项目中有些性能问题，在项目迭代中考虑升级包，开始查找相关资料； 简单“粗暴”的升级方式 当然包升级后带来的一些问题，需要更全面的思考，此处先省略... 直接进入主题："}, {"id": "6930428452856152077", "title": " webpack5新特性", "desc": "通过持久缓存提高构建性能. 使用更好的算法和默认值来改善长期缓存. 通过更好的树摇和代码生成来改善捆绑包大小. 清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改. 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5. 早期，web…"}, {"id": "6994068283758493704", "title": "webpack 基础学习", "desc": "1.定义 webpack是一个js的静态模块打包器module bundler。 从入口模块出发，递归查找所有文件的依赖，并入口和所有依赖打包成一个文件中。 是工程化自动化思想的体现。 2.安装 局部"}, {"id": "6844904153727107080", "title": "基于 webpack 优化老项目 👻", "desc": "Roadhog 官方介绍：Roadhog 是一个包含 dev 、build 和 test 的命令行工具，他基于 react-dev-utils，和 create-react-app 的体验保持一致。你可以想象他为可配置版的 create-react-app。 Roadhog是有…"}, {"id": "6844904053735063565", "title": "Webpack实战（八）：教你搞懂webpack如果实现代码分片（code splitting）", "desc": "现在工程项目中，实现高性能应用的其中重要的一点就是让用户每次只加载必要的资源，优先级别不太高的资源采用延迟加载等技术渐进地进行加载获取。 Webpack 作为打包工具所特有的一项技术就是代码分片技术，通过这项技术我们可以把代码按照特定的形式进行拆分，使用按需加载资源，不必要全部…"}, {"id": "6844904197045878798", "title": "关于AST 的梳理", "desc": "抽象语法树（Abstract Syntax Tree）简称 AST，是源代码的抽象语法结构的树状表现形式。webpack、eslint 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语…"}, {"id": "6844903652285480968", "title": "使用webpack4搭建一个基于Vue的组件库", "desc": "组内负责的几个项目都有一些一样的公共组件，所以就着手搭建了个公共组件开发脚手架，第一次开发 library，所以是参考着 iview 的配置来搭建的。记录如何使用webpack4搭建一个library的脚手架 然后就是书写配置文件。 我写的 library 的目录结构如下，仅供…"}, {"id": "6980148456065073182", "title": "怎样不输出React工程的sourceMap文件", "desc": "使用Create React App创建的单页应用生产环境下默认会使用sourceMap文件，这些文件一般很大，最好不要将它们部署到服务器上。当然，我们可以手动删除已经输出的文件，高级一点还可以使用一"}, {"id": "6844903543283925000", "title": "webpack多页面打包", "desc": "简介我们开发不可能只写一个页面，每次都要写很多页面，这时为了开发效率，我们使用前端自动化工具webpack，那么webpack是如何打包页面的呢？又是如何打包多页面的呢？单页面打包我们知道要打包单页面"}, {"id": "6844904006003736583", "title": "webpack构建流程及梳理", "desc": "webpack的核心功能是通过抽离出很多插件来实现的，因此系统内功能的划分粒度很细，这样做到了完美解偶同时又分工明确，代码容易维护。可以说插件就是webpack的基石，这些基石又影响着流程的走向。这些钩子是通过Tapable串起来的，可以类比Vue框架的生命周期，webpack…"}, {"id": "6883285521137680397", "title": "蒲公英 · JELLY技术周刊 Vol.25 · Webpack 5 正式发布，你学废了么", "desc": "自从 2018 年 2 月，Webpack 4 发布以来，Webpack 就暂时没有更进一步的重大更新，为了保持 API 的一致性，旧的架构没有做太多改变，遗留了很多的包袱。阔别 2 年多后，2020 年 10 月 10 日，Webpack 5 正式发布，并带来了诸多重大的变更…"}, {"id": "6844904169426386957", "title": "大声对webpack4.0说声你好之参见plugin与常用配置详解(三)", "desc": "在学会使用loader之后，我们再来看看webpack的plugin的使用。 如果你还不会使用webpack的基本使用和loader的使用，建议您先观看我的大声对webpack4.0说声你好前两个章节。因为我们例子就是结合上部分的继续讲，只要你跟着我的文章一直 敲代码，你就能很…"}, {"id": "6920037483485462541", "title": "vue-cli3使用vue-cli-plugin-dll优化构建速度", "desc": "确保项目是使用vue-clli3.x.x版本。 在了解这个配置之前，需要先了解一下vue-cli-plugin-dll的vendor文件获取机制，在获取vendor文件的时候有两种方式实现。 1.在执行 npm run dll命令时,将构建生成的所有文件的路径存储在cache.…"}, {"id": "6844903507888177160", "title": "Webpack经典入门", "desc": "之前你可能已经听说过这个叫webpack的很酷的工具，如果你没仔细了解过这个工具，你可能会有些困惑，因为有人说它像 Gulp 之类的构建工具，也有人说它像 Browserify 之类的模块管理工具，如果你有去仔细地了解一下，你可能还是会不明白到底是怎么一回事，因为官网上把web…"}, {"id": "6844903508337164296", "title": "内存分析与内存泄漏定位", "desc": "无论是分布式计算系统、服务端应用程序还是 iOS、Android 原生应用都会存在内存泄漏问题，Web 应用自然也不可避免地存在着类似的问题。虽然因为网页往往都是即用即走，较少地存在某个网页长期运行的问题，即使存在内存泄漏可能表现地也不明显；但是在某些数据展示型的，需要长期运行…"}, {"id": "6997235570300682248", "title": "wp2vite ~ 让webpack项目支持vite", "desc": "一个前端项目转换工具，可以让webpack项目支持vite。 wp2vite 不会删除你的项目的webpack的配置文件，但是会在你的项目中插入vite的配置文件。"}, {"id": "6989461400535973896", "title": "面试官：请手动实现一个Sass-loader", "desc": "本文讲述什么是Loader及它是干嘛的，Loader的基本使用，并动手实现自己的Loader。欢迎阅读"}, {"id": "6990869970385109005", "title": "webpack5 和 webpack4 的区别有哪些 ？", "desc": "1、Tree Shaking 作用： 如果我们的项目中引入了 lodash 包，但是我只有了其中的一个方法。其他没有用到的方法是不是冗余的？此时 tree-shaking 就可以把没有用的那些东西剔除"}, {"id": "6844903652956569608", "title": "手摸手，带你用合理的姿势使用webpack4（上）", "desc": "前几天 webpack 作者 Tobias Koppers 发布了一篇新的文章 webpack 4.0 to 4.16: Did you know?(需翻墙)，总结了一下webpack 4发布以来，做了哪些调整和优化。 并且说自己正在着手开发 webpack 5。 正好我也在使…"}, {"id": "6999611621987319845", "title": "150行代码了解webpack中HMR的实现", "desc": "Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。"}, {"id": "6882663278712094727", "title": "阔别两年，webpack 5 正式发布了！", "desc": "自从 2018 年 2 月，webpack4 发布以来，webpack 就暂时没有更进一步的重大更新，为了保持 API 的一致性，旧的架构没有做太多改变，遗留了很多的包袱。阔别 2 年多后，2020 年 10 月 10 日，webpack 5 正式发布，并带来了诸多重大的变更，…"}, {"id": "7005137667159654414", "title": "【长文】玩转 webpack 学习笔记", "desc": "写在最前面 最近工作中webpack用的比较多，想系统的学习一下，找到了极客时间的教程，跟着视频上讲的学了一遍，收获挺大的。虽然视频教程是2019年出的，有点老，有些知识已经过时了，但并不妨碍学习。那"}, {"id": "7003938516736409613", "title": "webpack5——Module Federation（微前端的一种实现方式）", "desc": "多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。"}, {"id": "6844903570001625102", "title": "2018春招前端面试: 闯关记(精排精校) | 掘金技术征文", "desc": "年末研发组解散失业, 选择回去学车了,也顺利拿到了驾照，最近回归大深圳,开始踏上漫漫的找工作之路。 问题截止日期(2018/3/23)，我去面的创业,中大型皆有。 这种问题见仁见智,我的回答大体是这样的..待我捋捋. 让我们来举个栗子,.自己新建一个 html 跑一下,. ha…"}, {"id": "7004751416564645901", "title": "Webpack配置-环境分离和代码分离", "desc": "环境分离 第一种方案添加两个配置文件，然后添加两个 build指令分别指向两个配置文件如下图显示 第二种方案是使用相同的入口配置文件但是需要在后面配置参数来区分生产环境还是开发环境 这样做的好处就是可"}, {"id": "6844904038543130637", "title": "webpack打包原理 ? 看完这篇你就懂了 !", "desc": "[实践系列] 主要是让我们通过实践去加深对一些原理的理解。 [实践系列]你能手写一个 Promise 吗？Yes I promise。 有兴趣的同学可以关注 [实践系列] 。 求 star 求 follow~ 入口起点(entry point)指示 webpack 应该使用哪个…"}, {"id": "7004711781276844045", "title": "【webpack系列】4. webpack的plugin插件是如何运行的", "desc": "我们都知道loader和plugin是webpack两个比较重要的配置项，也是深入了解webpack打包原理的关键。上篇文章介绍过loader的运行时机和原理（https://juejin.cn/po"}, {"id": "6978648939012554765", "title": "Webpack 实现 Tree shaking 的前世今生", "desc": "众所周知，原本不支持 tree-shaking 的 Webpack 在它的 2.x 版本也实现了 tree-shaking，好奇心又来了，rollup 从一开始就自实现了 tree-shaking，而"}, {"id": "6959449526197288996", "title": "你不知道的webpack静态文件生成过程", "desc": "webpack中静态文件生成的原理，细节还是非常多的，通过本文对详细过程分析以及一些demo实践，逐步揭开静态文件生成的面纱，希望可以帮助到你"}, {"id": "6984845444404740133", "title": "万字总结webpack的超入门核心知识", "desc": "🎨文章超过1w字，通读大约需要30min。在前端工程化日趋复杂的今天，模块化打包工具在我们的日常开发中起着越来越重要的作用，而其中， webpack 已然是前端打包构建的不二选择。 说到 w"}, {"id": "6949040393165996040", "title": "[万字总结] 一文吃透 Webpack 核心原理", "desc": "解析 webpack 核心流程与插件架构，理解： - Webpack 从启动到输出 bundle，内部逻辑流转过程 - 编写 webpack 插件前，你需要弄清楚哪些问题"}, {"id": "7004790532916379655", "title": "webpack chunk", "desc": "前端 webpack entry入口 chunk splitchunk code splitting 代码分割"}, {"id": "6985081488920281119", "title": "前端热更新原理-上篇", "desc": "web可以实现 热加载 hot-loader 或者是模块热更替 HMR 主要归功于HTML5中提出的俩种新的通信方式..."}, {"id": "6973825927708934174", "title": "120 行代码帮你了解 Webpack 下的 HMR 机制", "desc": "在使用Webpack Dev Server以后 可以让我们在开发工程中 专注于 Coding， 因为它可以监听代码的变化 从而实现打包更新，并且最后通过自动刷新的方式同步到浏览器，便于"}, {"id": "6844903573675835400", "title": "webpack详解", "desc": "webpack是现代前端开发中最火的模块打包工具，只需要通过简单的配置，便可以完成模块的加载和打包。那它是怎么做到通过对一些插件的配置，便可以轻松实现对代码的构建呢？ Plugins：Loaders将各类型的文件处理成webpack能够处理的模块，plugins有着很强的能力。…"}, {"id": "6844903874768158728", "title": "多端多页面项目 webpack 打包实践与优化", "desc": "webpack的核心是一切皆模块，所以它其实本质上就是个静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。官网显示的这幅图很形象地描述了这个过程： webpack4…"}, {"id": "6844903966849892359", "title": "从 0 到 1 实现一款简易版 Webpack", "desc": "输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结…"}, {"id": "6844903825120165895", "title": "vue客户端渲染首屏优化之道", "desc": "1、 dll动态链接库， 使用DllPlugin DllReferencePlugin，将第三方库提取出来另外打包出来，然后动态引入html。可以提高打包速度和缓存第三方库 主要是分离 第三方库，自定义模块（引入超过3次的自定义模块被分离），webpack运行代码（runtim…"}, {"id": "6844903817343926280", "title": "24 个实例入门并掌握「Webpack4」(三)", "desc": "这里会有选择是 React/Vue/JavaScript，我们统一都先选择 JavaScript。选完后会在项目的根目录下新建一个 .eslintrc.js 配置文件 @babel/parser 是 Babel 中使用的 JavaScript 解析器。"}, {"id": "6989439182464614436", "title": "webpack 基础概念教学-2", "desc": "今天主要讲解下loader和plugin loader 目前webpack搭建初始化的项目，是不识别javascript以外的语言模块，这就需要对应的loader将资源转化，加载进来。 1.已css举"}, {"id": "6998540923697102885", "title": "webpack性能优化", "desc": "1.优化 babel-loader 在babel-loader后加cacheDirectory，开启缓存， 没有改动的es6代码会启用缓存，不会重新编译"}, {"id": "6844903687412776974", "title": "Webpack Tree shaking 深入探究", "desc": "App往往有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过Tree shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。 关于Tree shaking的原理，在Tree S…"}, {"id": "6844904176342794254", "title": "精读《snowpack》", "desc": "基于 webpack 构建的大型项目开发速度已经非常慢了，前端开发者已经逐渐习惯忍受超过 100 秒的启动时间，超过 30 秒的 reload 时间。即便被寄予厚望的 webpack5 内置了缓存机制也不会得到质的提升。但放到十年前，等待时间是几百毫秒。 好在浏览器支持了 ES…"}, {"id": "6844903590503383054", "title": "怎么在 ES6+Webpack 下使用 Web Worker", "desc": "大家都知道 HTML 5 新增了很多 API，其中就包括 Web Worker，在普通的 js 文件上使用 ES5 编写相关代码应该是完全没有问题了，只需要在支持 H5 的浏览器上就能跑起来。 那如果我们需要在 ES6+Webpack 的组合环境下使用 Web Worker呢？…"}, {"id": "6975038104650383374", "title": "是什么让尤大选择放弃Webpack？面向未来的前端构建工具 Vite", "desc": "前两天在知乎看到过一篇文章，大致意思是讲：字节跳动已经开始“弃用Webpack”尝试在自研。。。详情戳"}, {"id": "6880487034130169869", "title": "webpack优化方案 | 实践总结", "desc": "解决 js、css 的依赖问题。（以前经常因为引入顺序问题，导致 css 没起作用或某个js变量找不到） webpack 原生只支持 js、json 两种模块类型，所以需要 loader 把其他类型的文件转化成有效的模块，并可以添加到依赖图中。 开启 dev-server 后默…"}, {"id": "6844903679401656333", "title": "【译】Google - 使用 webpack 进行 web 性能优化（二）：利用好持久化缓存", "desc": "在优化应用体积之后，下一个提升应用加载时间的策略就是缓存。将资源缓存在客户端中，可以避免之后每次都重新下载。 这个方法可以告诉浏览器去下载 JS 文件，并将它缓存，之后使用的都是它的缓存副本。浏览器只会在文件名发生改变（或者一年之后缓存失效）时才会请求网络。 使用 webpac…"}, {"id": "6844903604126482440", "title": "如何让webpack打包的速度提升50%？", "desc": "随着前端应用包含的模块数量日益增长，代码打包的耗时也越来越长。公司很多项目打包耗时超过了10秒，对于一般人来说超过10秒的等待是比较难受的，虽然后续增量编辑的速度很快。于是我想结合实际开发环境提升一下首次打包的速度。 1. 实际开发环境 许多需求只涉及到js模块的修改，并不涉及…"}, {"id": "6844903935828819981", "title": "webpack编译流程", "desc": "中无主而不止，外无正而不行。——庄子 现在前端开发基本上都会用到react、vue，用到了前端mvc、mvvm框架，基本上都会涉及到打包发布，打包常用的工具就是webpack、gulp等等。经常使用自然也要了解一些他大致的流程也会方便使用。 Entry: 指定webpack开始…"}, {"id": "6977628582419890206", "title": "Webpack publicPath配置详解", "desc": "webpack publicPath配置详解 output.publicPath 概念： 表示资源(assets)被引用的根路径，在生产环境下生效；可以是相对路径，也可以是绝对路径； 该配置会为ind"}, {"id": "6844903635072057358", "title": "webpack编译速度提升之DllPlugin", "desc": "DllPlugin结合DllRefrencePlugin插件的运用，对将要产出的bundle文件进行拆解打包，可以很彻底地加快webpack的打包速度，从而在开发过程中极大地缩减构建时间。 结论先行：使用DllPlugin和DllRefrencePlugin进行构建，可以缩减5…"}, {"id": "6844903682434138119", "title": "一个极简版本的 VUE SSR demo", "desc": "我本人在刚开始看 VUE SSR 官方文档的时候遇到很多问题，它一开始是建立在你有一个可运行的构建环境的，所以它直接讲代码的实现，但是对于刚接触的开发者来说并没有一个运行环境，所以所有的代码片段都无法运行。那为什么作者不先讲构建，再讲程序实现呢？我觉得可能是因为构建、运行又重度…"}, {"id": "6844903624074592270", "title": "谁说前端需要懂 Nginx 了？ ", "desc": "读了上文发现内容虽然还是挺好的，但看完，为啥要懂nginx呀，负载均衡和前端哪里有什么半毛钱关系了，没说清楚呀。 当然这个面向前端做个科普文让大家多知道一项只是还是不错的，文章拉到最后面看了下作者的使用场景举例说起个 host 给让产品走查。 这篇内容很热，结合最近聊天群里总是…"}, {"id": "6896297476546887694", "title": "webpack之proxy代理配置", "desc": "webpack之proxy代理配置模拟接口（不走代理，直接请求本地的服务）"}, {"id": "6918988523773100040", "title": " Webpack 中 enhanced-resolve 路径解析流程详解", "desc": "webpack 使用 enhanced-resolve 进行路径解析。它的作用类似于一个异步的 require.resolve 方法，将 require / import 语句中引入的字符串，解析为引入文件的绝对路径。 在其官方文档中，将其描述为高度可配置，这得益于它完善的插件…"}, {"id": "6844903876798185479", "title": "基于Webpack/TypeScript/Koa的环境配置", "desc": "TypeScript是一种开源编程语言，在软件开发社区中越来越受欢迎。TypeScript带来了可选的静态类型检查以及最新的ECMAScript特性。 作为Javascript的超集，它的类型系统通过在键入时报告错误来加速和保障我们的开发，同时越来越多对的库或框架提供的type…"}, {"id": "6844903614352195597", "title": "[干货]如何使用webpack构建多页应用", "desc": "有兴趣的同学可以看下,内附详细注释,适合刚学习 webpack 的童鞋. 1.多个入口(entry),每个页面对应一个入口,理解为 js 资源. 2.多个 html 实例,webpack 使用html-webpack-plugin插件来生成 html 页面. 3.每个页面需要对…"}, {"id": "6844904160115064839", "title": "图解Webpack——基础篇", "desc": "输入为一个数组，但是入口文件最终只会形成一个chunk，输出出去只有一个bundle文件。 因为每个人写代码的风格不同，为了统一js文件的风格，规范代码，可以采用eslint-loader进行处理。"}, {"id": "6844904186539147272", "title": "webpack搭建vue项目实现脚手架功能", "desc": "在今天学习webpack搭建前端环境时候我们应该先熟知node有关的知识，用node.js来安装一个包。便于我们更好的理解。 Webpack 可以做到按需加载。像 Grunt、Gulp 这类构建工具，打包的思路是：遍历源文件→匹配规则→打包，这个过程中做不到按需加载，即对于打包…"}, {"id": "6844903941302386696", "title": "最新打包配置，webpack 4 配置 React 项目，同时配置DEV和PROD环境", "desc": "babel-loader把ES6甚至更高的版本，编译成ES5，这样浏览器就能解析了。 在这里可以除无用的 console.log()来减少文件的体积。 这个时候yarn dev，我们启动本地server，应该是成功的了。"}, {"id": "6930506568257503245", "title": "webpack入口执行流及调试", "desc": "如果webpack某个钩子是SyncBailHook类型，则可以在对应订阅事件中加入return true(只要不是undefined)，来告诉webpack后续的订阅事件不用运行。"}, {"id": "6903407108973133838", "title": "webpack之常用配置 （二）", "desc": "webpack.prod.js 生产环境不需要配置这个，即使配置了这个也是无作用的。 我们为什么要做代码分割呢？举个例子。 假设我们引入了一个lodash第三方库，它的大小是1MB，我们的业务代码也有1MB。此时不做任何处理最后打包生成一个main.js大小为2MB。用户打开浏…"}, {"id": "6844903721885777934", "title": "webpack性能优化(下)", "desc": "limit属性是在文件大小超出limit的值才会单独打包，否则使用base64 的方式引用通常适用于小图片，这就是我们通常的文件处理方式。 当然从我们实际项目的测试效果来看，我只能说这种处理方式并不算是很优秀，仅供参考。 而source map是为了帮助我们定位程序出现的错误对…"}, {"id": "6844903587244425230", "title": "vue cli 平稳升级webapck4", "desc": "应该是parcel出来以后\b，webpack团队意识到其配置确实有点复杂，\b不太容易上手。so, webapck4 开始支持0配置启动。\b\b不过，万变不离其宗，webpack4的\b0配置也只是支持了默认\bentry 和 output而已，即\b默认entry为./src,默认ou…"}, {"id": "6844903832682496014", "title": "基于webpack4.x项目实战3 - 手写一个cli", "desc": "我们参考一下vue-cli，来学习一下怎么写cli工具。 参考vue-cli,我们的这个脚手架叫webpack-multi-cli,是基于基于webpack4.x项目实战2 - 配置一次,多个项目运行这个demo来构建的。 如果没有传入项目名，或者传入的项目名称已经存在，则抛出…"}, {"id": "6844903558869942279", "title": "Webpack Loader源码导读之css-loader", "desc": "本篇是Webpack Loader源码导读系列中关于css-loader的解读，主要阐述loader的工作，及部份配置项作用。 无论是loader.js还是localsLoader.js，都会先解析loader选项，然后执行processCss编译css文件，他们的区别在于对编…"}, {"id": "6844903751946338312", "title": "配置webpack作为你新轮子的打包工具", "desc": "使用es5语法编写javascript，语法啰嗦冗长。 js代码全部写到一个文件中，没有模块化，项目难以维护。 需要手动使用压缩工具压缩代码。 所以打算使用webpack作为新轮子的打包工具。 期望使用es6语法编写插件代码，代码整洁易读。 支持模块化编程，项目代码划分清晰。 …"}, {"id": "6956894965490253861", "title": "webpack系列之模块化原理", "desc": "1、webpack是什么？ 2、webpack如何实现对各种不同JS模块规范的兼容处理？ 3、webpack如何实现对js类型文件之外的模块化处理的 4、webpack将打包资源文件并整合到一个包中之"}, {"id": "6975039917587955748", "title": "webpack基础", "desc": "是一个打包模块化JavaScript的工具，它会从入口模块出发，识别出源码中的模块化导入语句，递归 地找出入口文件的所有依赖，将入口和其所有的依赖打包到一个单独的文件中"}, {"id": "6844904022558654472", "title": "浏览器缓存策略与webpack持久化缓存", "desc": "浏览器通过请求头实现缓存，关键的请求头有cache-control，expires，last-Modified，ETag等。我们从时间和空间两个角度来看浏览器缓存。 浏览器发送第一次请求：不缓存，服务端根据设定的缓存策略返回相应的header，如：cache-control，e…"}, {"id": "6956553363521536031", "title": "webpack5入门", "desc": "Webpack 五大模块 小结:执行顺序为： 基础配置 小结: webpack配置文件,webpack.config.js loader 翻译官 图片打包中的options的一些可选配置项 常见问题 "}, {"id": "6844903773609918478", "title": "打包工具的配置教程见的多了，但它们的运行原理你知道吗？", "desc": "前端模块化成为了主流的今天，离不开各种打包工具的贡献。社区里面对于webpack，rollup以及后起之秀parcel的介绍层出不穷，对于它们各自的使用配置分析也是汗牛充栋。为了避免成为一位“配置工程师”，我们需要来了解一下打包工具的运行原理，只有把核心原理搞明白了，在工具的使…"}, {"id": "6844903504570515470", "title": "React, TypeScript 写游戏探索", "desc": "1. React的优势 如果渲染的多了结构复杂了,阅读就会十分困难。现在的代码风格就能够一目了然的看到所有运行的组件 2. React的劣势 其中子弹也可以继承至飞行物使得飞行物等可以衍生更多子类。React中各组件只能继承至React.Component,可采用HOC高阶组件…"}, {"id": "6844903928694308871", "title": "最小知识-webpack加载js/ts的顺序", "desc": "1. 创建并进入空文件夹，初始化package 2. 创建项目其他文件 3. 安装webpack 修改package.json，如下。执行 npm i 安装webpack 4. 配置webpack.config.js 5. 编译打包 执行完后，会在根目录创建一个 dist 的文…"}, {"id": "6844904118176202759", "title": "项目编译中 fastclick插件报错问题修复", "desc": "公司项目每次新导入重新编译的时候，fastclick总会报错，显示如下：之前在百度里面搜索了半天，才找到了解决方案修改node——module中@type下fastclick相应文件，详细可阅读git"}, {"id": "6844904190083350542", "title": "『Webpack系列』—— externals用法详解", "desc": "如果小伙伴有做过首屏加载时间优化，应该会遇到chunk-vendors.js这个文件，巨大无比，加载时间超长，是首屏加载时间过长的罪魁祸首之一。 下面通过一个实际的项目来演示，先通过插件webpack-bundle-analyzer来可视化地查看chunk-vendors.js…"}, {"id": "6957597810938085384", "title": "vue cli项目打包优化，我能做的就这些了", "desc": "- 了解项目vue cli webpack配置 - webpack构建相关优化 - webpack打包体积相关优化 - docker相关优化"}, {"id": "6968027732504477726", "title": "webpack打包用Babel处理es6", "desc": "今天来梳理下webpack中关于js打包的处理方式，首先我们都知道需要处理es6+的编译就要用到babel,那什么是babel呢？ Babel是JavaScript编译器，能将ES6代码转换成ES5代"}, {"id": "7002235722467901471", "title": "webpack5之HMR原理探究", "desc": "本文和大家主要分享Webpack的HMR源码分析和工作原理，在工作原理分析中，通过一张“webpack hmr工作原理图”图让大家对HMR整个工作流程有所了解。"}, {"id": "6940447269703385095", "title": "带你入门Webpack及它能干什么？", "desc": "初衷： 本文我们讲一下Webpack，说说它能干什么及为什么要使用它。把我整理的笔记分享给大家，如有错误请各位指出，不喜勿喷。 适合人群： 前端初级开发，大佬绕道。 本文讲解是Webpack4.x，注意版本。 在之前我们都是用传统的方式去开发一个系统，html、css、js，就…"}, {"id": "6987036612035084296", "title": "今天，我们来实现一个基础版的webpack", "desc": "本文已参与好文召集令活动，点击查看：后端、大前端双赛道投稿，2万元奖池等你挑战！ 前言 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler"}, {"id": "6844903671445061640", "title": "webpack4 多页面，多环境配置", "desc": "项目需求制作为新的app的分享页，故需要制作多页面应用，那既然app是新的，这边我们也要更新上，经过多方考察（度娘）下，综合了一些他人的优点并结合项目实况产生了此文。 本文省去了部分初级操作。 一. webpack.base.conf.js 基本上就是一些变量的引用，简单解释一…"}, {"id": "6844903687819640845", "title": "8102年如何写一个现代的JavaScript库", "desc": "理想很丰满，现实很。。。，如何才能够让开发者和使用者都能够开心呢，jslib-base通过babel+rollup提供了解决方案"}, {"id": "7000225935215558687", "title": "Webpack 中 file-loader 和 url-loader 的区别", "desc": "webpack 打包处理图片或字体路径问题之 file-loader 和 url-loader 使用区别"}, {"id": "6942251233868513293", "title": "【Webpack5实践】搭建好用React 开发环境(The Last)", "desc": "Hi~ o(*￣▽￣*)ブ这是 Webpack5 搭建 React nice的开发环境的最后一篇。由于上一篇主要拿来试水讲的可能比较浅，细节考虑的不是很到位，那么通过这篇来完善一下吧。干货还是可以的看完会有收获，建议边看边喝水。最近也是忙着搞埋点，我也不想咕咕咕（放各位鸽子），…"}, {"id": "6844903520378814471", "title": "简单易懂的 webpack 打包后 JS 的运行过程", "desc": "hello~亲爱的看官老爷们大家好~ 最近一直在学习 webpack 的相关知识，当清晰地领悟到 webpack 就是不同 loader 和 plugin 组合起来打包之后，只作为工具使用而言，算是入门了。当然，在过程中碰到数之不尽的坑，也产生了想要深入一点了解 webpack…"}, {"id": "6844903630554808334", "title": "不聊webpack配置，来说说它的原理", "desc": "最近在前端论坛闲逛，看到了一些讲parcel、webpack的文章，就突然很好奇，每天都在用的打包工具，他们打包的原理究竟是什么。只有知道了这一点，才可以在众多的打包工具里，找到最适合的那个它。在了解打包原理之前，先花一些篇章说明了一下为什么要使用打包工具。 前端产品的交付是基…"}, {"id": "7002929474232647694", "title": "在使用 vue-cli-service 的项目中配置 htmlWebpackPlugin.options.title", "desc": "这篇文章解决的是使用 vue-cli-service 搭建开发服务器和打包构建的项目，html 模板中 htmlWebpackPlugin.options.title 标题的配置问题。"}, {"id": "6844904186912473096", "title": "Webpack配置全解析（基础篇）", "desc": "Webpack凭借强大的功能，成为最流行和最活跃的打包工具，也是面试时高级程序员必须掌握的“软技能”；笔者结合在项目中的使用经验，介绍webpack的使用；本文是入门篇，主要介绍webpack的入口、输出和各种loader、plugins的使用以及开发环境的搭建，技术大佬请ct…"}, {"id": "6992116181343666213", "title": "uni-app多环境配置｜ 8月更文挑战", "desc": "uniapp自身的配置只区分了生产和非生产环境，但是实际开发以及部署过程中还需要区分多套环境以满足不同的需求。"}, {"id": "6844903802189905934", "title": "从零开始配置webpack(基于webpack 4 和 babel 7版本)", "desc": "webpack启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有Module.每找到一个Module,就会根据配置的Loader去找出对应的转换规则，对Module进行转换后，再解析出当前的Module依赖的Module.这些模块会以Entry…"}, {"id": "6888936770692448270", "title": "Webpack手写loader和plugin", "desc": "我们在Webpack基础篇介绍了多种loader和plugin以及每种的用途；那么他们两者在webpack内部是如何进行工作的呢？让我们手写一个loader和plugin来看看它内部的原理，以便加深对webpack的理解。 因此我们就来尝试写一个less-loader和styl…"}, {"id": "6981841495338778660", "title": "Webpack入门到精通 五（常用配置）", "desc": "初始化项目 package.json中添加 运行yarn build,就会看见当前打包好的dist.js文件 webpack build 支持IE 用babel-loader打包js babel-lo"}, {"id": "6844903795286081550", "title": "Webpack5.0 新特性尝鲜实战 🦀🦀", "desc": "在老袁写这篇文章的时候，v5版本仍然处于早期阶段，可能仍然有问题。而且作为一个major版本，其中有一些breaking changes，可能会导致一些配置和插件不工作。但这并无妨碍我们去开始对changelog上的新特性进行尝鲜实战。大家如果遇到什么问题可以移步到这进行反馈。…"}, {"id": "7003514369317273613", "title": "webpck 入门进阶", "desc": "webpck 基础配置 安装依赖 npm init -y yarn add webpack webpack-cli webpack-dev-server package.json 中配置 npm ru"}, {"id": "6947874570057547790", "title": "Webpack原理系列（一）HMR", "desc": "相信很多人都使用过WebPack的热更新或者叫热替换（Hot Module Replacement），它让浏览器做到当我们修改源代码之后能够实时预览到修改之后的效果，也就是说我们不用对浏览器进行手动刷新就能看到效果，这在我们的开发过程尤为重要。 就是当一个源码发生变化时，只需重…"}, {"id": "6844903588150378510", "title": "Vue打包优化之code spliting", "desc": "在http1的时代，比较常见的一种性能优化就是合并http的请求数量，通常我们会把许多js代码合并在一起，但是如果一个js包体积特别大的话对于性能提升来说就有点矫枉过正了。而如果我们对所有的代码进行合理的拆分，将首屏和非首屏的代码进行剥离，将业务代码和基础库代码进行拆分，在需要…"}, {"id": "6923038574682046478", "title": "bable-preset-env", "desc": "bable-preset-env，通过根据目标浏览器或运行环境自动确认所需Babel和polyfills，将es2015+转为es5。在没有任何配置的情况下bable-preset-env行为与bab"}, {"id": "6873376942486192135", "title": "一不小心就写了一个webpack plugin", "desc": "嗯。。。事情是这样的。 前段时间新启动的一个紧急项目经过我们小而美的团队不懈的努力，终于顺利上线了。后面review代码的时候发现这样的目录结构 container里面都是react的容器组件。定睛一看咋这么多。其实还没完呢，其中Doctor，Dss，Operator，Pati…"}, {"id": "6844904022214705159", "title": "webpack5快发布了，你还没用过4吗？", "desc": "webpack5 预计会在 2020 年年初发布，之前从 alpha 版本就有关注，本次重点更新在长期缓存，tree shakking 和 es6 打包这块。具体变更可以参考https://github.com/webpack/changelog-v5/blob/master/…"}, {"id": "6844903592122384397", "title": "vuepress踩坑记", "desc": "vuepress是尤大大4月12日发布的一个全新的基于vue的静态网站生成器，实际上就是一个vue的spa应用，内置webpack，可以用来写文档。恰好最近需要为一些组件写文档，就动手撸了一波，毕竟刚发布，遇到不少坑，最终还是磕磕碰碰的运行起来了，为了避免大家踩同样的坑，特意将…"}, {"id": "6844903600800399373", "title": "Webpack 配置详解（含 4）——关注细节", "desc": "熟悉 webpack 与 webpack4 配置。 webpack4 相对于 3 的最主要的区别是所谓的零配置，但是为了满足我们的项目需求还是要自己进行配置，不过我们可以使用一些 webpack 的预设值。同时 webpack 也拆成了两部分，webpack 和 webpack…"}, {"id": "6974802709673148423", "title": "webpack 源码笔记", "desc": "前言 为了了解清楚webpack的每个环节，及其对应的工作、使用的技术。最好能实现一个自己的打包器：不同类型模块的加载，不同loader，插件的使用 webpack 构建流程 初始化参数：根据命令窗口"}, {"id": "6844904007949877256", "title": "webpack踩坑记录", "desc": "当使用 webpack打包时，创建一个 html 文件，并把 webpack 打包后的静态文件自动插入到这个 html 文件当中，并且可以使用自定义的模版，例如html、pug、ejs，还可配置hash值等一些配置。 这在项目中的使用场景是把css文件在js文件中import进…"}, {"id": "6844903780777984008", "title": "webpack系列之四loader详解2", "desc": "上篇文章主要讲了 loader 的配置，匹配相关的机制。这篇主要会讲当一个 module 被创建之后，使用 loader 去处理这个 module 内容的流程机制。首先我们来总体的看下整个的流程： 在 module 一开始构建的过程中，首先会创建一个 loaderContext…"}, {"id": "6844904024353800199", "title": "webapck 性能优化", "desc": "1. 构建速度优化 由于 Loader 对文件的转换操作很耗时，所以需要让尽可能少的文件被 Loader 处理。可以通过 test/include/exclude 三个配置项来命中 Loader 要应用规则的文件。 vue.runtime.esm.js 中只包含运行时的代码。如…"}, {"id": "6844903711991398414", "title": "显微镜下的webpack4：灵魂tapable，终于搞懂钩子系列！", "desc": "大家在看webpack源码的时候，有没有感觉像再看天书，似乎没有办法一个文件比如webpack.js从头看到尾。感觉webpack的跳跃性很强，完全不知道程序在运行的时候，发生了什么。完全不清楚这个事件是什么时候发生的，比如loader是什么时候执行的，plugin又是什么时候…"}, {"id": "6844903545641107469", "title": "教你用webpack搭一个vue脚手架[超详细讲解和注释！]", "desc": "4.1 生成package.json文件,配置npm scripts. 6.1 该文件主要用来配置构建开发环境和生产环境差异化的参数. 7.1 此文件主要是webpack开发环境和生成环境的通用配置. 9.1 此文件主要用于构建生产环境的配置. #10. 创建 build/bu…"}, {"id": "6911561328423337992", "title": "Webpack4.0各个击破（5）module篇", "desc": "一. 模块化乱炖 脚本合并是基于模块化规范的，javascript模块化是一个非常混乱的话题，各种**【MD】**规范乱飞还要外加一堆【.js】的规范实现。现代化前端项目多基于框架进行开发，较为流行的框架内部基本已经统一遵循ES6的模块化标准，尽管支持度不一，但通过构建工具可以…"}, {"id": "6844904049276354567", "title": "使用 webpack 构建 chrome 扩展的热更新问题", "desc": "前不久我写了一个 chrome 扩展，作为一个前端弄潮儿，我当然想用上各种前端界最 fashion 的开发工具。于是乎，折腾到最后使用了 webpack + TypeScript + react 这么一套技术栈。在 github 上研究了几个模板项目之后，发现大多数都太初级了，…"}, {"id": "6844904110257340430", "title": "微前端时代如何做 JS 模块的动态加载", "desc": "微前端是2019年很火的一个话题，很多公司都分享了他们的微前端解决方案，个人觉得“微前端”这个名字还是比较贴切的，因为它的目标主要是对标后端的“微服务”，希望前端的巨石工程也能够拆分成小工程来更好地进行维护。笔者近期也在做微前端的工作，参考了业界的很多方案，有了自己的一些体会，…"}, {"id": "6844903554692448270", "title": "前端多项目模块化实践", "desc": "公司的业务以做项目为主，主打的是电商行业，因此也决定了很多项目其实存在一定的共性。目前公司业绩不错（年底应该会有大把money吧），经常多个项目并行，这也暴露了整个团队存在的问题： 组件目录components和页面目录pages类似，所以这里以components中的TabB…"}, {"id": "6899364112531193869", "title": "webpack如何优化？", "desc": "使用speed-measure-webpack-plugin，可以看到loader和插件的执行耗时。 使用webpack-bundle-analyzer，构建完成后会在8888端口展示大小。 概念：一个模块可能有多个方法，只要其中某个方法使用到了，则整个文件都会被打包到bund…"}, {"id": "6844903951821701128", "title": "细说webpack 5. webpack的常见配置(下)", "desc": "大家好！我是萝卜，上篇介绍了与 entry 和 output 相关的配置，这一篇将介绍 Webpack 其他重要配置。 Webpack 进行构建的时候会从入口文件（entry）开始遍历寻找各个模块的依赖，resolve 配置是帮助 Webpack 查找依赖模块的，通过 reso…"}, {"id": "6844903831931715598", "title": "必会webpack（一）--- 初识webpack", "desc": "本章只是简单的介绍了下webpack的简单使用，通过本章应该记住如何去构建一个webpack环境。接下来一章我会介绍如何使用Loader、使用Plugin、使用DevServer"}, {"id": "6844904067580297230", "title": "Webpack那些你不知道的事", "desc": "随着前端工程化的不断发展，构建工具也在不断完善。Webpack藉由它强大的扩展能力及万物皆模块的概念，逐渐成为前端构建工具中的小王子，随着webpack4的不断迭代，我们享受着构建效率不断提升带来的快感，配置不断减少的舒适，也许你已经可以熟练使用Webpack进行项目构建，但是…"}, {"id": "6844903727246098440", "title": "记一次Webpack配置文件的分离", "desc": "随着前端技术的发展，业务逻辑的增多及功能化的繁琐已经成为前端人员最烧脑的问题。前端自动化构建工具的出现，为前端人员带来了项目构建上的福音，成为每个前端工程师必回的技术栈，目前比较流行的Webpack以万物皆模块的思想构建我们的前端项目，同样也是笔者正在使用的一个前端自动化构建工…"}, {"id": "6844903545242648589", "title": "深入Webpack-编写Loader", "desc": "Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。 可以看出以上的处理过程需要有顺序的链式执行，先 sass-loader 再 css-loader 再 style-loader。 由上面的例子可以看出：一个 Load…"}, {"id": "6844903550623940621", "title": "Webpack原理-编写Plugin", "desc": "Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 Webpack 启动后，在读取配置的过程中会先执行…"}, {"id": "6844903645058695176", "title": "Webpack 中 css import 使用 alias 相对路径", "desc": "在用 Webpack 处理打包时，可将某一目录配置一个别名，代码中就能使用与别名的相对路径引用资源。 这样我们就可以在 js 文件中用形如 import tool from '@/utils/xxx' 的方式引用 /src/utils/xxx.js 文件，并且 Webpack …"}, {"id": "6905320663335043086", "title": "webpack-react-ts 构建前端项目", "desc": "错误2：webpack-cli/bin/config-yargs..."}, {"id": "6844904036282400775", "title": "【你应该掌握的】webpack4介绍&配置项详解", "desc": "作为一名前端开发，按时按质实现业务需求只是基础条件，了解一些webpack相关的配置，除了能够帮助我们提升一下自己的技术能力（不局限于满足业务需求），也能够帮助我们更好的维护项目、搭建适合自己团队的web站点。 希望通过本文能让大家对webpack4的相关配置项有一个直观的了解…"}, {"id": "6844903505669390343", "title": "基于 Nuxt 的 Vue.js 服务端渲染实践", "desc": "服务端渲染（Server Side Render）并不是一个新的概念，在单页应用（SPA）还没有流行起来的时候，页面就是通过服务端渲染好，并传递给浏览器的。当用户需要访问新的页面时，需要再次请求服务器，返回新的页面。 为了优化体验，开发者们开始选择采用 JavaScript 在…"}, {"id": "6954606400761200648", "title": "WebPack对ESMoudle和CommonJS 的不同处理", "desc": "ES6支持了原生的Moudle（简称：ESM）,在此之前前端的模块化主要依靠CommonJS。 两者在使用上的直观区别是语法不同，但在底层的处理方式是不同的，主要的区别在于两者作用的阶段不一样。 Co"}, {"id": "6844903586443296781", "title": "移动spa商城优化记（二）--- 减少70%的打包等待时间", "desc": "上篇讲了首屏优化，具体文章详见移动spa商城优化记（一）---首屏优化篇，这次来分享一下打包速度的一些优化经验，因为在实际项目开发中，随着项目的不断增大，依赖项不断增多，我们会发现webpack打包速度会越来越慢，有时候npm run一下可能出去上个厕所的时间都够了，在这快速发…"}, {"id": "6844904127252676622", "title": "凹凸极客沙龙 · 两位大咖即将免费直播啦", "desc": "由凹凸实验室主办的第二季极客沙龙《大咖面对面》即将开幕！我们邀请到了凹凸实验室的技术大咖来分享他们的宝贵经验。更有幸运观众可以获得与大咖直接对话的机会。本次沙龙将采用线上直播的方式，让你一睹大咖风采。还在等什么？速来报名围观。 极客沙龙由凹凸实验室主办。沙龙邀请凹凸实验室的资深…"}, {"id": "6844903830623092744", "title": "前端工程化（4）：http-proxy-middleware在多环境下的代理应用", "desc": "...... 是的，就是有这么多的环境等着你去访问它们。那么跑前端代码的时候如何才能与各个环境进行联调呢？最简单直接的办法就是修改proxy选项中的target，然后再重新执行开发脚本。这个方法在项目小的情况你还能忍受，如果项目大的话，过长的编译时间将直接消磨掉你的工作激情。 …"}, {"id": "6844903616512262151", "title": "前端常用开发工具的路径解析配置", "desc": "题注：本文是 Webpack CheatSheet | Webpack 基础与实践清单的一部分，项目代码可以参考 fe-boilerplate | 多技术栈前端项目模板。 毫无疑问，这样繁多的引用不可避免地会导致代码之间耦合度的增加，使得更难以重构或者优化。在适当地模块划分的基…"}, {"id": "6844903715346857997", "title": "webpack-dev-server 其实并不难", "desc": "我们都知道webpack是一个构建工具，但是在开发测试过程中，我们会经常修改代码后，然后频繁刷新页面查看效果，可惜我们就是厌旧重复工作的物种。 刚好webpack这个工具，提供了另外一个工具——webpack-dev-server，它可以帮我们从中解脱。 我们可以监听入口文件和…"}, {"id": "6946170979794190366", "title": "搭建前端工程化", "desc": "在我们日常开发项目时，基本上会采用官方脚手架进行开发。然后使用官方脚手架开发也有缺点：不能很好的自定义一些功能。下面我将总结出来我是如何从零开始搭建前端工程的，希望对大家有所帮助。 1. 工程化的目的 2. 工程化开发的流程 3. 编译工具的选择 3.3 编译typescrip…"}, {"id": "6844904105811378184", "title": "Webpack 实战入门系列（二）：插件使用及热更新打包", "desc": "今天带来webpack入门系列第二篇，如果对webpack还不熟悉的可以先看入门第一篇一小时入门webpack。本文重点是插件用法及热更新打包，会涉及三个知识点，都是比较基础重要的内容。包括：插件用法(HtmlWebpackPlugin)、文件监听、热更新打包。教程相关代码已经…"}, {"id": "6844904070927351822", "title": "从零搭建TypeScript与React开发环境", "desc": "平时进行开发大多数是基于vue-cli或者create-react-app等官方或者公司内部搭建的脚手架。 我们业务仔做的最多就是npm i和npm run dev或者npm start，然后在router文件夹上添加路由，在views或者pages文件夹中添加业务页面。这种快…"}, {"id": "6844903519896485901", "title": "全新打包工具-Parcel介绍", "desc": "快速打包 - 多核编译，以及文件系统缓存，即使在重新启动之后也能快速重新构建。 支持JS，CSS，HTML，文件资源等- 不需要安装任何插件。 在需要的时候自动使用Babel，PostCSS和PostHTML自动转换模块 - 甚至是node_modules。 零配置代码拆分，使…"}, {"id": "6901857258767351822", "title": "webpack之常用配置 （一）", "desc": "webpack目前是前端常用的工程化工具了。它可以帮助我们自动化构建打包各类的资源，极大的提高了我们打包代码的效率。在webpack看来，所有的资源文件都是模块(module),只是处理的方式不同。 建议不要全局安装webpack,因为不同的项目webpack的版本号是不一样的…"}, {"id": "6844903664079863822", "title": "前端项目框架搭建随笔---Webpack踩坑记", "desc": "只知道Webpack怎么拼怎么用的我。。被领导委托搭建移动端项目框架。。。 “得过几天想想。。搞不好咱们自己手写一套” “好的老板。一定完成任务” 熟练的打开PowerShell，把vue脚手架搞好，把多页面跟着教程配置好。 什么意思呢？如果我在src/page下创建一个pas…"}, {"id": "6957976536905416712", "title": "webpack5三种mode默认配置对比", "desc": "虽然webpack的文档中已经给出了三种模式默认的配置项的配置，但是我还是好奇除了这些列出的配置，是否还有其他的配置之间的差异呢？ 导出三种模式的配置对象 webpack的版本是V5.36.1"}, {"id": "6844904151147626510", "title": "假如用王者荣耀的方式学习webpack", "desc": "崴博.派克诞生于遥远西方的勇士之地，拥有着高超的机械技艺，善于运用各种工具来实现一些看似不可能完成的事。游历王者大陆时机缘巧合遇到了年轻的墨子，与之成为好友。后协助大宗师墨子建造了大陆第一雄城,被后人称为上古文明终结后最伟大的奇迹——长安！长安以“方舟”为驱动核心中枢，配合层出…"}, {"id": "6844903925179482119", "title": "webpack系列之七-文件生成", "desc": "经过前几篇文章我们介绍了 webpack 如何从配置文件的入口开始，将每一个文件转变为内部的 module，然后再由 module 整合成一个一个的 chunk。这篇文章我们来看一下最后一步 —— chunk 如何转变为最终的 js 文件。 上篇文章主要是梳理了在 seal 阶…"}, {"id": "6844903761853284365", "title": "如何利用webpack来提升前端开发效率（一）？", "desc": "create-react-app project vue create project等命令。 ... 可能大家在遇到上述开发场景时，可能就二话不说，直接开启编辑器，撸起袖子就是“代码一把梭”。 webpack 是一个现代 JavaScript 应用程序的静态模块打包器(mod…"}, {"id": "6963600982580133918", "title": "从0开始 使用webpack构建发布一个npm包", "desc": "背景 小A同学是个很热爱开发的技术仔，小B整天是个摸鱼的高手。有天小B遇到一个很棘手的逻辑，正好这个逻辑是小A刚写过的，小B表示能不能把代码分享给他，小A很慷慨的复制给他了。但是小C也不想重复造轮子，"}, {"id": "6844903582492426254", "title": "webpack4新特性介绍", "desc": "当下最流行的模块打包器 webpack 于2018年2月25日正式发布v4.0.0版本，代号legato。从官方的 发布日志 来看, 本次大版本更新带来了很多新特性更新和改善，这将会让webpack的配置更加简单。本文，笔者将会全面介绍webpack4的新特性及实践。 在发布日…"}, {"id": "6958977619723288590", "title": "【建议细读】从0到1手把手带你捋一套webpack+vue项目模板", "desc": "灵魂拷问 有小伙伴肯定会好奇的问，这都什么年代了？还自己搭建项目模板？你这不是瞎折腾么？使用vue-cli一条命令就搞定了，它不香么？ 为什么要自己搭建项目模板？ 从团队的角度 在团队中使得我们的项目"}, {"id": "6934621941232271368", "title": "以尽可能通俗易懂的方式看懂webpack-dev-server的热更新", "desc": "传统开发页面，每次更新的时候需要我们手动刷新浏览器才会更新。自从构建工具横空出世。我们可以通过热更新的方式来进行更新。通称HMR（hot module replacement），也就是模块热替换，当你每次需要更新代码的时候，不在需要手动刷新即可实现效果预览。 探究热更新是怎么实…"}, {"id": "6844903631045525518", "title": "Vue SPA项目优化小记", "desc": "之前做了一个React项目和Vue的项目，在做完后不加任何优化的情况下，这2个项目的首屏加载平均时间居然达到了20+s，好一点能进10s，差一点快30s，完全不能忍，优化势在必行，本文章记录下Vue项目的优化过程，React项目的优化后续补上。 上图是Vue项目的首页，整个项目…"}, {"id": "6999442216431124516", "title": "webpack如何打包CSS样式资源", "desc": "这是我参与8月更文挑战的第22天，活动详情查看：8月更文挑战 处理css都是用的loader来进行，具体使用如下： 1、处理CSS css-loader：识别import 和 url() 比如 imp"}, {"id": "6982870388116029453", "title": "webpack4流程分析8", "desc": "1.compiler 2.emitAssets 3.emitRecords1.compiler 2.emitAssets 3.emitRecords1.compiler 2.emitAssets 3."}, {"id": "6900934461660069902", "title": "webpack打包多页面，怎么按需分chunk", "desc": "前几天，同事在群里问了这么一个问题：一个 vue-cli 启动的项目，使用多页面打包方式，打包出两个应用a和b。a应用引入vant库ipunt组件，b引入vant库list组件。如果把vant打成一个单独的包，里面会既有input也有list，所以a应用加载了它并不需要的lis…"}, {"id": "6844903993530023950", "title": "编写自定义webpack插件从理解Tapable开始", "desc": "在上篇文章《Webpack源码解读：理清编译主流程》中，大体了解了webpack的编译主流程，其中我们跳过了一个重要内容Tapable。webpack 插件向第三方开发者提供了钩入webpack引擎中的编译流程的方式，而Tapable是插件的最核心基础。 本文首先分析Tapab…"}, {"id": "6884045019615854605", "title": "webpack5 文档解析(上)", "desc": "webpack是用于编译JavaScript模块。 一个文件依赖另一个文件，包括静态资源(图片/css等),都会视为依赖关系。 在webpack处理程序时，会在入口处，根据依赖关系进行处理，生成一个依赖关系图，最终将所有的文件打包成一个bundle。 当浏览器发起请求时，大大节…"}, {"id": "6994349673238495269", "title": "PostCss、Webpack中的file-loader、url-loader、asset module type", "desc": "引言：浏览器的兼容性，我们这里的兼容性是指对CSS、JS的兼容性，但是现在前端已经非常工程化，比如css可以用autoprefixer来给浏览器加前缀，就不用我们手动添加，但是这也会导致一个问题，我可"}, {"id": "6844903602822053895", "title": "babel-polyfill VS babel-runtime VS babel-preset-env", "desc": "其中涉及到的包执行一下npm install安装一下即可，这里就不赘述了。这里的部分包接下来会重复提到，说明为什么要这样装 babel-polyfill 是为了模拟一个完整的ES2015+环境，旨在用于应用程序而不是库/工具。并且使用babel-node时，这个polyfill…"}, {"id": "6984427331385294884", "title": "webpack试练02", "desc": "1、CleanWebpackPlugin 自动清除上次构建产物 2、多文件入口打包自动配置 3、css打包优化 px2rem-loader：自动转换成rem自适应显示比例变化 自动转换时还需安装lib"}, {"id": "6933126999951015949", "title": "webpack源码分析：打包规范", "desc": "  1.webpack简介    webpack是当下最热门的前端资源模块化管理和打包工具。简单来说，通过指定入口文件，按照依赖和规则，将许多松散的模块打包成符合环境部署的前端资源。   通过加载器（"}, {"id": "6844903655313768461", "title": "手把手教你用原生JavaScript造轮子（二）——轮播图（文章内容已过期，可不看）", "desc": "通过上一篇文章的学习，我们基本掌握了一个轮子的封装和开发流程。那么这次将带大家开发一个更有难度的项目——轮播图，希望能进一步加深大家对于面向对象插件开发的理解和认识。 老规矩，在写代码之前，我们需要对要开发的东西有个感性的认识，比如你可以先在脑中大致过一遍最终的项目效果是如何的…"}, {"id": "6997312318350573581", "title": "webpack-dev-server HMR内部逻辑", "desc": "仅仅通过配置hot hotOnly来开启（或者使用命令行参数 并且命令行参数的优先级更高） 记得在webpack早期版本中开启HMR还是比较繁琐，混乱的，各种的配置方式，有时候也各种不生效。 目前we"}, {"id": "6844904046294204429", "title": "「搞点硬货」从源码窥探Webpack4.x原理", "desc": "随着多终端设备的迅速普及，Web前端开发的复杂性和应用场景日益扩大，Webpack在前端构建演变的工程化浪潮中担当起了针对不同应用场景打包的大任。 如今，Webpack可谓是JavaScript社区最伟大的项目之一。 本文力争从源码层面窥探Webpack的实现原理。文中出示了核…"}, {"id": "6946094725703139358", "title": "webpack核心模块tapable源码解析", "desc": "上一篇文章我写了tapable的基本用法，我们知道他是一个增强版版的发布订阅模式，本文想来学习下他的源码。tapable的源码我读了一下，发现他的抽象程度比较高，直接扎进去反而会让人云里雾里的，所以本文会从最简单的SyncHook和发布订阅模式入手，再一步一步抽象，慢慢变成他源…"}, {"id": "6844903888319954952", "title": "webpack是如何实现动态导入的", "desc": "在单页应用中，经常使用 webpack 的 动态导入 功能来异步加载模块，从而减少部分文件的体积。我们可以通过webpack 提供的 import() 和 require.ensure 两个 API 来使用该功能。由于两个方法根本实现都是相同的，本文的示例都基于 import(…"}, {"id": "7005194442478977061", "title": "webpack 4.X - 构建流程", "desc": "webpack 构建流程, webpack 模块化管理工具和打包工具。通过 loader 的对任何形式的资源转换，任何形式的资源都可视为模块，比如：CommonJS 模块、AMD 模块、ES6模块.."}, {"id": "6844903907810869261", "title": "webpack输出文件分析以及编写一个loader", "desc": "webpack是时下最流行的前端打包构建工具，本质上是一个模块打包器，通过从入口文件开始递归的分析寻找模块之间的依赖，最终输出一个或多个bundle文件。 将生成的内容根据配置生成文件，输出到指定的位置。 webpack的核心对象是Compile，负责文件的监听和启动编译，继承…"}, {"id": "6844903719335624711", "title": "《从零构建前后分离的web项目》：前端完善 - 手把手教你快速构建网站布局", "desc": "本文为方便讲述重构去除了 Element、vux 库，用了最近比较火的 bulma 轻量、快捷、易读。 首先，似上图，我们思考把一个小型网站拆成三部分：页头(Header)、内容(Content)、页脚(Footer) 这几乎每个网站内都必须有的，通常把万年不变的：页头(Hea…"}, {"id": "6934216388722556936", "title": "Webpack5 配置手册", "desc": "则是生成的页面中对图片路径的引用时，加上publicPath,这样访问时姐可以放到文件的正确地址了。 外部postcss.confgi.js配置文件的配置方式。注意：还需要在package.json中定义browserlist"}, {"id": "6844903687232421902", "title": "基于vue-cli3.0构建功能完善的前端架子", "desc": "vue-cli3 最大的特点就是零配置，脚手架把webpack相关的配置都隐藏在@vue\\preload-webpack-plugin中，默认的配置可以满足大部分应用场景，优点是我们可以节省很多折腾配置的时间，webpack对于新手来说，还是有点门槛的，这样一来，新人上手可以更…"}, {"id": "6844903765745598472", "title": "【手把手带你配 webpack】第一步, 做一个高级前端工程师", "desc": "webpack 顾名思义, web 应用的 pack(打包) 工具. 举个栗子, 假如你出门旅行需要携带各种各样的随身物品, 怎么办咧? 一个背包搞定. 所有的随身物品打包到背包里, 管他充电器还是充电宝, 杜蕾斯还是冈本全都一步到位... 早期的 web 应用相对单调, 网页…"}, {"id": "6844903780337582088", "title": "使用 happypack 提升 Webpack 项目构建速度", "desc": "本文简单介绍了 Happypack 的简单使用，不了解的同学可以进来看一看。也许会有所帮助。 在使用 Webpack 对项目进行构建时，会对大量文件进行解析和处理。当文件数量变多之后，Webpack 构件速度就会变慢。由于运行在 Node.js 之上的 Webpack 是单线程…"}, {"id": "6999848851569901582", "title": "深入 Webpack5 等构建工具系列二(9) - postcss 在 webpack 中的使用", "desc": "这是我参与8月更文挑战的第22天，活动详情查看：8月更文挑战 上一篇文章最后，我们使用的是命令行工具来对 css 进行处理，但是，如果项目中有很多地方（文件）都用到了 css，而且这些 css 需要添"}, {"id": "6946024729526403108", "title": "Webpack4升级Webpack5 IE兼容性问题", "desc": "webpack4升级到webpack5，打包后在google上正常运行，IE11报错 记录两个兼容性问题的坑"}, {"id": "7000657572512399397", "title": "关于webpack重构建的问题跟踪 ", "desc": "问题描述: 本地组件库修改后，使用yalc publish发布； 在项目中执行yalc update更新组件库； 问题： webpack有重新构建，但构建后的内容没有变更 调试跟踪 webpack/l"}, {"id": "6844903581582098446", "title": "从babel讲到AST", "desc": "babel的过程：解析——转换——生成。 比如我们在读一句话的时候，我们也会做分词操作，比如：“今天天气真好”，我们会把他切割成“今天”，“天气”，“真好”。 那换成js的解析器呢,我们看一下下面一个语句console.log(1);,js会看成console,.,log,(,…"}, {"id": "6844903679607177229", "title": "webpack4打包vue前端多页面项目", "desc": "之前一直用的脚手架，这次自己搭建webpack前端项目，花费了不少心思，于是做个总结。 public文件夹存放一些静态文件，src文件夹存放源码。每个页面通过一个入口文件（page1.js，page2.js,..）生成vue实例，挂载到插件生成的html文件的#app元素上。 …"}, {"id": "6844903848977367048", "title": "webpack4 SplitChunks实现代码分隔详解", "desc": "Webpack 4给我们带来了一些改变。包括更快的打包速度，引入了SplitChunksPlugin插件来取代（之前版本里的）CommonsChunksPlugin插件。在这篇文章中，你将学习如何分割你的输出代码，从而提升我们应用的性能。 SplitChunks插件(webpa…"}, {"id": "6844904198023168013", "title": "『Webpack系列』—— SplitChunks插件用法详解", "desc": "SplitChunks插件是什么呢，简单的来说就是Webpack中一个提取或分离代码的插件，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件。 提到前端优化，提取公共代码是必不可少的手段。在Webpack出现前，提取公共代码是人为去处理，而Sp…"}, {"id": "6993577544725495839", "title": "从零开发一个模块化打包工具", "desc": "前言 构建打包是前端工程化领域的关键组成之一。作为一名前端开发者，对构建打包工具的认知，是绕不过去的一道坎。构建工具帮助前端流程化，自动化，更对前端各大框架有着深远的影响，大多数前端框架已经深度依赖编"}, {"id": "6844903582651645965", "title": "webpack4之高级篇", "desc": "HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack"}, {"id": "6992204355571023903", "title": "前端小白不迷路，今天聊聊工作中遇到的环境变量", "desc": "刚参加工作的时候，production、 development，发生产等变量名词傻傻搞不清楚，走了很多弯路，今天小白不迷路，一起来搞懂它！"}, {"id": "6844903925473099784", "title": "webpack自动化集成雪碧图并压缩方案 postcss-sprites", "desc": "一、目标二、图片合并工具postcss-sprites三、图片压缩工具image-webpack-loader四、如何体验点击查看Github完整Demo1、安装与启动2、页面展示五、postcss-"}, {"id": "6922994687175294984", "title": "Webpack入门之使用Webpack打包Vue文件", "desc": "3. 继续安装 yarn add babel-loader @babel/core @babel/preset-env -D 之前的项目中都没有写入CSS代码，webpack编译CSS代码需要css-loader和style-loader。 到此这篇文章的主题内容就结束了。 做…"}, {"id": "6931278186722361358", "title": "webpack基础学习笔记", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，当 webpack 处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。 从入口文件开始，分析整个应用的依赖树…"}, {"id": "6948728184976179237", "title": "webpack tapable啥玩意？", "desc": "刚才打开了webpack官网，api下发现webpack竟然有辣么多～的钩子，可以看到每一个钩子下方都会显示自己的钩子类型，这些钩子类型就是tapable提供的。而webpack也是靠这些钩子实现了复杂的功能，我们先来瞧一瞧这些钩子是咋用的，再去看webpack源码吧（🤦‍♀…"}, {"id": "6844904047229550605", "title": "webpack 4 源码主流程分析（六）：构建 module（上）", "desc": "这里触发 normalModuleFactory.hooks:createModule，如果钩子里没有项目配置的自定义 module，则使用 webpack 生成的 module。 得到 module 实例，接着触发 normalModuleFactory.hooks:modu…"}, {"id": "6844903604856291335", "title": "原汁原味的配方:「微信小程序支持 NPM」", "desc": "微信小程序本身不支持 npm 包的使用，目前市面上很多框架也有了相对应的解决方案。 本文旨在为那些不愿意引入第三方框架， 想在小程序环境中写原汁原味代码的人（例如我），提供一种解决问题的思路。 在现代的 Web 开发中，我们对 Webpack 已经再熟悉不过了，简单理解，它就是…"}, {"id": "6906089118447435784", "title": "webpack系列之16个常用的插件", "desc": "webpack 是个很强大的构建工具，其丰富灵活的配置决定了使用也不简单。在面试中经常能遇到 webpack 相关的问题，如果平常只是使用脚手架如 vue-cli 而没有好好深入学习研究 webpack 的话，估计答不上什么。我相信，如果没有深入了解，部分面试官也问不出什么。可…"}, {"id": "6844904069794906120", "title": "Webpack源码分析 - 入口Entry", "desc": "Webpack的执行流程思想非常简单，从入口文件开始，递归地查找文件的依赖，最终将所有依赖输出到一个文件中。在这过程中又穿插了文件解析、输出优化等复杂的操作，我们就从最简单的入口开始，逐渐剥茧抽丝，拨开webpack的神秘面纱。 配置是衡量一个系统灵活性的主要标识，我们在使用某…"}, {"id": "6844903869554638856", "title": "Webpack介绍和使用(配置环境变量，打包依赖)", "desc": "webpack是一个前端模块化打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。主要由入口，出口，loader，plugins四个部分。 Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则…"}, {"id": "6844903768044077063", "title": "一个合格的Webpack4配置工程师素养：第二部分", "desc": "我们给打包的文件打上hash是为了解决缓存更新问题，常见需要打上hash的地方有。 但是打上hash我们怎么引入是一个问题。 html-webpack-plugin插件可以把js/css注入到一个模板文件, 所以不需要再手动更改引用。 设置一个模板文件。 我们会发现每次打包后d…"}, {"id": "6844903762641813511", "title": "一起来燃烧 Bundle 的“卡路里”", "desc": "编者按：npm 为前端 er 带来了诸多便利，我们只需敲上一条安装语句，便能用上别人精心开发的各种精品库。但你有没有发现，你的应用悄悄地吃成了个“大胖子”？今天，我们请来 Google Web 的工程师 Djirdeh 带你科学“瘦身”，去掉那些“多余的热量”🔥。 npm 使…"}, {"id": "6844903821571784718", "title": "webpack4配置(1)-打包一个js文件", "desc": "两者的区别：-D只在开发环境中使用，如loader,babel等；-S在生产环境和开发环境中都要使用，如Vue,jquery等。 npm为5.x版本以上的话，会生产node_modules文件夹和package.lock.json文件。 我们手动来配置一下。打开webpack.…"}, {"id": "6844903830237216775", "title": "最全的前端模块化方案", "desc": "模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。将一个复杂的系统分解为多个模块以方便编码。 如果没有写后缀名Node会尝试为文件名添加.js、.json、.node后再搜索。 .js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本…"}, {"id": "6844903568525230087", "title": "webpack深入——使用篇（二） | 席小白的边缘世界", "desc": "水平有限，欢迎批评指正 目录： webpack深入 ——使用篇（一） 在我们打包项目时，除了js文件之外，还有许多其他类型的文件，比如css，less，ts以及图片等资源都是需要打包进去的，webpack默认是不识别其他类型的文件或者说是模块的，是通过 各种不同的loader…"}, {"id": "6914814040711626765", "title": "webpack系列学习-各种loader使用", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 可以下载调试。"}, {"id": "6844903502804697095", "title": "翻译 | 关键CSS和Webpack: 减少阻塞渲染的CSS的自动化解决方案", "desc": "\"消除阻塞渲染的CSS和JavaScript\"。 这一条Google Page Speed Insights的建议总让我困惑。 当一个网页被访问时，Google希望它仅加载对初始视图有用的内容，并使用空闲时间来加载其他内容。这种方式可以使用户尽可能早地看到页面。 我们可以做很多…"}, {"id": "6844904031458951182", "title": "有意思的webpack——tree-shaking", "desc": "首先，我们来看一张图。（很形象，借用别处） 如图所示，我们的js文件就相当于这棵树，tree-shaking就相当对摇动这个操作，目的是让枯黄的叶子和坏掉的苹果掉下来。说到这里，tree-shaking的原理就是，通过摇动我们的js文件，剔除掉DCE（Dead Code Eli…"}, {"id": "6844903983094431758", "title": "一个自动生成vue路由文件的webpack插件", "desc": "生成路由文件应在所有事情开始之前执行，webpack提供的生命周期钩子实在太多，这里就挑了一个最靠前的afterPlugins，有兴趣的可以看下这张完整的生命周期图。 fs模块的promise语法写起来舒服多了。 webpack内容实在太多，文档写的也不是很清楚，有些钩子的说明…"}, {"id": "6844903952870440968", "title": "Webpack 之 basic chunk graph", "desc": "有以下文件 a.js / b.js / c.js / d.js 以及 webpack.config.js, 其中 a.js 为入口文件，它们之间的依赖关系如下图，实心箭头代表异步加载。 chunkGroup：一个 chunkGroup 可以包含多个 chunk，可以通过 chu…"}, {"id": "6844904084797915143", "title": "webpack你必须知道的那些事儿", "desc": "webpack并不强制你使用某种模块化方案，而是通过兼容所有模块化方案让你无痛接入项目。有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，webpack会帮你处理好的。 正如js文件可以是一个“模块（module）”一样，其他的…"}, {"id": "6844903588775329799", "title": "深入浅出Webpack", "desc": "Entry:入口,Webpack执行构建的第一步将从Entry开始，可抽象成输入。 Module:模块,在Webpack里一切皆模块，一个模块对应一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块。 Chunk:代码块，一个Chunk由多个模块组合而成，用于…"}, {"id": "6847902219418009607", "title": "DLLPlugin 和 DLLReferencePlugin的使用", "desc": "可以看到npm run build后的时间大幅度减少，在dist打包体积上也比之前的小。在项目优化中，可以很大程度上加快项目的构建速度和减少项目的打包体积。"}, {"id": "6844903816165326856", "title": "Webpack源码基础-Tapable从使用Hook到源码解析", "desc": "当我第一次看webpack源码的时候，会被其中跳转频繁的源码所迷惑，很多地方不断点甚至找不到头绪，因为plugin是事件系统，没有明确的调用栈。这一切都是因为没有先去了解webpack的依赖库Tapable。 Tapble是webpack在打包过程中，控制打包在什么阶段调用Pl…"}, {"id": "6844903808397475847", "title": "webpack学习(四) -- css tree shaking", "desc": "css抖动一定要放在js之前，否则会报错。"}, {"id": "6844904199197556750", "title": "CMS 公共模块打包实践", "desc": "最近新搭建了两个 CMS (内容管理)系统，为了减少开发切换项目成本，和降低用户使用成本，两个系统使用了统一的脚手架 antd-pro。 在功能开发的过程中发现，两个系统之间存在很多相同的功能、逻辑。可能 A 项目写一下，后面 B 项目需要同样的实现又得再写一遍。 例如登录页面…"}, {"id": "6888594303447531527", "title": "聊聊 webpack 异步加载（一）：webpack 如何加载拆包后的代码", "desc": "前端代码在使用​webpack​进行打包时，经常会做两种优化：把稳定的库代码（如​react​、​antd​等）与业务代码分离，业务代码的更改不影响用户本地的库代码缓存，同时也把一个大文件拆分成多个文"}, {"id": "6844903535436365838", "title": "Webpack自动化构建实践指南", "desc": "由于现在的博客是使用wordpress搭建，自己得经常修改过一些代码，但是修改第三方源码真的比较痛苦，于是决定计划开始使用React + Node.js / Python开发新博客项目，最终替换当前博客代码，方便以后博客的维护和更新，也能实现自我开发技术，架构设计，解决问题能力…"}, {"id": "6946571793570365454", "title": "Webpack相关知识点总结（基础，性能优化）", "desc": "随着前端的不断发展，前端进入了模块化开发的时代，同时也产生了各种高阶的支持能力，比如TS（Typescript），Less，Sass等，这些是不能直接被浏览器识别的，我们需要借助工具将其转化为浏览器能识别的代码再进行部署，由此便产生了编译打包工具，例如Webpack，rollu…"}, {"id": "6844903551613960206", "title": "webpack模块化实现探究", "desc": "我们都知道，浏览器是无法识别commonjs规范的模块和es6 module的。将这些规范的模块转化为浏览器认识的语句就是webpack做的最基本事情，webpack 本身维护了一套模块系统，这套模块系统兼容了所有前端历史进程下的模块规范，包括 amd commonjs es6…"}, {"id": "6844903589643550728", "title": "webpack-loader详解", "desc": "Loader有些场景下还需要返回除了内容之外的东西。 Loader 有同步和异步之分，上面介绍的 Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。 但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用…"}, {"id": "6960997197030621215", "title": "Webpack 总结", "desc": "Webpack 总结，包括基本配置，高级使用，以及对webpack打包构建速度和打包产出代码的一系列优化！"}, {"id": "6960837282316173342", "title": "vue2老项目webpack打包架构升级", "desc": "老的vue2项目对webpack打包以及相应依赖升级的解决过程，并不是采用常用的手动升级依赖的方式，而是采用vue-cli提供的server服务进行移植升级"}, {"id": "6844903632974905351", "title": "Webpack 提取公共代 CommonsChunkPlugin", "desc": "1. 相同资源重复加载引用，浪费用户流量以及服务器成本； 2. 每个页面需要加载的资源太多，导致网页首页加载缓慢； 1. 相同资源只打包加载一次，减少网络传输流量，降低服务器压力； 2. 页面加载速度加快，提交用户体验； 1. 根据项目使用的技术栈，把所有页面都要使用到的基础库…"}, {"id": "6903529588271136782", "title": "Webpack学习笔记二：Webpack初体验", "desc": "开始之前，切换到存放项目的路径，在本地目录下初始化一个node项目，本文是在 webpack-study 目录下。初始化的命令如下： 根据步骤设置下项目名称等一些基础信息，其他的步骤按照默认配置一路回车到底即可。创建完成后，在 webpack-study 目录下会生成最基本的p…"}, {"id": "6915664669185474574", "title": "webpack优化生成代码（1）", "desc": "tree shaking 是 webpack 里的术语，用于移除 JS 上下文中未引用过的代码，以减小代码体积，间接减少代码在网络请求过程中的耗时。我把这个称为代码清洁工。需要注意的是 tree shaking 依赖于 ES6 的模块语法 —— import和export。 经…"}, {"id": "6844903550921736206", "title": "从搭建vue-脚手架到掌握webpack配置（三.多页面构建）", "desc": "postcss官方的GitHub上还有中文的介绍。 简单来说postcss就是一个css的转换器，有了postcss或许你就不用再用less和sass了，通过在postcss上添加插件可以组装出你需要的语法需求和功能（属性变量，父子嵌套，版本兼容等），在postcss上通常会用…"}, {"id": "6940953295477276702", "title": "webpack5搭建vue3(二)", "desc": "这时候我们到根目录下按住shift 加鼠标右键， 选择在此处打开命令窗口， 输入 yarn dev,敲回车,等待项目启动，这时候不出意外应该会报错。报错信息应该是这样子的。 这是因为缺少@vue/compiler-sfc, 这时候我们安装一下他。 之所以要安装它，是因为我们的v…"}, {"id": "6877825861379162125", "title": "深入了解webpack原理（上）", "desc": "本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个…"}, {"id": "6886404950507831309", "title": "Webpack 的插件机制 - Tapable", "desc": "上述代码定义了一个同步串行钩子，并声明了接收的参数的个数，可以通过hook实例对象（SyncHook本身也是继承自Hook类的）的tap方法订阅事件，然后利用call函数触发订阅事件，执行 callback 函数，值得注意的是 call 传入参数的数量需要与实例化时传递给钩子类…"}, {"id": "6844904167429898253", "title": "从0开始的Webpack - 写Demo用的简单配置", "desc": "如今的前端，必定都用过Vue或者React，多多少少都有接触过webpack，我还清楚地记得第一次看Vue的Webpack配置时，仿佛在看天书一般。webpack作为前端工程化的核心知识之一，因为其功能太多，配置项又多又杂，初学时也比较难啃。 这是一个面向初学者的webpack…"}, {"id": "6844903953797234695", "title": "认识webpack原理-万物皆可打包", "desc": "Webpack把一切都当作模块，当webpack处理应用程序时，根据给定的一个主文件，递归的构建一个关系依赖图。其中包含应用程序需要的每一个模块，然后把这些模块打包成一个或多个包。 Loader: Webpack把一切文件都视为模块，但是原生的js只能解析js文件，如果其它文件…"}, {"id": "6844903684472569864", "title": "小程序多业务线融合【完整分包业务接入】", "desc": "因为我们这条业务线小程序是用mpvue构建的（整个项目也是通过mpvue的cli生成的），所以后面相关配置都是以mpvue为例，如果是wepy项目基本也大同小异。 登录问题，推荐和主程序使用同样的cookie名称，这样可以通用一套用户信息，免得双方各维护一套，还能避免重复授权。…"}, {"id": "6844903623688880136", "title": "基于webpack工程化的思考", "desc": "本文章是在基于webpack多入口配置工程并且项目需要持续迭代作为基础去讨论的，单页面不作讨论。文章适合对webpack有一定了解的人看，主要讨论工程化中关于缓存利用率的问题。 在webpack中，我们通常会打包一个vendor和一个common文件作为基础包，vendor通常…"}, {"id": "6930613066866524173", "title": "一字一句的搞懂vue-cli之vue webpack template配置", "desc": "webpack--神一样的存在。无论写了多少次，再次相见，仍是初见。有的时候开发vue项目，对尤大的vue-cli感激涕零。但是，但是，但是。。。不是自己的东西，真的很不想折腾。所以，我们就得深入内部，cp them us。所以呢，就利用两天时间，参考了一些他人的文章，查阅了一…"}, {"id": "6921860461491126286", "title": "webpack系列学习-使用eslint和发布npm包", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 可以下载调试。"}, {"id": "6844903878215860231", "title": "Webpack 4 构建大型项目实践 / 开发服务", "desc": "本节就将通过使用 webpack-dev-server 来解决这个问题，并且在体验上会比以前更好，因为连刷新浏览器都不需要你做了。 在介绍 webpack-dev-server 之前，我们其实还有一种不完善的方法来处理开发环境调试的问题，那就是 Webpack 的 watch …"}, {"id": "6844903847748435981", "title": "Webpack入门到精通（1）", "desc": "什么是webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将…"}, {"id": "6954386977063960612", "title": "Webpack——【入门篇-中篇】", "desc": "本系列为Webpack——入门篇，跟着此文档，可轻松入门webpack，分为上篇、中篇、下篇；此篇为中篇"}, {"id": "6844903860285210638", "title": "傻傻分不清的Manifest", "desc": "CACHE MANIFEST指定需要缓存的文件，第一次下载完成以后，文件都不会再从网络请求了，即使用户不是离线状态，除非tc.mymanifest更新了，缓存清单更新之后，才会再次下载。标记了manifest的html本身也被缓存 FALLBACK指定了一个后备页面，当资源无法…"}, {"id": "6844903832485363726", "title": "webpack探索---从零搭建一个vue项目", "desc": "最近感觉自己越来越像一个API调用程序员，很多基础的原理以及项目构建都没实际操作过，所以这里动手自己去搭建了一个vue项目，从webpack配置到vue配置，以及构建的优化，虽然写得并不好，但是自己在这个过程中也学到了一些东西，以此记录。 这个时候如果在index.html中引…"}, {"id": "6844903541450997768", "title": "Webpack实战-加载SVG", "desc": "SVG 作为矢量图的一种标准格式，已经得到了各大浏览器的支持，它也成为了 Web 中矢量图的代名词。 SVG 相对于位图更清晰，在任意缩放的情况下后不会破坏图形的清晰度，SVG 能方便地解决高分辨率屏幕下图像显示不清楚的问题。 在图形线条比较简单的情况下，SVG 文件的大小要小…"}, {"id": "6844903641522896909", "title": "多页项目的webpack配置", "desc": "在我们使用vue，angular等框架开发的时候，大多数都是构建单页项目。而且，像这样的框架都有对应的命令一步生成webpack配置（比如vue的vue init webpack my-project之类）。 但是如果我们要开发多页面项目的时候就没有这么方便了，你必须要自己配置…"}, {"id": "6920541421401276429", "title": "关于Gzip", "desc": "gzip是一种压缩文件格式并且也是一个在类 Unix 上的一种文件解压缩的软件。在基于 HTTP 协议的网络传输中，gzip是一种在万维网中加速传输HTML和其他内容的技术 *（gzip通过减小文件体积，去节省带宽和加快传输速度。）*。它是在 RFC 2016 中规定的三种标准…"}, {"id": "6844904017647124488", "title": "webpack 项目优化实践", "desc": "这个文件以前没有注意到，这次看到不知道为什么会有这个js文件，不知道是用来做什么的，项目中并没有引入这个js文件。 这个是devtool的引入的js，如果没有安装devtool就不会引入这个js，所以这个不需要优化。 可以看到dllself这个文件压缩后，还有差不多311kb，…"}, {"id": "6844903501751926797", "title": "Webpack中的静态资源文件指纹", "desc": "本文讲解了在webpack中如何给静态资源加hash值：每次构建过程都会生成一个新的hash，所以一般用于做版本控制；chunkhash是基于内容生成的，但是webpack把所有类型的文件都以js为汇聚点打成一个bundle，改了css也会导致整个js的hash发生改变..."}, {"id": "6844903936072089607", "title": "页面加载编译优化", "desc": "前言这是项目优化中的一小部分但是我举得比较适用并且有效的在优化页面加载时间我之前已经做了一下的这些事使用lighthouse，观察需要优化的有哪些着手点使用前端监控，观察用户实际的效果优化方向网络层面"}, {"id": "6886725301292761095", "title": "解决webpack开发环境绝对路径接口跨域问题", "desc": "在开发的时候，如果我们需要从子域名或者其他网站获得数据接口，可能会碰到跨域问题，这个时候常用的做法是修改hosts文件，或者配置一个反向代理服务器，难免有些麻烦，而且有时候需要测试的接口是开发环境的，就更加繁琐了。本来想用webpack-dev-server的反向代理来实现，发…"}, {"id": "6844903544542199821", "title": "Webpack原理-输出文件分析", "desc": "本节将解释清楚以上问题。 bundle.js 能直接运行在浏览器中的原因在于输出的文件中通过 __webpack_require__ 函数定义了一个可以在浏览器中执行的加载函数来模拟 Node.js 中的 require 语句。 原来一个个独立的模块文件被合并到了一个单独的 b…"}, {"id": "6976184787971244045", "title": "Webpack(一)", "desc": "这是我参与更文挑战的第10天，活动详情查看： 更文挑战 来啦来啦，接day9 1. 作用： 打包：可"}, {"id": "6844903694215938062", "title": "React最佳实践尝试（二）", "desc": "配置完成之后，接下来就要考虑打包启动以及前后端同构的架构方面的问题了。 首先我的整体思路是：根据webpack.ssr.config.js配置文件，将前端代码打包进node层供node做SSR使用，然后前端正常启动webpack-dev-server服务器即可。 这样基本上we…"}, {"id": "6885373663382601742", "title": "手摸手教你配置webpack", "desc": "相信很多童鞋在面试的时候经常会被问到\"自己有没有手动配置过webpack\", \"webpack基础配置\"等问题。通过本篇文章带你了解常用的webpack基础配置(此文章基于react技术栈)。 1. webpack相关依赖包 2. babel相关依赖包 3. 样式处理相关依赖包…"}, {"id": "6844903924818771981", "title": "深入理解webpack的chunkId对线上缓存的思考", "desc": "想必经常使用基于webpack打包工具的框架的同学们，无论是使用React还是Vue在性能优化上使用最多的应该是分包策略（按需加载）。按需加载的方式使我们的每一个bundle变的更小，在每一个单页中只需要引入当前页所使用到的JavaScript代码，从而提高了代码的加载速度。但…"}, {"id": "6917271313350721549", "title": "总会遇到那么几个库是ES6的代码， 怎么办？｜七日打卡", "desc": "前几天，笔者把项目里的query-string升级到v6的版本，为了里面一些新特性（比如，字符串的'1'转成数字1）。今天，测试同事和我说，移动端低版本的浏览器跑不起来，我看了报错，发现是编辑完的代码里有箭头函数，心想简单，把query-string纳入babel的编译范围即可…"}, {"id": "6844903618059960328", "title": "使用模块化工具打包自己开发的JS库", "desc": "小程序的模块化采用了Commonjs规范。也就是说，我需要提供一个monitor.js文件，并且该文件需要支持Commonjs，从而可以在小程序的入口文件app.js中导入： 但是考虑到代码量，为了降低耦合度，我还是倾向于把代码拆分成不同模块，最后把所有JS文件打包成一个mon…"}, {"id": "6844903880073936904", "title": "vuecli3项目中webpack4配置（四）懒加载及Prefetch/Preload", "desc": "懒加载或“按需”加载是优化站点或应用程序的一个好方法。这种实践基本上涉及到在逻辑断点处拆分代码，然后在用户完成需要新代码块的操作后加载它。这会加速应用程序的初始负载，并减轻其整体重量，因为某些块甚至可能永远不会加载。懒加载并不是webpack才有的，只不过是webpack支持这…"}, {"id": "6913428479069388807", "title": "Webpack从手把手配置到原理浅析(三)：基本概念", "desc": "其中左边部分可以理解为module，就是各个源码文件，webpack的世界中，一切皆模块，只要可以被引用的都是模块。 中间部分就是chunk，多模块合并成的，如：entry,import(),splitChunk等都会产生chunk，做依赖分析 。 右边部分就是bundle，即…"}, {"id": "6844904176976166925", "title": "CommonsChunkPlugin代码拆分挖坑之路", "desc": "vue单文件打包，vendor体积过大，影响页面性能。将vue相关的（vue、vuex、vue-router），element-ui、echarts（echarts、zrender），以单独js文件抽离出来，从而减少vendor体积。同时，抽离不太可能更改的模块，对于项目的版本…"}, {"id": "6844903826575605768", "title": "Vue-CLI2项目从 babel 6 + webpack 3.x 升级到 babel7 + webpack4.x 踩坑", "desc": "当前项目是通过当时Vue-CLI 2.x生成使用，配置是babel 6编译、webpack 3.x打包。由于项目发展到某个阶段，需要升级优化。目标是打包速度更快、bundle体积更小。 本文通过分享代码片段讲述部分版本升级后的不同以及可能发生的报错案例，达到让小伙伴们能找到对应…"}, {"id": "6844903516973039623", "title": "webpack稳定moduleid和chunkid以实现持久化缓存的梳理", "desc": "如何基于webpack做持久化缓存目前感觉是一直没有一个非常好的方案来实践。网上的文章非常多，但是真的有用的非常少，并没有一些真正深入研究和总结的文章。现在依托于于早教宝线上项目和自己的实践，有了一个完整的方案。 想要做持久化缓存那么就要依赖 webpack 自身提供的两个 h…"}, {"id": "6912334829430243341", "title": "react + webpack 项目搭建", "desc": "默认情况下，webpack 值支持.js,.json文件，通过 loader，可以让他解析其他类型的文件(.css, .less, .ts, .vue ....)，充当翻译官的角色。理论上只要有响应的 loader，就可以处理任何文件。一个 loader 只干一件事，webpa…"}, {"id": "6921887504211804167", "title": "[webpack学习]你知道经webapck打包后的代码是怎么运行的吗？", "desc": "对Webpack的打包后的代码的运行逻辑蛮有兴趣，所以阅读了下代码学习总结一下。 它是一个立即执行函数。通过把开发模块传入到modules形参，然后立即执行函数执行。我们先看一下模块数组的代码： 开发的所有模块会按照引入顺序依次放到modules数组中。入口文件中的代码会放到数…"}, {"id": "6844903848427913224", "title": "Webpack坑位之输出", "desc": "webpack的最后就是为了得到打包结果。 本文的原文在我的博客中:https://github.com/RachelRen/blog/issues/27,欢迎star。 首先从最简单的配置开始output。告诉webpack在哪里打包应用程序。 webpack 将多个模块打包…"}, {"id": "6898263439962013709", "title": "【webpack参数配置系列】之配置你的第一个webpack", "desc": "如今各种前端框架大行其道，而大部分框架内部也对webpack配置做了隐藏，目的当然是让你用起来更方便，降低你的学习成本。但是这也让webpack对于我们更像是一个黑盒，只知道如何使用脚本命令，而对于其内部的参数配置以及底层原理了解甚少。所以我打算出一个系列来讲一讲webpack…"}, {"id": "6950275472223633422", "title": "webpack热更新原理", "desc": "前言Webpack热更新（ Hot Module Replacement，简称 HMR），它允许在运行时更新模块，而无需重新加载整个页面。刷新一般分为两种：一种是页面刷新，不保留页面状态，直接wind"}, {"id": "6860688500392787982", "title": "聊聊 Webpack 那些事 - 丑陋的 tapable", "desc": "tapable 是个很小的库, 但是却是 Webpack 插件机制的核心, tapable 的含义是类似一根自来水管那样, Webpack 将所有的构建过程封装成插件, 这些插件都被插在一个叫 Hook 的插槽上, 因为 JavaScript 的异步特征, Hook 分为 Sy…"}, {"id": "6844904112589537288", "title": "想要学习Webpack前端工程化构建，你必须要掌握这些核心知识点", "desc": "在很久之前，模块化管理还没有出现，如果我们开发一个页面想要引入一些依赖的话，最常见的做法就是将依赖文件引入到.html文件中。比如，我们要使用JS的一些依赖库，就要在.html文件中使用<script>标签引用；要引用CSS的依赖就要使用<link>标签。如果页面中引入的依赖文…"}, {"id": "6961289401813073933", "title": "关于webpack的一些问题", "desc": "1.详解webpack中的hash、chunkhash、contenthash区别 hash一般结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变"}, {"id": "6920404048491479047", "title": "webpack循序渐进篇", "desc": "开篇必看彩蛋：点这里前言git地址：https://github.com/OnionMister/webpack-demo.gitwebpack核心概念1.入口(entry)入口起点(entrypoi"}, {"id": "6936559001043730439", "title": "webpack是怎么实现js模块化的？", "desc": "博主最近一直在学习算法相关的内容，所以挺长一段时间没有更新技术文章了，正好最近有个朋友问了我一个问题，webpack是怎么实现模块化的？我也就顺便把这块相关的内容写成一篇掘文，分享给那些对这块内容不太清楚的同学。 对于前端的模块化，相信大家都很熟悉。在现在的前端开发中，因为三大…"}, {"id": "6844904191031246862", "title": "webpack --- 使用 loaders 处理静态资源", "desc": "默认情况下，webpack 只处理 JS 文件。如果要处理其他文件，webpack 需要配置 loaders 对文件进行预处理，这样 webpack 就能处理任意静态资源。 处理静态资源的常用 webpack loaders 分别有 file-loader 、 url-load…"}, {"id": "6844903715564945416", "title": "Webpack devServer.proxy反向代理地址模糊相似规则问题", "desc": "在开发模式下请求数据多少会涉及到它里面提供的devServe.proxy即Node.js的反向代理中间件。 Node.js代理很简单。轻松的配置代理服务器中间件连接，快递，浏览器同步以及更多。 假设当我们访问/api135/abc时，也就是真实地址B服务器/api/abc。 此…"}, {"id": "6916517042308775944", "title": "前端学习笔记（十三）--webpack学习", "desc": "今天学习 webpack 4，希望没学错版本。 学习材料是官方文档。 1. webpack 介绍 webpack 是一个模块打包工具，从一个入口模块开始，生成依赖图。最后把整个项目打包成多个浏览器可用的文件。 用 npm 安装即可，安装到开发版本。 webpack 4 版本还需…"}, {"id": "6956871269841109022", "title": "webpack系列--浅析webpack的原理", "desc": "一、前言 现在随着前端开发的复杂度和规模越来越大，鹰不能抛开工程化来独立开发，比如：react的jsx代码必须编译后才能在浏览器中使用，比如sass和less代码浏览器是不支持的。如果摒弃这些开发框架"}, {"id": "6844903760989257742", "title": "结合vue-cli来谈webpack打包优化", "desc": "CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。简单来说CommonsChunkPlugin主要是用来提取第三方库和公共模块，避免首屏加载的bundle文件或者按需加载的bu…"}, {"id": "6900448060758425614", "title": "webpack之plugin编写 -- 从html-webpack-plugin源码的角度来看如何编写plugin", "desc": "它可以理解为webpack编译一次生成的整个编译资源，一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。本次主要关注 assets …"}, {"id": "6979393978869219359", "title": "webpack的打包优化的一些具体操作", "desc": "这是我参与更文挑战的第30天，活动详情查看： 更文挑战 不扯别的，直接主题，主要整理一下我们项目中较为常用的一些优化操作：比如多线程打包，缩小打包作用域，动态链接库思想，还有tree shaking。"}, {"id": "6844903886147289095", "title": "按需引入polyfill", "desc": "在开发过程中，如果我们写的代码是es6语法的，其中有很多语法如：async、Array.isArray、Object.assign等等是低版本浏览器所不支持的。为了保证我们写的es6语法能够在各个新旧客户端上撒欢跑，我们需要引入polyfill对这些新的语法进行全局注入。 它会…"}, {"id": "6844904005047418894", "title": "webpack编译流程浅析", "desc": "webpack 只支持JS模块，所有其他类型的模块，比如图片，css等，都需要通过对应的loader转成JS模块。所以在webpack中无论任何类型的资源，本质上都被当成JS模块处理。 Webpack 源码是一个插件的架构，他的很多功能都是通过诸多的内置插件实现的。 而其他一些…"}, {"id": "6844903929310871559", "title": "webpack4搭建vue项目：踩坑及优化(项目总结)", "desc": "第一次写掘金，之前都是看别人的文章，这次主要是想记录下近期项目中遇到的问题，和自己的一些成长。 先简述下最近项目的技术选型，公司在两个月前前端技术方面进行升级，之后的项目均要采用主流框架来开发。在做了三个 vue 的中型项目后，有一些坑和爬坑的过程，也是对这三个项目的进行一些系…"}, {"id": "6844903779209314317", "title": "重构之路：webpack区分生产环境和开发环境", "desc": "我们现在的配置都是写在一个webpack.config.js文件夹里，但是实际上，我们在开发环境和生产环境中使用的配置是不一样的，比如生产环境中我们需要包的体积不能很大，不然在线上响应会变慢。所以我们需要将生产环境和开发环境分开来。 在node里，我们有一个process对象，…"}, {"id": "6844903534421344263", "title": "跟着Vue-cli来'学'并'改'Webpack之多环境配置和发布", "desc": "Vue之所以现在如此之火热，一部分也得益于有官方的脚手架生成工具Vue-cli,大大简化了初学者环境搭建的成本，但是实际业务中我们往往需要实现其他的功能来对webpack进行改造，本文将会根据一些实际的业务需求，先学习vue-cli生成的模版，然后在进行相关修改。 Vue-cl…"}, {"id": "6844903695033843726", "title": "显微镜下的webpack4的新特性：mode详解", "desc": "webpack4支持的一个新特性就是zero配置，不需要config，也可以打包，这对于懒癌患者很有诱惑力，但是这也意味着我们不清楚零配置发生了写什么，也不知道打包出来的文件是否符合我们的心意，全部都是佛系打包。不过作为项目的亲爹亲妈，还是要对自己的孩子负责，每个打包过程都是要…"}, {"id": "6844903668014120967", "title": "用实验的思路优化webpack4项目编译速度", "desc": "最近开发的时候遇到一个问题：当项目越来越大的时候，webpack构建和编译的速度变得很慢。尽管webpack4官方宣称速度提高了90%以上，但实际使用的时候感觉速度和webpack2也差不多。我实在受不了热加载的时候要等几秒才能编译好，于是就开始了优化之路。 最终优化的效果不错…"}, {"id": "6844904153664356365", "title": "webpack+vue学习一：配置webpack（分离开发和生产环境），并实现vue页面输出", "desc": "webpack的应用很广泛，就算不深入使用，还是需要了解一番的。 这个文件记录了项目的配置信息。 至此，项目可以使用 npm run build进行打包项目，npm start运行项目了。vue的路由配置还在学习中，等待更新下一篇学习二的文档。共勉。"}, {"id": "6844903918275657735", "title": "掌握Webpack4（实战篇一）", "desc": "1. 搭建项目并打包 JS 文件 它将查找 ./src/index.js 作为默认入口点。 而且，它会在 ./dist/main.js 中输出模块包，目前代码量小，可以格式化看效果 拥有 2 个配置文件在 webpack 中是的常见模式。 webpack4 引入了 produc…"}, {"id": "6844903537592238088", "title": "React16+Redux+Router4+Koa+Webpack服务器端渲染（按需加载，热更新）", "desc": "开发环境使用webpack-dev-server做后端服务器，实现不刷新页面的热更新，包括组件和reducer变动的热更新。 生产环境使用koa做后端服务器，与前端公用createApp代码，打包后通过读取文件获得createApp的方法，然后通过react-loadable按…"}, {"id": "6910860305975214088", "title": "Webpack从手把手配置到原理浅析(一)：基础配置", "desc": "本系列文章并不打算从Webpack的概念和原理开始和你娓娓道来，因为我知道，如果你有这个时间，你就不会搜到我这篇文章，而是会选择之间从官网的文档开始慢慢看起。 既然时间紧张，那么我直接从实战开始，从基础配置，到高级配置，再慢慢深入Webpack内部，不仅让你会用，还知道为什么这…"}, {"id": "6844903448740118535", "title": "【webpack多入口打包】单工程下的多项目结构", "desc": "大佬n：... 众人：... 一个工程，默认有一个打包入口，build文件夹下存放着webpack的打包配置，包括开发环境和生产环境。 找到打包的入口文件(main.js)和模板文件(index.html)，然后通过我们配置的loader对不同类型文件进行解析或编译，最后生成不…"}, {"id": "6844903571259916302", "title": "2018 如何玩转 JavaScript", "desc": "从命令行工具和 webpack 到 TypeScript 和 Flow 等，让我们来谈一下在 2018 年如何玩转 JavaScript。"}, {"id": "6844903837547905031", "title": "webpack4 基础🐱", "desc": "一个功能加载一个script 标签 e.g. Jquery , Swiper 加载一个巨大的JS文件。 扩展性太差，标签很多的情况下维持标签的顺序很痛苦。 加载过多的JS文件有加载性能问题，因为浏览器的并行连接数有限制。可以参考html - Max parallel http …"}, {"id": "6983996547637706759", "title": "我是这样搭建React+TS的通用webpack脚手架的（阶段一）", "desc": "前言 目前公司前端体系还不太完善的原因，一般写项目用的都是使用 create-react-app 搭建的一套通用的脚手架。这个脚手架虽然非常的通用、基础，但是在搭配了 tailwindcss、post"}, {"id": "6844903892031897608", "title": "Webpack基本使用（详解）", "desc": "由于Webpack默认只能打包处理Js类型的文件，无法处理其它的非Js类型的文件，所以如果要处理非Js类型的文件，我们需要手动安装一些合适的第三方loader加载器。 您正在使用Vue的仅运行时版本，其中模板编译器不可用。 将模板预编译为渲染函数，或使用包含编译器的构建。"}, {"id": "6972470140910698532", "title": "Webpack4从入门到入土", "desc": "Webpack 一、Webpack简介 二、Webpack初体验 三、Webpack性能优化 四、webpack配置详解"}, {"id": "6844903605481242637", "title": "开发必备的webpack4", "desc": "首先webpack4建议使用node版本在8.5以上，是因为要兼容新版npm下的npx，cmd中node -v查看node版本。 WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss…"}, {"id": "6844904138044604430", "title": "webpack4配置到优化到原理（上）", "desc": "一. 核心概念 2. output（输出） 3. loader（资源解析转换） 4. plugin （利用插件对webpack进行扩展和增强） 5. mode（针对开发环境和生成环境的区分处理） 二. 常用配置 6. devServer（热更新） 7. resolve(模块解析…"}, {"id": "6967233054171463717", "title": "webpack5（四）plugin的使用", "desc": "插件是 webpack 的 支柱 功能。webpack 自身也是构建于你在 webpack 配置中用到的相同的插件系统之上！ 插件目的在于解决 loader 无法实现的其他事。 clean-webpa"}, {"id": "6996993098735681566", "title": "webpack打包ES6模块的bundle.js源码分析", "desc": "这是我参与8月更文挑战的第16天，活动详情查看：8月更文挑战 前言 webpack是前端模块化打包工具,我们在使用vue2或者react的官方脚手架生成的项目里面，里面都有webpack的影子。 但是"}, {"id": "6969752467072352269", "title": "Webpack 必会的基础概念", "desc": "webapck 是一个现代 JavaScript 应用程序的静态模块打包器。 当 webpack 处理应用程序时，它会递归的构建一个依赖关系图，其中包括应用程序的每个模块，然后将这些模块打包成一个或"}, {"id": "6998800269655932958", "title": "webpack全面解析（1）- webpack 的主要配置", "desc": "webpack作为现代前端打包最重要的工具之一，在前端开发应用中是必不可少的。虽然说工程化的项目中，比如 react 的 cra、 VUE 的 cli 以及其他的一些脚手架，都会将相关的配置给我们配置"}, {"id": "6989168450153545764", "title": "postcss-loader 与 mini-css-extract-plugin 打包冲突问题", "desc": "postcss-loader 与 mini-css-extract-plugin 打包冲突问题 postcss-loader 简单来来说就是 css3 的一些特性 在低版本浏览器也能运行，自动添加加前"}, {"id": "6844903875405676557", "title": "超详细使用webpack4.x搭建标准前端项目", "desc": "在开始教程前，先看看我们通过本教程能学到什么。 调整 package.json 文件，以便确保我们安装包是私有的(private)，并且移除 main 入口。这可以防止意外发布你的代码。 同时加入script命令，让执行npx webpack 等同于执行npm run buil…"}, {"id": "6970333716040122381", "title": "webpack5 的使用（四）：加载资源文件", "desc": "这是我参与更文挑战的第5天，活动详情查看： 更文挑战 前言 目前项目已经可以加载了 css 文件了，这篇文章将会介绍如何加载资源文件（如：图片）。 旧版本与 webpack5+ 加载资源的区别 在 w"}, {"id": "6976157217867169800", "title": "webpack项目中如何调试loader插件？", "desc": "最近，在学习webpack使用时，发现webpack-replace-loader配置正则不起用，调试插件后才发现，search健值竟然不支持正则的写法，后有换成string-replace-load"}, {"id": "6844903680357957645", "title": "ElementUI的构建流程", "desc": "最近一直在着手做一个与业务强相关的组件库，一直在思考要从哪里下手，怎么来设计这个组件库，因为业务上一直在使用ElementUI（以下简称Element），于是想参考了一下Element组件库的设计，看看Element构建方式，并且总结成了这篇文章。 废话不多说，先看看目录结构，…"}, {"id": "7000014661739347998", "title": "初识Webpack(二)", "desc": "loader介绍 由于webpack 只能识别与分析 JavaScript 和 JSON 文件，于是面对不是这类文件时，我们需要对webpack扩展..."}, {"id": "6891565484324585480", "title": "还不会写Webpack loader？没事，带你从0到1实现简易的css-loader和style-loader！", "desc": "作为前端每天都在打交道的 webpack ，学精是很有必要的，尤其是负责文件解析的 webpack-loader（以下简称loader），它作为 webpack 的加载器成了打包必不可少的一环。本文将从实现层面洞察 loader 的实现原理，相信看完本文，你自己也可以写一个属于…"}, {"id": "6986272360772927496", "title": "webpack5入门到精通(二)（css篇）", "desc": "webpack 5入门到精通（二）css打包篇。文章中若是有错误或者不准确的地方，欢迎大家指出讨论。"}, {"id": "6844903582970429454", "title": "Vue SPA项目SEO优化之预渲染Prerender-spa-plugin", "desc": "由于基于Vue的SPA项目普通的爬虫无法爬取项目的静态文本的内容，通过预渲染插件prerender-spa-plugin解决vue的SPA项目的SEO问题。 可以看到项目编译后的index.html中只有一些HTML和js，css文件的引用，而无关于内容的静态文本。当然你也可以…"}, {"id": "6960178452787888158", "title": "如何优化 Webpack？", "desc": "1）优化 Webpack 的构建速度 使用高版本的 Webpack（使用 webpack4） 多线程/多实例构建：happypack（不维护了）、thread-loader 缩小打包作用域： excl"}, {"id": "6844903686460686350", "title": "[译]怎样学习React—从初级到高级路线图", "desc": "这个指南是为初学React的朋友写的，在每个部分，我用心收集了最好的视频和文章，让我们学习起来更加容易。 Kent C. Dodds的Beginners guide to React React Router帮助你的单页面应用创建路由，它非常强大并且容易使用。 React的服务…"}, {"id": "6854573217336541192", "title": "手写webpack核心原理，再也不怕面试官问我webpack原理", "desc": "需要读到入口文件里面的内容。 分析入口文件，递归的去读取模块所依赖的文件内容，生成AST语法树。 我们创建了add.js文件和minus.js文件,然后 在index.js中引入，再将index.js文件引入index.html。 现在我们打开index.html。你猜会发生什…"}, {"id": "7005072077430456333", "title": "后台项目的webpack 优化之路", "desc": "最近接手组内的后台项目、每次打包的时间很长、高达4分钟左右、已经严重的影响了开发效率， 本着一个程序员的素养 打算入手优化、如果内容有帮助到你的话欢迎点赞!"}, {"id": "6844903886898069511", "title": "嘿，不要给 async 函数写那么多 try/catch 了", "desc": "另外可以发现并不是一个 token 对应一个 Node，等号左右必须都有值才能组成一个声明语句，否则会作出警告，这就是 eslint 的基本原理。最后所有的 Node 组合在一起就形成了 AST 语法树 通过 @babel/traverse 我们能够轻松的找到 await 表达…"}, {"id": "6844903582337237006", "title": "2018 年了，你还是只会 npm install 吗？", "desc": "nodejs 社区乃至 Web 前端工程化领域发展到今天，作为 node 自带的包管理工具的 npm 已经成为每个前端开发者必备的工具。但是现实状况是，我们很多人对这个nodejs基础设施的使用和了解还停留在: 会用 npm install 这里（一言不合就删除整个 node_…"}, {"id": "6984966164629225502", "title": "Module Federation 你的浪漫我来懂", "desc": "前言 我们在实际开发中，经历过许多次的模块共享的场景。最常见的场景例如我们将代码封装后根据版本和环境的不同发布到公共平台或者私有平台，供不同项目进行使用，npm 工程化就是其中最日常的实践。"}, {"id": "6979058369352957960", "title": "三千字基于 HMR 插件解析 Webpack 源码", "desc": "本文由团队成员 [咕噜](https://github.com/ShinyLeee) 撰写，已授权涂鸦大前端独家使用，包括但不限于编辑、标注原创等权益。"}, {"id": "7004472324976017439", "title": "动态修改webpack中的publicPath", "desc": "需求背景 最近接到一个需求，比如项目本来的访问地址是 https://juejin.cn/pro/index.html, 现在要针对某个商户配置的访问地址是https://juejin.cn/pro/"}, {"id": "6976052326947618853", "title": "Webpack - 手把手教你写一个 loader / plugin", "desc": "loader 干啥的？ 也就是说，webpack 把任何文件都看做模块，loader 能 import 任何类型的模块，但是 webpack 原生不支持譬如 css 文件等的"}, {"id": "6844903862898262024", "title": "webpack4 的30个步骤打造优化到极致的 react 开发环境，如约而至", "desc": "本篇所有代码线上代码react-webpack4-cook,翻译过来叫：webpack4和react的乱炖，可以跟着代码进行配置，之前有很多坑，线上代码都已经被解决了 。如果对您有帮助，不妨给个star.点赞关注不迷路 一篇文章不写前言总感觉不太正式，大概介绍下我是怎么完成一个…"}, {"id": "6942322281913778206", "title": "分享12个Webpack中常用的Loader", "desc": "初衷： 整理一些常用的loader分享给大家，方便知道在什么场景下该用什么loader。如果有大佬都懂悄悄左滑就行，不喜勿喷。 适合人群： 前端初级开发。 用途： 用于将css编译完成的样式，挂载到页面style标签上。需要注意loader执行顺序，style-loader放到…"}, {"id": "6844904163558555662", "title": "如何修改 node_modules 里的文件（同事看了直呼内行）", "desc": "有时候使用npm上的包，发现有bug，我们知道如何修改，但是别人可能一时半会没法更新，或者是我们特殊需求，别人不愿意修改，这时候我们只能自己动手丰衣足食。那么我们应该如何修改别人的源码呢？首先，直接修改node_modules里面的文件是不太行的，重新安装依赖就没有了。一般常用…"}, {"id": "6990538424545443854", "title": "从零搭建Webpack5-react脚手架(附源码)", "desc": "webpack5 近期终于有时间和精力专注于公司技术基础建设了，于是将公司的Saas系统改造成了微前端模式，解决了历史遗留的一部分问题 接着，想着webpack5已经发布这么久了，该在生产环境推广了"}, {"id": "6997227418113032200", "title": "webpack5升级指南（附打包性能优化大全）", "desc": "webpack5升级有哪些问题，升级webpack5之后如何做性能优化，哪些优化项是比较重要的？这篇文章告诉你答案"}, {"id": "6937086236926410783", "title": "【Webpack 进阶】Webpack 打包后的代码是怎样的？", "desc": "webpack 是我们现阶段要掌握的重要的打包工具之一，我们知道 webpack 会递归的构建依赖关系图，其中包含应用程序的每个模块，然后将这些模块打包成一个或者多个 bundle。 莫慌，我们一点点拆分开看，其实总体的文件就是一个 IIFE——立即执行函数。 函数的入参 mo…"}, {"id": "7002157698108096543", "title": "自我沉淀webpack5+react+eslint+tslint", "desc": "自己学了一段时间webpack准备将自己的知识沉淀一下，千里之行始于足下，如果不沉淀一下的话总是觉得知识点有些浮躁，无法彻底沉淀下来。"}, {"id": "6999796988136914981", "title": "Webpack常用配置详解", "desc": "entry 入口起点 string 单入口 打包形成一个chunk。 输出一个bundle文件。 此时chunk的名称默认是 main a"}, {"id": "7004474389739601928", "title": "【webpack】- 打包流程", "desc": "目录 webpack简介 原理分析 功能实现 一、webpack简介 二、 原理分析 假设有两个js模块，这里我们先假设这两个模块是复合commomjs标准的es5模块。 语法和模块化规范转换的事我们"}, {"id": "6887863430510968839", "title": "【webpack 性能优化】编译速度从 50S 到 7S", "desc": "随着项目不断发展壮大，组件数量开始变得越来越多，项目也开始变得庞大，webpack 编译的时间也会越来越久，我们现在的项目编译一次在 40s ——70s 之间，这是一个效率非常低下的操作。优化的手段有很多，之前项目原本已经做了很多，本文从缓存的角度进行优化讲解 babel-lo…"}, {"id": "6888848660591968264", "title": "【值得收藏】前端优化详解以及需要关注的几个问题", "desc": "前端优化是一个大的课题，需要花好多时间才能理解，之前对前端优化陆陆续续有一些了解。所以这次从渲染优化，打包优化，代码优化做了一个系统的总结，并且引申出了几个需要关注的问题，文章可能有点长，大家一定要看到最后。最后写作不易，希望觉得还可以的话，帮忙点赞一波，提前感谢了。当然如果有…"}, {"id": "6860129883398668296", "title": "[2.7w字]我是这样搭建 React+Typescript项目环境的(上)", "desc": "现在我们开发一个 React 项目最快的方式便是使用 Facebook 官方开源的脚手架 create-react-app ，但是随着业务场景的复杂度提升，难免会需要我们再去添加或修改一些配置，这个时候如果对 webpack 不够熟练的话，会比较艰难，那种无力的感觉，就好像是女…"}, {"id": "6844904160375078925", "title": "webpack打包ts的两种方案对比", "desc": "@babel/preset-typescript：它是直接移除TypeScript，转为JS，这使得它的编译速度飞快,并且只需要管理Babel一个编译器就行了。 高版本的浏览器，这部分代码也不会被打包进来，因为高版本浏览器已经可以直接使用promise。 执行打包，发现bund…"}, {"id": "6993919669933441032", "title": "Webpack5学习 --- devServer和resolve", "desc": "DevServer 会启动一个 HTTP 服务器用于预览服务，并接收文件变更信号，通过 WebSocket 协议自动刷新网页做到实时预览。Resolve用于别名，简化开发时路径查找操作。"}, {"id": "6911519627772329991", "title": "webpack4打包优化(HappyPack、thread-loader）", "desc": "webpack构建过程中直接影响构建效率的，一个是文件的编译，另一个是文件的分类打包。相较之下文件的编译更为耗时，而且在Node环境下文件只能一个一个去处理，因此这块的优化需要解决。那么要怎样优化打包速度呢？ 1. 使用高版本的webpack和node.js 2. 多进程/多实…"}, {"id": "6993613568004325412", "title": "Webpack5学习 --- HMR", "desc": "在每次修改代码以后，我们都需要手动进行编译打包后才可以看到实际打包后的内容。这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示，此时就需要使用HMR。"}, {"id": "6937609106022727717", "title": "构建效率大幅提升，webpack5 在企鹅辅导的升级实践", "desc": "|导语2020年10月10日，webpack5正式发布，并带来了诸多重大的变更，将会使前端的构建效率与质量大为提升。其实现在各大博客网站已经有很多关于webpack5的文章，但真正通过业务实践并获得第"}, {"id": "6968264178129698852", "title": "Webpack 构建性能优化之旅", "desc": "目前负责的项目，是未通过脚手架和其他框架搭建的 react 项目。开发过程中，启动项目和热更新速度都不是很理想；打包构建时，速度也比较缓慢且由于单个文件过大，用户在访问时，加载动画的时间也比较长。所以"}, {"id": "6844904023791796237", "title": "Webpack 设置环境变量的误区", "desc": "原先我一直以为这个插件，可以用来设置所有环境（浏览器环境、node 环境）下的变量。经过测试发现，只能设置node 环境下的变量 —— NODE_ENV 经常在一些群里看到这个问题： cross-env 和 webpack.DefinePlugin 配合使用的时候，无法通过 p…"}, {"id": "6991772113761730574", "title": "Webpack配置-常用loader", "desc": "Webpack核心概念 Entry（入口): 入口文件配置。指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和"}, {"id": "6988026777704595492", "title": "webpack进阶（三）", "desc": "引言 本文主要介绍 sourcemap的分析与使用，页面公共资源的提取，Tree Shaking的原理与使用"}, {"id": "6844903577794641928", "title": "精读《webpack4.0 升级指南》", "desc": "本周精读的是 webpack4.0 一些变化，以及 typescript 该怎么做才能最大化利用 webpack4.0 的所有特性。 前段时间尝试了 parcel 作为构建工具，就像农村人享受了都市的生活，就再也回不去了一样，发现无配置真是前端构建工具的大趋势，用起来非常方便快…"}, {"id": "6970586869826486302", "title": "《webpack 实战（入门、进阶与调优）》笔记", "desc": "《webpack 实战（入门、进阶与调优）》笔记，深入理解webpack常见面试问题，开发部署的优化方案。建议阅读原书，可以当成工具书，用的时候拿出来翻一番。"}, {"id": "6914175633635409933", "title": "webpack4.x 打包工具 | (三)", "desc": "Tree-shaking的字面意思就是摇树。 一般伴随着摇树这样一个动作我们树上的这些枯树枝和树叶就会掉落下来。 那我们这里要说的Tree-shaking也是相同的道理，不过我们这里摇掉的使我们代码当中那些没有用到的部分，那这部分代码更专业的说叫未引用代码（dead-code）…"}, {"id": "7005572487643660325", "title": "babel基础知识", "desc": "(1)什么是babel？ babel是一个js工具包，用于向后兼容，常用于新版本，即新版本仍然可以使用老版本代码. babel的主要作用：1.源码转换。2.转换语法 例如代码转换（通过将新版本代码编译"}, {"id": "6985014455415341086", "title": "webpack 4升级到 webpack 5 (node 14.6 升级到 node16 引发的问题)", "desc": "项目启动报错 按照以往的经验，删除 node_modules, 然后重新按照 node-sass, 你会发现都报错，并且npm 安装也是一直报错如下： .... 一系列莫名其妙的错误。然后我发现一个问"}, {"id": "6966417062633832461", "title": "webpack学习笔记(一)：初次见面，请多关照", "desc": "大家都采用webpack来打包自己的项目，于是便生出了想要学习webpack的想法。这篇文章为学习webpack的第一篇学习笔记。"}, {"id": "6999186632221917214", "title": "webpack实战：将一个库的加载速度提升四倍", "desc": "项目背景 该项目是一个公司内部使用的库，使用webpack进行打包。（webpack版本： 5.40.0）以往是使用npm的形式进行包管理，但由于项目打包后的体积较大（约1.7M），影响页面的加载速度"}, {"id": "6844903693070909447", "title": "【webpack进阶】你真的掌握了loader么？- loader十问", "desc": "1. loader 十问 在我学习webpack loader的过程中，也阅读了网上很多相关文章，收获不少。但是大多都只介绍了loader的配置方式或者loader的编写方式，对其中参数、api及其他细节的介绍并不清晰。 也许你也会有类似的疑问。下面我会结合loader相关的部…"}, {"id": "6914165207183360013", "title": "rollup 打包工具", "desc": "通过探索我们知道可以把css文件作为打包的入口，不过webpack的打包入口一般还是JavaScript, 因为他的打包入口从某种程度来说可以算是我们应用的运行入口。 而就目前而言，前端应用当中的业务是由JavaScript去驱动的，我们只是尝试一下，正确的做法还是把js文件作…"}, {"id": "6948950633814687758", "title": "webpack编译流程详解", "desc": "说明一点看webpack的编译流程非常枯燥，即使看完理解之后也不见得能对本上有很多帮助。 Entry: 指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库。 Module: 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。W…"}, {"id": "7004089708640731167", "title": "webpack性能优化打包", "desc": "1. MiniCssExtractPlugin 样式抽离 使用 MiniCssExtractPlugin 抽离出 css 文件，以 link 标签的形式引入样式文件 2. 不同环境不同config 配"}, {"id": "6844903542436839437", "title": "Parcel Vs Webpack", "desc": "横空出世的Parcel近日成为了前端圈的又一大热点，在短短几周内就获得了13K的Star。 我花了6个月的时间写了一本全面介绍Webpack的图书《深入浅出 Webpack》近日刚出版，感觉被新出的Parcel给腰斩了。 但本文将本着公平公正的心态来详细对比一下他两，让你能明白…"}, {"id": "6844903687576354824", "title": "webpack dll打包重复问题优化", "desc": "关于webpack dll的使用，我这里不做过多介绍，网上都有，一撸一大把，今天我要说的是在使用dll plugin过程中出现的一个包依赖问题，这个问题导致打出来的包会包含重复的代码。"}, {"id": "6844903518365548551", "title": "尚妆达人店 UI 组件化 工程实践（weex vue）", "desc": "尚妆大前端团队使用 weex 进行三端统一开发有一段时间了，截止本文发表「达人店」APP大部分页面都已经用 weex 进行了重构，在此期间也积累了一些基础组件和业务组件。 之前维护组件的方式是在达人店项目的工程内维护一个 components 文件夹，随日常开发迭代，并行需求与…"}, {"id": "6844903511746936846", "title": "用webpack搭建多页面项目", "desc": "如上配置执行 webpack 命令后，会将入口文件中所有的成员都打包到 build 下，文件名为 entry 对象中的键名。"}, {"id": "6969877515691098120", "title": "webpack5 的使用（三）：加载 css", "desc": "这是我参与更文挑战的第4天，活动详情查看： 更文挑战 前言 在 webpack5 的使用（一）：起步 文章里，介绍了如何管理 html 和 js，接触了 entry、output 和 plugins "}, {"id": "6982527684186210341", "title": "2021-07-08 Webpack集成React和TypeScript的两种方案", "desc": "初始化项目 安装依赖 这里的依赖主要有react、react-dom以及他们对应的@types/react、@types/react-dom等还有webpack相关的依赖 配置webpack.conf"}, {"id": "6973896520412168222", "title": "前端学习笔记-webpack学习", "desc": "webpack三种哈希值 hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。（一般不用） chunkhash：根据不同的入口文"}, {"id": "6844904009585655816", "title": "如何用webpack优化moment.js的体积", "desc": "本篇为转译，原出处。 当你在代码中写了var moment = require('moment') 然后再用webpack打包, 打出来的包会比你想象中的大很多，因为打包结果包含了各地的local文件. IgnorePlugin的原理是会移除moment的所有本地文件，因为我们…"}, {"id": "6844903603983892487", "title": "babel原理及插件开发", "desc": "如今的前端界已经离不开ES6，然而老旧浏览器并不支持，项目中特别是国内公司又需要兼容低版本的老旧浏览器，多亏了babel这个神奇的工具，可以让我们的ES6代码运行在旧浏览器中。 大部分前端开发人员只是配置一下babel，根据需要装个插件之类，我想肯定少有人去研究babel转换E…"}, {"id": "6934163789067583496", "title": "从零开始使用 webpack5 搭建 react 项目", "desc": "webpack5 也已经发布一段时间了，其模块联邦、bundle 缓存等新特性值得在项目中进行使用。经过笔者在公司实际项目中的升级结果来看，其提升效果显著，热更新时间由原来的 8s 减少到了 2s，会极大的提升开发幸福感。除此之外，webpack5 也带来了更好的 tree s…"}, {"id": "6844903558437928967", "title": "webpack 4 测试版 —— 现在让我们先一睹为快吧！", "desc": "为了支持数以百万计的功能，用例和需求，它需要一个安全，稳定，可靠和可拓展的基础。只有 webpack 具有无限的可能性。 自八月初以来 —— 当我们从 **webpack/webpack#master** 中分出 **next** 分支的时候 —— 我们看到了惊人的贡献量涌入。…"}, {"id": "6958073514628743182", "title": "初探webpack的导入导出", "desc": "在esmodule和commonjs两种方式下webpack的导入导出解析策略实验。做了一些简单的小实验，之后可能会深入源码层面对这些现象"}, {"id": "6967903015303020558", "title": "[ Webpack ] 实现一个 mini 版的webpack ", "desc": "Vite 和 Webpack Vite 的发布是不是意味着 webpack 的终结？当然不是， webpack 存在这么多年是解决了不少奇奇怪怪的问题而且也适合处理那些深度复杂的场景，这一点 Vite"}, {"id": "6911299768048320526", "title": "解决微前端应用间模块冲突", "desc": "在微前端开发阶段，子应用会经常发生模块加载失败的错误： can't read property call of undefined 导致应用崩溃。由于微前端子应用是通过 systemjs 动态加载的 umd 模块，导致很难 debug 该问题，因此这个问题困扰了我们许久。 这行…"}, {"id": "6915028318900125703", "title": "构建速度——记 Vue 项目中 Webpack 使用 DllPlugin ", "desc": "使用 webpack 插件 DllPlugin 和 DllReferencePlugin ，是前端工程化中优化打包速度的重要途径。webpack中文网-DllPlugin。 他们可以打包常用的且不经常更新的模块，生成 JS 和 json文件，一般放入 public 目录中；项目…"}, {"id": "6854573215650414600", "title": "webpack入门--通过实践带你学习webpack", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 …"}, {"id": "6844903822473560071", "title": "webpack4配置(3)-打包css/js/图片等资源", "desc": "webpack可以使用各种不同loader来预处理不同格式的资源。 使用css-loader+style-loader的方式是将样式打包进js文件，然后以style标签的形式嵌入页面。css样式与js文件混在一起可能导致一些样式混乱，所以使用插件将css样式统一打包进一个css…"}, {"id": "6918633181458235399", "title": "Webpack从手把手配置到原理浅析(五)：自动刷新与热更新", "desc": "在开发过程中，我们希望源代码文件后，Webpack就能检测到文件的变化，然后马上更新有改动的文件，不需要重启服务就能看到文件的变化。 自动刷新是指webpack的devServer在监听到文件有变化后，会触发重新构建打包，然后自动刷新页面，源文件的变化就可以实时查看效果。 在d…"}, {"id": "6987724950010331143", "title": "webpack搭建scss环境", "desc": "webpack搭建scss环境 目录结构 1 scss 运行环境 初始项目 npm init - king 2 安装依赖 node-sass sass-loader 加载 Sass/SCSS 文件并将"}, {"id": "6844904161369128967", "title": "在实践中深入了解跨域 + devServer.proxy", "desc": "1. 背景 2. 回顾跨域的知识 对于跨域，MDN里的这篇文章：HTTP访问控制（CORS）讲的很清晰。截取里面非常经典的图片（见下图），我们在domain-a.com网站下，访问domain-b.com的资源（png图片和eot的字体），这两个资源就会跨域，此时浏览器可能会阻…"}, {"id": "6960975878687817758", "title": "使用webpack+ts搭建项目", "desc": "1.npm初始化 2.新建目录结构 （ 简易版，仅供参考 ） 3.配置mode、入口文件和输出文件 4.引入HtmlWebpackPlugin 该插件将为你生成一个 HTML5 文件， 在 body"}, {"id": "6844903718031196168", "title": "浅谈webpack4.0 性能优化", "desc": "对开发者而言，我们希望webpack这个工具可以给我们带来流畅的开发体验。比如，当不断修改代码时，我们希望代码的变更能及时的通知浏览器刷新页面，而不是手动去刷新页面。更进一步的我们希望，代码的修改只会局部更换某个模块，而不是整个页面的刷新。这样可以使我们不需要在等待刷新中浪费很…"}, {"id": "6844903847408713735", "title": "巧用 webpack 做页面静态资源依赖分析", "desc": "所谓【静态资源依赖分析】，指的是可以通过分析页面资源后，可以以 json 数据或者图表的方式拿到页面资源间的依赖关系。 对一个多页面 repo 而言，每次要发布的时候，我希望通过 git diff 拿到本次改动的文件，再通过依赖分析拿到此次需要构建的资源，这样就可以做到单页面发…"}, {"id": "6844904070776356871", "title": "Webpack源码分析 - 模块Module", "desc": "在Webpack中，一切资源都被看作模块，也就是说不管是js、css还是图片文件，Webpack都将他们都抽象成一个个模块，模块记录了资源的位置和内容，编译过程就是从入口模块开始递归找到所有需要用的模块，最终将所有模块打包输出。 前面的入口Entry章节我们已经知道，一个单入口…"}, {"id": "6978842749181100069", "title": "用webpack5搭建Vue3项目架构", "desc": "探索webpack5新特性，使用webpack5搭建Vue3项目架构。开发、生产环境配置代码分拆，体验最新webpack-dev-server@4。"}, {"id": "6844903967793627149", "title": "[译] webpack 5 之持久化缓存", "desc": "首先，要注意的是默认情况下不会启用持久化缓存。你可以自行选择启用。 webpack 旨在注重构建安全而非性能。 我们没有打算默认启用这一功能，主要原因在于此功能虽然有 95% 几率提升性能，但仍有 5% 的几率中断你的应用程序/工作流/构建。 这可能听起来很糟，但相信我它并非如…"}, {"id": "6844904166125469710", "title": "webpack解决本地开发跨域问题", "desc": "在本地开发前端项目时，经常会遇到需要本地请求测试环境或是生产环境地址，但是这样会导致跨域问题，如果我们使用了webpack，通常会通过代理解决跨域问题，那么接下来我们一起看看什么是跨域，使用webpack如何解决该问题，而webpack解决跨域的实现原理。 3.无法向非同源地址…"}, {"id": "6967287751779549214", "title": "webpack 入门笔记", "desc": "1. webpack作用 webpack的核心功能 打包。 什么是打包 简而言之打包就是将多个文件合并到一个js文件中，也就是说开发完成后合并的过程就是打包。 为什么使用webpack 我们在开发时在"}, {"id": "6844903602054660103", "title": " webpack系列之-原理篇", "desc": "本系列将会从原理、开发、优化、对比四个方面给大家介绍webpack的工作流程。【默认是以webpack v3为例子】 我们可以把webpack看做一个黑盒，只要会用就可以。先来体验一次很简单的webpack打包过程 npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去…"}, {"id": "6844903678244044813", "title": "React router动态加载组件-适配器模式的应用", "desc": "本文讲述怎么实现动态加载组件，并借此阐述适配器模式。 以上是最常见的React router。在简单的单页应用中，这样写是ok的。因为打包后的单一js文件bundle.js也不过200k左右，gzip之后，对加载性能并没有太大的影响。 但是，当产品经历多次迭代后，追加的页面导致…"}, {"id": "6911643815816200205", "title": "Webpack4/5 打包原理分析", "desc": "由于最近在公司写一些webpack的插件，用于处理一下工作上面的代码，所以研究了一下webpack的打包原理。本文就是总结一下webpack的基本实现的原理，由于公司内部使用webpack 4.35.0， 所以基于这个版本对webpack进行简单的了解，之后升级为webpack…"}, {"id": "6844903846511116295", "title": "webpack4 + vue多页面项目精细构建思路", "desc": "这里就第4点做一些解释，也对多页面的应用场景做一个我认为有价值的思路，在组内的一个项目中，因为项目日益膨胀，拆分系统有一定困难，项目页面达到200+个以上， 因此构建速度十分缓慢，部署时间也很长，经常因为文案的更改及一些简单的bug修复就要进行重新构建，如果采用单页面一方面构建…"}, {"id": "6960685656527863844", "title": "webpack搭建react脚手架", "desc": "1.生成 package.json 文件 npm init -y 2.安装 webpack webpack ebpack-cli webpack-merge webpack-merge 通过“通用”配"}, {"id": "6866767076380377096", "title": "webpack 教程「一.基本使用」", "desc": "1.webpack基本使用-工程化系列。凑字！凑字！凑字！凑字！凑字！凑字！凑字！凑字！凑字！凑字！凑字！"}, {"id": "6867163268377477133", "title": "【webpack系列】webpack打包组件和基础库", "desc": "webpack除了可以用来打包应用，也可以用来打包js库。 下面我们用一个例子，来演示一下如何用webpack来打包一个js库。 实现一个大整数加法库的打包。 支持AMD/Commonjs/ES6 Module模块引入。 1. 创建项目目录 2. 安装webpack &#x26…"}, {"id": "6844903667506610189", "title": "预告：JavaScript模块全览", "desc": "之前写的文章急速Js全栈教程得到了不错的阅读量，霸屏掘金头条3天，点赞过千，阅读近万，甚至还有人在评论区打广告，可见也是一个小小的生态了；）。看来和JS全栈有关的内容，还是有人颇有兴趣的。今天看到的霸屏的，也是讲全栈的，见参考文章7 接下来要写的是模块。JavaScript M…"}, {"id": "6844903780778000398", "title": "webpack系列之四loader详解3", "desc": "前2篇文章：webpack loader详解1和webpack loader详解2主要通过源码分析了 loader 的配置，匹配和加载，执行等内容，这篇文章会通过具体的实例来学习下如何去实现一个 loader。 这里我们来看下 vue-loader(v15) 内部的相关内容，这…"}, {"id": "6844903497415016462", "title": "VueJS 开发常见问题集锦", "desc": "由于公司的前端开始转向 VueJS，最近开始使用这个框架进行开发，遇到一些问题记录下来，以备后用。 主要写一些 官方手册 上没有写，但是实际开发中会遇到的问题，需要一定知识基础。 CLI: Vue-CLI UI: Element HTML: Pug(Jade) CSS: Les…"}, {"id": "6844904035728932878", "title": "从0到1教你撸一撸webpack4", "desc": "给自己的2019年画上一个完美的句号。 webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模…"}, {"id": "6932848640574619661", "title": "使用webpack和rollup打包React组件", "desc": "之前做了一个loading的样式组件，为了实现代码的可重用性，将这个小项目打包并且发布在了npm上。在一次次的打包发包过程中经历了一个有一个报错，@buzuosheng/loading这个组件已经到了2.7.0版本，虽然还有一些要调整的地方，但总算是可以用了。 webpack算…"}, {"id": "6844903566868496391", "title": "webpack工程化集成React技术栈（一）", "desc": "项目开始前，我们先聊一聊关于项目的一些说明。该项目起始于2017年初，当时公司主要技术栈为gulp+angular，鉴于react的火热的生态，在公司决定研发bss管理系统时选用react开发，目的也是为react native打下基础，以解决后期公司大前端技术栈的逐步成熟。（…"}, {"id": "6844904071627816973", "title": "Webpack4 进阶与实践", "desc": "通过 《Webpack4 基础入门与实践》 的基础学习，已经了解到应用程序通过 webpack 执行打包的入口 entry 及文件输出 output。它们的默认值分别是 './src' 和 main.js。 但如果我们的项目是一个可能会有多个入口文件的多页面的应用。 那么此时 …"}, {"id": "6844904100237148173", "title": "webpack Parser对JS表达式语句的解析计算", "desc": "上一篇文章梳理了webapck Parser解析模块的流程，根据解析模块过程中Parser针对不同语句即表达式解析抛出的事件，我们可以自定义地为模块添加依赖，从而通过依赖来完成相应的功能。本文将继续从Parser表达式的解析和计算来理解Parser，并配合webpack Def…"}, {"id": "6844903668009926663", "title": "用实验的思路优化webpack4项目编译速度", "desc": "最近开发的时候遇到一个问题：当项目越来越大的时候，webpack构建和编译的速度变得很慢。尽管webpack4官方宣称速度提高了90%以上，但实际使用的时候感觉速度和webpack2也差不多。我实在受不了热加载的时候要等几秒才能编译好，于是就开始了优化之路。 最终优化的效果不错…"}, {"id": "6844904099935174664", "title": "webpack+Vue+ts+仿写element-ui源码1(持续更新)", "desc": "5. 此时的目录结构"}, {"id": "6926921111091445774", "title": "webpack配置（三）", "desc": "当修改了webpack配置，新配置要想生效，必须重新webpack服务。 HMR功能：一个模块发生变化，只会重新打包这一个模块，而不是打包所有模块，极大提升构建速度。 样式文件可以使用HMR功能，因为style-loader内部实现了。 js文件默认不可以使用HMR功能，所以需…"}, {"id": "6844903501764493319", "title": "坐稳咯，webgl入门小贴士！", "desc": "经过这一个月来欲仙欲死的摸索，总算在摸索出了一些入门webGl的门道。本文不做关于webgl的任何教程内容，本文旨在分享一下我在摸索webgl中的一些姿势和一些坑，帮助一些初学者学习得更舒服一点。"}, {"id": "6844903997170515975", "title": "解决 webpack-dev-server 启动后手机上无法访问本地起的服务", "desc": "1 先把 webpack-dev-server 升级到最新版本。"}, {"id": "6844903728831692808", "title": "前端工程化 / 构建自动化", "desc": "前端工程化的概念在近些年来逐渐成为主流构建大型web应用不可或缺的一部分，在此我通过以下这三方面总结一下自己的理解。 1. 为什么需要前端工程化。 2. 前端工程化的演化。 3. 怎么实现前端工程化。"}, {"id": "6905629049188515853", "title": "从被测试大佬鄙视出发,封装一个wepback插件", "desc": "原来是出现了好几次前端 mock 数据带到测试环境的问题,使得测试大佬仇恨值++,差点要来给我一套化挥发加闪电五连鞭. 每次build的时候,心里都很慌,生怕手写的mock数据带到测试环境. 我寻思,作为一个程序猿,这种事我应该耗子尾汁,不应该每次都手动的去检查这个问题,所以也…"}, {"id": "6901081123078537224", "title": "Webpack基于baseUrl和paths引入模块", "desc": "excerpt: 在很多项目中，我们使用了webpack alias，从而支持基于alias进行import，但webpack alias使用过程中往往会遇到问题。怎样解决这些问题？正确的配置姿势应该是怎么样的？本文就来讲讲如何正确的配置项目支持相对路径引入模块。 。。。 怎样…"}, {"id": "6844903985808162830", "title": "webpack react脚手架配置-1", "desc": "而规范很好看，而现实是浏览器并不支持，所以就要用到webpack这样的打包工具。 但由于create-react-app配置默认是隐藏的，我们如果需要修改配置，就变得比较麻烦。 这里我们一步步来配置自己的脚手架，学习下webpack的使用方法。 推荐印记webpack中文文档，…"}, {"id": "6844903829272526856", "title": "一步步使用 webpack 第三篇：使用 webpack  管理图片等资源文件", "desc": "前面两篇文章，从零开始配置 webpack，分别使用 webpack 完成了 es6 代码的编译 以及 PostCSS 代码的编译。那接下来，我们就需要处理 js 、css 之外的资源文件，最常见的资源文件为图片，其他的资源文件还有 字体、音乐、和 xml 数据文件等。 本文的…"}, {"id": "6844903554046492686", "title": "前端每周清单第 48 期：Slack Webpack 构建优化，CSS 命名规范与用户追踪，Vue.js 单元测试", "desc": "前端每周清单专注前端领域内容，以对外文资料的搜集为主，帮助开发者了解一周前端热点；分为新闻热点、开发教程、工程实践、深度阅读、开源项目、巅峰人生等栏目。欢迎关注【前端之巅】微信公众号（ID: frontshow），及时获取前端每周清单。 ECharts 4.0 发布: 2018…"}, {"id": "6854573208419598343", "title": "Webpack的性能优化", "desc": "注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。 ​ 1. eval-cheap-source-map hash：每次wepack构建时会生成一个唯一的hash值。 问题:因为js和css同时使用一个hash值。 如果重新打包，会导致所有缓存失效。 chunkh…"}, {"id": "6895897788502409229", "title": "Webpack学习笔记(一)", "desc": "事情是这样的，之前做毕设的时候做了个项目。这个项目是用React的做的，但没有使用官方的cli工具，经过自己的一顿折腾搭建起来的。项目上线后，体积太大，导致首次加载需要8s之久！！成了我一块心病，于是准备重新学习一下webpack，找个机会把这个项目的打包做一个优化。 之前也对…"}, {"id": "6844904050362695688", "title": "Webpack实战（五）：轻松读懂Webpack如何分离样式文件", "desc": "通过js引入样式文件只是把样式添加到style标签内，而不是引入一个独立的css文件，一般来说，在生产环境下，我们希望样式存在于CSS文件中而不是style标签中，因为文件更有利于客户端进行缓存。 Webpack社区有专门的插件：extract-text-webpack-plu…"}, {"id": "6933947661712097287", "title": "从零到一学会webpack 03-缓存", "desc": "这里的[name] 我们称之为：substitutions --- 也就是一个占位符，执行build后被会替换。 在客户端向服务端请求资源时候，对应的资源匹配符一般是 url/path/filename,因此，当filename不发生变化时候，客户端会命中缓存，当我们文件发生修…"}, {"id": "6955757056070516772", "title": "当面试官问Webpack的时候他想知道什么", "desc": "在前端工程化日趋复杂的今天，模块打包工具在我们的开发中起到了越来越重要的作用，其中webpack就是最热门的打包工具之一。"}, {"id": "6860143903622823944", "title": "webpack入门（开发环境）", "desc": "随着三大框架的日渐成熟，我们已经很少自己去配置webpack了，因为三大框架已经对webpack进行了相应的配置，有些时候我们只需要在它的基础上去做一定的优化。 虽然是这么说，但是在面试的时候我们还是会被问到webpack的相关信息，此文就带大家打开webpack的大门。 页面…"}, {"id": "7001138300178137118", "title": "正确使用externals，vue工程构建性能提升67%", "desc": "webpack性能优化中必不可少的一环就是externals，本文详细阐述externals的使用场景以及如何使用"}, {"id": "6844903601060446221", "title": "Webpack中publicPath详解", "desc": "而关于如何应用该路径并没有说清楚... 这个最终静态资源访问路径在使用html-webpack-plugin打包后得到的html中可以看到。所以publicPath设置成相对路径后，相对路径是相对于build之后的index.html的，例如，如果设置publicPath: '…"}, {"id": "7004766160440803336", "title": "webpack编译结果分析", "desc": "合并 webpack通过入口文件将所有需要加载的模块合并到一个js文件中，该通过函数作用域的方式解决模块化中的代码污染全局。每一个模块都是一个函数。 合并之后生成的模块，key是模块的路径，value"}, {"id": "7001301355218501645", "title": "webpack掠影-4", "desc": "前面我们介绍了 webpack 的压缩合并代码，babel 的配置，今天我们练习 webpack 中暴露全局变量和 webpack 内置插件的使用"}, {"id": "6844904079320154126", "title": "Webpack优化总会让你不得不爱", "desc": "优化，就是加以改变或选择使优良，在工作当中是让提升效率的好办法。 1. 去除无用的样式 配置完毕了，上面包含了一些基本的配置。大家可以把重点放在注释为去除无用的样式代码部分即可了 2. 动态添加CDN 3. Tree-shaking 可想而知，副作用出现了，去dist目录下再看…"}, {"id": "6995073296517562376", "title": "webpack工作原理及loader和plugin的区别", "desc": "webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图"}, {"id": "6996334834662506503", "title": "Webpack中使用Web Worker", "desc": "最近老大说计算消息的函数耗时很长，导致后续渲染直接卡住，让我调研下能否使用web worker来处理处理消息的函数看看是否能解决渲染阻塞的问题，然后我就开始动手实践。"}, {"id": "6904829145188925447", "title": "聊聊webpack的那些事", "desc": "hello，大家好，我是德莱问，又和大家见面了。 前端构建工具的发展已经很久了，从最开始的不进行编译；到后来的grunt、gulp，流式的进行编译；到现在的webpack；在现在看来，webpack俨然成为前端打包编译的趋势，而且由于webpack的社区比较强大，发展也是非常迅…"}, {"id": "6844903784305393677", "title": "Webpack4+Babel7优化70%速度", "desc": "随着2018年2月15号webpack4.0.0出来已经有一段时间了，webpack依靠着“零配置”，“最高可提升98%的速度”成功吸粉无数，对于饱受项目打包时间过长的我，无疑是看到了曙光，于是决定开始试水。 随着项目的不断迭代，样式文件和js文件的数量越来越多，造成webpa…"}, {"id": "7002593564618129439", "title": "webpack5——揭示内部原理", "desc": "打包，是指处理某些文件并将其输出为其他文件的能力。但是，在输入和输出之间，还包括有 模块, 入口起点, chunk, chunk 组和许多其他中间部分。"}, {"id": "6952137026825093134", "title": "webpack全方位由浅到深讲解，做到简历上真正所谓的“熟悉”(系列一)", "desc": ".为什么需要构建工具转换 ES6 语法转换 JSXCSS 前缀补全/预处理器压缩混淆图片压缩...欢迎补充2"}, {"id": "6844903510530588685", "title": "妈妈再也不用担心我不会webpack了", "desc": "webpack前端工程中扮演的角色越来越重要，它也是前端工程化很重要的一环。本文将和大家一起按照项目流程学习使用wbepack，妈妈再也不用担心我不会使用webpack，哪里不会看哪里。这是一个由浅入深的文章。 现在vue、react等脚手架都会自动将开发环境使用的webpac…"}, {"id": "6971237797734645767", "title": "【Webpack】devServer 实验报告", "desc": "Webpack 的使用目前已经是前端开发工程师必备技能之一。若是想在本地环境启动一个开发服务快速开发我们的应用（而不是每次 coding 完，手动执行 run build，全量打包），大家只需在"}, {"id": "6844903910960791566", "title": "AST 与前端工程化实战", "desc": "AST 是一个非常基础但是同时非常重要的知识点，我们熟知的 TypeScript、babel、webpack、vue-cli 得都是依赖 AST 进行开发的。本文将通过 AST 与前端工程化的实战向大家展示 AST 的强大以及重要性。 第一次看见 AST 这个概念的时候还是在《…"}, {"id": "6978832288586924046", "title": "Webpack5 从零配置一个基础的 Vue 项目", "desc": "查了两个周末的文档，为你整理了这份 Webpack v5 配置基础 Vue3 项目的过程记录~~~。"}, {"id": "6844903608379506701", "title": "ESLint里的规则教会我，无规矩 不编程", "desc": "编程风格这个东西，说实在的对于刚加入团队的新成员来说还是很难让人完全适应的。因为每人的编程风格都不同，完全是各有千秋的既视感啊 放眼望去，在前端，但凡有个项目，无论大小，都会看到它的身影。并非为了提高比格，让别人暗赞专业，而是它确确实实帮我们检测出不易察觉的错误，避免N多个线上…"}, {"id": "6998324289787150343", "title": "Webpack配置-Babel深入解析", "desc": "初识Babel以及Babel作用 通俗点说 Babel其实就是一个转换工具，可以帮助我们语法转换、源代码转换、Polyfill实现目标缓解缺少的功能等；就是让一些代码中含有的浏览器不支持的代码转换成浏"}, {"id": "6844904042066345998", "title": "Webpack 再深入再总结", "desc": "文章内容参考书籍《深入浅出 Webpack》，因为该书籍基于 Webpack 3.4.0 版本，本文的实践基于 Webpack 4.28.2 版本，所以也踩了不少由于模块版本问题出现的坑，已经汇总到第 6 章节 踩坑汇总，大家记得避免踩坑；也印证了那句哲理：纸上得来终觉浅，绝知…"}, {"id": "6854573213171580941", "title": "你可能不知道的9条Webpack优化策略", "desc": "webpack的打包优化一直是个老生常谈的话题，常规的无非就分块、拆包、压缩等。 本文以我自己的经验向大家分享如何通过一些分析工具、插件以及webpack新版本中的一些新特性来显著提升webpack的打包速度和改善包体积，学会分析打包的瓶颈以及问题所在。 webpack 有时候…"}, {"id": "6992369894125731854", "title": "react-从零开始搭建项目-配置各种webpack-loader", "desc": "这是我参与8月更文挑战的第4天，活动详情查看：8月更文挑战 上一篇 react-从零开始搭建项目-webpack-dev-server 前言 上一篇我们通过配置webpack-dev-server完成"}, {"id": "6909717929923870728", "title": "手写一个webpack", "desc": "页面逐渐复杂，前端页面也想吃上模块化的糖。既然有想法，那何不做一个 既然 node 有现成模块化方案，就按 node 的规范来吧。开发时按照上边 node 规范写代码，通过一个工具把生成的文件输出到一个大文件夹即可，需要解决的问题如下： ok，代码成功执行。证明把文件转化为改数…"}, {"id": "6844903825115987976", "title": "把你的devtools从webpack里删除", "desc": "生产环境是没有 vConsole 了吧！想象很丰满，打包很骨感。 如果你 splitChunks 了的话，打包后的文件多出了个 vConsole，约 90k。使用 webpack-bundle-analyzer 分析也会看到多出一大块。。。 在这个移动端分秒必争的时代，凡是能从…"}, {"id": "6893885335018110983", "title": "webpack在vue/cli3中详细配置指南", "desc": "webpack的原理和手动实践实现webpack后续再进行补充。 在vue/cli 3 中为减少使用者对webpack繁杂的配置项，将webpack集成在cli内部，同时提供vue.config.js文件允许用户进行配置。 为涵盖了使用 vue-cli 开发过程中大部分配置需求…"}, {"id": "6844903510685777934", "title": "10集视频让你入门React构建和路由操作", "desc": "10集图文+视频的形式，让你掌握React项目的构建和路由操作。 希望帮助更多的前端爱好者学习。"}, {"id": "6985463009233600520", "title": "webpack从零开始", "desc": "webpack顾名思义，web为网页，pack为打包，webpack就是应用于前端的打包(bundle)工具。"}, {"id": "6844903859190513672", "title": "6个必须掌握的基础配置 - [webpack第一篇]", "desc": "一. entry入口配置 所以，webpack在执行构建的时候，第一步就是找到入口，从入口开始，寻找，遍历，递归解析出所有入口依赖的模块。 当然，除了上面三种静态类型，我们还可以动态配置entry: 即采用箭头函数动态返回。 此处，关于entry, 我们只需要记住，它有多种配置…"}, {"id": "6844903535146958862", "title": "Webpack多页面实现公共头部尾部和分离生产环境", "desc": "在日常开发中，经常会遇到这种类似头部和尾部，多个页面的拥有相同的HTML结构，如果每个页面都添加这种一样的代码，会让文件显得臃肿，且后期维护成本也很大。因此，我们可以将这些共用的HTML抽取出来形成类似组件的形式，在页面中直接引入就可以 不推荐，因为无法实时编译。 这样就可以实…"}, {"id": "6847902207610716167", "title": "webpack3.x升级4.x时遇到的问题", "desc": "在 vue-cli3 发布之前，使用 vue-cli2 构建的 vue 项目是基于 webpack3.x 的，伴随着项目的版本迭代，功能逐渐增多，文件也逐渐增多，打包时间从最初的 4.5 分钟，最久的时候 17 分钟。 因为使用 ts 的缘故，每次打包 ts-loader 需要…"}, {"id": "6844903673009537038", "title": "webpack性能优化不完全指北", "desc": "体积的大小直接关系到我们项目的加载速度， 而SPA的首屏加载速度又决定了用户的留存。对于体积优化，我们可以从俩个方面来下手。But 在那之前我们要先对自己的项目依赖构成进行分析，确定了优化的目标才能着手思考优化方案，进而实施优化方案。 我们只需要在每次打包的时候使用它，可以通过…"}, {"id": "6844904052128497678", "title": "Webpack实战（七）：简单搞懂PostCSS的用法及与一些插件的用法", "desc": "使用npm 进行安装postcss-loader,postcss-loader是连接PostCSS和Webpack。安装命令行如下： postcss-loader可以结合css-loader使用，也可单独使用，就是单独使用也可以达到需要的效果，但是单独使用的时候不建议用css中…"}, {"id": "6924484604086878216", "title": "webpack(二)", "desc": "使用HtmlWebpackPlugin插件，会生成新的index.html文件，替换我们的原有文件。 webpack 将生成文件并放置在 /dist 文件夹中，但是它不会追踪哪些文件是实际在项目中用到的。 使用clean-webpack-plugin插件，在每次构建前清理/di…"}, {"id": "6977375420358328328", "title": "WebPack | Loader处理非JavaScript模块机制详解", "desc": "webpack系列文章连载中...loader 让 webpack 能够去处理那些非 JavaScript 文件"}, {"id": "6844903588242653192", "title": "30分钟快速了解webpack", "desc": "(2) loader:如果你只需要一个loader来处理那么就传一个字符串，如果有多个则写一个数组（这里需要两个css-loader解析css里的路径如背景图路径等等，style-loader用来把css文件内容变为style标签并插入）转换的时候是按数组从右往左去转换的。 p…"}, {"id": "6844903507607158798", "title": "前端开发：如何写一手漂亮的 Vue", "desc": "前几日听到一句生猛与激励并存，可怕与尴尬同在，最无奈也无解的话：“90后，你的中年危机已经杀到”。这令我很受触动。显然，这有些夸张了，但就目前这日复一日的庸碌下去，眨眼的功夫，那情形就会在这骨感的现实面前，悄然的被显现。所以，越发体验到，当必要有计划的去做，去写，去玩，去嗨，利…"}, {"id": "6908245925206949895", "title": "探索 webpack", "desc": "loader 可以理解为 webpack 的编译器，用于对模块的源代码进行转换。它使得 webpack 可以处理一些非 JS 文件，如 png、css、json"}, {"id": "6844903565069123591", "title": "Webpack 4 不完全迁移指北", "desc": "在 webpack 3 发布 之后， webpack 团队向社区承诺，之后 webpack 主版本的迭代会有一个时间比较长且稳定的开发周期。而在2017年8月份的时候，webpack 团队从 master 分支切出了 next 分支用于 webpack 4 的开发，经历 5 个月"}, {"id": "6844903961527336968", "title": "【探索源码】html-webpack-plugin 4.x 对多模板下热重载缓慢问题的修复", "desc": "手上的公司项目热重载一直很慢，每次热重载大概要 15s 左右，最近实在忍无可忍，决定排查一下。 项目是基于 vue-cli2 搭建的，前人将 webpack 升级到了 webpack4。出于历史原因，公司项目的模块是根据模板（.html）划分的，因此项目中存在超过 30 个模板…"}, {"id": "6896797902996733959", "title": "单工程多项目", "desc": "1. 创建目录结构 2. 创建项目：npm init 3. 安装依赖： 4. 配置工程： 5. 配置项目： 6. 添加指令："}, {"id": "6844904067349626888", "title": "webpack 基础", "desc": "依据 webpack 官方文档，webpack 是一个 module bundler (模块打包器)。初次听到这个概念的时候，可能会一脸蒙蔽：这是个啥？对我的开发有啥影响么？ 为了更好理解 webpack，我们需要先了解模块 Module 与打包 Bundle 的具体含义。只有…"}, {"id": "6844904051344146440", "title": "Webpack源码分析 - 学习概论", "desc": "在使用过Webpack后，它强大的的灵活性给我留下了深刻印象，通过Plugin和Loader几乎可以随意扩展功能，所以决定探究Webpack的实现原理，学习作者的编程思想。 但是在学习源码过程中还是遇到了挺大困难，一是它的插件系统设计的错综复杂，刚开始看容易被绕晕，另外是它功能…"}, {"id": "6997229569912602661", "title": "webpack按需加载：从实践到原理", "desc": "在h5首屏优化的时候，代码分割（code spitting）是一个常用的优化手段，本文介绍了webpack按需加载的使用及其原理。"}, {"id": "6938975818659921957", "title": "深入探索Webpack5之Module Federation的“奇淫技巧”", "desc": "Module Federation使 JavaScript 应用可以动态运行另一个 JavaScript 应用中的代码，同时可以共享依赖。 如何理解上面这句话呢，我们可以从实际场景出发来看待这项技术。在我们日常开发中，经常能遇到需要复用一段代码逻辑的场景，一般我们可以从以下几种…"}, {"id": "6999540250091454495", "title": "基于react和typescript的webpack5 升级参考-2021.8.19", "desc": "前言 webpack5 现在的最新版本已经是5.5了，相对来说比较稳定，但是截止到2021.08.19，React的相关脚手架工具create-react-app最近一次更新仅仅是在14天前，comm"}, {"id": "6844903894745612295", "title": "Vue项目webpack打包优化实践总结", "desc": "Vue项目的页面是使用的虚拟路由，页面内容是靠vue-router配置的路由链接来访问的，SPA单页面应用开发，适合开发后台系统，但是对搜索引擎不友好，因为最后只生成一个页面。 搜索引擎是靠页面的链接来爬取网页内容，然后搜录进去搜索引擎数据库的，而vue打包以后的项目只有一个页…"}, {"id": "6844903619913842696", "title": "React中型项目的优化实践", "desc": "整个项目大概有60+个页面，用到的组件大概150+，package里面的依赖大概有70+个，应该勉强算得上是一个中型的React的项目了。 打包时间约150s，打包完之后的资源gzip之后约1.2m，尽管之前分离了一些公用依赖，但是index包的体积达到了600+还是令人难以接…"}, {"id": "6992234703793160205", "title": "Webpack5学习 --- babel", "desc": "在开发中我们很少直接去接触babel，但babel对于前端开发来说是不可缺少的一部分。其是在我们想要使用ES6+的语法，想要使用TypeScript的时候，我们都离不开Babel。"}, {"id": "6844903590046203918", "title": "改造vue-cli,使用mockjs搭建mock server", "desc": "最近准备开发一款web应用，考虑到可能会有前后端并行开发的场景,所以决定使用mockjs做mock server。 浏览官网文档时发现没有跑在webpack上的例子，索性自己找方法解决。 这时可以考虑前端搭建web server自己模拟假数据,mockjs用来生成随机数据,拦截…"}, {"id": "6993301727021629453", "title": "webpack实践 | 8月更文挑战", "desc": "这是我参与8月更文挑战的第6天，活动详情查看：8月更文挑战 安装： 在使用过程中npm比较慢，大家可以把npm源设置为淘宝镜像源，执行命令： 但是如果其他同事没有设置这个，或者并不知道如何设置，我们可"}, {"id": "6992608356443619335", "title": "Webpack5学习 --- ESLint", "desc": "ESLint 是一个插件化并且可配置的JavaScript 语法规则和代码风格的检查工具。ESLint 能够帮我们轻松写出高质量的JavaScript 代码。"}, {"id": "6844904004825120782", "title": "总结几个webpack打包优化的方法", "desc": "1.2 第三方组件和插件。按需加载需引入第三方组件 通过 include、exclude 来减少被处理的文件。 extension 配置之后可以不用在 require 或是 import 的时候加文件扩展名,会依次尝试添加扩展名进行匹配。 alias 通过配置别名可以加快 we…"}, {"id": "6968276421798002725", "title": "老工程打包提速折腾记（上）- roadhog 打包提速", "desc": "背景： 目前项目这套前端框架，build常常达到900s以上，开发环境修改代码重新编译也需要10-20s左右，严重影响开发效率，优化刻不容缓。 环境： 硬件：I5-6200U 4核 @2.3GHz， "}, {"id": "6993158945833484296", "title": "webpack4升级webpack5各种坑", "desc": "背景 webpack5出现也一年了，也该升级一下了 网上资料一通找，一堆升级教程，照着做，开始... 各种坑 开始勤劳的的填坑 开始 vue-loader问题 注意 vue-loader不同的版本是对"}, {"id": "6906392371785793543", "title": "webpack: 多页面+vue单页面 老项目jq升级", "desc": "不能慌张，我们可是前端工程师...那么我们该怎么办呢？首先我们先分析一下我们可以怎么办，那么我们首先分析一下他使用的技术栈和运用场景。 通过和项目组，产品的沟通。该项目，是运行在微信公众号上的的一个h5页面。那么能够给你的时间，差不多是一周时间，去熟悉了解，整个项目。 | 文件…"}, {"id": "6972756491715477541", "title": "[ webpack ] webpack 的 loader 和 plugin 开发的方法", "desc": "Loader 和 Plugins 的区别 loader 主要的是处理静态资源，而 plugins 是可以贯穿在整个 webpack 构建的周期中，他能做到 loader 做不到的事情。但是，loade"}, {"id": "6844903875774775303", "title": "利用webpack搭建脚手架一套完整流程", "desc": "我们的目标是利用webpack搭建一个基于react + react-router +dva + es6 + less + antd用于中后台开发的脚手架，同学们可能会说社区里那么多优秀的脚手架为什么还要自己搭，而且网络上这类文章也非常的多，没有再重复写的必要，但是对我而言，分…"}, {"id": "6954598853593169951", "title": "Webpack 写一个 markdown loader", "desc": "前段时间在公司内部写了个 UI 组件库，需要有组件说明文档。我们的组件文档一般都是用 md 文件书写，然后渲染成页面展示。我们首先基于 vue-cli 脚手架生成前端项目配置，然后我们通过 webpa"}, {"id": "7000762563189276709", "title": "初识Webpack(三)", "desc": "这是我参与8月更文挑战的第20天，活动详情查看：8月更文挑战 插件plugin 插件是 webpack 除了loader以外的另一个核心功能。而通过对Webpack源码的观察发现.."}, {"id": "6974641180592046116", "title": "EMP v1.8 配置优化详解", "desc": "为了更直观地配置EMP 1.8之后把配置文件进行了TS改造，适配了绝大多数的webpack5配置的同时、简化了配置难度，加入了代码提示！"}, {"id": "6980226716178317319", "title": "记录-实现封装webpack", "desc": "记录-实现封装webpack 封装webpack是什么意思？ 封装webpack有什么好处？ 如何封装webpack？ 难点1：需要一个命令平台 难点2：需要在封装后的包内部，去执行webpack及w"}, {"id": "6844903623944568839", "title": "webpack4.x 入门一篇足矣", "desc": "webpack4出了以后，一些插件变化很大，和之前的版本使用方式不一样，新手入坑，本篇将介绍如何从一开始配置webpack4的开发版本，对css，js进行编译打包合并生成md5，CSS中的图片处理，js自动注入html页，删除指定文件，提取公共文件，热更新等等。 执行webpa…"}, {"id": "7007794020575346719", "title": "Angular CLI下的自定义Webpack配置方法和自定义loader处理案例实践", "desc": "本文结合DevUI团队丰富的真实业务场景实践，带大家入门`Webpack loader`，干货满满！"}, {"id": "7008033212156870693", "title": "如何用webpack打包各种资源🤷‍♀️", "desc": "webpack五个核心概念webpack基础概念 打包样式资源、非js资源、html资源、图片资源等等"}, {"id": "7007626276148248613", "title": "Webpack Plugin学习笔记", "desc": "webpack根据打包流程定义了不同阶段的事件集。在打包过程中，通过调用预先在事件集中注册事件，实现特定的处理功能，完成自定义打包"}, {"id": "7007780411988246536", "title": "通过webpack解决浏览器兼容问题", "desc": "前言 很多面试时都会问到关于浏览器兼容问题，正好最近在看webpack打包，那就在这里记录一下我们如何通过webpack来实现兼容。"}, {"id": "7002839760792190989", "title": "webpack 十连问你能接住几题", "desc": "前言 面试题只是一个引子，快速刷题就是背（面试官问你，但是他不一定很深入），想深入理解还是得花大量精力； webpack 的构建流程是什么 初始化参数：解析webpack配置参数，合并shell传入和"}, {"id": "7007292709316591629", "title": "webpack项目里面波浪号~的使用", "desc": "背景 在项目里面使用大量的相对路径 ../../../, 看起来真的不好看，也不优雅，webpack给我们提供了~ 去解决这个问题 方法 总结"}, {"id": "6992754161221632030", "title": "多图详解，一次性搞懂Webpack Loader", "desc": "本文通过精美的图文，深入分析 Webpack Loader 的运行机制，带你吃透 Webpack loader 的 11 个核心问题。"}, {"id": "6982361231071903781", "title": "webpack 最佳实践", "desc": "本文讲述的最佳实践是从日常业务中总结而出的，不一定适合所有项目。毕竟每个公司或个人的项目不同，最佳实践也会有所不同。但是可以从这篇文章借鉴吸收一点有用的东西，有问题的地方也欢迎大家积极吐槽指正。"}, {"id": "7006109696926941221", "title": "webpack5配置及优化", "desc": "webpack的官网文档没用那么通俗易懂，本文拆解了部分开发需要用到的相关配置项，可能会有你想要的。"}, {"id": "7007373370144587806", "title": "webpack4 持久化缓存（长缓存）", "desc": "webpack4 持久化缓存 hash、chunkhash 和 contenthash 的区别 chunkId namedModules namedChunks"}, {"id": "7006952872894005255", "title": "Webpack + React + TypeScript 构建一个标准化应用", "desc": "项目及工程化配置以及主要功能配置、规范化管理和使用细节应该都没啥问题了。 后面若发现构建及配置问题、以及可优化的细节部分、包括功能的进一步迭代也会使项目不断更新完善的~ 目前主要是做了规范及工程化的配"}, {"id": "6961961165656326152", "title": "做了一夜动画，让大家十分钟搞懂Webpack", "desc": "做了一夜动画，让大家十分钟搞懂Webpack 一、什么是webpack webpack是一个打包工具，他的宗旨是一切静态资源皆可打包。 二、原理分析 首先我们通过一个制作一个打包文件的原型。 假设有两"}, {"id": "7006650476158517256", "title": "Webpack5 系列（七）：代码分离", "desc": "一、前言 上一篇讲到不同模式下的打包配置，本篇将介绍代码分离（Code Splitting）。 观察以上代码，我们发现在开头同步引入了 lodash，这没什么问题，但是一旦这个 index.js 文件"}, {"id": "6926760819375996941", "title": "Webpack 详解（一）", "desc": "有一段时间没有做积累和学习了，近期学习的内容会陆陆续续更新进来。 Webpack 应该会写一个系列吧，从 初探 => 深入 => 实战。 现在就将相对路径的根目录改成了 src，这个时候使用相对路径就是从 src 目录下进行查找。例如上面的 entry，就会从 src 目录下进…"}, {"id": "7007196448240435230", "title": "从入门到入土使用Webpack5搭建一个项目", "desc": "引言 在日常开发中，我们开发一个项目用到的都是Vue、React等官方出的脚手架；或者团队内部自定义的脚手架。脚手架中封装了许多功能，但是如果没有特别好的文档的话，我们要通过脚手架去自定义的话就会发现"}, {"id": "6943468761575849992", "title": "当面试官问Webpack的时候他想知道什么", "desc": "在前端工程化日趋复杂的今天，模块打包工具在我们的开发中起到了越来越重要的作用，其中webpack就是最热门的打包工具之一。 说到webpack，可能很多小伙伴会觉得既熟悉又陌生，熟悉是因为几乎在每一个项目中我们都会用上它，又因为webpack复杂的配置和五花八门的功能感到陌生。…"}, {"id": "7002898476388319269", "title": "手撸组件库之文档工具", "desc": "因为最近失业中，便闲来无事，就整了个React组件库（不想面试），主要不喜欢antd，还有一些其他原因。也发过沸点，也有一些好奇实现方案的，所以便有了本文。"}, {"id": "7007324339926204452", "title": "【webpack系列】6. 从源码角度深度剖析html-webpack-plugin执行过程", "desc": "之前文章介绍了webpack的plugin插件是如何运行的，但是对于某个特定的插件具体如何执行的还是不太清楚，这篇文章从实例的角度来剖析html-webpack-plugin的执行流程，相信通过这篇文"}, {"id": "6998416819497205774", "title": "webpack loader 源码、原理、实践", "desc": "为什么需要 loader,如何配置,loader 怎么工作,loader-runner 基本规则,让我们实现 loader-runner,开始编写css、style、file loader。"}, {"id": "6996816316875161637", "title": "学习 Webpack5 之路（优化篇）- 近 7k 字", "desc": "本篇将从优化开发体验、加快编译速度、减小打包体积、加快加载速度 4 个角度出发，介绍如何对 webpack 项目进行优化。"}, {"id": "6844903502544633869", "title": "vue-cli npm run build空白页的两个坑 webpack gzip文件压缩优化打包文件", "desc": "npm run build 是vue-cli用来打包项目的命令行，本文是关于vue-cli打包的一些常见的坑，会尽量详细的写每个步骤，大家可以一边看着文章，一边打包试试。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 这里初始化一个项目，因为导致…"}, {"id": "6984671993299730468", "title": "webpack-dev-server 以及热更新原理", "desc": "webpack 将我们的项目源代码进行编译打包成可分发上线的静态资源，在开发阶段我们想要预览页面效果的话就需要启动一个服务器伺服 webpack 编译出来的静态资源。webpack-dev-serve"}, {"id": "6844903633742462983", "title": "webpack 4 ：从0配置到项目搭建", "desc": "webpack4发布以来，我写项目都是用脚手架，即使再简单的项目，真的是really shame。。虽然道听途说了很多 webpack4 的特性，却没有尝试过，因为它给人的感觉就是，em...很难。但是今天我从最简单的部分开始，一点点搭建起一个项目。 而 webpack4 的 …"}, {"id": "6844903777296728072", "title": "使用 Webpack 的 DllPlugin 提升项目构建速度", "desc": "本文介绍了 Webpack 中 DllPlugin 插件的使用，以及配合使用 AddAssetHtmlPlugin 将构建好的 JS 文件插入到 html 页面中。 DLLPlugin 就是将包含大量复用模块且不会频繁更新的库进行编译，只需要编译一次，编译完成后存在指定的文件（…"}, {"id": "6955517410761932807", "title": "Webpack 优化", "desc": "公共代码抽离（代码分割） 单页面跟多页面都可使用，公共代码只需要下载一次就缓存起来了，避免了重复下载。可以参上xxxx,配置在 optimization.splitChunks 中, element-"}, {"id": "6959871717527257125", "title": "在小程序中愉快地写scss", "desc": "利用webpack将sass编译成wxss插入小程序页面 公司的电商小程序项目有点年头了，一直用的原生写法，由于种种原因，没法用其他技术栈重构，每次写wxss都是很难受的，所以有了这个想法"}, {"id": "6914944560544088072", "title": "webpack基础配置笔记", "desc": "手动新建目录比如我这里的testwebpack在testwebpack目录下执行npm init。 备注 ：在安装webpack之前先使用npm init初始化下项目，这时候项目中就有package.json了,package.json是node的包管理的文件，如果当前项目需要…"}, {"id": "6844903625077030925", "title": "webpack 从入门到放弃(一)", "desc": "为什么使用 webpack，这应该是和前端的发展有关系的，我认为，webpack 是前端发展到一定阶段的必然产物（貌似是一句废话）。 因为计算机网络的飞速发展，导致 web 前端也在迅猛发展。最初的实践方案已经不能满足我们的需求，于是，越来越多的新技术新思想新框架孕育而生，比如…"}, {"id": "6894876598793666573", "title": "Webpack 深入理解之Loader", "desc": "10 月面试的时候，有位面试官在和我谈及 Webpack 相关知识的时候提到了 Loader，并问及是否有自己实现过一些 Loader。从使用 Webpack 开始每个项目都会配置很多的 Loader，我们都知道 Loader 的作用是处理一些资源文件。例如 sass-load…"}, {"id": "6967182838978314271", "title": "在weboack构建的项目中(vue)使用mockjs", "desc": "在webpack构建的项目中(vue)使用mockjs 首先需要了解一个方法require.context"}, {"id": "6844903951410659341", "title": "Webpack 打包太慢? 试试 Dllplugin", "desc": "1. 介绍 对于 CommonsChunkPlugin，webpack 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而 DLLPlugin 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。Dll这个概念是借鉴了Window…"}, {"id": "6844903701434335246", "title": "webpack4、Koa配置Vue服务器端渲染(SSR)", "desc": "从这段代码我们应该可以明白vue-server-renderer的作用是拿到vue实例并渲染成html结构，但它不仅仅只做着一件事，后面会介绍其他配置参数和配合webpack进行构建。 拿到html结构渲染到页面上是我们接下来要做的事情，这里官方事例用的是express搭建服务…"}, {"id": "6844903555938123783", "title": "《React 学习之道》The Road to learn React (简体中文版)", "desc": "《React 学习之道》这本书使用路线图中的精华部分用于传授 React，并将其融入一个独具吸引力的真实世界 App的具体代码实现。 如何掌握 React 存在特别多的路线图。本书提取这些路线图中的精华部分，并将其融入于一个具体的应用程序当中。您将会构建一个属于自己的 Reac…"}, {"id": "6944962404891492388", "title": "vue/cli3 通过自定义loader控制console日志输出", "desc": "在web项目开发过程中，为了方便调试，我们经常会在控制台通过console.log输出很多日志,然而通常在项目上线的时候，我们都需要把它屏蔽掉。正好通过webpack配置，可以帮我们实现这个功能。 我们在node_modules同级文件夹下新建一个loaders文件夹，这里面存…"}, {"id": "6844903645411016718", "title": "旧项目 TypeScript 改造问题与解决方案记", "desc": "由于本次改造的项目为一个通过NPM进行发布的基础服务包，因此本次采用TypeScript进行改造的目标是移除Babel全家桶，减小包体积，同时增加强类型约束从而避免今后开发时可能的问题。 本次改造使用的是TypeScript v2.9.2，采用Webpack v4.16.0进行…"}, {"id": "6913531130180272142", "title": "vue-cli3.0 打包优化实践", "desc": "1. 配置 gzip 压缩，打出来一个待 gzip 后缀的文件 2. webpack-bundle-analyzer 分析包 3. webpack splitChunks， 提取出来的通用 'echarts', 'moment', 'element-ui', 'xlsx'等 4…"}, {"id": "6921653345685864456", "title": "webpack5 会自动命名代码块 ID", "desc": "你知道 chunkFilename 的作用吗？了解之前，先了解懒加载，动态导入的功能。 1、假如你在 YouTube 上加载一个视频页面，你更关心的肯定是视频而不是评论。所以，这里视频就比评论重要。 2、又比如你在一个新闻网站看一篇文章，你更关心的肯定是文章的文字而不是广告。所…"}, {"id": "6844903608715067400", "title": "手把手实战react + storybook组件库", "desc": "在UI组件库的开发过程中，如何方便的展示组件，测试组件，编写文档呢？storybook就提供了这样一种工具，利用它我们可以更方便地进行UI组件开发。最近一直在研究react，react和storybook的碰撞会是怎么样的呢。下面将从零开始，运用storybook手把手撸一个r…"}, {"id": "6985458703566635044", "title": "你要知道的 webpack 性能优化总结", "desc": "本文写了整理了好久好久了，一直在 bolg 上未发出来，虽然可能已经有一丢丢过时了～ 文章的优化内容是建立在 webpack 4.x 上的，后面也会有 webpack 5.x 相关的介绍~"}, {"id": "6961638204659204104", "title": "初识Webpack", "desc": "用Webpack解决什么问题？模块化 高级特性、开发效率、安全性 ES6+、Typescript、sass、less 监听文件变化并反映到浏览器"}, {"id": "6998403447770857509", "title": "前端页面优化指北", "desc": "本文主要讲了为什么要做页面优化，从客户，开发本身，公司有什么好处。 在众多的衡量标准里面如何选择适合自己的标准。 衡量的手段有哪些。"}, {"id": "6922039283016531982", "title": "webpack 模块化原理", "desc": "在webpack中既可以书写commonjs模块也可以书写es模块，而且不用考虑浏览器的兼容性问题，我们来分析一下原理。 查看编译结果，可以发现webpack对于每个模块的做法类似于node，将每个模块放在一个函数环境中并向其中传入一些必要的参数。webpack将这些模块组成一…"}, {"id": "6844903581661790216", "title": "浅谈模块化开发", "desc": "现在的前端开发, 不仅仅是完成浏览的基本需求，并且通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码. 如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个…"}, {"id": "6987383865748750343", "title": "新手使用webpack5搭建typescript项目", "desc": "新手记录webpack5搭建typescript项目时遇到的一些问题，根据实际操作总结出来的一点儿经验，已备以后搭建项目时借鉴"}, {"id": "6844903606043279367", "title": "【翻译】Webpack 4 教程：从0配置到生产模式", "desc": "这个流行的模块打包工具进行了大规模的升级。 webpack4，有什么更新？大幅度的性能优化，零配置和明智的默认配置。 给中大型项目提供一个配置文件不是什么大问题。你甚至无法离开它。然而，对于一些较小型应用来说就有点麻烦了，尤其是你在心血来潮想开始做一些好玩的app的时候。 简要…"}, {"id": "6844903985267261454", "title": "webpack4.0搭建vue脚手架详解", "desc": "出于某些原因要完成一个demo,思考后决定搭个简单脚手架veu的spa项目来做。对于webpack基本概念(entry,output,loader,plugin,mode...)有了的认识，但是没有尝试撸过脚手架的朋友可以继续往下看。 到此一个简单的编译打包vue项目的脚手架就…"}, {"id": "6844904166993690638", "title": "ERROR in Entry module not found: Error: Can't resolve './src' in XXX的一个解决方案", "desc": "今天在学习 Vue 的 webpack 时（使用配置文件配置），使用 webpack 命令打包项目时，报了 ERROR in Entry module not found: Error: Can't resolve './src' in XXX 的错误。报错截图以及项目目录如下…"}, {"id": "6956759447716757517", "title": "开发Loader 你得知道有哪些Loader API", "desc": "前情回顾 上篇文章简单介绍了一下如何简单实现一个loader,今天聊一聊Loader API相关的内容。 Loader API loader实际上是一个有权调用Loader API的函数模块儿。并且这"}, {"id": "6976197192151203877", "title": "webpack插件 - 自动抽取css中的主题颜色,并实现一键换肤", "desc": "- 该插件主要用于提取主题颜色 - 提取到的css数据会挂载到window下 - 通过颜色替换再插入到`<style>`，可达到动态修改主题的目的"}, {"id": "6844903600833970190", "title": "异步多图加载这件小事儿（Promise与async)", "desc": "日常开发过程中，时不时会遇到要同时预加载几张图片，并且等都加载完再干活的情况，结合 Promise 和 async/await 代码会优雅很多，但也容易遇到坑，今天就来简单聊聊。 先从最基本的 ES5 说起，基本思路就是做一个计数器，每次 image 触发 onload 就加一…"}, {"id": "6969165512722890789", "title": "webpack5 的使用（一）：起步", "desc": "这是我参与更文挑战的第2天，活动详情查看： 更文挑战 前言 本系列将分多篇文章，逐一介绍 webpack5 的使用。 本系列比较新手向，适合从来没有使用过 webpack 或略知一二的人看，不适合希望"}, {"id": "6882912316906078221", "title": "【实战】webpack4 + ejs + egg 多页应用项目最终解决方案", "desc": "好久都没有写过文章了，之前写过一篇 《【实战】webpack4 + ejs + express 带你撸一个多页应用项目架构》，发布后我发现大家对于 “简化多页应用开发流程” 这块需求强烈，并且，随着我将上一篇文章中介绍的多页开发模式运用到实际项目中后，发现还是存在一些缺陷的。其…"}, {"id": "6844903635072057357", "title": "webpack心得总结", "desc": "我对学习webpack的起因很简单，因为它够潮，而我恰恰喜欢潮的东西。我之前也了解过webpack，但是仅仅是局限于他的使用方法，能够看懂他的配置文件。而我这次对他的用处有了更深的了解。 首先从es6说起吧，浏览器对es6的支持度并不高。仅仅实现了其中的一部分而已，但是es6的…"}, {"id": "6844903891994148871", "title": "create-react-app 多页应用配置", "desc": "本文主要讲的是如何使用 react-app-rewired 扩展 create-react-app 配置支持多页应用，包含开启 PWA, 支持 ant-design 按需加载，兼容 IE11。"}, {"id": "6844903541400698887", "title": "vue-cli解析", "desc": "这篇文章的主题是vue-cli的理解。或许，很多人在开发vue的时候，我们会发现一个问题——只会去用，而不明白它的里面的东西。现在的框架可以说是足够的优秀，让开发者不用为搭建开发环境而烦恼。但是有时候，我们还是得回到原始生活体验一下，才能够让自己更上层楼，希望大家共勉。如果你喜…"}, {"id": "6844903665803722759", "title": "【webpack进阶】前端运行时的模块化设计与实现", "desc": "webpack是一个强大而复杂的前端自动化工具。其中一个特点就是配置复杂，这也使得「webpack配置工程师」这种戏谑的称呼开始流行🤷但是，难道你真的只满足于玩转webpack配置么？ 显然不是。在学习如何使用webpack之外，我们更需要深入webpack内部，探索各部分的…"}, {"id": "6987029428463697956", "title": "webpack常用开发体验/分析相关工具", "desc": "webpack常用开发体验/分析相关工具。主要为了解决在使用webpack中，主题以及提示不直观的问题。"}, {"id": "6844903581477421063", "title": "[prerender-spa-plugin]--微型Vue项目的静态化利器", "desc": "我们的官网是特别“纯正”的vue-cli项目，也就是说这是个用webpack进行打包的单页应用。 在路由方面选择的是vue-router，mode是hash模式，因为并不需要考虑IE浏览器以及移动端浏览器(特别是微信这个小妖精)，所以并没有特别注意路由这一块的配置。 在页面开发…"}, {"id": "6948949388899123236", "title": "webpack 源码调试", "desc": "感觉还是通过clone webpack源码包调试的比较好一点，也方便调试最新代码和切换版本。 不同的调试方法适合不同的运行方式，下面会进行一一介绍。 首先通过github找到webpack源码，进行clone。通过https协议进行克隆，代码如下： clone源码后要创建一个新…"}, {"id": "6844903935837208584", "title": "编写一个自己的webpack插件plugin", "desc": "非彼无我，非我无所取。——庄子 插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事。 要想写好插件就要知道Webpack中的两个比较核心的概念compiler…"}, {"id": "6927248113979637774", "title": "webpack系列之AutoWebPlugin多页面应用管理", "desc": "在webpack系列之多页面应用打包通用方案一文中，介绍了多页面应用打包的实现方案。该方案借助glob模块拿到src目录下的多个入口文件，遍历后得到多个模板文件，最后将入口文件和模板文件都暴露出去，在"}, {"id": "6899745224084422663", "title": "webpack从零开始配置大全", "desc": "为了避免插件版本的兼容问题，以下安装个别npm依赖时我会指定版本号。 本文仅作为webpack学习之用，实际项目中还是更推荐使用成熟的脚手架搭建，然后根据学习的成果再去定制改造。 正常的话，会在项目根目录生成dist文件夹，里面就是打包后的文件。 chunkhash 根据不同的…"}, {"id": "6950242785421164580", "title": "webapck热更新基本原理", "desc": "写在前面Hot Module Replacement，简称HMR，无需完全刷新整个页面的同时，更新模块。HMR的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。刷新我们一般分为两种："}, {"id": "6854573212823453710", "title": "揭开 webpack 的那层纱", "desc": "关于 webpack，在我眼里一直都是蒙了一层“面纱”，一些配置也只能做到 “眼熟”。至于如何从 0 到 1 地去搭建一套“能用”的 webpack 配置更是“痴人说梦”。 “痛定思痛”之后， 我决定揭开那层“面纱”，重新梳理一遍它的基础配置，并进行一次从 0 到 1 的搭建。…"}, {"id": "6844903732736442376", "title": "采用 vue+webpack 构建的单页应用——私人博客 MintloG 诞生记", "desc": "MintloG是我在五天之内完全由自己开发的私人博客，前端技术方案采用了vue+vue-router+vue-resource+webpack的构建方案，后端技术采用了原生PHP+MySQL。博客完全由ajax实现和后台的通信，后台只提供了一个接口，通过传入不同的参数实现不同的…"}, {"id": "6844903555342532622", "title": "Laravel框架中缩小Vue应用的体积", "desc": "这两天写一个很小的Laravel+Vue的前后端分离应用，前端的代码文件并不多，但webpack打包生成的app.js居然有3M，生成的production版也有1.4M，放到自己的服务器上，那速度完全无法忍受。于是探究起如何缩小应用体积。 这里使用webpack-bundle…"}, {"id": "6932311821869121550", "title": "webpack 源码流程", "desc": "webpack 是一个静态模块打包工具。当webpack处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每一个模块，然后将这些模块打包成一个或多个bundle。 after-compile 这个在seal阶段，对每个module和chunk进行整理，生成编译…"}, {"id": "6935746577508073479", "title": "Webpack 到底是如何打包的？", "desc": "打包，是指处理某些文件并将其输出为其他文件的能力。 下面以一个简单的 demo 来分析 webpack 是如何做打包的。 src 下文件肯定不能直接在浏览器运行，因为不识别 import 等语法，所以需要对其编译打包。 下面直接进入今天的主题，编写一个打包文件 bundler.…"}, {"id": "6844903829906046990", "title": "一步步使用 webpack 第四篇：使用 webpack 编译 vue 代码", "desc": "之前写的三篇文章，分别简单介绍了如何配置 webpack 完成 es6 代码编译、PostCSS 代码编译、以及 使用 webpack 管理资源文件。接下来将配置 webpack 完成 vue 代码的编译。 配置完 vue 的处理规则后，我们的基本配置就已经完成了。在前三篇文章…"}, {"id": "6903882606987706381", "title": "从手把手编写 webpack 插件开始", "desc": "为方便初学者快速上手，暂时抛开那些晦涩的概念，直接跟着笔者写一个 webpack 插件，来感受一下吧。笔者这里的代码是基于 webpack 5.x 版本写的，跟 4.x 版本有一定差异。这是一篇入门文，如果已经有基础，就不需要看此文了。 我们假设这样一个场景：发布静态资源之后，…"}, {"id": "6844904082969198605", "title": "Webpack4不求人(3) ——性能优化", "desc": "项目比较小的情况下Webpack的性能问题几乎可以忽略，但是一旦项目复杂度上升，Webpack会有额外的性能损失需要我们进行优化。 通过entry指定的入口脚本进行依赖解析。 找到文件后通过配置的loader对其进行处理。 因此，我们可以从这方面入手进行优化，减少Webpack…"}, {"id": "6844903853930840071", "title": "渐进式配置webpack4单页面和多页面(二)", "desc": "webpack.base.conf.js 配置可视化现在打包文件。 打包提示代码太大，需要进行拆包。 optimization.splitChunks是webpack4新的特性，默认进行代码拆包。 上图是默认配置。 all: 不管文件是异步还是同步引入，都可以使用splitCh…"}, {"id": "6844903537642569742", "title": "基于react16 webpack3 搭建前端spa基础框架 react-router的4种异步加载方式", "desc": "这两天看了下react的文档，准备搭建一套适用的基本react开发架子。 由于我一直使用的是vue，很少使用过react进行项目的开发，因此此构建主要参考的是vue的项目经验。 react和vue的开发模式很像，同样的组件化，模块化，统一状态管理机制，路由 ... 等等，因此我…"}, {"id": "6844903506424365064", "title": "webpack3--plugins大用处", "desc": "电力保障在线，好比我们 devServer 服务开启。 这一形象的比喻，目的在于帮助我们理解webpack的工作机制，要想用好它，就必须清楚每个module的原理和使用方法。 loader 仅在每个文件的基础上执行转换，而 插件(plugins) 更常用于（但不限于）在打包模块…"}, {"id": "6844904058591920141", "title": "Webpack源码分析 - loader-runner", "desc": "loader-runner在Webpack的构建模块周期使用，负责将文件路径转换为文件内容。我们添加的loader最终会在这里执行，另外资源文件也是在这里被加载。文章使用2.4.0版本代码调试。 loader可以支持以同步或异步(callback, Promise)方式运行，调…"}, {"id": "6912437596706570253", "title": "记录webpack优化", "desc": "自动刷新 （知道就行。 webpack-dev-server 有这功能） 一个js文件打包成一个函数，文件多了打包后的函数也会多。使用 Scope Hosting 合并、减少打包后的函数"}, {"id": "6844903681289093128", "title": "一次webapck4 配置文件无效的解决历程", "desc": "升级webpack4，一定要去看文档，特别是更新说明，不要自持用过原本webpack就自己开始折腾。折腾到后面，可能就默默流下眼泪了。 webpack-cli被单独拆了出来，使用的时候如果只是全局装了CLI，直接执行的时候是可以的。 如果是我没有全局装，我肯定会意识到要选一个，…"}, {"id": "6970276599606280223", "title": "Webpack 的 tree-shaking 进阶之路（三）", "desc": "webpack 打包 + terser 实现 tree-shaking 的分析来了！ terser 是一个用于 ES6+ 的 JavaScript 解析器和 mangler/compressor工具"}, {"id": "6868075380054425607", "title": "「Webpack 基础」常用配置解读", "desc": "1. mode 设置打包环境，production为生产环境，development为开发环境。可以在不同环境配置不同打包需求，如在生产环境中，尽量提升打包速度，减少包体积等，在开发环境增加必要的调试信息。 2. devtool 为了更容易地追踪错误和警告，JavaScript…"}, {"id": "6844903604873068551", "title": "webpack打包优化探索", "desc": "虽然webpack的已经升级到了webpack4，而我们目前还在使用webpack3，但其中的优化点都大同小异，升级后同样适用。性能优化初步原则减小代码量减小请求数最大化利用浏览器缓存这三条原则永远是"}, {"id": "6888651579772436487", "title": "聊聊 webpack 异步加载（三）：webpack 如何做到持久化缓存", "desc": "前两篇文章我们基本清楚了在两种不同情况下，webpack如何处理拆包后的代码：1、库代码与业务代码分离2、import()与codespliting默认情况下chunks与modules都以顺序的数字"}, {"id": "6922235444650475527", "title": "webpack系列学习-构建webpack配置", "desc": "前言：笔者把学习的webpack知识从基础到原理写个系列，以便回顾。希望能帮助到更多正在学习webpack的小伙伴。 代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成 可以下载调试。"}, {"id": "6937833691938979871", "title": "从零学脚手架(三)---webpack属性详解", "desc": "在上一篇中，介绍了 webpack 的 entry 、 output 、 plugins 属性。 在这一篇，接着介绍其它配置属性。 搭建的 工程化 代码基本都无法直接运行在浏览器，所以本地测试也都是使用打包编译后的代码预览。 但是本地开发预览又必须具有代码可读性、可调试性等条件…"}, {"id": "6850418111762399240", "title": "Webpack4 学习指南（一）", "desc": "Webpack 是代码编译工具，可以通过配置文件，解析项目结构，找到 HTML、JS、CSS、图片等资源模块之间的依赖关系，然后把所有的模块打包压缩。 在 Webpack 启动后，首先会读取配置文件，然后从 Entry 里面配置的入口文件开始解析 Entry 依赖的所有的 Mo…"}, {"id": "6844903535922905096", "title": "基于webpack打造前端在线编译器", "desc": "本文是针对公司内部UI组件开发的用来编辑代码与查看效果的平台。文章梳理了项目的完整开发流程与一些细节的思考：对前端代码的编译使用 webpack实现，如何实现编译错误的处理？用户提交的代码在哪儿编译，基于物理硬盘还是内存？等。本文专注于对实现思路的梳理，弱化具体代码展示，抛砖引玉"}, {"id": "6844903795265126413", "title": "webpack4升级指南", "desc": "作者| 王呈威鉴于图书项目编译速度极慢的情况（项目里面module太多了，编译慢很正常)且最近需求不多（很少出现的空挡期）。所以我觉得搞一波webpack升级,看看有没有帮助。webpack于2018"}, {"id": "6844903780362747918", "title": "Webpack 打包含动态加载的类库", "desc": "在编写库的时候，我们有时候会希望按需加载某些依赖，例如如果代码的运行环境不支持某些功能的话，就加载相关的 Polyfill 。 webpack 作为当前最流行的打包工具，早已支持动态加载的功能了。 本文将讨论一种用 webpack 打包含动态加载的类库的方法。 注意，本文是写给…"}, {"id": "6844903584945930253", "title": "Express搭建在线便利贴——Webpack配置", "desc": "在浏览器输入localhost:3000 就可以看到欢迎画面了。 我们把前端的源码放在src目录下，使用webpack打包到node的public目录下面。添加之后的目录结构为： 然后简单配置webpack入口文件和出口文件。 但是我们不能一直在src里面执行，我们要在根目录下…"}, {"id": "6844903550531665928", "title": "3分钟了解webpack", "desc": "webpack是一款强大的前端模块管理和打包工具。"}, {"id": "6844903641707446280", "title": "更优雅的使用 Parcel 进行前端项目的打包", "desc": "Parcel 有着开箱即用的特性, 为我们初始化工程省却了许多时间, 但是零配置的特性导致我们比较不方便进行一些预处理, 这篇文章就带领读者解决一些我们常会遇到的一些问题. 只需要很简单的添加几个参数,就可以满足我们大部分的特殊情况. 在去年, Parcel 没有支持 Sour…"}, {"id": "6948404296190787615", "title": "面试题记系列之Webpack", "desc": "通过 import 和 export 语法，我们已经找出需要删除的“未引用代码(dead code)”，然而，不仅仅是要找出，还要在 bundle 中删除它们。"}, {"id": "6844903537030201351", "title": "Webpack实战-构建同构应用", "desc": "同构应用是指写一份代码但可同时在浏览器和服务器中运行的应用。 搜索引擎无法收录你的网页，因为展示出的数据都是在浏览器端异步渲染出来的，大部分爬虫无法获取到这些数据。 对于复杂的单页应用，渲染过程计算量大，对低端移动设备来说可能会有性能问题，用户能明显感知到首屏的渲染延迟。 为了…"}, {"id": "6844903680039206920", "title": "一套自生成组件系统的构想与实践", "desc": "一套功能类似于有赞商城后台管理系统中店铺-微页面的系统，该系统实现用户可以选择所需要的组件，拖动调整组件的顺序，以及编辑组件的内容并且在移动端展示等相关功能,如下图所示。 因为之前且尝试开发过element ui库的组件，详情点这，对于element ui的架构有一定的了解，于…"}, {"id": "6916144962232926222", "title": "Webpack基础配置(四)", "desc": "url-loader、file-loader。 a. 使用低于limit的文件 b. 使用高于limit的文件 a. 字体文件 b. 媒体文件"}, {"id": "6948201005439942687", "title": "Webpack部分常用配置速览｜小册免费学", "desc": "总结Webpack部分常用的配置，不单单是对配置项的一个罗列，而是通过代码加截图的方式展示，方便之后遗忘时迅速回忆起。"}, {"id": "6844903858947244040", "title": "配置Webpack4支持ES6/TypeScript/异步文件引用加载", "desc": "由于Webpack以及它的周边工具babel等更新过快，在当前的时间线来看，很多相关的文章已被版本所淘汰，已经不足以借鉴来搭建一个可以正常使用的环境，所以打算写来记录一下。 在写这篇文章的时候我会同步搭建本地环境，尽量避免有略过的细节部分。 熟悉初始化项目的亲可直接跳过。 安装…"}, {"id": "6844904047225339912", "title": "webpack 4 源码主流程分析（五）：reslove 流程", "desc": "接上文，开始 module 构建前的 reslove 流程。目的是为了获取个 module 的相关信息及各依赖的 loader 的绝对路径。 触发 NormalModuleFactory.hooks:factory，该事件返回了一个 factory 函数。接着执行该 facto…"}, {"id": "6900944549967822855", "title": "webpack性能优化", "desc": "跟上技术的迭代（Node，Npm，Yarn）：webpack版本更新时，内部会做优化，打包速度会提升。webpack运行在Node之上，node升级，webpack打包速度也会变快。npm的升级可以更快速处理包依赖，可以间接提升打包速度 resolve参数合理配置：将impor…"}, {"id": "6931327838582734856", "title": "模块化开发-模块化演变过程", "desc": "由于早期的前端技术标准根本没有预料到前端行业没有今天这样一个规模，所以说很多设计上的遗留问题就导致了现在去实现前端模块化的时候会遇到很多问题。虽然说现如今一些问题都被一些标准或者工具去解决了，但是它的一个演进过程是值得思考的，这个过程就是模块化思想在前端领域的实践过程。这个过程…"}, {"id": "6844903876236148749", "title": "webpack4.0.0.beta尝鲜", "desc": "近年来前端技术如雨后春笋蓬勃发展，我们也在不断学习中成长。例如：jsx 方便了我们在 js 中编写 html，less/sass 的出现提高了我们书写 css 的能力，AMD/CommonJS/ES6 的出现为我们模块化开发提供了便利。然而，我们需要使用其它工具将这些工具转化成…"}]